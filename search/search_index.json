{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Rompy-SWAN","text":"<p>Python interface for the SWAN spectral wave model</p> <p>Rompy-swan provides a type-safe, Pythonic way to configure and run SWAN simulations. It is part of the rompy ecosystem for regional ocean modelling.</p> <p>About SWAN</p> <p>SWAN (Simulating WAves Nearshore) is a third-generation spectral wave model developed at Delft University of Technology. It computes random, short-crested wind-generated waves in coastal regions and inland waters. SWAN accounts for wave propagation, refraction, shoaling, generation by wind, whitecapping, bottom friction, depth-induced breaking, and nonlinear wave-wave interactions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-safe configuration \u2014 Pydantic models validate parameters before running SWAN, catching errors early with clear messages</li> <li>Command generation \u2014 Automatic generation of SWAN input files from Python objects or YAML</li> <li>Data interfaces \u2014 Connect external data sources (NetCDF, THREDDS, local files) to SWAN input grids and boundaries</li> <li>Structured organisation \u2014 SWAN commands grouped into logical components for better discoverability</li> <li>YAML support \u2014 Define configurations declaratively for reproducibility</li> <li>IDE support \u2014 Full autocomplete and type hints in modern editors</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from rompy_swan.config import SwanConfig\nfrom rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_JONSWAP\nfrom rompy_swan.components.numerics import PROP, NUMERIC\nfrom rompy_swan.components.group import STARTUP, PHYSICS\n\nconfig = SwanConfig(\n    cgrid=REGULAR(\n        spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n    ),\n    startup=STARTUP(\n        project=PROJECT(name=\"Example\", nr=\"001\"),\n        set=SET(level=0.0),\n        mode=MODE(),\n        coordinates=COORDINATES(),\n    ),\n    physics=PHYSICS(\n        gen=GEN3(),\n        breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n        friction=FRICTION_JONSWAP(cfjon=0.067),\n    ),\n)\n</code></pre> <p>This generates valid SWAN command input:</p> <pre><code>PROJECT 'Example' '001'\nSET level=0.0\nMODE NONSTATIONARY TWODIMENSIONAL\nCOORDINATES CARTESIAN\nCGRID REGULAR 0 0 0 100000 50000 100 50 CIRCLE 36 0.04 1.0\nGEN3\nBREAKING CONSTANT alpha=1.0 gamma=0.73\nFRICTION JONSWAP cfjon=0.067\n</code></pre>"},{"location":"#why-rompy-swan","title":"Why Rompy-SWAN?","text":"<p>SWAN uses a command-based input file format with many options and parameters. While flexible, this can be:</p> <ul> <li>Error-prone \u2014 Typos in command names or parameters cause runtime failures</li> <li>Hard to discover \u2014 Which commands exist? What are valid options?</li> <li>Difficult to validate \u2014 Invalid combinations only fail when SWAN runs</li> </ul> <p>Rompy-swan addresses these by:</p> <ol> <li>Validating at construction \u2014 Invalid values raise clear errors immediately</li> <li>Grouping related commands \u2014 Find physics settings under <code>physics</code>, output under <code>output</code></li> <li>Enforcing constraints \u2014 Type checking ensures valid parameter combinations</li> <li>Providing defaults \u2014 Sensible SWAN defaults with documentation</li> </ol>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li> <p> Getting Started</p> <p>Install rompy-swan and run your first simulation</p> <p> Installation</p> </li> <li> <p> Concepts</p> <p>Learn the architecture and how to configure SWAN models</p> <p> Architecture</p> </li> <li> <p> Components</p> <p>Detailed reference for each component (Physics, Boundary, Output, etc.)</p> <p> Components</p> </li> <li> <p> Subcomponents</p> <p>Branching options within SWAN commands (locations, spectra, etc.)</p> <p> Subcomponents</p> </li> <li> <p> Data Interfaces</p> <p>Bridge external data sources with SWAN model inputs</p> <p> Data Interfaces</p> </li> <li> <p> Examples</p> <p>Jupyter notebooks demonstrating common workflows</p> <p> Examples</p> </li> <li> <p> API Reference</p> <p>Complete API documentation generated from source code</p> <p> API Reference</p> </li> <li> <p> Developer</p> <p>Contributing guidelines and development setup</p> <p> Contributing</p> </li> </ul>"},{"location":"#part-of-the-rompy-ecosystem","title":"Part of the Rompy Ecosystem","text":"<p>Rompy-swan is a plugin for rompy, the regional ocean modelling framework. Other model plugins include:</p> <ul> <li>rompy-xbeach \u2014 XBeach coastal morphodynamic model</li> <li>rompy-schism \u2014 SCHISM unstructured grid model</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>SWAN Documentation</li> <li>SWAN Download</li> <li>Rompy Core</li> </ul>"},{"location":"api-reference/components/","title":"Components API","text":""},{"location":"api-reference/components/#cgrid-components","title":"CGRID Components","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR","title":"REGULAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN regular computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR--note","title":"Note","text":"<p>In 1D-mode, <code>alpc</code> should be equal to the direction <code>alpinp</code>.</p>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import REGULAR\ncgrid = REGULAR(\n    grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class REGULAR(CGRID):\n    \"\"\"SWAN regular computational grid.\n\n    .. code-block:: text\n\n        CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Note\n    ----\n    In 1D-mode, `alpc` should be equal to the direction `alpinp`.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import REGULAR\n        cgrid = REGULAR(\n            grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"regular\", \"REGULAR\"] = Field(\n        default=\"regular\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"Computational grid definition\")\n\n    @model_validator(mode=\"after\")\n    def grid_suffix(self) -&gt; \"REGULAR\":\n        \"\"\"Set expected grid suffix.\"\"\"\n        if self.grid.suffix != \"c\":\n            logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n            self.grid.suffix = \"c\"\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['regular', 'REGULAR'] = Field(default='regular', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='Computational grid definition')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR.grid_suffix","title":"grid_suffix","text":"<pre><code>grid_suffix() -&gt; REGULAR\n</code></pre> <p>Set expected grid suffix.</p> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef grid_suffix(self) -&gt; \"REGULAR\":\n    \"\"\"Set expected grid suffix.\"\"\"\n    if self.grid.suffix != \"c\":\n        logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n        self.grid.suffix = \"c\"\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.REGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR","title":"CURVILINEAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN curvilinear computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n    FREE|FORMAT ('form'|[idfm])\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import CURVILINEAR\ncgrid = CURVILINEAR(\n    mxc=199,\n    myc=199,\n    readcoord=dict(fname=\"./coords.txt\"),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class CURVILINEAR(CGRID):\n    \"\"\"SWAN curvilinear computational grid.\n\n    .. code-block:: text\n\n        CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n            FREE|FORMAT ('form'|[idfm])\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import CURVILINEAR\n        cgrid = CURVILINEAR(\n            mxc=199,\n            myc=199,\n            readcoord=dict(fname=\"./coords.txt\"),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curvilinear\", \"CURVILINEAR\"] = Field(\n        default=\"curvilinear\", description=\"Model type discriminator\"\n    )\n    mxc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03be-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    myc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03b7-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    xexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the x-coordinate considered in the file of the \"\n            \"x-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    yexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the y-coordinate considered in the file of the \"\n            \"y-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    readcoord: READCOORD = Field(\n        description=\"Grid coordinates reader.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n        if [self.xexc, self.yexc].count(None) == 1:\n            raise ValueError(\"xexc and yexc must be specified together\")\n        return self\n\n    @property\n    def exception(self):\n        if self.xexc is not None:\n            return f\"EXCEPTION xexc={self.xexc} xexc={self.yexc}\"\n        else:\n            return \"\"\n\n    @property\n    def format_repr(self):\n        if self.format == \"free\":\n            repr = \"FREE\"\n        elif self.format == \"fixed\" and self.form:\n            repr = f\"FORMAT form='{self.form}'\"\n        elif self.format == \"fixed\" and self.idfm:\n            repr = f\"FORMAT idfm={self.idfm}\"\n        elif self.format == \"unformatted\":\n            repr = \"UNFORMATTED\"\n        return repr\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n        if self.exception:\n            repr += f\" {self.exception}\"\n        repr += f\" {self.spectrum.render()}\"\n        repr = [repr] + [self.readcoord.render()]\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curvilinear', 'CURVILINEAR'] = Field(default='curvilinear', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.mxc","title":"mxc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxc: int = Field(description='Number of meshes in computational grid in \u03be-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.myc","title":"myc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myc: int = Field(description='Number of meshes in computational grid in \u03b7-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.xexc","title":"xexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the x-coordinate considered in the file of the x-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.yexc","title":"yexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the y-coordinate considered in the file of the y-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.readcoord","title":"readcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readcoord: READCOORD = Field(description='Grid coordinates reader.')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.exception","title":"exception  <code>property</code>","text":"<pre><code>exception\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.format_repr","title":"format_repr  <code>property</code>","text":"<pre><code>format_repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.xexc_and_yexc_or_neither","title":"xexc_and_yexc_or_neither","text":"<pre><code>xexc_and_yexc_or_neither() -&gt; CURVILINEAR\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n    if [self.xexc, self.yexc].count(None) == 1:\n        raise ValueError(\"xexc and yexc must be specified together\")\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.CURVILINEAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n    if self.exception:\n        repr += f\" {self.exception}\"\n    repr += f\" {self.spectrum.render()}\"\n    repr = [repr] + [self.readcoord.render()]\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED","title":"UNSTRUCTURED","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN unstructured computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID UNSTRUCTURED [grid_type] ('fname')\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import UNSTRUCTURED\ncgrid = UNSTRUCTURED(\n    grid_type=\"adcirc\",\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class UNSTRUCTURED(CGRID):\n    \"\"\"SWAN unstructured computational grid.\n\n    .. code-block:: text\n\n        CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID UNSTRUCTURED [grid_type] ('fname')\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import UNSTRUCTURED\n        cgrid = UNSTRUCTURED(\n            grid_type=\"adcirc\",\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"unstructured\"] = Field(\n        default=\"unstructured\", description=\"Model type discriminator\"\n    )\n    grid_type: Literal[\"adcirc\", \"triangle\", \"easymesh\"] = Field(\n        default=\"adcirc\",\n        description=\"Unstructured grid type\",\n    )\n    fname: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file containing the unstructured grid\",\n        max_length=36,\n    )\n\n    @model_validator(mode=\"after\")\n    def check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n        \"\"\"Check that fname needs to be provided.\"\"\"\n        if self.grid_type == \"adcirc\" and self.fname is not None:\n            raise ValueError(\"fname must not be specified for ADCIRC grid\")\n        elif self.grid_type != \"adcirc\" and self.fname is None:\n            raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n        repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n        if self.grid_type in [\"triangle\", \"easymesh\"]:\n            repr[-1] += f\" fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['unstructured'] = Field(default='unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['adcirc', 'triangle', 'easymesh'] = Field(default='adcirc', description='Unstructured grid type')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: Optional[str] = Field(default=None, description='Name of the file containing the unstructured grid', max_length=36)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED.check_fname_required","title":"check_fname_required","text":"<pre><code>check_fname_required() -&gt; UNSTRUCTURED\n</code></pre> <p>Check that fname needs to be provided.</p> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n    \"\"\"Check that fname needs to be provided.\"\"\"\n    if self.grid_type == \"adcirc\" and self.fname is not None:\n        raise ValueError(\"fname must not be specified for ADCIRC grid\")\n    elif self.grid_type != \"adcirc\" and self.fname is None:\n        raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.cgrid.UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n    repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n    if self.grid_type in [\"triangle\", \"easymesh\"]:\n        repr[-1] += f\" fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#startup-components","title":"Startup Components","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT","title":"PROJECT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Project.</p> <p>.. code-block:: text</p> <pre><code>PROJECT 'name' 'nr' 'title' 'title2 'title3'\n</code></pre> <p>With this required command the user defines a number of strings to identify the SWAN run (project name e.g., an engineering project) in the print and plot file.</p>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT\nproj = PROJECT(nr=\"01\")\nprint(proj.render())\nproj = PROJECT(\n    name=\"waus\",\n    nr=\"001\",\n    title1=\"Western Australia\",\n    title2=\"Perth Nest\"\n)\nprint(proj.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class PROJECT(BaseComponent):\n    \"\"\"SWAN Project.\n\n    .. code-block:: text\n\n        PROJECT 'name' 'nr' 'title' 'title2 'title3'\n\n    With this required command the user defines a number of strings to identify the\n    SWAN run (project name e.g., an engineering project) in the print and plot file.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT\n        proj = PROJECT(nr=\"01\")\n        print(proj.render())\n        proj = PROJECT(\n            name=\"waus\",\n            nr=\"001\",\n            title1=\"Western Australia\",\n            title2=\"Perth Nest\"\n        )\n        print(proj.render())\n\n    \"\"\"\n\n    model_type: Literal[\"project\", \"PROJECT\"] = Field(\n        default=\"project\",\n        description=\"Model type discriminator\",\n    )\n    name: Optional[str] = Field(\n        default=None,\n        description=\"Is the name of the project, at most 16 characters long\",\n        max_length=16,\n    )\n    nr: str = Field(\n        description=(\n            \"Is the run identification (to be provided as a character string; e.g. \"\n            \"the run number) to distinguish this run among other runs for the same \"\n            \"project; it is at most 4 characters long. It is the only required \"\n            \"information in this command.\"\n        ),\n        max_length=4,\n    )\n    title1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A string of at most 72 characters provided by the user to appear in the \"\n            \"output of the program for the user's convenience (SWAN default: blanks)\"\n        ),\n        max_length=72,\n    )\n    title2: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n    title3: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"PROJECT\"\n        if self.name is not None:\n            repr += f\" name='{self.name}'\"\n        repr += f\" nr='{self.nr}'\"\n        if self.title1 is not None:\n            repr += f\" title1='{self.title1}'\"\n        if self.title2 is not None:\n            repr += f\" title2='{self.title2}'\"\n        if self.title3 is not None:\n            repr += f\" title3='{self.title3}'\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['project', 'PROJECT'] = Field(default='project', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Is the name of the project, at most 16 characters long', max_length=16)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.nr","title":"nr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nr: str = Field(description='Is the run identification (to be provided as a character string; e.g. the run number) to distinguish this run among other runs for the same project; it is at most 4 characters long. It is the only required information in this command.', max_length=4)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.title1","title":"title1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title1: Optional[str] = Field(default=None, description=\"A string of at most 72 characters provided by the user to appear in the output of the program for the user's convenience (SWAN default: blanks)\", max_length=72)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.title2","title":"title2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title2: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.title3","title":"title3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title3: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.PROJECT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"PROJECT\"\n    if self.name is not None:\n        repr += f\" name='{self.name}'\"\n    repr += f\" nr='{self.nr}'\"\n    if self.title1 is not None:\n        repr += f\" title1='{self.title1}'\"\n    if self.title2 is not None:\n        repr += f\" title2='{self.title2}'\"\n    if self.title3 is not None:\n        repr += f\" title3='{self.title3}'\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET","title":"SET","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN setting commands.</p> <p>.. code-block:: text</p> <pre><code>SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n    [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n</code></pre> <p>With this optional command the user assigns values to various general parameters.</p>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET--notes","title":"Notes","text":"<p>The error level <code>maxerr</code> is coded as follows:</p> <ul> <li>1: warnings</li> <li>2: errors (possibly automatically repaired or repairable by SWAN)</li> <li>3: severe errors</li> </ul> <p>Default values for <code>pwtail</code> depend on formulations of physics:</p> <ul> <li>command GEN1: <code>pwtail = 5</code></li> <li>command GEN2: <code>pwtail = 5</code></li> <li>command GEN3 KOMEN: <code>pwtail = 4</code></li> <li>command GEN3 WESTH: <code>pwtail = 4</code></li> <li>command GEN3 JANSSEN: <code>pwtail = 5</code></li> </ul>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SET\nset = SET(level=0.5, direction_convention=\"nautical\")\nprint(set.render())\nset = SET(\n    level=-1.0,\n    nor=90,\n    depmin=0.01,\n    maxerr=3,\n    grav=9.81,\n    rho=1025,\n    cdcap=2.5e-3,\n    inrhog=0,\n    hsrerr=0.1,\n    direction_convention=\"nautical\",\n)\nprint(set.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class SET(BaseComponent):\n    \"\"\"SWAN setting commands.\n\n    .. code-block:: text\n\n        SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n            [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n\n    With this optional command the user assigns values to various general parameters.\n\n    Notes\n    -----\n    The error level `maxerr` is coded as follows:\n\n    * 1: warnings\n    * 2: errors (possibly automatically repaired or repairable by SWAN)\n    * 3: severe errors\n\n    Default values for `pwtail` depend on formulations of physics:\n\n    * command GEN1: `pwtail = 5`\n    * command GEN2: `pwtail = 5`\n    * command GEN3 KOMEN: `pwtail = 4`\n    * command GEN3 WESTH: `pwtail = 4`\n    * command GEN3 JANSSEN: `pwtail = 5`\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SET\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        print(set.render())\n        set = SET(\n            level=-1.0,\n            nor=90,\n            depmin=0.01,\n            maxerr=3,\n            grav=9.81,\n            rho=1025,\n            cdcap=2.5e-3,\n            inrhog=0,\n            hsrerr=0.1,\n            direction_convention=\"nautical\",\n        )\n        print(set.render())\n\n    \"\"\"\n\n    model_type: Literal[\"set\", \"SET\"] = Field(\n        default=\"set\", description=\"Model type discriminator\"\n    )\n    level: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Increase in water level that is constant in space and time can be given \"\n            \"with this option, `level` is the value of this increase (in m). For a \"\n            \"variable water level reference is made to the commands \"\n            \"INPGRID and READINP (SWAN default: 0)\"\n        ),\n        examples=[0],\n    )\n    nor: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Direction of North with respect to the x-axis (measured \"\n            \"counterclockwise); default `nor = 90`, i.e. x-axis of the problem \"\n            \"coordinate system points East. When spherical coordinates are used \"\n            \"(see command COORD) the value of `nor` may not be modified\"\n        ),\n        ge=-360.0,\n        le=360.0,\n    )\n    depmin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Threshold depth (in m). In the computation any positive depth smaller \"\n            \"than `depmin` is made equal to `depmin` (SWAN default: 0.05)\"\n        ),\n        ge=0.0,\n    )\n    maxmes: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of error messages during the computation at which the \"\n            \"computation is terminated. During the computational process messages are \"\n            \"written to the print file (SWAN default: 200)\"\n        ),\n        ge=0,\n    )\n    maxerr: Optional[Literal[1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"During pre-processing SWAN checks input data. Depending on the severity \"\n            \"of the errors encountered during this pre-processing, SWAN does not \"\n            \"start computations. The user can influence the error level above which \"\n            \"SWAN will  not start computations (at the level indicated the \"\n            \"computations will continue) (SWAN default: 1)\"\n        ),\n    )\n    grav: Optional[float] = Field(\n        default=None,\n        description=\"The gravitational acceleration (in m/s2) (SWAN default: 9.81)\",\n        ge=0.0,\n    )\n    rho: Optional[float] = Field(\n        default=None,\n        description=\"The water density (in kg/m3) (SWAN default: 1025)\",\n        ge=0.0,\n    )\n    cdcap: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The maximum value for the wind drag coefficient. A value of 99999 means\"\n            \"no cutting off the drag coefficient. A suggestion for this parameter is \"\n            \"`cdcap = 2.5x 10-3` (SWAN default: 99999) \"\n        ),\n        ge=0.0,\n    )\n    inrhog: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"To indicate whether the user requires output based on variance or based \"\n            \"on true energy (see Section 2.5). `inrhog` = 0: output based on variance, \"\n            \"`inrhog` = 1: output based on true energy (SWAN default: 0)\"\n        ),\n    )\n    hsrerr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The relative difference between the user imposed significant wave height \"\n            \"and the significant wave height computed by SWAN (anywhere along the \"\n            \"computational grid boundary) above which a warning will be given. This \"\n            \"relative difference is the difference normalized with the user provided \"\n            \"significant wave height. This warning will be given for each boundary \"\n            \"grid point where the problem occurs (with its x- and y-index number of \"\n            \"the computational grid). The cause of the difference is explained in \"\n            \"Section 2.6.3. To suppress these warnings (in particular for \"\n            \"nonstationary computations), set `hsrerr` at a very high value or use \"\n            \"command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)\"\n        ),\n        ge=0.0,\n    )\n    direction_convention: Literal[\"nautical\", \"cartesian\"] = Field(\n        description=(\n            \"Direction convention: `nautical` indicates that the Nautical convention \"\n            \"for wind and wave direction (SWAN input and output) will be used, \"\n            \"`cartesian` indicates that the Cartesian convention for wind and wave \"\n            \"direction will be used. For definition, see Section 2.5 or Appendix A \"\n            \"(SWAN default: `cartesian`)\"\n        ),\n    )\n    pwtail: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Power of high frequency tail; defines the shape of the spectral tail \"\n            \"above the highest prognostic frequency `fhigh` (see command CGRID). \"\n            \"The energy density is assumed to be proportional to frequency to the \"\n            \"power `pwtail`. If the user wishes to use another value, then this SET \"\n            \"command should be located in the command file after GEN1, GEN2 or GEN3 \"\n            \"command (these will override the SET command with respect to `pwtail`)\"\n        ),\n        ge=0,\n    )\n    froudmax: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the \"\n            \"water depth). The currents taken from a circulation model may mismatch \"\n            \"with given water depth `d` in the sense that the Froude number becomes \"\n            \"larger than 1. For this, the current velocities will be maximized by \"\n            \"Froude number times `sqrt(gh)` (SWAN default: 0.8)\"\n        ),\n        ge=0.0,\n    )\n    icewind: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of wind input by open water fraction. Default value \"\n            \"of zero corresponds to the case where wind input is scaled by the open \"\n            \"water fraction. If `icewind = 1` then sea ice does not affect wind input \"\n            \"directly. (Though there is still indirect effect via the sea ice sink \"\n            \"term; see command SICE) (SWAN default: 0)\"\n        ),\n    )\n\n    @field_validator(\"pwtail\")\n    @classmethod\n    def pwtail_after_gen(cls, v):\n        if v is not None:\n            logger.warning(\"pwtail only has effect if set after GEN command\")\n        return v\n\n    def cmd(self) -&gt; str:\n        repr = \"SET\"\n        if self.level is not None:\n            repr += f\" level={self.level}\"\n        if self.nor is not None:\n            repr += f\" nor={self.nor}\"\n        if self.depmin is not None:\n            repr += f\" depmin={self.depmin}\"\n        if self.maxmes is not None:\n            repr += f\" maxmes={self.maxmes}\"\n        if self.maxerr is not None:\n            repr += f\" maxerr={self.maxerr}\"\n        if self.grav is not None:\n            repr += f\" grav={self.grav}\"\n        if self.rho is not None:\n            repr += f\" rho={self.rho}\"\n        if self.cdcap is not None:\n            repr += f\" cdcap={self.cdcap}\"\n        if self.inrhog is not None:\n            repr += f\" inrhog={self.inrhog}\"\n        if self.hsrerr is not None:\n            repr += f\" hsrerr={self.hsrerr}\"\n        if self.direction_convention is not None:\n            repr += f\" {self.direction_convention.upper()}\"\n        if self.pwtail is not None:\n            repr += f\" pwtail={self.pwtail}\"\n        if self.froudmax is not None:\n            repr += f\" froudmax={self.froudmax}\"\n        if self.icewind is not None:\n            repr += f\" icewind={self.icewind}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.SET.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['set', 'SET'] = Field(default='set', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: Optional[float] = Field(default=None, description='Increase in water level that is constant in space and time can be given with this option, `level` is the value of this increase (in m). For a variable water level reference is made to the commands INPGRID and READINP (SWAN default: 0)', examples=[0])\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.nor","title":"nor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nor: Optional[float] = Field(default=None, description='Direction of North with respect to the x-axis (measured counterclockwise); default `nor = 90`, i.e. x-axis of the problem coordinate system points East. When spherical coordinates are used (see command COORD) the value of `nor` may not be modified', ge=-360.0, le=360.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.depmin","title":"depmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depmin: Optional[float] = Field(default=None, description='Threshold depth (in m). In the computation any positive depth smaller than `depmin` is made equal to `depmin` (SWAN default: 0.05)', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.maxmes","title":"maxmes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxmes: Optional[int] = Field(default=None, description='Maximum number of error messages during the computation at which the computation is terminated. During the computational process messages are written to the print file (SWAN default: 200)', ge=0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.maxerr","title":"maxerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxerr: Optional[Literal[1, 2, 3]] = Field(default=None, description='During pre-processing SWAN checks input data. Depending on the severity of the errors encountered during this pre-processing, SWAN does not start computations. The user can influence the error level above which SWAN will  not start computations (at the level indicated the computations will continue) (SWAN default: 1)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.grav","title":"grav  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grav: Optional[float] = Field(default=None, description='The gravitational acceleration (in m/s2) (SWAN default: 9.81)', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.rho","title":"rho  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rho: Optional[float] = Field(default=None, description='The water density (in kg/m3) (SWAN default: 1025)', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.cdcap","title":"cdcap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdcap: Optional[float] = Field(default=None, description='The maximum value for the wind drag coefficient. A value of 99999 meansno cutting off the drag coefficient. A suggestion for this parameter is `cdcap = 2.5x 10-3` (SWAN default: 99999) ', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.inrhog","title":"inrhog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inrhog: Optional[Literal[0, 1]] = Field(default=None, description='To indicate whether the user requires output based on variance or based on true energy (see Section 2.5). `inrhog` = 0: output based on variance, `inrhog` = 1: output based on true energy (SWAN default: 0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.hsrerr","title":"hsrerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hsrerr: Optional[float] = Field(default=None, description='The relative difference between the user imposed significant wave height and the significant wave height computed by SWAN (anywhere along the computational grid boundary) above which a warning will be given. This relative difference is the difference normalized with the user provided significant wave height. This warning will be given for each boundary grid point where the problem occurs (with its x- and y-index number of the computational grid). The cause of the difference is explained in Section 2.6.3. To suppress these warnings (in particular for nonstationary computations), set `hsrerr` at a very high value or use command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.direction_convention","title":"direction_convention  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction_convention: Literal['nautical', 'cartesian'] = Field(description='Direction convention: `nautical` indicates that the Nautical convention for wind and wave direction (SWAN input and output) will be used, `cartesian` indicates that the Cartesian convention for wind and wave direction will be used. For definition, see Section 2.5 or Appendix A (SWAN default: `cartesian`)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.pwtail","title":"pwtail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pwtail: Optional[int] = Field(default=None, description='Power of high frequency tail; defines the shape of the spectral tail above the highest prognostic frequency `fhigh` (see command CGRID). The energy density is assumed to be proportional to frequency to the power `pwtail`. If the user wishes to use another value, then this SET command should be located in the command file after GEN1, GEN2 or GEN3 command (these will override the SET command with respect to `pwtail`)', ge=0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.froudmax","title":"froudmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>froudmax: Optional[float] = Field(default=None, description='Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the water depth). The currents taken from a circulation model may mismatch with given water depth `d` in the sense that the Froude number becomes larger than 1. For this, the current velocities will be maximized by Froude number times `sqrt(gh)` (SWAN default: 0.8)', ge=0.0)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.icewind","title":"icewind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icewind: Optional[Literal[0, 1]] = Field(default=None, description='Controls the scaling of wind input by open water fraction. Default value of zero corresponds to the case where wind input is scaled by the open water fraction. If `icewind = 1` then sea ice does not affect wind input directly. (Though there is still indirect effect via the sea ice sink term; see command SICE) (SWAN default: 0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.SET.pwtail_after_gen","title":"pwtail_after_gen  <code>classmethod</code>","text":"<pre><code>pwtail_after_gen(v)\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>@field_validator(\"pwtail\")\n@classmethod\ndef pwtail_after_gen(cls, v):\n    if v is not None:\n        logger.warning(\"pwtail only has effect if set after GEN command\")\n    return v\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.SET.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"SET\"\n    if self.level is not None:\n        repr += f\" level={self.level}\"\n    if self.nor is not None:\n        repr += f\" nor={self.nor}\"\n    if self.depmin is not None:\n        repr += f\" depmin={self.depmin}\"\n    if self.maxmes is not None:\n        repr += f\" maxmes={self.maxmes}\"\n    if self.maxerr is not None:\n        repr += f\" maxerr={self.maxerr}\"\n    if self.grav is not None:\n        repr += f\" grav={self.grav}\"\n    if self.rho is not None:\n        repr += f\" rho={self.rho}\"\n    if self.cdcap is not None:\n        repr += f\" cdcap={self.cdcap}\"\n    if self.inrhog is not None:\n        repr += f\" inrhog={self.inrhog}\"\n    if self.hsrerr is not None:\n        repr += f\" hsrerr={self.hsrerr}\"\n    if self.direction_convention is not None:\n        repr += f\" {self.direction_convention.upper()}\"\n    if self.pwtail is not None:\n        repr += f\" pwtail={self.pwtail}\"\n    if self.froudmax is not None:\n        repr += f\" froudmax={self.froudmax}\"\n    if self.icewind is not None:\n        repr += f\" icewind={self.icewind}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE","title":"MODE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Mode.</p> <p>.. code-block:: text</p> <pre><code>MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n</code></pre> <p>With this optional command the user indicates that the run will be either stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional (2D-mode). Nonstationary means either (see command COMPUTE):</p> <ul> <li>(a) one nonstationary computations or</li> <li>(b) a sequence of stationary computations or</li> <li>(c) a mix of (a) and (b)</li> </ul>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import MODE\nmode = MODE()\nprint(mode.render())\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\nprint(mode.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class MODE(BaseComponent):\n    \"\"\"SWAN Mode.\n\n    .. code-block:: text\n\n        MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n\n    With this optional command the user indicates that the run will be either\n    stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional\n    (2D-mode). Nonstationary means either (see command COMPUTE):\n\n    * (a) one nonstationary computations or\n    * (b) a sequence of stationary computations or\n    * (c) a mix of (a) and (b)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import MODE\n        mode = MODE()\n        print(mode.render())\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        print(mode.render())\n\n    \"\"\"\n\n    model_type: Literal[\"mode\", \"MODE\"] = Field(\n        default=\"mode\", description=\"Model type discriminator.\"\n    )\n    kind: Literal[\"stationary\", \"nonstationary\"] = Field(\n        default=\"stationary\",\n        description=\"Indicates if run will be stationary or nonstationary\",\n    )\n    dim: Literal[\"onedimensional\", \"twodimensional\"] = Field(\n        default=\"twodimensional\",\n        description=(\n            \"Indicates that the run will be either one-dimensional (1D-mode) or \"\n            \"two-dimensional (2D-mode)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.MODE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['mode', 'MODE'] = Field(default='mode', description='Model type discriminator.')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Literal['stationary', 'nonstationary'] = Field(default='stationary', description='Indicates if run will be stationary or nonstationary')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Literal['onedimensional', 'twodimensional'] = Field(default='twodimensional', description='Indicates that the run will be either one-dimensional (1D-mode) or two-dimensional (2D-mode)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.MODE-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.MODE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES","title":"COORDINATES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Coordinates.</p> <p>.. code-block:: text</p> <pre><code>COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n</code></pre> <p>Command to choose between Cartesian and spherical coordinates (see Section 2.5). A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.</p>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import COORDINATES\ncoords = COORDINATES()\nprint(coords.render())\ncoords = COORDINATES(\n    kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n    reapeating=True,\n)\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class COORDINATES(BaseComponent):\n    \"\"\"SWAN Coordinates.\n\n    .. code-block:: text\n\n        COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n\n    Command to choose between Cartesian and spherical coordinates (see Section 2.5).\n    A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import COORDINATES\n        coords = COORDINATES()\n        print(coords.render())\n        coords = COORDINATES(\n            kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n            reapeating=True,\n        )\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"coordinates\", \"COORDINATES\"] = Field(\n        default=\"coordinates\",\n        description=\"Model type discriminator\",\n    )\n    kind: CARTESIAN | SPHERICAL = Field(\n        default_factory=CARTESIAN,\n        description=\"Coordinates kind\",\n    )\n    reapeating: bool = Field(\n        default=False,\n        description=(\n            \"This option is only for academic cases. It means that wave energy \"\n            \"leaving at one end of the domain (in computational x-direction) enter at \"\n            \"the other side; it is as if the wave field repeats itself in x-direction \"\n            \"with the length of the domain in x-direction. This option cannot be used \"\n            \"in combination with computation of set-up (see command SETUP). This \"\n            \"option is available only with regular grids\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"COORDINATES {self.kind.render()}\"\n        if self.reapeating:\n            repr += \" REPEATING\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['coordinates', 'COORDINATES'] = Field(default='coordinates', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: CARTESIAN | SPHERICAL = Field(default_factory=CARTESIAN, description='Coordinates kind')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES.reapeating","title":"reapeating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reapeating: bool = Field(default=False, description='This option is only for academic cases. It means that wave energy leaving at one end of the domain (in computational x-direction) enter at the other side; it is as if the wave field repeats itself in x-direction with the length of the domain in x-direction. This option cannot be used in combination with computation of set-up (see command SETUP). This option is available only with regular grids')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.startup.COORDINATES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"COORDINATES {self.kind.render()}\"\n    if self.reapeating:\n        repr += \" REPEATING\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#boundary-components","title":"Boundary Components","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC","title":"BOUNDSPEC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary along sides or segment.</p> <p>.. code-block:: text</p> <pre><code>BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n</code></pre> <p>This command BOUNDSPEC defines parametric spectra at the boundary. It consists of two parts, the first part defines the boundary side or segment where the spectra will be given, the second part defines the spectral parameters of these spectra. Note that in fact only the incoming wave components of these spectra are used by SWAN. The fact that complete spectra are calculated at the model boundaries from the spectral parameters should not be misinterpreted. Only the incoming components are effective in the computation.</p> <p>TODO: Add support for unstructured grid (k).</p>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(\n        model_type=\"segment\",\n        points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n    ),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDSPEC(BaseComponent):\n    \"\"\"Boundary along sides or segment.\n\n    .. code-block:: text\n\n        BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n\n    This command BOUNDSPEC defines parametric spectra at the boundary. It consists of\n    two parts, the first part defines the boundary side or segment where the spectra\n    will be given, the second part defines the spectral parameters of these spectra.\n    Note that in fact only the incoming wave components of these spectra are used by\n    SWAN. The fact that complete spectra are calculated at the model boundaries from\n    the spectral parameters should not be misinterpreted. Only the incoming components\n    are effective in the computation.\n\n    TODO: Add support for unstructured grid (k).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDSPEC\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(\n                model_type=\"segment\",\n                points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n            ),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundspec\", \"BOUNDSPEC\"] = Field(\n        default=\"boundspec\",\n        description=\"Model type discriminator\",\n    )\n    shapespec: SHAPESPEC = Field(\n        default_factory=SHAPESPEC,\n        description=\"Spectral shape specification\",\n    )\n    location: SIDE | SEGMENT = Field(\n        description=\"Location to apply the boundary\",\n    )\n    data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(\n        description=\"Spectral data\",\n    )\n\n    def cmd(self) -&gt; list:\n        repr = [f\"{self.shapespec.render()}\"]\n        repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundspec', 'BOUNDSPEC'] = Field(default='boundspec', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC.shapespec","title":"shapespec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shapespec: SHAPESPEC = Field(default_factory=SHAPESPEC, description='Spectral shape specification')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SIDE | SEGMENT = Field(description='Location to apply the boundary')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(description='Spectral data')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDSPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = [f\"{self.shapespec.render()}\"]\n    repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1","title":"BOUNDNEST1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from a coarser SWAN nest.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid SWAN run (generated in that previous SWAN run with command NESTOUT). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid run, use command NGRID. For the nested run, use the command CGRID with identical geographical information except the number of meshes (which will be much higher for the nested run). This BOUNDNEST1 command is not available for 1D computations; in such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A nested SWAN run must use the same coordinate system as the coarse grid SWAN run. For a curvilinear grid, it is advised to use the commands POINTS or CURVE and SPECOUT instead of NGRID and NESTOUT.</p>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST1\nboundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST1(BaseComponent):\n    \"\"\"Boundary spectra from a coarser SWAN nest.\n\n    .. code-block:: text\n\n        BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid SWAN run (generated in that previous SWAN\n    run with command NESTOUT). The spectral frequencies and directions of the coarse\n    grid run do not have to coincide with the frequencies and directions used in the\n    nested SWAN run; SWAN will interpolate to these frequencies and directions in the\n    nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid\n    run, use command NGRID. For the nested run, use the command CGRID with identical\n    geographical information except the number of meshes (which will be much higher for\n    the nested run). This BOUNDNEST1 command is not available for 1D computations; in\n    such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A\n    nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n    For a curvilinear grid, it is advised to use the commands POINTS or CURVE and\n    SPECOUT instead of NGRID and NESTOUT.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST1\n        boundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest1\", \"BOUNDNEST1\"] = Field(\n        default=\"boundnest1\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"Name of the file containing the boundary conditions for the present run, \"\n            \"created by the previous SWAN coarse grid run. This file is structured \"\n            \"according to the rules given in Appendix D for 2D spectra\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest1', 'BOUNDNEST1'] = Field(default='boundnest1', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the boundary conditions for the present run, created by the previous SWAN coarse grid run. This file is structured according to the rules given in Appendix D for 2D spectra', min_length=1, max_length=36)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST1.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2","title":"BOUNDNEST2","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAM.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n</code></pre> <p>With this optional command (not fully tested) a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5, source code as distributed by the Max Planck Institute in Hamburg). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). Note that SWAN will accept output of a WAM output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAM output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAM output locations. This BOUNDNEST2 command is not available for 1D computations. Only boundary conditions generated by WAM Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries. WAM output files are unformatted (binary); this usually implies that WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN run on different types of machines (binary files do not transfer properly), the option FREE is available in this command. The distributed version of WAM does not support the required free format nesting output; WAM users who modify WAM such that it can make formatted output, must modify WAM such that the files made by WAM can be read in free format, i.e. with at least a blank or comma between numbers.</p>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2--note","title":"Note","text":"<p>the contents of 'fname' file could look like:</p> <p>.. code-block:: text</p> <pre><code>CBO9212010000\nCBO9212020000\nCBO9212030000\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST2\nboundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST2(BaseComponent):\n    \"\"\"Boundary spectra from WAM.\n\n    .. code-block:: text\n\n        BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n\n    With this optional command (not fully tested) a nested SWAN run can be carried out\n    with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5,\n    source code as distributed by the Max Planck Institute in Hamburg). The spectral\n    frequencies and directions of the coarse grid run do not have to coincide with the\n    frequencies and directions used in the nested SWAN run; SWAN will interpolate to\n    these frequencies and directions in the nested run (see Section 2.6.3). Note that\n    SWAN will accept output of a WAM output location only if the SWAN grid point on the\n    nest boundary lies within a rectangle between two consecutive WAM output locations\n    with a width equal to 0.1 times the distance between these output locations on\n    either side of the line between these WAM output locations. This BOUNDNEST2 command\n    is not available for 1D computations. Only boundary conditions generated by WAM\n    Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian\n    or spherical coordinates. A curvilinear grid may be used in the nested grid but the\n    boundaries of this nest should conform to the rectangular course grid nest\n    boundaries. WAM output files are unformatted (binary); this usually implies that\n    WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN\n    run on different types of machines (binary files do not transfer properly), the\n    option FREE is available in this command. The distributed version of WAM does not\n    support the required free format nesting output; WAM users who modify WAM such that\n    it can make formatted output, must modify WAM such that the files made by WAM can\n    be read in free format, i.e. with at least a blank or comma between numbers.\n\n    Note\n    ----\n    the contents of 'fname' file could look like:\n\n    .. code-block:: text\n\n        CBO9212010000\n        CBO9212020000\n        CBO9212030000\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST2\n        boundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest2\", \"BOUNDNEST2\"] = Field(\n        default=\"boundnest2\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"A file name that contains all the names of WAM files containing the \"\n            \"nested boundary conditions in time-sequence (usually one file per day)\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"cray\", \"wkstat\", \"free\"] = Field(\n        description=(\n            \"Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: \"\n            \"WORKSTATION version of WAM, `free`: Free format (these files are not \"\n            \"generated standard by WAM)\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    lwdate: Literal[10, 12, 14] = Field(\n        default=12,\n        description=(\n            \"Length of character string for date-time as used in the WAM files. \"\n            \"Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) \"\n            \"or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)\"\n        ),\n    )\n\n    @property\n    def format_str(self):\n        if self.format == \"cray\":\n            return \"UNFORMATTED CRAY\"\n        elif self.format == \"wkstat\":\n            return \"UNFORMATTED WKSTAT\"\n        elif self.format == \"free\":\n            return \"FREE\"\n        else:\n            raise ValueError(f\"Unknown format {self.format}\")\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        repr += f\" lwdate={self.lwdate}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest2', 'BOUNDNEST2'] = Field(default='boundnest2', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='A file name that contains all the names of WAM files containing the nested boundary conditions in time-sequence (usually one file per day)', min_length=1, max_length=36)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['cray', 'wkstat', 'free'] = Field(description='Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: WORKSTATION version of WAM, `free`: Free format (these files are not generated standard by WAM)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.lwdate","title":"lwdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lwdate: Literal[10, 12, 14] = Field(default=12, description='Length of character string for date-time as used in the WAM files. Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.format_str","title":"format_str  <code>property</code>","text":"<pre><code>format_str\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST2.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    repr += f\" lwdate={self.lwdate}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3","title":"BOUNDNEST3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAVEWATCHIII.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). The output files of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub type 3) at the locations along the nest boundary (i.e. computational grid points in WAVEWATCH III). These locations are equal to the corner points of the SWAN nested grid and optionally also distributed between the corner points of the SWAN nested grid (the boundary of the WAVEWATCH III nested grid need not be closed and may cover land). The locations should be output by WAVEWATCH III in sequence (going along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept output of a WAVEWATCH III output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAVEWATCH III output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAVEWATCH III output locations. This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries.</p>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST3\nboundary = BOUNDNEST3(\n    fname=\"boundary.ww3\",\n    format=\"free\",\n    rectangle=\"closed\",\n)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST3(BaseComponent):\n    \"\"\"Boundary spectra from WAVEWATCHIII.\n\n    .. code-block:: text\n\n        BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies\n    and directions of the coarse grid run do not have to coincide with the frequencies\n    and directions used in the nested SWAN run; SWAN will interpolate to these\n    frequencies and directions in the nested run (see Section 2.6.3). The output files\n    of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as\n    output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub\n    type 3) at the locations along the nest boundary (i.e. computational grid points in\n    WAVEWATCH III). These locations are equal to the corner points of the SWAN nested\n    grid and optionally also distributed between the corner points of the SWAN nested\n    grid (the boundary of the WAVEWATCH III nested grid need not be closed and may\n    cover land). The locations should be output by WAVEWATCH III in sequence (going\n    along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept\n    output of a WAVEWATCH III output location only if the SWAN grid point on the nest\n    boundary lies within a rectangle between two consecutive WAVEWATCH III output\n    locations with a width equal to 0.1 times the distance between these output\n    locations on either side of the line between these WAVEWATCH III output locations.\n    This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may\n    use either Cartesian or spherical coordinates. A curvilinear grid may be used in\n    the nested grid but the boundaries of this nest should conform to the rectangular\n    course grid nest boundaries.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST3\n        boundary = BOUNDNEST3(\n            fname=\"boundary.ww3\",\n            format=\"free\",\n            rectangle=\"closed\",\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest3\", \"BOUNDNEST3\"] = Field(\n        default=\"boundnest3\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"The name of the file that contains the spectra computed by WAVEWATCH III\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"unformatted\", \"free\"] = Field(\n        description=(\n            \"Format of the WW3 file. `unformatted`: The input WW3 files are binary, \"\n            \"`free`: The input WW3 files are formatted\"\n        ),\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n        repr += f\"{self.rectangle.upper()}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest3', 'BOUNDNEST3'] = Field(default='boundnest3', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='The name of the file that contains the spectra computed by WAVEWATCH III', min_length=1, max_length=36)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['unformatted', 'free'] = Field(description='Format of the WW3 file. `unformatted`: The input WW3 files are binary, `free`: The input WW3 files are formatted')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.BOUNDNEST3.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n    repr += f\"{self.rectangle.upper()}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL","title":"INITIAL","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Initial conditions.</p> <p>.. code-block:: text</p> <pre><code>INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n</code></pre> <p>This command can be used to specify the initial values for a stationary (INITIAL HOTSTART only) or nonstationary computation. The initial values thus specified override the default initialization (see Section 2.6.3). Note that it is possible to obtain an initial state by carrying out a previous stationary or nonstationary computation.</p>"},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import INITIAL\ninit = INITIAL()\nprint(init.render())\ninit = INITIAL(\n    kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n)\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class INITIAL(BaseComponent):\n    \"\"\"Initial conditions.\n\n    .. code-block:: text\n\n        INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n\n    This command can be used to specify the initial values for a stationary (INITIAL\n    HOTSTART only) or nonstationary computation. The initial values thus specified\n    override the default initialization (see Section 2.6.3). Note that it is possible\n    to obtain an initial state by carrying out a previous stationary or nonstationary\n    computation.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import INITIAL\n        init = INITIAL()\n        print(init.render())\n        init = INITIAL(\n            kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n        )\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"initial\", \"INITIAL\"] = Field(\n        default=\"initial\",\n        description=\"Model type discriminator\",\n    )\n    kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(\n        default_factory=DEFAULT,\n        description=\"Initial condition type\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"INITIAL {self.kind.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['initial', 'INITIAL'] = Field(default='initial', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(default_factory=DEFAULT, description='Initial condition type')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.boundary.INITIAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"INITIAL {self.kind.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#physics-components","title":"Physics Components","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1","title":"GEN1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>First generation source terms GEN1.</p> <p>.. code-block:: text</p> <pre><code>GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in first-generation mode (see Scientific/Technical documentation).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN1\ngen = GEN1()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN1(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN1(BaseComponent):\n    \"\"\"First generation source terms GEN1.\n\n    .. code-block:: text\n\n        GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in first-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN1\n        gen = GEN1()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN1(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen1\", \"GEN1\"] = Field(\n        default=\"gen1\", description=\"Model type discriminator\"\n    )\n    cf10: Optional[float] = Field(\n        default=None,\n        description=\"Controls the linear wave growth (SWAN default: 188.0)\",\n    )\n    cf20: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.59)\",\n    )\n    cf30: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.12)\",\n    )\n    cf40: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the dissipation rate, i.e., the time decay scale \"\n            \"(SWAN default: 250.0)\"\n        ),\n    )\n    edmlpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum non-dimensionless energy density of the wind sea part of the \"\n            \"spectrum according to Pierson Moskowitz (SWAN default: 0.0036)\"\n        ),\n    )\n    cdrag: Optional[float] = Field(\n        default=None, description=\"Drag coefficient (SWAN default: 0.0012)\"\n    )\n    umin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Minimum wind velocity (relative to current; all wind speeds \"\n            \"are taken at 10 m above sea level) (SWAN default: 1)\"\n        ),\n    )\n    cfpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the Pierson Moskowitz frequency: \"\n            \"`delta_PM = 2pi g / U_10` (SWAN default: 0.13)\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN1\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen1', 'GEN1'] = Field(default='gen1', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cf10","title":"cf10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf10: Optional[float] = Field(default=None, description='Controls the linear wave growth (SWAN default: 188.0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cf20","title":"cf20  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf20: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.59)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cf30","title":"cf30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf30: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.12)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cf40","title":"cf40  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf40: Optional[float] = Field(default=None, description='Controls the dissipation rate, i.e., the time decay scale (SWAN default: 250.0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.edmlpm","title":"edmlpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>edmlpm: Optional[float] = Field(default=None, description='Maximum non-dimensionless energy density of the wind sea part of the spectrum according to Pierson Moskowitz (SWAN default: 0.0036)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cdrag","title":"cdrag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdrag: Optional[float] = Field(default=None, description='Drag coefficient (SWAN default: 0.0012)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.umin","title":"umin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>umin: Optional[float] = Field(default=None, description='Minimum wind velocity (relative to current; all wind speeds are taken at 10 m above sea level) (SWAN default: 1)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cfpm","title":"cfpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfpm: Optional[float] = Field(default=None, description='Coefficient which determines the Pierson Moskowitz frequency: `delta_PM = 2pi g / U_10` (SWAN default: 0.13)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN1.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN1\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2","title":"GEN2","text":"<p>               Bases: <code>GEN1</code></p> <p>Second generation source terms GEN2.</p> <p>.. code-block:: text</p> <pre><code>GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in second-generation mode (see Scientific/Technical documentation).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN2\ngen = GEN2()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    cf50=0.0023,\n    cf60=-0.223,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN2(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN2(GEN1):\n    \"\"\"Second generation source terms GEN2.\n\n    .. code-block:: text\n\n        GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in second-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN2\n        gen = GEN2()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            cf50=0.0023,\n            cf60=-0.223,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN2(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen2\", \"GEN2\"] = Field(\n        default=\"gen2\", description=\"Model type discriminator\"\n    )\n    cf50: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: 0.0023)\"\n        ),\n    )\n    cf60: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Ccontrols the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: -0.223\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN2\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.cf50 is not None:\n            repr += f\" cf50={self.cf50}\"\n        if self.cf60 is not None:\n            repr += f\" cf60={self.cf60}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen2', 'GEN2'] = Field(default='gen2', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2.cf50","title":"cf50  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf50: Optional[float] = Field(default=None, description='Controls the spectral energy scale of the limit spectrum (SWAN default: 0.0023)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2.cf60","title":"cf60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf60: Optional[float] = Field(default=None, description='Ccontrols the spectral energy scale of the limit spectrum (SWAN default: -0.223')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN2.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN2\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.cf50 is not None:\n        repr += f\" cf50={self.cf50}\"\n    if self.cf60 is not None:\n        repr += f\" cf60={self.cf60}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3","title":"GEN3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Third generation source terms GEN3.</p> <p>.. code-block:: text</p> <pre><code>GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n</code></pre> <p>With this command the user indicates that SWAN should run in third-generation mode for wind input, quadruplet interactions and whitecapping.</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN3\ngen = GEN3(\n    source_terms=dict(\n        model_type=\"westhuysen\",\n        wind_drag=\"wu\",\n        agrow=True,\n    ),\n)\nprint(gen.render())\nfrom rompy_swan.subcomponents.physics import ST6C1\ngen = GEN3(source_terms=ST6C1())\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN3(BaseComponent):\n    \"\"\"Third generation source terms GEN3.\n\n    .. code-block:: text\n\n        GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n\n    With this command the user indicates that SWAN should run in third-generation mode\n    for wind input, quadruplet interactions and whitecapping.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN3\n        gen = GEN3(\n            source_terms=dict(\n                model_type=\"westhuysen\",\n                wind_drag=\"wu\",\n                agrow=True,\n            ),\n        )\n        print(gen.render())\n        from rompy_swan.subcomponents.physics import ST6C1\n        gen = GEN3(source_terms=ST6C1())\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen3\", \"GEN3\"] = Field(\n        default=\"gen3\", description=\"Model type discriminator\"\n    )\n    source_terms: SOURCE_TERMS = Field(\n        default_factory=WESTHUYSEN,\n        description=\"SWAN source terms to be used (SWAN default: WESTHUYSEN)\",\n        discriminator=\"model_type\",\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = f\"GEN3 {self.source_terms.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen3', 'GEN3'] = Field(default='gen3', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3.source_terms","title":"source_terms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_terms: SOURCE_TERMS = Field(default_factory=WESTHUYSEN, description='SWAN source terms to be used (SWAN default: WESTHUYSEN)', discriminator='model_type')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.GEN3.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = f\"GEN3 {self.source_terms.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT","title":"BREAKING_CONSTANT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING CONSTANT [alpha] [gamma]\n</code></pre> <p>Indicates that a constant breaker index is to be used.</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_CONSTANT\nbreaking = BREAKING_CONSTANT()\nprint(breaking.render())\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\nprint(breaking.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BREAKING_CONSTANT(BaseComponent):\n    \"\"\"Constant wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING CONSTANT [alpha] [gamma]\n\n    Indicates that a constant breaker index is to be used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_CONSTANT\n        breaking = BREAKING_CONSTANT()\n        print(breaking.render())\n        breaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constant\", \"CONSTANT\"] = Field(\n        default=\"constant\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The breaker index, i.e. the ratio of maximum individual wave height \"\n            \"over depth (SWAN default: 0.73)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING CONSTANT\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma is not None:\n            repr += f\" gamma={self.gamma}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constant', 'CONSTANT'] = Field(default='constant', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT.gamma","title":"gamma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma: Optional[float] = Field(default=None, description='The breaker index, i.e. the ratio of maximum individual wave height over depth (SWAN default: 0.73)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_CONSTANT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING CONSTANT\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma is not None:\n        repr += f\" gamma={self.gamma}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD","title":"BREAKING_BKD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Variable wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n</code></pre> <p>Indicates that the breaker index scales with both the bottom slope (<code>beta</code>) and the dimensionless depth (kd).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_BKD\nbreaking = BREAKING_BKD()\nprint(breaking.render())\nbreaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\nprint(breaking.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BREAKING_BKD(BaseComponent):\n    \"\"\"Variable wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n\n    Indicates that the breaker index scales with both the bottom slope (`beta`)\n    and the dimensionless depth (kd).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_BKD\n        breaking = BREAKING_BKD()\n        print(breaking.render())\n        breaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bkd\", \"BKD\"] = Field(\n        default=\"bkd\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma0: Optional[float] = Field(\n        default=None,\n        description=\"The reference $gamma$ for horizontal slopes (SWAN default: 0.54)\",\n    )\n    a1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First tunable coefficient for the breaker index (SWAN default: 7.59)\"\n        ),\n    )\n    a2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second tunable coefficient for the breaker index (SWAN default: -8.06)\"\n        ),\n    )\n    a3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Third tunable coefficient for the breaker index (SWAN default: 8.09)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING BKD\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma0 is not None:\n            repr += f\" gamma0={self.gamma0}\"\n        if self.a1 is not None:\n            repr += f\" a1={self.a1}\"\n        if self.a2 is not None:\n            repr += f\" a2={self.a2}\"\n        if self.a3 is not None:\n            repr += f\" a3={self.a3}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bkd', 'BKD'] = Field(default='bkd', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.gamma0","title":"gamma0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma0: Optional[float] = Field(default=None, description='The reference $gamma$ for horizontal slopes (SWAN default: 0.54)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.a1","title":"a1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1: Optional[float] = Field(default=None, description='First tunable coefficient for the breaker index (SWAN default: 7.59)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.a2","title":"a2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2: Optional[float] = Field(default=None, description='Second tunable coefficient for the breaker index (SWAN default: -8.06)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.a3","title":"a3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a3: Optional[float] = Field(default=None, description='Third tunable coefficient for the breaker index (SWAN default: 8.09)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.BREAKING_BKD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING BKD\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma0 is not None:\n        repr += f\" gamma0={self.gamma0}\"\n    if self.a1 is not None:\n        repr += f\" a1={self.a1}\"\n    if self.a2 is not None:\n        repr += f\" a2={self.a2}\"\n    if self.a3 is not None:\n        repr += f\" a3={self.a3}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP","title":"FRICTION_JONSWAP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Hasselmann et al. (1973) Jonswap friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION JONSWAP CONSTANT [cfjon]\n</code></pre> <p>Indicates that the semi-empirical expression derived from the JONSWAP results for bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated. This option is default.</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP--references","title":"References","text":"<p>Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K., Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973. Measurements of wind-wave growth and swell decay during the Joint North Sea Wave Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany, Rep. No. 12, 95 pp.</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_JONSWAP\nfriction = FRICTION_JONSWAP()\nprint(friction.render())\nfriction = FRICTION_JONSWAP(cfjon=0.038)\nprint(friction.render())\n</code></pre> <p>TODO: Implement VARIABLE option?</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_JONSWAP(BaseComponent):\n    \"\"\"Hasselmann et al. (1973) Jonswap friction.\n\n    .. code-block:: text\n\n        FRICTION JONSWAP CONSTANT [cfjon]\n\n    Indicates that the semi-empirical expression derived from the JONSWAP results for\n    bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated.\n    This option is default.\n\n    References\n    ----------\n    Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K.,\n    Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973.\n    Measurements of wind-wave growth and swell decay during the Joint North Sea Wave\n    Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany,\n    Rep. No. 12, 95 pp.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_JONSWAP\n        friction = FRICTION_JONSWAP()\n        print(friction.render())\n        friction = FRICTION_JONSWAP(cfjon=0.038)\n        print(friction.render())\n\n    TODO: Implement VARIABLE option?\n\n    \"\"\"\n\n    model_type: Literal[\"jonswap\", \"JONSWAP\"] = Field(\n        default=\"jonswap\", description=\"Model type discriminator\"\n    )\n    cfjon: Optional[float] = Field(\n        default=None,\n        description=\"Coefficient of the JONSWAP formulation (SWAN default: 0.038)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION JONSWAP CONSTANT\"\n        if self.cfjon is not None:\n            repr += f\" cfjon={self.cfjon}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['jonswap', 'JONSWAP'] = Field(default='jonswap', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP.cfjon","title":"cfjon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfjon: Optional[float] = Field(default=None, description='Coefficient of the JONSWAP formulation (SWAN default: 0.038)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_JONSWAP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION JONSWAP CONSTANT\"\n    if self.cfjon is not None:\n        repr += f\" cfjon={self.cfjon}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS","title":"FRICTION_COLLINS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Collins (1972) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION COLLINS [cfw]\n</code></pre> <p>Note that <code>cfw</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>cfw</code> in this command is then not required (it will be ignored).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS--references","title":"References","text":"<p>Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical Research, 77(15), pp.2693-2707.</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_COLLINS\nfriction = FRICTION_COLLINS()\nprint(friction.render())\nfriction = FRICTION_COLLINS(cfw=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_COLLINS(BaseComponent):\n    \"\"\"Collins (1972) friction.\n\n    .. code-block:: text\n\n        FRICTION COLLINS [cfw]\n\n    Note that `cfw` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `cfw` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical\n    Research, 77(15), pp.2693-2707.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_COLLINS\n        friction = FRICTION_COLLINS()\n        print(friction.render())\n        friction = FRICTION_COLLINS(cfw=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"collins\", \"COLLINS\"] = Field(\n        default=\"collins\", description=\"Model type discriminator\"\n    )\n    cfw: Optional[float] = Field(\n        default=None,\n        description=\"Collins bottom friction coefficient (SWAN default: 0.015)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION COLLINS\"\n        if self.cfw is not None:\n            repr += f\" cfw={self.cfw}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['collins', 'COLLINS'] = Field(default='collins', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS.cfw","title":"cfw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfw: Optional[float] = Field(default=None, description='Collins bottom friction coefficient (SWAN default: 0.015)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_COLLINS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION COLLINS\"\n    if self.cfw is not None:\n        repr += f\" cfw={self.cfw}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN","title":"FRICTION_MADSEN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Madsen et al (1988) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION MADSEN [kn]\n</code></pre> <p>Note that <code>kn</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>kn</code> in this command is then not required (it will be ignored).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN--references","title":"References","text":"<p>Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).</p> <p>Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).</p>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_MADSEN\nfriction = FRICTION_MADSEN()\nprint(friction.render())\nfriction = FRICTION_MADSEN(kn=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_MADSEN(BaseComponent):\n    \"\"\"Madsen et al (1988) friction.\n\n    .. code-block:: text\n\n        FRICTION MADSEN [kn]\n\n    Note that `kn` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `kn` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by\n    bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).\n\n    Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom\n    friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_MADSEN\n        friction = FRICTION_MADSEN()\n        print(friction.render())\n        friction = FRICTION_MADSEN(kn=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"madsen\", \"MADSEN\"] = Field(\n        default=\"madsen\", description=\"Model type discriminator\"\n    )\n    kn: Optional[float] = Field(\n        default=None,\n        description=(\n            \"equivalent roughness length scale of the bottom (in m) \"\n            \"(SWAN default: 0.05)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION MADSEN\"\n        if self.kn is not None:\n            repr += f\" kn={self.kn}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['madsen', 'MADSEN'] = Field(default='madsen', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN.kn","title":"kn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kn: Optional[float] = Field(default=None, description='equivalent roughness length scale of the bottom (in m) (SWAN default: 0.05)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.physics.FRICTION_MADSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION MADSEN\"\n    if self.kn is not None:\n        repr += f\" kn={self.kn}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#numerics-components","title":"Numerics Components","text":""},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP","title":"PROP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Propagation scheme.</p> <p>.. code-block:: text</p> <pre><code>PROP BSTB|GSE\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP--notes","title":"Notes","text":"<ul> <li>The scheme defaults to <code>S&amp;L</code> and <code>SORDUP</code> for nonstationary and stationary   simulations if not specified.</li> <li>All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear   grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a   gradually varying grid otherwise there may be a severe loss of accuracy. If sharp   transitions in the grid cannot be avoided it is safer to use the BSBT scheme.</li> <li>In the computation with unstructured meshes, a lowest order upwind scheme will be   employed. This scheme is very robust but rather diffusive. This may only be   significant for the case when swell waves propagate over relative large distances   (in the order of thousands of kilometers) within the model domain. However and   most fortunately, in such a case this will alleviate the garden-sprinkler effect.</li> <li>Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN   computation conditionally stable. You can either use (i) a smaller time step,   (ii) a lower value of <code>waveage</code>, (iii) better resolution in the directional   space, or (iv) worse resolution in the geographic space, in order of preference,   to make the model stable when necessary.</li> </ul>"},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import PROP\nprop = PROP()\nprint(prop.render())\nprop = PROP(scheme=dict(model_type=\"bsbt\"))\nprint(prop.render())\nprop = PROP(\n    scheme=dict(\n        model_type=\"gse\",\n        waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n    ),\n)\nprint(prop.render())\n</code></pre> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>class PROP(BaseComponent):\n    \"\"\"Propagation scheme.\n\n    .. code-block:: text\n\n        PROP BSTB|GSE\n\n    Notes\n    -----\n    * The scheme defaults to `S&amp;L` and `SORDUP` for nonstationary and stationary\n      simulations if not specified.\n    * All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear\n      grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a\n      gradually varying grid otherwise there may be a severe loss of accuracy. If sharp\n      transitions in the grid cannot be avoided it is safer to use the BSBT scheme.\n    * In the computation with unstructured meshes, a lowest order upwind scheme will be\n      employed. This scheme is very robust but rather diffusive. This may only be\n      significant for the case when swell waves propagate over relative large distances\n      (in the order of thousands of kilometers) within the model domain. However and\n      most fortunately, in such a case this will alleviate the garden-sprinkler effect.\n    * Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN\n      computation conditionally stable. You can either use (i) a smaller time step,\n      (ii) a lower value of `waveage`, (iii) better resolution in the directional\n      space, or (iv) worse resolution in the geographic space, in order of preference,\n      to make the model stable when necessary.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import PROP\n        prop = PROP()\n        print(prop.render())\n        prop = PROP(scheme=dict(model_type=\"bsbt\"))\n        print(prop.render())\n        prop = PROP(\n            scheme=dict(\n                model_type=\"gse\",\n                waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n            ),\n        )\n        print(prop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"prop\", \"PROP\"] = Field(\n        default=\"prop\", description=\"Model type discriminator\"\n    )\n    scheme: Optional[PROP_TYPE] = Field(\n        default=None,\n        description=(\n            \"Propagation scheme, by default S&amp;L for nonstationary and SORDUP for \"\n            \"stationary computation.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"PROP\"\n        if self.scheme is not None:\n            repr += f\" {self.scheme.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['prop', 'PROP'] = Field(default='prop', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP.scheme","title":"scheme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scheme: Optional[PROP_TYPE] = Field(default=None, description='Propagation scheme, by default S&amp;L for nonstationary and SORDUP for stationary computation.')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.numerics.PROP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"PROP\"\n    if self.scheme is not None:\n        repr += f\" {self.scheme.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC","title":"NUMERIC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Numerical properties.</p> <p>.. code-block:: text</p> <pre><code>NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n    ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n    ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import NUMERIC\nnumeric = NUMERIC()\nprint(numeric.render())\nnumeric = NUMERIC(\n    stop=dict(\n        model_type=\"stopc\",\n        dabs=0.05,\n        drel=0.01,\n        curvat=0.05,\n        npnts=99.5,\n    ),\n    dirimpl=dict(cdd=0.5),\n    sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n    ctheta=dict(cfl=0.9),\n    csigma=dict(cfl=0.9),\n    setup=dict(eps2=1e-4, outp=0, niter=20),\n)\nprint(numeric.render())\n</code></pre> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>class NUMERIC(BaseComponent):\n    \"\"\"Numerical properties.\n\n    .. code-block:: text\n\n        NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n            ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n            ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import NUMERIC\n        numeric = NUMERIC()\n        print(numeric.render())\n        numeric = NUMERIC(\n            stop=dict(\n                model_type=\"stopc\",\n                dabs=0.05,\n                drel=0.01,\n                curvat=0.05,\n                npnts=99.5,\n            ),\n            dirimpl=dict(cdd=0.5),\n            sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n            ctheta=dict(cfl=0.9),\n            csigma=dict(cfl=0.9),\n            setup=dict(eps2=1e-4, outp=0, niter=20),\n        )\n        print(numeric.render())\n\n    \"\"\"\n\n    model_type: Literal[\"numeric\", \"NUMERIC\"] = Field(\n        default=\"numeric\", description=\"Model type discriminator\"\n    )\n    stop: Optional[Union[STOPC, ACCUR]] = Field(\n        default=None,\n        description=\"Iteration termination criteria\",\n        discriminator=\"model_type\",\n    )\n    dirimpl: Optional[DIRIMPL] = Field(\n        default=None,\n        description=\"Numerical scheme for refraction\",\n    )\n    sigimpl: Optional[SIGIMPL] = Field(\n        default=None,\n        description=\"Frequency shifting accuracy\",\n    )\n    ctheta: Optional[CTHETA] = Field(\n        default=None,\n        description=\"Prevents excessive directional turning\",\n    )\n    csigma: Optional[CSIGMA] = Field(\n        default=None,\n        description=\"Prevents excessive frequency shifting\",\n    )\n    setup: Optional[SETUP] = Field(\n        default=None,\n        description=\"Stop criteria in the computation of wave setup\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NUMERIC\"\n        if self.stop is not None:\n            repr += f\" {self.stop.render()}\"\n        if self.dirimpl is not None:\n            repr += f\" {self.dirimpl.render()}\"\n        if self.sigimpl is not None:\n            repr += f\" {self.sigimpl.render()}\"\n        if self.ctheta is not None:\n            repr += f\" {self.ctheta.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['numeric', 'NUMERIC'] = Field(default='numeric', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.stop","title":"stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop: Optional[Union[STOPC, ACCUR]] = Field(default=None, description='Iteration termination criteria', discriminator='model_type')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.dirimpl","title":"dirimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirimpl: Optional[DIRIMPL] = Field(default=None, description='Numerical scheme for refraction')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.sigimpl","title":"sigimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigimpl: Optional[SIGIMPL] = Field(default=None, description='Frequency shifting accuracy')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.ctheta","title":"ctheta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctheta: Optional[CTHETA] = Field(default=None, description='Prevents excessive directional turning')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.csigma","title":"csigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csigma: Optional[CSIGMA] = Field(default=None, description='Prevents excessive frequency shifting')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP] = Field(default=None, description='Stop criteria in the computation of wave setup')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.numerics.NUMERIC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NUMERIC\"\n    if self.stop is not None:\n        repr += f\" {self.stop.render()}\"\n    if self.dirimpl is not None:\n        repr += f\" {self.dirimpl.render()}\"\n    if self.sigimpl is not None:\n        repr += f\" {self.sigimpl.render()}\"\n    if self.ctheta is not None:\n        repr += f\" {self.ctheta.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#output-components","title":"Output Components","text":""},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK","title":"BLOCK","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n    [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that one or more spatial distributions should be written to a file.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK--note","title":"Note","text":"<p>The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the <code>sname</code> field.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK--note_1","title":"Note","text":"<p>The text of the header indicates run identification (see command <code>PROJECT</code>), time, frame or group name ('sname'), variable and unit. The number of header lines is 8.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK--note_2","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BLOCK\nblock = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\nprint(block.render())\nblock = BLOCK(\n    sname=\"COMPGRID\",\n    header=False,\n    fname=\"./output-grid.nc\",\n    idla=3,\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(\n        tbeg=\"2012-01-01T00:00:00\",\n        delt=\"PT30M\",\n        tfmt=1,\n        dfmt=\"min\",\n        suffix=\"\",\n    )\n)\nprint(block.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class BLOCK(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n            [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that one or more spatial\n    distributions should be written to a file.\n\n    Note\n    ----\n    The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the `sname` field.\n\n    Note\n    ----\n    The text of the header indicates run identification (see command `PROJECT`), time,\n    frame or group name ('sname'), variable and unit. The number of header lines is 8.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BLOCK\n        block = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\n        print(block.render())\n        block = BLOCK(\n            sname=\"COMPGRID\",\n            header=False,\n            fname=\"./output-grid.nc\",\n            idla=3,\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(\n                tbeg=\"2012-01-01T00:00:00\",\n                delt=\"PT30M\",\n                tfmt=1,\n                dfmt=\"min\",\n                suffix=\"\",\n            )\n        )\n        print(block.render())\n\n    \"\"\"\n\n    model_type: Literal[\"block\", \"BLOCK\"] = Field(\n        default=\"block\", description=\"Model type discriminator\"\n    )\n    header: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Indicate if the output should be written to a file with header lines \"\n            \"(SWAN default: True)\"\n        ),\n    )\n    idla: Optional[IDLA] = Field(\n        default=None,\n        description=(\n            \"Prescribe the lay-out of the output to file (supported options here are \"\n            \"1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by \"\n            \"MATLAB, however option 3 is recommended in case of binary MATLAB output \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n    unit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of the output. The program divides computed values \"\n            \"by `unit` before writing to file, so the user should multiply the \"\n            \"written value by `unit` to obtain the proper value. By default, if \"\n            \"HEADER is selected, value is written as a 5 position integer. SWAN takes \"\n            \"`unit` such that the largest number occurring in the block can be \"\n            \"printed. If NOHEADER is selected, values are printed in floating-point \"\n            \"format by default (`unit=1`)\"\n        ),\n    )\n\n    @field_validator(\"idla\")\n    @classmethod\n    def validate_idla(cls, idla: IDLA) -&gt; IDLA:\n        if idla is not None and idla not in (1, 3, 4):\n            raise ValueError(\n                f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n            )\n        return idla\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"blk\"\n\n    @property\n    def _header(self) -&gt; str:\n        \"\"\"Render the header instruction.\"\"\"\n        if self.header:\n            return \"HEADER\"\n        else:\n            return \"NOHEADER\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"BLOCK sname='{self.sname}'\"\n        if self.header is not None:\n            repr += f\" {self._header}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.idla is not None:\n            repr += f\" LAYOUT idla={self.idla}\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.unit is not None:\n            repr += f\"\\nunit={self.unit}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['block', 'BLOCK'] = Field(default='block', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: Optional[bool] = Field(default=None, description='Indicate if the output should be written to a file with header lines (SWAN default: True)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[IDLA] = Field(default=None, description='Prescribe the lay-out of the output to file (supported options here are 1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by MATLAB, however option 3 is recommended in case of binary MATLAB output (SWAN default: 1)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: Optional[float] = Field(default=None, description='Controls the scaling of the output. The program divides computed values by `unit` before writing to file, so the user should multiply the written value by `unit` to obtain the proper value. By default, if HEADER is selected, value is written as a 5 position integer. SWAN takes `unit` such that the largest number occurring in the block can be printed. If NOHEADER is selected, values are printed in floating-point format by default (`unit=1`)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(idla: IDLA) -&gt; IDLA\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"idla\")\n@classmethod\ndef validate_idla(cls, idla: IDLA) -&gt; IDLA:\n    if idla is not None and idla not in (1, 3, 4):\n        raise ValueError(\n            f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n        )\n    return idla\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.BLOCK.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"BLOCK sname='{self.sname}'\"\n    if self.header is not None:\n        repr += f\" {self._header}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.idla is not None:\n        repr += f\" LAYOUT idla={self.idla}\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.unit is not None:\n        repr += f\"\\nunit={self.unit}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE","title":"TABLE","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n    (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) one or more variables should be written to a file. The keywords <code>HEADER</code> and <code>NOHEADER</code> determine the appearance of the table; the filename determines the destination of the data.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE--note","title":"Note","text":"<p>HEADER: output is written in fixed format to file with headers giving name of variable and unit per column (numbers too large to be written will be shown as <code>****</code>. The number of header lines is 4.</p> <p>NOHEADER: output is written in floating point format to file and has no headers.</p> <p>INDEXED: output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should give two TABLE commands, one to produce one file with <code>XP</code> and <code>YP</code> as output quantities, the other with <code>HS</code>, <code>RTM01</code> or other output quantities.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import TABLE\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./output_table.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(table.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class TABLE(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n            (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) one or\n    more variables should be written to a file. The keywords `HEADER` and `NOHEADER`\n    determine the appearance of the table; the filename determines the destination of\n    the data.\n\n    Note\n    ----\n    **HEADER**:\n    output is written in fixed format to file with headers giving name of variable\n    and unit per column (numbers too large to be written will be shown as `****`.\n    The number of header lines is 4.\n\n    **NOHEADER**:\n    output is written in floating point format to file and has no headers.\n\n    **INDEXED**:\n    output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should\n    give two TABLE commands, one to produce one file with `XP` and `YP` as output\n    quantities, the other with `HS`, `RTM01` or other output quantities.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import TABLE\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./output_table.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(table.render())\n\n    \"\"\"\n\n    model_type: Literal[\"table\", \"TABLE\"] = Field(\n        default=\"table\", description=\"Model type discriminator\"\n    )\n    format: Optional[Literal[\"header\", \"noheader\", \"indexed\"]] = Field(\n        default=None,\n        description=(\n            \"Indicate if the table should be written to a file as a HEADER, NOHEADER \"\n            \"or INDEXED table format (SWAN default: HEADER)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"tbl\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"TABLE sname='{self.sname}'\"\n        if self.format is not None:\n            repr += f\" {self.format.upper()}\"\n        repr += f\" fname='{self.fname}'\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.output.TABLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['table', 'TABLE'] = Field(default='table', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[Literal['header', 'noheader', 'indexed']] = Field(default=None, description='Indicate if the table should be written to a file as a HEADER, NOHEADER or INDEXED table format (SWAN default: HEADER)')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.TABLE-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.output.TABLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"TABLE sname='{self.sname}'\"\n    if self.format is not None:\n        repr += f\" {self.format.upper()}\"\n    repr += f\" fname='{self.fname}'\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT","title":"SPECOUT","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write to data file the wave spectra.</p> <p>.. code-block:: text</p> <pre><code>SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n    (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) the 1D or 2D variance / energy (see command <code>SET</code>) density spectrum (either the relative frequency or the absolute frequency spectrum) is to be written to a data file.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT--note","title":"Note","text":"<p>This write command supports the following location types: <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> and <code>GROUP</code>.</p>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT--note_1","title":"Note","text":"<p>This output file can be used for defining boundary conditions for subsequent SWAN runs (command <code>BOUNDSPEC</code>).</p>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import SPECOUT\nout = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\nprint(out.render())\nout = SPECOUT(\n    sname=\"outpts\",\n    dim=dict(model_type=\"spec2d\"),\n    freq=dict(model_type=\"rel\"),\n    fname=\"./specout.nc\",\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(out.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class SPECOUT(BaseWrite):\n    \"\"\"Write to data file the wave spectra.\n\n    .. code-block:: text\n\n        SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n            (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) the 1D\n    or 2D variance / energy (see command `SET`) density spectrum (either the relative\n    frequency or the absolute frequency spectrum) is to be written to a data file.\n\n    Note\n    ----\n    This write command supports the following location types: `POINTS`, `CURVE`,\n    `FRAME` and `GROUP`.\n\n    Note\n    ----\n    This output file can be used for defining boundary conditions for subsequent SWAN\n    runs (command `BOUNDSPEC`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import SPECOUT\n        out = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\n        print(out.render())\n        out = SPECOUT(\n            sname=\"outpts\",\n            dim=dict(model_type=\"spec2d\"),\n            freq=dict(model_type=\"rel\"),\n            fname=\"./specout.nc\",\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"specout\", \"SPECOUT\"] = Field(\n        default=\"specout\", description=\"Model type discriminator\"\n    )\n    dim: Optional[DIM_TYPE] = Field(default=None)\n    freq: Optional[FREQ_TYPE] = Field(default=None)\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"spc\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"SPECOUT sname='{self.sname}'\"\n        if self.dim is not None:\n            repr += f\" {self.dim.render()}\"\n        if self.freq is not None:\n            repr += f\" {self.freq.render()}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.times is not None:\n            repr += f\" OUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['specout', 'SPECOUT'] = Field(default='specout', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Optional[DIM_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT.freq","title":"freq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freq: Optional[FREQ_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.output.SPECOUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"SPECOUT sname='{self.sname}'\"\n    if self.dim is not None:\n        repr += f\" {self.dim.render()}\"\n    if self.freq is not None:\n        repr += f\" {self.freq.render()}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.times is not None:\n        repr += f\" OUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"api-reference/components/#group-components","title":"Group Components","text":""},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP","title":"STARTUP","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Startup group component.</p> <p>.. code-block:: text</p> <pre><code>PROJECT ...\nSET ...\nMODE ...\nCOORDINATES ...\n</code></pre> <p>This group component is used to group individual startup components. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.group import STARTUP\nproj = PROJECT(nr=\"01\")\nset = SET(level=0.5, direction_convention=\"nautical\")\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\ncoords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\nstartup = STARTUP(\n    project=proj,\n    set=set,\n    mode=mode,\n    coordinates=coords,\n)\nprint(startup.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class STARTUP(BaseGroupComponent):\n    \"\"\"Startup group component.\n\n    .. code-block:: text\n\n        PROJECT ...\n        SET ...\n        MODE ...\n        COORDINATES ...\n\n    This group component is used to group individual startup components. Only fields\n    that are explicitly prescribed are rendered by this group component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\n        from rompy_swan.components.group import STARTUP\n        proj = PROJECT(nr=\"01\")\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        coords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\n        startup = STARTUP(\n            project=proj,\n            set=set,\n            mode=mode,\n            coordinates=coords,\n        )\n        print(startup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"startup\", \"STARTUP\"] = Field(\n        default=\"startup\", description=\"Model type discriminator\"\n    )\n    project: Optional[PROJECT_TYPE] = Field(default=None)\n    set: Optional[SET_TYPE] = Field(default=None)\n    mode: Optional[MODE_TYPE] = Field(default=None)\n    coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.project is not None:\n            repr += [f\"{self.project.cmd()}\"]\n        if self.set is not None:\n            repr += [f\"{self.set.cmd()}\"]\n        if self.mode is not None:\n            repr += [f\"{self.mode.cmd()}\"]\n        if self.coordinates is not None:\n            repr += [f\"{self.coordinates.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['startup', 'STARTUP'] = Field(default='startup', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.project","title":"project  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project: Optional[PROJECT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.set","title":"set  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set: Optional[SET_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[MODE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.coordinates","title":"coordinates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.group.STARTUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.project is not None:\n        repr += [f\"{self.project.cmd()}\"]\n    if self.set is not None:\n        repr += [f\"{self.set.cmd()}\"]\n    if self.mode is not None:\n        repr += [f\"{self.mode.cmd()}\"]\n    if self.coordinates is not None:\n        repr += [f\"{self.coordinates.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS","title":"PHYSICS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Physics group component.</p> <p>The physics group component is a convenience to allow specifying several individual components in a single command and check for consistency between them.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS--exemples","title":"Exemples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import PHYSICS\ngen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\nphys = PHYSICS(gen=gen)\nprint(phys.render())\nphys = PHYSICS(\n    gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n    negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n    sswell={\"model_type\": \"zieger\"},\n    breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n    friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n)\nprint(phys.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class PHYSICS(BaseGroupComponent):\n    \"\"\"Physics group component.\n\n    The physics group component is a convenience to allow specifying several individual\n    components in a single command and check for consistency between them.\n\n    Exemples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import PHYSICS\n        gen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\n        phys = PHYSICS(gen=gen)\n        print(phys.render())\n        phys = PHYSICS(\n            gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n            negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n            sswell={\"model_type\": \"zieger\"},\n            breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n            friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n        )\n        print(phys.render())\n\n    \"\"\"\n\n    model_type: Literal[\"physics\", \"PHYSICS\"] = Field(\n        default=\"physics\", description=\"Model type discriminator\"\n    )\n    gen: Optional[GEN_TYPE] = Field(default=None)\n    sswell: Optional[SSWELL_TYPE] = Field(default=None)\n    negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n    wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n    quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n    breaking: Optional[BREAKING_TYPE] = Field(default=None)\n    friction: Optional[FRICTION_TYPE] = Field(default=None)\n    triad: Optional[TRIAD_TYPE] = Field(default=None)\n    vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n    mud: Optional[MUD_TYPE] = Field(default=None)\n    sice: Optional[SICE_TYPE] = Field(default=None)\n    turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n    bragg: Optional[BRAGG_TYPE] = Field(default=None)\n    limiter: Optional[LIMITER_TYPE] = Field(default=None)\n    obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n    setup: Optional[SETUP_TYPE] = Field(default=None)\n    diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n    surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n    scat: Optional[SCAT_TYPE] = Field(default=None)\n    deactivate: Optional[OFF_TYPE] = Field(default=None)\n\n    @field_validator(\"deactivate\")\n    @classmethod\n    def deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n        \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n        for phys in PhysicsOff:\n            print(phys.value)\n        return off\n\n    @model_validator(mode=\"after\")\n    def negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n        \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n        if self.negatinp is None:\n            return self\n        elif self.sswell is None:\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n            )\n        elif self.sswell.model_type != \"zieger\":\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n                f\"{self.sswell.model_type.upper()} has been specified.\"\n            )\n        return self\n\n    def cmd(self):\n        repr = []\n        if self.gen is not None:\n            repr += [self.gen.cmd()]\n        if self.sswell is not None:\n            repr += [f\"{self.sswell.cmd()}\"]\n        if self.negatinp is not None:\n            repr += [self.negatinp.cmd()]\n        if self.wcapping is not None:\n            repr += [self.wcapping.cmd()]\n        if self.quadrupl is not None:\n            repr += [self.quadrupl.cmd()]\n        if self.breaking is not None:\n            repr += [self.breaking.cmd()]\n        if self.friction is not None:\n            repr += [self.friction.cmd()]\n        if self.triad is not None:\n            repr += [self.triad.cmd()]\n        if self.vegetation is not None:\n            repr += [self.vegetation.cmd()]\n        if self.mud is not None:\n            repr += [self.mud.cmd()]\n        if self.sice is not None:\n            repr += [self.sice.cmd()]\n        if self.turbulence is not None:\n            repr += [self.turbulence.cmd()]\n        if self.bragg is not None:\n            repr += [self.bragg.cmd()]\n        if self.limiter is not None:\n            repr += [self.limiter.cmd()]\n        if self.obstacle is not None:\n            repr += self.obstacle.cmd()  # Object returns a list of components\n        if self.setup is not None:\n            repr += [self.setup.cmd()]\n        if self.diffraction is not None:\n            repr += [self.diffraction.cmd()]\n        if self.surfbeat is not None:\n            repr += [self.surfbeat.cmd()]\n        if self.scat is not None:\n            repr += [self.scat.cmd()]\n        if self.deactivate is not None:\n            repr += self.deactivate.cmd()  # Object returns a list of components\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['physics', 'PHYSICS'] = Field(default='physics', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.gen","title":"gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gen: Optional[GEN_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.sswell","title":"sswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sswell: Optional[SSWELL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.negatinp","title":"negatinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.wcapping","title":"wcapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.quadrupl","title":"quadrupl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.breaking","title":"breaking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>breaking: Optional[BREAKING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>friction: Optional[FRICTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.triad","title":"triad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>triad: Optional[TRIAD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.vegetation","title":"vegetation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.mud","title":"mud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mud: Optional[MUD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.sice","title":"sice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sice: Optional[SICE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.turbulence","title":"turbulence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.bragg","title":"bragg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bragg: Optional[BRAGG_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[LIMITER_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.obstacle","title":"obstacle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.diffraction","title":"diffraction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.surfbeat","title":"surfbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.scat","title":"scat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scat: Optional[SCAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.deactivate","title":"deactivate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deactivate: Optional[OFF_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.deactivate_physics","title":"deactivate_physics  <code>classmethod</code>","text":"<pre><code>deactivate_physics(off: OFF_TYPE) -&gt; OFF_TYPE\n</code></pre> <p>Convert OFF to OFFS so list is rendered.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@field_validator(\"deactivate\")\n@classmethod\ndef deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n    \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n    for phys in PhysicsOff:\n        print(phys.value)\n    return off\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.negatinp_only_with_zieger","title":"negatinp_only_with_zieger","text":"<pre><code>negatinp_only_with_zieger() -&gt; PHYSICS\n</code></pre> <p>Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n    \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n    if self.negatinp is None:\n        return self\n    elif self.sswell is None:\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n        )\n    elif self.sswell.model_type != \"zieger\":\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n            f\"{self.sswell.model_type.upper()} has been specified.\"\n        )\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.PHYSICS.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self):\n    repr = []\n    if self.gen is not None:\n        repr += [self.gen.cmd()]\n    if self.sswell is not None:\n        repr += [f\"{self.sswell.cmd()}\"]\n    if self.negatinp is not None:\n        repr += [self.negatinp.cmd()]\n    if self.wcapping is not None:\n        repr += [self.wcapping.cmd()]\n    if self.quadrupl is not None:\n        repr += [self.quadrupl.cmd()]\n    if self.breaking is not None:\n        repr += [self.breaking.cmd()]\n    if self.friction is not None:\n        repr += [self.friction.cmd()]\n    if self.triad is not None:\n        repr += [self.triad.cmd()]\n    if self.vegetation is not None:\n        repr += [self.vegetation.cmd()]\n    if self.mud is not None:\n        repr += [self.mud.cmd()]\n    if self.sice is not None:\n        repr += [self.sice.cmd()]\n    if self.turbulence is not None:\n        repr += [self.turbulence.cmd()]\n    if self.bragg is not None:\n        repr += [self.bragg.cmd()]\n    if self.limiter is not None:\n        repr += [self.limiter.cmd()]\n    if self.obstacle is not None:\n        repr += self.obstacle.cmd()  # Object returns a list of components\n    if self.setup is not None:\n        repr += [self.setup.cmd()]\n    if self.diffraction is not None:\n        repr += [self.diffraction.cmd()]\n    if self.surfbeat is not None:\n        repr += [self.surfbeat.cmd()]\n    if self.scat is not None:\n        repr += [self.scat.cmd()]\n    if self.deactivate is not None:\n        repr += self.deactivate.cmd()  # Object returns a list of components\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS","title":"INPGRIDS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>SWAN input grids group component.</p> <p>.. code-block:: text</p> <pre><code>INPGRID ...\nREADGRID ...\n\nINPGRID ...\nREADGRID ...\n\n...\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of input grid components.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR, ICE\nfrom rompy_swan.components.group import INPGRIDS\ninpgrid_bottom = REGULAR(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"bottom.txt\"),\n)\ninpgrid_wind = REGULAR(\n    grid_type=\"wind\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\ninpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\ninpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\nprint(inpgrids.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class INPGRIDS(BaseGroupComponent):\n    \"\"\"SWAN input grids group component.\n\n    .. code-block:: text\n\n        INPGRID ...\n        READGRID ...\n\n        INPGRID ...\n        READGRID ...\n\n        ...\n\n    This group component is a convenience to allow defining and rendering\n    a list of input grid components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import REGULAR, ICE\n        from rompy_swan.components.group import INPGRIDS\n        inpgrid_bottom = REGULAR(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"bottom.txt\"),\n        )\n        inpgrid_wind = REGULAR(\n            grid_type=\"wind\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        inpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\n        inpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\n        print(inpgrids.render())\n\n    \"\"\"\n\n    model_type: Literal[\"inpgrids\"] = Field(\n        default=\"inpgrids\", description=\"Model type discriminator\"\n    )\n    inpgrids: list[INPGRID_TYPE] = Field(\n        min_length=1,\n        description=\"List of input grid components\",\n    )\n\n    @field_validator(\"inpgrids\")\n    @classmethod\n    def ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n        \"\"\"Ensure that each grid type is unique.\"\"\"\n        grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n        if len(grid_types) != len(set(grid_types)):\n            raise ValueError(\"Each grid type must be unique\")\n        return inpgrids\n\n    def cmd(self) -&gt; str | list:\n        repr = []\n        for inpgrid in self.inpgrids:\n            repr += [inpgrid.cmd()]\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['inpgrids'] = Field(default='inpgrids', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS.inpgrids","title":"inpgrids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inpgrids: list[INPGRID_TYPE] = Field(min_length=1, description='List of input grid components')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS.ensure_unique_grid_type","title":"ensure_unique_grid_type  <code>classmethod</code>","text":"<pre><code>ensure_unique_grid_type(inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE\n</code></pre> <p>Ensure that each grid type is unique.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@field_validator(\"inpgrids\")\n@classmethod\ndef ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n    \"\"\"Ensure that each grid type is unique.\"\"\"\n    grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n    if len(grid_types) != len(set(grid_types)):\n        raise ValueError(\"Each grid type must be unique\")\n    return inpgrids\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.INPGRIDS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str | list\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str | list:\n    repr = []\n    for inpgrid in self.inpgrids:\n        repr += [inpgrid.cmd()]\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT","title":"OUTPUT","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Output group component.</p> <p>.. code-block:: text</p> <pre><code>FRAME 'sname' ...\nGROUP 'sname' ...\nCURVE 'sname' ...\nRAY 'rname' ...\nISOLINE 'sname' 'rname' ...\nPOINTS 'sname ...\nNGRID 'sname' ...\nQUANTITY ...\nOUTPUT OPTIONS ...\nBLOCK 'sname' ...\nTABLE 'sname' ...\nSPECOUT 'sname' ...\nNESTOUT 'sname ...\n</code></pre> <p>This group component is used to define multiple types of output locations and write components in a single model. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT--note","title":"Note","text":"<p>The components prescribed are validated according to some constraints as defined in the SWAN manual:</p> <ul> <li>The name <code>'sname'</code> of each Locations component must be unique.</li> <li>The Locations <code>'sname'</code> assigned to each write component must be defined.</li> <li>The BLOCK component must be associated with either a <code>FRAME</code> or <code>GROUP</code>.</li> <li>The ISOLINE write component must be associated with a <code>RAY</code> component.</li> <li>The NGRID and NESTOUT components must be defined together.</li> </ul>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\nfrom rompy_swan.components.group import OUTPUT\npoints = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\nquantity = QUANTITIES(\n    quantities=[\n        dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n    ]\n)\ntimes = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\nblock = BLOCK(\n    model_type=\"block\",\n    sname=\"COMPGRID\",\n    fname=\"./swangrid.nc\",\n    output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n    times=times,\n)\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./swantable.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=times,\n)\nout = OUTPUT(\n    points=points,\n    quantity=quantity,\n    block=block,\n    table=table,\n)\nprint(out.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class OUTPUT(BaseGroupComponent):\n    \"\"\"Output group component.\n\n    .. code-block:: text\n\n        FRAME 'sname' ...\n        GROUP 'sname' ...\n        CURVE 'sname' ...\n        RAY 'rname' ...\n        ISOLINE 'sname' 'rname' ...\n        POINTS 'sname ...\n        NGRID 'sname' ...\n        QUANTITY ...\n        OUTPUT OPTIONS ...\n        BLOCK 'sname' ...\n        TABLE 'sname' ...\n        SPECOUT 'sname' ...\n        NESTOUT 'sname ...\n\n    This group component is used to define multiple types of output locations and\n    write components in a single model. Only fields that are explicitly prescribed are\n    rendered by this group component.\n\n    Note\n    ----\n    The components prescribed are validated according to some constraints as defined\n    in the SWAN manual:\n\n    - The name `'sname'` of each Locations component must be unique.\n    - The Locations `'sname'` assigned to each write component must be defined.\n    - The BLOCK component must be associated with either a `FRAME` or `GROUP`.\n    - The ISOLINE write component must be associated with a `RAY` component.\n    - The NGRID and NESTOUT components must be defined together.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\n        from rompy_swan.components.group import OUTPUT\n        points = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n        quantity = QUANTITIES(\n            quantities=[\n                dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n            ]\n        )\n        times = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\n        block = BLOCK(\n            model_type=\"block\",\n            sname=\"COMPGRID\",\n            fname=\"./swangrid.nc\",\n            output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n            times=times,\n        )\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./swantable.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=times,\n        )\n        out = OUTPUT(\n            points=points,\n            quantity=quantity,\n            block=block,\n            table=table,\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"output\", \"OUTPUT\"] = Field(\n        default=\"output\", description=\"Model type discriminator\"\n    )\n    frame: Optional[FRAME_TYPE] = Field(default=None)\n    group: Optional[GROUP_TYPE] = Field(default=None)\n    curve: Optional[CURVE_TYPE] = Field(default=None)\n    ray: Optional[RAY_TYPE] = Field(default=None)\n    isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n    points: Optional[POINTS_TYPE] = Field(default=None)\n    ngrid: Optional[NGRID_TYPE] = Field(default=None)\n    quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n    output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n    block: Optional[BLOCK_TYPE] = Field(default=None)\n    table: Optional[TABLE_TYPE] = Field(default=None)\n    specout: Optional[SPECOUT_TYPE] = Field(default=None)\n    nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n    test: Optional[TEST_TYPE] = Field(default=None)\n    _location_fields: list = [\"frame\", \"group\", \"curve\", \"isoline\", \"points\", \"ngrid\"]\n    _write_fields: list = [\"block\", \"table\", \"specout\", \"nestout\"]\n\n    @model_validator(mode=\"after\")\n    def write_locations_exists(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n        for write in self.write_set:\n            obj = getattr(self, write)\n            if obj is None:\n                continue\n            snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for sname in snames:\n                if sname in SPECIAL_NAMES:\n                    return self\n                try:\n                    self._filter_location(sname)\n                except ValueError as err:\n                    raise ValueError(\n                        f\"Write component '{write}' specified with sname='{sname}' but \"\n                        f\"no location component with sname='{sname}' has been defined\"\n                    ) from err\n        return self\n\n    @model_validator(mode=\"after\")\n    def locations_sname_unique(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n        duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n        if duplicates:\n            raise ValueError(\n                \"The following snames are used to define more than one set of output \"\n                f\"components: {duplicates}, please ensure each location component has \"\n                \"a unique `sname`\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n        if self.block is not None:\n            snames = self.block.sname\n            if isinstance(snames, str):\n                snames = [self.block.sname]\n            for sname in snames:\n                if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                    location = self._filter_location(sname)\n                    component = location.model_type.upper().split(\"_\")[0]\n                    if component not in [\"FRAME\", \"GROUP\"]:\n                        raise ValueError(\n                            f\"Block sname='{sname}' specified with {component} \"\n                            \"location component but only only FRAME or GROUP \"\n                            \"components are supported\"\n                        )\n        return self\n\n    @model_validator(mode=\"after\")\n    def isoline_ray_defined(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the isoline ray has been defined.\"\"\"\n        if self.isoline is not None:\n            if self.ray is None:\n                raise ValueError(\n                    f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                    \" but no RAY component has been defined\"\n                )\n            elif self.ray.rname != self.isoline.rname:\n                raise ValueError(\n                    f\"Isoline rname='{self.isoline.rname}' does not match \"\n                    f\"the ray rname='{self.ray.rname}'\"\n                )\n        return self\n\n    @model_validator(mode=\"after\")\n    def ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n        if self.ngrid is not None and self.nestout is None:\n            raise ValueError(\n                \"NGRID component specified but no NESTOUT component has been defined\"\n            )\n        elif self.ngrid is None and self.nestout is not None:\n            raise ValueError(\n                \"NESTOUT component specified but no NGRID component has been defined\"\n            )\n        elif self.ngrid is not None and self.nestout is not None:\n            if self.ngrid.sname != self.nestout.sname:\n                raise ValueError(\n                    f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                    f\"the NESTOUT sname='{self.nestout.sname}'\"\n                )\n        return self\n\n    @property\n    def locations_set(self):\n        \"\"\"List of specified location fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._location_fields]\n\n    @property\n    def write_set(self):\n        \"\"\"List of specified write fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._write_fields]\n\n    @property\n    def snames(self):\n        \"\"\"List of snames from specified location components.\"\"\"\n        snames = []\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            sname = obj.sname\n            if isinstance(sname, str):\n                sname = [sname]\n            snames.extend(sname)\n        return snames\n\n    def _filter_location(self, sname):\n        \"\"\"Filter the location component defined with the specified sname.\"\"\"\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            obj_snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for obj_sname in obj_snames:\n                if obj_sname == sname:\n                    return obj\n        raise ValueError(f\"Location component with sname='{sname}' not found\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.frame is not None:\n            repr += [f\"{self.frame.cmd()}\"]\n        if self.group is not None:\n            repr += [f\"{self.group.cmd()}\"]\n        if self.curve is not None:\n            # Component renders a list\n            repr += self.curve.cmd()\n        if self.ray is not None:\n            repr += [f\"{self.ray.cmd()}\"]\n        if self.isoline is not None:\n            repr += [f\"{self.isoline.cmd()}\"]\n        if self.points is not None:\n            repr += [f\"{self.points.cmd()}\"]\n        if self.ngrid is not None:\n            repr += [f\"{self.ngrid.cmd()}\"]\n        if self.quantity is not None:\n            # Component renders a list\n            repr += self.quantity.cmd()\n        if self.output_options is not None:\n            repr += [f\"{self.output_options.cmd()}\"]\n        if self.block is not None:\n            # Component may or may not render a list, handles both\n            cmds = self.block.cmd()\n            if not isinstance(cmds, list):\n                cmds = [cmds]\n            for cmd in cmds:\n                repr += [f\"{cmd}\"]\n        if self.table is not None:\n            repr += [f\"{self.table.cmd()}\"]\n        if self.specout is not None:\n            repr += [f\"{self.specout.cmd()}\"]\n        if self.nestout is not None:\n            repr += [f\"{self.nestout.cmd()}\"]\n        if self.test is not None:\n            repr += [f\"{self.test.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['output', 'OUTPUT'] = Field(default='output', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.frame","title":"frame  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame: Optional[FRAME_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: Optional[GROUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curve: Optional[CURVE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.ray","title":"ray  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ray: Optional[RAY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.isoline","title":"isoline  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Optional[POINTS_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.ngrid","title":"ngrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ngrid: Optional[NGRID_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.output_options","title":"output_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Optional[BLOCK_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: Optional[TABLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.specout","title":"specout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specout: Optional[SPECOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.nestout","title":"nestout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.test","title":"test  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>test: Optional[TEST_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.locations_set","title":"locations_set  <code>property</code>","text":"<pre><code>locations_set\n</code></pre> <p>List of specified location fields.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.write_set","title":"write_set  <code>property</code>","text":"<pre><code>write_set\n</code></pre> <p>List of specified write fields.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.snames","title":"snames  <code>property</code>","text":"<pre><code>snames\n</code></pre> <p>List of snames from specified location components.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.write_locations_exists","title":"write_locations_exists","text":"<pre><code>write_locations_exists() -&gt; OUTPUT\n</code></pre> <p>Ensure the location component requested by a write component exists.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef write_locations_exists(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n    for write in self.write_set:\n        obj = getattr(self, write)\n        if obj is None:\n            continue\n        snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n        for sname in snames:\n            if sname in SPECIAL_NAMES:\n                return self\n            try:\n                self._filter_location(sname)\n            except ValueError as err:\n                raise ValueError(\n                    f\"Write component '{write}' specified with sname='{sname}' but \"\n                    f\"no location component with sname='{sname}' has been defined\"\n                ) from err\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.locations_sname_unique","title":"locations_sname_unique","text":"<pre><code>locations_sname_unique() -&gt; OUTPUT\n</code></pre> <p>Ensure same <code>sname</code> isn't used in more than one set of output locations.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef locations_sname_unique(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n    duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n    if duplicates:\n        raise ValueError(\n            \"The following snames are used to define more than one set of output \"\n            f\"components: {duplicates}, please ensure each location component has \"\n            \"a unique `sname`\"\n        )\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.block_with_frame_or_group","title":"block_with_frame_or_group","text":"<pre><code>block_with_frame_or_group() -&gt; OUTPUT\n</code></pre> <p>Ensure Block is only defined for FRAME or GROUP locations.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n    if self.block is not None:\n        snames = self.block.sname\n        if isinstance(snames, str):\n            snames = [self.block.sname]\n        for sname in snames:\n            if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                location = self._filter_location(sname)\n                component = location.model_type.upper().split(\"_\")[0]\n                if component not in [\"FRAME\", \"GROUP\"]:\n                    raise ValueError(\n                        f\"Block sname='{sname}' specified with {component} \"\n                        \"location component but only only FRAME or GROUP \"\n                        \"components are supported\"\n                    )\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.isoline_ray_defined","title":"isoline_ray_defined","text":"<pre><code>isoline_ray_defined() -&gt; OUTPUT\n</code></pre> <p>Ensure the isoline ray has been defined.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef isoline_ray_defined(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the isoline ray has been defined.\"\"\"\n    if self.isoline is not None:\n        if self.ray is None:\n            raise ValueError(\n                f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                \" but no RAY component has been defined\"\n            )\n        elif self.ray.rname != self.isoline.rname:\n            raise ValueError(\n                f\"Isoline rname='{self.isoline.rname}' does not match \"\n                f\"the ray rname='{self.ray.rname}'\"\n            )\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.ngrid_and_nestout","title":"ngrid_and_nestout","text":"<pre><code>ngrid_and_nestout() -&gt; OUTPUT\n</code></pre> <p>Ensure NGRID and NESTOUT are specified together.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n    if self.ngrid is not None and self.nestout is None:\n        raise ValueError(\n            \"NGRID component specified but no NESTOUT component has been defined\"\n        )\n    elif self.ngrid is None and self.nestout is not None:\n        raise ValueError(\n            \"NESTOUT component specified but no NGRID component has been defined\"\n        )\n    elif self.ngrid is not None and self.nestout is not None:\n        if self.ngrid.sname != self.nestout.sname:\n            raise ValueError(\n                f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                f\"the NESTOUT sname='{self.nestout.sname}'\"\n            )\n    return self\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.OUTPUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.frame is not None:\n        repr += [f\"{self.frame.cmd()}\"]\n    if self.group is not None:\n        repr += [f\"{self.group.cmd()}\"]\n    if self.curve is not None:\n        # Component renders a list\n        repr += self.curve.cmd()\n    if self.ray is not None:\n        repr += [f\"{self.ray.cmd()}\"]\n    if self.isoline is not None:\n        repr += [f\"{self.isoline.cmd()}\"]\n    if self.points is not None:\n        repr += [f\"{self.points.cmd()}\"]\n    if self.ngrid is not None:\n        repr += [f\"{self.ngrid.cmd()}\"]\n    if self.quantity is not None:\n        # Component renders a list\n        repr += self.quantity.cmd()\n    if self.output_options is not None:\n        repr += [f\"{self.output_options.cmd()}\"]\n    if self.block is not None:\n        # Component may or may not render a list, handles both\n        cmds = self.block.cmd()\n        if not isinstance(cmds, list):\n            cmds = [cmds]\n        for cmd in cmds:\n            repr += [f\"{cmd}\"]\n    if self.table is not None:\n        repr += [f\"{self.table.cmd()}\"]\n    if self.specout is not None:\n        repr += [f\"{self.specout.cmd()}\"]\n    if self.nestout is not None:\n        repr += [f\"{self.nestout.cmd()}\"]\n    if self.test is not None:\n        repr += [f\"{self.test.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP","title":"LOCKUP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Lockup group component.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE ...\nHOTFILE ...\nCOMPUTE ...\nHOTFILE ...\n...\nSTOP\n</code></pre> <p>This is a group component to specify SWAN \"Lockup\" commands including multiple <code>COMPUTE</code> commands that may or may not be interleaved with <code>HOTFILE</code> commands, and a final <code>STOP</code> command.</p>"},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import LOCKUP\nlockup = LOCKUP(\n    compute=dict(\n        model_type=\"stat\",\n        times=dict(\n            model_type=\"nonstationary\",\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-01-01T03:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        ),\n        hotfile=dict(fname=\"hotfile\"),\n        hottimes=[-1],\n    ),\n)\nprint(lockup.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class LOCKUP(BaseComponent):\n    \"\"\"Lockup group component.\n\n    .. code-block:: text\n\n        COMPUTE ...\n        HOTFILE ...\n        COMPUTE ...\n        HOTFILE ...\n        ...\n        STOP\n\n    This is a group component to specify SWAN \"Lockup\" commands including multiple\n    `COMPUTE` commands that may or may not be interleaved with `HOTFILE` commands,\n    and a final `STOP` command.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import LOCKUP\n        lockup = LOCKUP(\n            compute=dict(\n                model_type=\"stat\",\n                times=dict(\n                    model_type=\"nonstationary\",\n                    tbeg=\"1990-01-01T00:00:00\",\n                    tend=\"1990-01-01T03:00:00\",\n                    delt=\"PT1H\",\n                    dfmt=\"hr\",\n                ),\n                hotfile=dict(fname=\"hotfile\"),\n                hottimes=[-1],\n            ),\n        )\n        print(lockup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"lockup\", \"LOCKUP\"] = Field(\n        default=\"lockup\", description=\"Model type discriminator\"\n    )\n    compute: COMPUTE_TYPE = Field(description=\"Compute components\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lockup', 'LOCKUP'] = Field(default='lockup', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP.compute","title":"compute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compute: COMPUTE_TYPE = Field(description='Compute components')\n</code></pre>"},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP-functions","title":"Functions","text":""},{"location":"api-reference/components/#rompy_swan.components.group.LOCKUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"api-reference/config/","title":"Config","text":"<p>The <code>SwanConfig</code> class is the main entry point for configuring SWAN simulations.</p>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig","title":"SwanConfig","text":"<p>               Bases: <code>BaseConfig</code></p> <p>SWAN config class.</p> <p>TODO: Combine boundary and inpgrid into a single input type.</p>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig--note","title":"Note","text":"<p>The <code>cgrid</code> is the only required field since it is used to define the swan grid object which is passed to other components.</p>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig--time-control","title":"Time Control","text":"<p>When calling the config with a runtime <code>TimeRange</code> object (e.g., from <code>ModelRun.period</code>), the temporal parameters are set as follows:</p> <p>COMPUTE Components (LOCKUP):     - Time values (<code>tbeg</code>, <code>tend</code>, <code>delt</code>) are always from the runtime <code>TimeRange</code>     - Time and interval formatting (<code>tfmt</code>, <code>dfmt</code>) can be specified in the component's        <code>times</code> field     - The runtime <code>interval</code> defines the computational timestep (<code>deltc</code>)</p> <p>OUTPUT Components (BLOCK, TABLE, SPECOUT, NESTOUT):     - Start time (<code>tbeg</code>) is always from runtime <code>start</code>     - Time interval (<code>delt</code>) can be specified in the component's <code>times</code> field to        override runtime <code>interval</code>     - Time and interval formatting (<code>tfmt</code>, <code>dfmt</code>) can be specified in the component's        <code>times</code> field     - If no <code>times</code> field is specified, the component uses runtime <code>interval</code> for <code>delt</code></p> <p>This allows fine-grained control over: - COMPUTE: Time and interval formatting - OUTPUT: Time interval and formatting</p> <p>All components start at the same time from <code>ModelRun.period.start</code>.</p>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig--examples","title":"Examples","text":"<p>.. code-block:: python</p> <pre><code>from datetime import datetime, timedelta\nfrom rompy.core.time import TimeRange\n\n# Runtime with 1-hour interval\nruntime = TimeRange(\n    start=datetime(2024, 1, 1, 0, 0, 0),\n    end=datetime(2024, 1, 2, 0, 0, 0),\n    interval=timedelta(hours=1),\n)\n\nconfig = SwanConfig(\n    cgrid=dict(...),\n    output=dict(\n        # Custom 30-minute output interval\n        block=dict(\n            sname=\"COMPGRID\",\n            fname=\"output.nc\",\n            output=[\"hsign\"],\n            times=dict(delt=timedelta(minutes=30), tfmt=1, dfmt=\"min\"),\n        ),\n        # Uses runtime interval (1 hour)\n        table=dict(\n            sname=\"COMPGRID\",\n            fname=\"table.nc\",\n            output=[\"dir\"],\n        ),\n    ),\n)\n\n# Result:\n# - COMPUTE: deltc = 1 HR (from runtime)\n# - BLOCK: deltblk = 30 MIN (from component times)\n# - TABLE: delttbl = 1 HR (from runtime)\nrendered = config(runtime)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.cgrid","title":"cgrid  <code>instance-attribute</code>","text":"<pre><code>cgrid: CGRID_TYPES\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.startup","title":"startup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>startup: Optional[STARTUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.inpgrid","title":"inpgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inpgrid: Optional[INPGRID_TYPES] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.boundary","title":"boundary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>boundary: Optional[BOUNDARY_TYPES] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial: Optional[INITIAL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.physics","title":"physics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>physics: Optional[PHYSICS_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.prop","title":"prop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prop: Optional[PROP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.numeric","title":"numeric  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>numeric: Optional[NUMERIC_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Optional[OUTPUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.lockup","title":"lockup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lockup: Optional[LOCKUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"api-reference/config/#rompy_swan.config.SwanConfig.grid","title":"grid  <code>property</code>","text":"<pre><code>grid\n</code></pre> <p>Define a SwanGrid from the cgrid field.</p>"},{"location":"api-reference/data/","title":"Data API","text":""},{"location":"api-reference/data/#grid","title":"Grid","text":""},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid","title":"SwanGrid","text":"<p>               Bases: <code>RegularGrid</code></p> <p>Regular SWAN grid in geographic space.</p> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>class SwanGrid(RegularGrid):\n    \"\"\"Regular SWAN grid in geographic space.\"\"\"\n\n    grid_type: Literal[\"REG\", \"CURV\"] = Field(\n        \"REG\", description=\"Type of grid (REG=regular, CURV=curvilinear)\"\n    )\n    exc: Optional[float] = Field(None, description=\"Missing value\")\n    gridfile: Optional[str] = Field(\n        None, description=\"Name of grid file to load\", max_length=36\n    )\n\n    @field_validator(\"grid_type\")\n    @classmethod\n    def validate_grid_type(cls, v):\n        if v not in [\"REG\", \"CURV\"]:\n            raise ValueError(\"grid_type must be one of REG or CURV\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_curvilinear_grid(self) -&gt; \"SwanGrid\":\n        if self.grid_type == \"CURV\" and self.gridfile is None:\n            raise ValueError(\"gridfile must be provided for CURV grid\")\n        return self\n\n    def _regen_grid(self):\n        if self.grid_type == \"REG\":\n            _x, _y = self._gen_reg_cgrid()\n        elif self.grid_type == \"CURV\":\n            _x, _y = self._gen_curv_cgrid()\n        self.x = _x\n        self.y = _y\n\n    def _gen_curv_cgrid(self):\n        \"\"\"loads a SWAN curvilinear grid and returns cgrid lat/lons and\n        command to be used in SWAN contol file. The Default grid is one I made using\n        Deltares' RGFGrid tool and converted to a SWAN-friendly formate using Deltares\n        OpenEarth code \"swan_io_grd.m\"\n\n        \"\"\"\n        # number of grid cells in the 'x' and 'y' directions:\n        # (you can get this from d3d_qp.m or other Deltares OpenEarth code)\n        nX = self.nx\n        nY = self.ny\n\n        grid_Data = open(self.gridpath).readlines()\n        ix = grid_Data.index(\"x-coordinates\\n\")\n        iy = grid_Data.index(\"y-coordinates\\n\")\n        lons = []\n        lats = []\n        for idx in np.arange(ix + 1, iy):\n            lons.append(re.sub(\"\\n\", \"\", grid_Data[idx]).split())\n        for idx in np.arange(iy + 1, len(grid_Data)):\n            lats.append(re.sub(\"\\n\", \"\", grid_Data[idx]).split())\n\n        def flatten(l):\n            return [item for sublist in l for item in sublist]\n\n        lons = np.array(flatten(lons)).astype(np.float)\n        lats = np.array(flatten(lats)).astype(np.float)\n\n        x = np.reshape(lats, (nX, nY))\n        y = np.reshape(lons, (nX, nY))\n\n        return x, y\n\n    @property\n    def inpgrid(self):\n        if self.grid_type == \"REG\":\n            inpstr = f\"REG {self.x0} {self.y0} {self.rot} {self.nx-1:0.0f} {self.ny-1:0.0f} {self.dx} {self.dy}\"\n            if self.exc is not None:\n                inpstr += f\" EXC {self.exc}\"\n            return inpstr\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return f'CURVilinear {self.nx-1:0.0f} {self.ny-1:0.0f} \\nREADGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE'\n\n    @property\n    def cgrid(self):\n        if self.grid_type == \"REG\":\n            return f\"REG {self.x0} {self.y0} {self.rot} {self.xlen} {self.ylen} {self.nx-1:0.0f} {self.ny-1:0.0f}\"\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return (f'CURVilinear {self.nx-1:0.0f} {self.ny-1:0.0f}',f'READGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE')\n\n    @property\n    def cgrid_read(self):\n        if self.grid_type == \"REG\":\n            return \"\"\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return f'READGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE'\n\n    @property\n    def component(self):\n        \"\"\"Return the respective SWAN component for this grid.\"\"\"\n        if self.grid_type == \"REG\":\n            return GRIDREGULAR(\n                xp=self.x0,\n                yp=self.y0,\n                alp=self.rot,\n                xlen=self.xlen,\n                ylen=self.ylen,\n                mx=self.nx - 1,\n                my=self.ny - 1,\n            )\n        else:\n            raise NotImplementedError(\"Only regular grid is currently supported\")\n\n    def __call__(self):\n        output = f\"CGRID {self.cgrid} CIRCLE 36 0.0464 1. 31\\n\"\n        output += f\"{self.cgrid_read}\\n\"\n        return output\n\n    def boundary(self, *args, **kwargs) -&gt; tuple:\n        \"\"\"Returns the grid boundary polygon.\n\n        Override the parent method to use the actual points from the regular grid\n        boundary instead of the convex hull which is not always the boundary.\n\n        \"\"\"\n        x = np.concatenate(\n            [self.x[0, :], self.x[1:, -1], self.x[-1, -2::-1], self.x[-2::-1, 0]]\n        )\n        y = np.concatenate(\n            [self.y[0, :], self.y[1:, -1], self.y[-1, -2::-1], self.y[-2::-1, 0]]\n        )\n        return Polygon(zip(x, y))\n\n    def nearby_spectra(self, ds_spec, dist_thres=0.05, plot=True):\n        \"\"\"Find points nearby and project to the boundary\n\n        Parameters\n        ----------\n        ds_spec: xarray.Dataset\n            an XArray dataset of wave spectra at a number of points.\n            Dataset variable names standardised using wavespectra.read_*\n            functions.\n\n            See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n        dist_thres: float, optional [Default: 0.05]\n            Maximum distance to translate the input spectra to the grid boundary\n        plot: boolean, optional [Default: True]\n            Generate a plot that shows the applied projections\n\n        Returns\n        -------\n        xarray.Dataset\n            A subset of ds_spec with lat and lon coordinates projected to the boundary\n        \"\"\"\n\n        bbox = self.bbox(buffer=dist_thres)\n        minLon, minLat, maxLon, maxLat = bbox\n\n        inds = np.where(\n            (ds_spec.lon &gt; minLon)\n            &amp; (ds_spec.lon &lt; maxLon)\n            &amp; (ds_spec.lat &gt; minLat)\n            &amp; (ds_spec.lat &lt; maxLat)\n        )[0]\n        ds_spec = ds_spec.isel(site=inds)\n\n        # Work out the closest spectral points\n        def _nearestPointOnLine(p1, p2, p3):\n            # calculate the distance of p3 from the line between p1 and p2 and return\n            # the closest point on the line\n\n            from math import fabs, sqrt\n\n            a = p2[1] - p1[1]\n            b = -1.0 * (p2[0] - p1[0])\n            c = p2[0] * p1[1] - p2[1] * p1[0]\n\n            dist = fabs(a * p3[0] + b * p3[1] + c) / sqrt(a**2 + b**2)\n            x = (b * (b * p3[0] - a * p3[1]) - a * c) / (a**2 + b**2)\n            y = (a * (-b * p3[0] + a * p3[1]) - b * c) / (a**2 + b**2)\n\n            return dist, x, y\n\n        bx, by = self.boundary_points()\n        pol = np.stack([bx, by])\n\n        # Spectra points\n        ds_spec.lon.load()\n        ds_spec.lat.load()\n        ds_spec[\"lon_original\"] = ds_spec[\"lon\"]\n        ds_spec[\"lat_original\"] = ds_spec[\"lat\"]\n        p3s = list(zip(ds_spec.lon.values, ds_spec.lat.values))\n\n        if plot:\n            fig, ax = self.plot()\n            ax.scatter(ds_spec.lon, ds_spec.lat)\n\n        specPoints = []\n        for i in range(pol.shape[1] - 1):\n            p1 = pol[:, i]\n            p2 = pol[:, i + 1]\n            np.stack((p1, p2))\n            output = np.array(\n                list(map(lambda xi: _nearestPointOnLine(p1, p2, xi), p3s))\n            )\n            dists = output[:, 0]\n            segmentPoints = output[:, 1:]\n            inds = np.where((dists &lt; dist_thres))[0]\n\n            # Loop through the points projected onto the line\n            for ind in inds:\n                specPoint = ds_spec.isel(site=ind)\n\n                segLon = segmentPoints[ind, 0]\n                segLat = segmentPoints[ind, 1]\n\n                if plot:\n                    ax.plot(\n                        [segLon, specPoint.lon],\n                        [segLat, specPoint.lat],\n                        color=\"r\",\n                        lw=2,\n                    )\n                    ax.scatter(specPoint.lon, specPoint.lat, marker=\"o\", color=\"b\")\n                    ax.scatter(segLon, segLat, marker=\"x\", color=\"g\")\n\n                specPoint[\"lon\"] = segLon\n                specPoint[\"lat\"] = segLat\n                specPoints.append(specPoint)\n\n            logger.debug(f\"Segment {i} - Indices {inds}\")\n\n        if plot:\n            fig.show()\n\n        ds_boundary = xr.concat(specPoints, dim=\"site\")\n        return ds_boundary\n\n    def __repr__(self):\n        return f\"SwanGrid: {self.grid_type}, {self.nx}x{self.ny}\"\n\n    def __str__(self):\n        return f\"SwanGrid: {self.grid_type}, {self.nx}x{self.ny}\"\n\n    @classmethod\n    def from_component(cls, component: GRIDREGULAR) -&gt; \"SwanGrid\":\n        \"\"\"Swan grid from an existing component.\n\n        Parameters\n        ----------\n        component: GRIDREGULAR\n            A GRIDREGULAR SWAN component.\n\n        Returns\n        -------\n        SwanGrid\n            A SwanGrid object.\n\n        \"\"\"\n        return cls(\n            x0=component.xp,\n            y0=component.yp,\n            rot=component.alp,\n            dx=component.dx,\n            dy=component.dy,\n            nx=component.mx + 1,\n            ny=component.my + 1,\n        )\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['REG', 'CURV'] = Field('REG', description='Type of grid (REG=regular, CURV=curvilinear)')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.exc","title":"exc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exc: Optional[float] = Field(None, description='Missing value')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.gridfile","title":"gridfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gridfile: Optional[str] = Field(None, description='Name of grid file to load', max_length=36)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.inpgrid","title":"inpgrid  <code>property</code>","text":"<pre><code>inpgrid\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.cgrid","title":"cgrid  <code>property</code>","text":"<pre><code>cgrid\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.cgrid_read","title":"cgrid_read  <code>property</code>","text":"<pre><code>cgrid_read\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Return the respective SWAN component for this grid.</p>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.validate_grid_type","title":"validate_grid_type  <code>classmethod</code>","text":"<pre><code>validate_grid_type(v)\n</code></pre> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>@field_validator(\"grid_type\")\n@classmethod\ndef validate_grid_type(cls, v):\n    if v not in [\"REG\", \"CURV\"]:\n        raise ValueError(\"grid_type must be one of REG or CURV\")\n    return v\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.validate_curvilinear_grid","title":"validate_curvilinear_grid","text":"<pre><code>validate_curvilinear_grid() -&gt; SwanGrid\n</code></pre> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_curvilinear_grid(self) -&gt; \"SwanGrid\":\n    if self.grid_type == \"CURV\" and self.gridfile is None:\n        raise ValueError(\"gridfile must be provided for CURV grid\")\n    return self\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.boundary","title":"boundary","text":"<pre><code>boundary(*args, **kwargs) -&gt; tuple\n</code></pre> <p>Returns the grid boundary polygon.</p> <p>Override the parent method to use the actual points from the regular grid boundary instead of the convex hull which is not always the boundary.</p> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>def boundary(self, *args, **kwargs) -&gt; tuple:\n    \"\"\"Returns the grid boundary polygon.\n\n    Override the parent method to use the actual points from the regular grid\n    boundary instead of the convex hull which is not always the boundary.\n\n    \"\"\"\n    x = np.concatenate(\n        [self.x[0, :], self.x[1:, -1], self.x[-1, -2::-1], self.x[-2::-1, 0]]\n    )\n    y = np.concatenate(\n        [self.y[0, :], self.y[1:, -1], self.y[-1, -2::-1], self.y[-2::-1, 0]]\n    )\n    return Polygon(zip(x, y))\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.nearby_spectra","title":"nearby_spectra","text":"<pre><code>nearby_spectra(ds_spec, dist_thres=0.05, plot=True)\n</code></pre> <p>Find points nearby and project to the boundary</p>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.nearby_spectra--parameters","title":"Parameters","text":"<p>ds_spec: xarray.Dataset     an XArray dataset of wave spectra at a number of points.     Dataset variable names standardised using wavespectra.read_*     functions.</p> <pre><code>See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n</code></pre> <p>dist_thres: float, optional [Default: 0.05]     Maximum distance to translate the input spectra to the grid boundary plot: boolean, optional [Default: True]     Generate a plot that shows the applied projections</p>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.nearby_spectra--returns","title":"Returns","text":"<p>xarray.Dataset     A subset of ds_spec with lat and lon coordinates projected to the boundary</p> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>def nearby_spectra(self, ds_spec, dist_thres=0.05, plot=True):\n    \"\"\"Find points nearby and project to the boundary\n\n    Parameters\n    ----------\n    ds_spec: xarray.Dataset\n        an XArray dataset of wave spectra at a number of points.\n        Dataset variable names standardised using wavespectra.read_*\n        functions.\n\n        See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n    dist_thres: float, optional [Default: 0.05]\n        Maximum distance to translate the input spectra to the grid boundary\n    plot: boolean, optional [Default: True]\n        Generate a plot that shows the applied projections\n\n    Returns\n    -------\n    xarray.Dataset\n        A subset of ds_spec with lat and lon coordinates projected to the boundary\n    \"\"\"\n\n    bbox = self.bbox(buffer=dist_thres)\n    minLon, minLat, maxLon, maxLat = bbox\n\n    inds = np.where(\n        (ds_spec.lon &gt; minLon)\n        &amp; (ds_spec.lon &lt; maxLon)\n        &amp; (ds_spec.lat &gt; minLat)\n        &amp; (ds_spec.lat &lt; maxLat)\n    )[0]\n    ds_spec = ds_spec.isel(site=inds)\n\n    # Work out the closest spectral points\n    def _nearestPointOnLine(p1, p2, p3):\n        # calculate the distance of p3 from the line between p1 and p2 and return\n        # the closest point on the line\n\n        from math import fabs, sqrt\n\n        a = p2[1] - p1[1]\n        b = -1.0 * (p2[0] - p1[0])\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n\n        dist = fabs(a * p3[0] + b * p3[1] + c) / sqrt(a**2 + b**2)\n        x = (b * (b * p3[0] - a * p3[1]) - a * c) / (a**2 + b**2)\n        y = (a * (-b * p3[0] + a * p3[1]) - b * c) / (a**2 + b**2)\n\n        return dist, x, y\n\n    bx, by = self.boundary_points()\n    pol = np.stack([bx, by])\n\n    # Spectra points\n    ds_spec.lon.load()\n    ds_spec.lat.load()\n    ds_spec[\"lon_original\"] = ds_spec[\"lon\"]\n    ds_spec[\"lat_original\"] = ds_spec[\"lat\"]\n    p3s = list(zip(ds_spec.lon.values, ds_spec.lat.values))\n\n    if plot:\n        fig, ax = self.plot()\n        ax.scatter(ds_spec.lon, ds_spec.lat)\n\n    specPoints = []\n    for i in range(pol.shape[1] - 1):\n        p1 = pol[:, i]\n        p2 = pol[:, i + 1]\n        np.stack((p1, p2))\n        output = np.array(\n            list(map(lambda xi: _nearestPointOnLine(p1, p2, xi), p3s))\n        )\n        dists = output[:, 0]\n        segmentPoints = output[:, 1:]\n        inds = np.where((dists &lt; dist_thres))[0]\n\n        # Loop through the points projected onto the line\n        for ind in inds:\n            specPoint = ds_spec.isel(site=ind)\n\n            segLon = segmentPoints[ind, 0]\n            segLat = segmentPoints[ind, 1]\n\n            if plot:\n                ax.plot(\n                    [segLon, specPoint.lon],\n                    [segLat, specPoint.lat],\n                    color=\"r\",\n                    lw=2,\n                )\n                ax.scatter(specPoint.lon, specPoint.lat, marker=\"o\", color=\"b\")\n                ax.scatter(segLon, segLat, marker=\"x\", color=\"g\")\n\n            specPoint[\"lon\"] = segLon\n            specPoint[\"lat\"] = segLat\n            specPoints.append(specPoint)\n\n        logger.debug(f\"Segment {i} - Indices {inds}\")\n\n    if plot:\n        fig.show()\n\n    ds_boundary = xr.concat(specPoints, dim=\"site\")\n    return ds_boundary\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.from_component","title":"from_component  <code>classmethod</code>","text":"<pre><code>from_component(component: GRIDREGULAR) -&gt; SwanGrid\n</code></pre> <p>Swan grid from an existing component.</p>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.from_component--parameters","title":"Parameters","text":"<p>component: GRIDREGULAR     A GRIDREGULAR SWAN component.</p>"},{"location":"api-reference/data/#rompy_swan.grid.SwanGrid.from_component--returns","title":"Returns","text":"<p>SwanGrid     A SwanGrid object.</p> Source code in <code>src/rompy_swan/grid.py</code> <pre><code>@classmethod\ndef from_component(cls, component: GRIDREGULAR) -&gt; \"SwanGrid\":\n    \"\"\"Swan grid from an existing component.\n\n    Parameters\n    ----------\n    component: GRIDREGULAR\n        A GRIDREGULAR SWAN component.\n\n    Returns\n    -------\n    SwanGrid\n        A SwanGrid object.\n\n    \"\"\"\n    return cls(\n        x0=component.xp,\n        y0=component.yp,\n        rot=component.alp,\n        dx=component.dx,\n        dy=component.dy,\n        nx=component.mx + 1,\n        ny=component.my + 1,\n    )\n</code></pre>"},{"location":"api-reference/data/#data-classes","title":"Data Classes","text":""},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid","title":"SwanDataGrid","text":"<p>               Bases: <code>DataGrid</code></p> <p>This class is used to write SWAN data from a dataset.</p> Source code in <code>src/rompy_swan/data.py</code> <pre><code>class SwanDataGrid(DataGrid):\n    \"\"\"This class is used to write SWAN data from a dataset.\"\"\"\n\n    z1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the data variable in dataset representing either a scaler \"\n            \"parameter or the u-componet of a vector field\"\n        ),\n    )\n    z2: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the data variable in dataset representing \"\n            \"the v-componet of a vector field\"\n        ),\n    )\n    var: GridOptions = Field(description=\"SWAN input grid name\")\n    fac: float = Field(\n        description=(\n            \"SWAN multiplies all values that are read from file by `fac`. For \"\n            \"instance if the values are given in unit decimeter, one should make \"\n            \"`fac=0.1` to obtain values in m. To change sign use a negative `fac`\"\n        ),\n        default=1.0,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_z1_in_data_vars(self) -&gt; \"SwanDataGrid\":\n        data_vars = self.variables\n        for z in [self.z1, self.z2]:\n            if z and z not in data_vars:\n                logger.debug(f\"Adding {z} to data_vars\")\n                data_vars.append(z)\n        self.variables = data_vars\n        return self\n\n    def get(\n        self,\n        destdir: str | Path,\n        grid: Optional[SwanGrid] = None,\n        time: Optional[TimeRange] = None,\n    ) -&gt; Path:\n        \"\"\"Write the data source to a new location.\n\n        Parameters\n        ----------\n        destdir : str | Path\n            The destination directory to write the netcdf data to.\n        grid: SwanGrid, optional\n            The grid to filter the data to, only used if `self.filter_grid` is True.\n        time: TimeRange, optional\n            The times to filter the data to, only used if `self.filter_time` is True.\n\n        Returns\n        -------\n        cmd: str\n            The command line string with the INPGRID/READINP commands ready to be\n            written to the SWAN input file.\n\n        Note\n        ----\n        The data are assumed to not have been rotated. We cannot use the grid.rot attr\n        as this is the rotation from the model grid object which is not necessarily the\n        same as the rotation of the data.\n\n        \"\"\"\n        if self.crop_data:\n            if grid is not None:\n                self._filter_grid(grid)\n            if time is not None:\n                self._filter_time(time)\n\n        output_file = os.path.join(destdir, f\"{self.var.value}.grd\")\n\n        # Create a formatted box for logging\n        log_box(\n            title=f\"WRITING {self.var.value.upper()} GRID DATA\",\n            logger=logger,\n            add_empty_line=False,\n        )\n\n        # Log output file and dataset information using bullet points\n        items = [f\"Output file: {output_file}\"]\n\n        # Add variable information if available\n        if self.z1:\n            shape_info = f\"{self.ds[self.z1].shape}\"\n            items.append(f\"Variable: {self.z1} with shape {shape_info}\")\n        if self.z2:\n            shape_info = f\"{self.ds[self.z2].shape}\"\n            items.append(f\"Variable: {self.z2} with shape {shape_info}\")\n\n        # Add scaling factor\n        items.append(f\"Scaling factor: {self.fac}\")\n\n        # Log all items as a bulleted list\n        logger.bullet_list(items, indent=2)\n\n        start_time = time_module.time()\n        if self.var.value == \"bottom\":\n            inpgrid, readgrid = self.ds.swan.to_bottom_grid(\n                output_file,\n                fmt=\"%4.2f\",\n                x=self.coords.x,\n                y=self.coords.y,\n                z=self.z1,\n                fac=self.fac,\n                rot=0.0,\n                vmin=float(\"-inf\"),\n            )\n        else:\n            inpgrid, readgrid = self.ds.swan.to_inpgrid(\n                output_file=output_file,\n                x=self.coords.x,\n                y=self.coords.y,\n                z1=self.z1,\n                z2=self.z2,\n                fac=self.fac,\n                rot=0.0,\n                var=self.var.name,\n            )\n\n        # Log completion and processing time\n        elapsed_time = time_module.time() - start_time\n        file_size = Path(output_file).stat().st_size / (1024 * 1024)  # Size in MB\n\n        # Use the centralized functions from rompy package\n\n        # Log completion information as a bulleted list\n        logger.bullet_list(\n            [\n                f\"Completed in {elapsed_time:.2f} seconds\",\n                f\"File size: {file_size:.2f} MB\",\n            ],\n            indent=2,\n        )\n\n        return f\"{inpgrid}\\n{readgrid}\\n\"\n\n    def __str__(self):\n        return f\"SWANDataGrid {self.var.name}\"\n\n    def _format_value(self, obj):\n        \"\"\"Format SwanDataGrid values using the new formatting framework.\n\n        This method provides special formatting for SwanDataGrid objects.\n\n        Args:\n            obj: The object to format\n\n        Returns:\n            A formatted string or None to use default formatting\n        \"\"\"\n        # Only format SwanDataGrid objects\n        if not isinstance(obj, SwanDataGrid):\n            return None\n\n        # Use the new formatting framework\n        from rompy.formatting import format_value\n\n        return format_value(obj)\n        lines.append(f\"  {bullet} Variable:   {obj.var.name}\")\n\n        # Add source information if available\n        if hasattr(obj, \"source\") and obj.source:\n            source_type = getattr(obj.source, \"model_type\", \"unknown\")\n            lines.append(f\"  {bullet} Source:     {source_type}\")\n\n            # Add dataset information if available\n            if hasattr(obj.source, \"dataset_id\"):\n                lines.append(f\"  {bullet} Dataset ID: {obj.source.dataset_id}\")\n\n        # Add coordinate information if available\n        if hasattr(obj, \"coords\") and obj.coords:\n            coords = [f\"{k}={v}\" for k, v in obj.coords.items()]\n            coords_str = \", \".join(coords)\n            lines.append(f\"  {bullet} Coordinates: {coords_str}\")\n\n        # Add scaling factor if available\n        if hasattr(obj, \"fac\"):\n            lines.append(f\"  {bullet} Scale factor: {obj.fac}\")\n\n        # Add z variables information if available\n        if hasattr(obj, \"z1\") and obj.z1:\n            lines.append(f\"  {bullet} Z1 variable: {obj.z1}\")\n        if hasattr(obj, \"z2\") and obj.z2:\n            lines.append(f\"  {bullet} Z2 variable: {obj.z2}\")\n\n        # Close with footer\n        lines.append(footer)\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.z1","title":"z1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z1: Optional[str] = Field(default=None, description='Name of the data variable in dataset representing either a scaler parameter or the u-componet of a vector field')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.z2","title":"z2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z2: Optional[str] = Field(default=None, description='Name of the data variable in dataset representing the v-componet of a vector field')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.var","title":"var  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>var: GridOptions = Field(description='SWAN input grid name')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.fac","title":"fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fac: float = Field(description='SWAN multiplies all values that are read from file by `fac`. For instance if the values are given in unit decimeter, one should make `fac=0.1` to obtain values in m. To change sign use a negative `fac`', default=1.0)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.ensure_z1_in_data_vars","title":"ensure_z1_in_data_vars","text":"<pre><code>ensure_z1_in_data_vars() -&gt; SwanDataGrid\n</code></pre> Source code in <code>src/rompy_swan/data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_z1_in_data_vars(self) -&gt; \"SwanDataGrid\":\n    data_vars = self.variables\n    for z in [self.z1, self.z2]:\n        if z and z not in data_vars:\n            logger.debug(f\"Adding {z} to data_vars\")\n            data_vars.append(z)\n    self.variables = data_vars\n    return self\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.get","title":"get","text":"<pre><code>get(destdir: str | Path, grid: Optional[SwanGrid] = None, time: Optional[TimeRange] = None) -&gt; Path\n</code></pre> <p>Write the data source to a new location.</p>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.get--parameters","title":"Parameters","text":"<p>destdir : str | Path     The destination directory to write the netcdf data to. grid: SwanGrid, optional     The grid to filter the data to, only used if <code>self.filter_grid</code> is True. time: TimeRange, optional     The times to filter the data to, only used if <code>self.filter_time</code> is True.</p>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.get--returns","title":"Returns","text":"<p>cmd: str     The command line string with the INPGRID/READINP commands ready to be     written to the SWAN input file.</p>"},{"location":"api-reference/data/#rompy_swan.data.SwanDataGrid.get--note","title":"Note","text":"<p>The data are assumed to not have been rotated. We cannot use the grid.rot attr as this is the rotation from the model grid object which is not necessarily the same as the rotation of the data.</p> Source code in <code>src/rompy_swan/data.py</code> <pre><code>def get(\n    self,\n    destdir: str | Path,\n    grid: Optional[SwanGrid] = None,\n    time: Optional[TimeRange] = None,\n) -&gt; Path:\n    \"\"\"Write the data source to a new location.\n\n    Parameters\n    ----------\n    destdir : str | Path\n        The destination directory to write the netcdf data to.\n    grid: SwanGrid, optional\n        The grid to filter the data to, only used if `self.filter_grid` is True.\n    time: TimeRange, optional\n        The times to filter the data to, only used if `self.filter_time` is True.\n\n    Returns\n    -------\n    cmd: str\n        The command line string with the INPGRID/READINP commands ready to be\n        written to the SWAN input file.\n\n    Note\n    ----\n    The data are assumed to not have been rotated. We cannot use the grid.rot attr\n    as this is the rotation from the model grid object which is not necessarily the\n    same as the rotation of the data.\n\n    \"\"\"\n    if self.crop_data:\n        if grid is not None:\n            self._filter_grid(grid)\n        if time is not None:\n            self._filter_time(time)\n\n    output_file = os.path.join(destdir, f\"{self.var.value}.grd\")\n\n    # Create a formatted box for logging\n    log_box(\n        title=f\"WRITING {self.var.value.upper()} GRID DATA\",\n        logger=logger,\n        add_empty_line=False,\n    )\n\n    # Log output file and dataset information using bullet points\n    items = [f\"Output file: {output_file}\"]\n\n    # Add variable information if available\n    if self.z1:\n        shape_info = f\"{self.ds[self.z1].shape}\"\n        items.append(f\"Variable: {self.z1} with shape {shape_info}\")\n    if self.z2:\n        shape_info = f\"{self.ds[self.z2].shape}\"\n        items.append(f\"Variable: {self.z2} with shape {shape_info}\")\n\n    # Add scaling factor\n    items.append(f\"Scaling factor: {self.fac}\")\n\n    # Log all items as a bulleted list\n    logger.bullet_list(items, indent=2)\n\n    start_time = time_module.time()\n    if self.var.value == \"bottom\":\n        inpgrid, readgrid = self.ds.swan.to_bottom_grid(\n            output_file,\n            fmt=\"%4.2f\",\n            x=self.coords.x,\n            y=self.coords.y,\n            z=self.z1,\n            fac=self.fac,\n            rot=0.0,\n            vmin=float(\"-inf\"),\n        )\n    else:\n        inpgrid, readgrid = self.ds.swan.to_inpgrid(\n            output_file=output_file,\n            x=self.coords.x,\n            y=self.coords.y,\n            z1=self.z1,\n            z2=self.z2,\n            fac=self.fac,\n            rot=0.0,\n            var=self.var.name,\n        )\n\n    # Log completion and processing time\n    elapsed_time = time_module.time() - start_time\n    file_size = Path(output_file).stat().st_size / (1024 * 1024)  # Size in MB\n\n    # Use the centralized functions from rompy package\n\n    # Log completion information as a bulleted list\n    logger.bullet_list(\n        [\n            f\"Completed in {elapsed_time:.2f} seconds\",\n            f\"File size: {file_size:.2f} MB\",\n        ],\n        indent=2,\n    )\n\n    return f\"{inpgrid}\\n{readgrid}\\n\"\n</code></pre>"},{"location":"api-reference/data/#boundary-data","title":"Boundary Data","text":""},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1","title":"Boundnest1","text":"<p>               Bases: <code>BoundaryWaveStation</code></p> <p>SWAN BOUNDNEST1 NEST data class.</p> Source code in <code>src/rompy_swan/boundary.py</code> <pre><code>class Boundnest1(BoundaryWaveStation):\n    \"\"\"SWAN BOUNDNEST1 NEST data class.\"\"\"\n\n    model_type: Literal[\"boundnest1\", \"BOUNDNEST1\"] = Field(\n        default=\"boundnest1\", description=\"Model type discriminator\"\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Defines whether boundary is defined over an closed or open rectangle\"\n        ),\n    )\n\n    def get(\n        self, destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None\n    ) -&gt; str:\n        \"\"\"Write the data source to a new location.\n\n        Parameters\n        ----------\n        destdir : str | Path\n            Destination directory for the SWAN ASCII file.\n        grid : RegularGrid\n            Grid instance to use for selecting the boundary points.\n        time: TimeRange, optional\n            The times to filter the data to, only used if `self.crop_data` is True.\n\n        Returns\n        -------\n        filename: Path\n            The filename of the written boundary file.\n        cmd : str\n            Boundary command string to render in the SWAN INPUT file\n\n        \"\"\"\n        if self.crop_data and time is not None:\n            self._filter_time(time)\n        if self.crop_data and grid is not None:\n            self._filter_grid(grid)\n\n        ds = self._sel_boundary(grid).sortby(\"dir\")\n\n        # If nearest, ensure points are returned at the requested positions\n        if self.sel_method == \"nearest\":\n            xbnd, ybnd = self._boundary_points(grid=grid)\n            ds[\"lon\"].values = xbnd\n            ds[\"lat\"].values = ybnd\n\n        filename = Path(destdir) / f\"{self.id}.bnd\"\n        ds.spec.to_swan(filename)\n        cmd = f\"BOUNDNEST1 NEST '{filename.name}' {self.rectangle.upper()}\"\n        return filename, cmd\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest1', 'BOUNDNEST1'] = Field(default='boundnest1', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Defines whether boundary is defined over an closed or open rectangle')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1.get","title":"get","text":"<pre><code>get(destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None) -&gt; str\n</code></pre> <p>Write the data source to a new location.</p>"},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1.get--parameters","title":"Parameters","text":"<p>destdir : str | Path     Destination directory for the SWAN ASCII file. grid : RegularGrid     Grid instance to use for selecting the boundary points. time: TimeRange, optional     The times to filter the data to, only used if <code>self.crop_data</code> is True.</p>"},{"location":"api-reference/data/#rompy_swan.boundary.Boundnest1.get--returns","title":"Returns","text":"<p>filename: Path     The filename of the written boundary file. cmd : str     Boundary command string to render in the SWAN INPUT file</p> Source code in <code>src/rompy_swan/boundary.py</code> <pre><code>def get(\n    self, destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None\n) -&gt; str:\n    \"\"\"Write the data source to a new location.\n\n    Parameters\n    ----------\n    destdir : str | Path\n        Destination directory for the SWAN ASCII file.\n    grid : RegularGrid\n        Grid instance to use for selecting the boundary points.\n    time: TimeRange, optional\n        The times to filter the data to, only used if `self.crop_data` is True.\n\n    Returns\n    -------\n    filename: Path\n        The filename of the written boundary file.\n    cmd : str\n        Boundary command string to render in the SWAN INPUT file\n\n    \"\"\"\n    if self.crop_data and time is not None:\n        self._filter_time(time)\n    if self.crop_data and grid is not None:\n        self._filter_grid(grid)\n\n    ds = self._sel_boundary(grid).sortby(\"dir\")\n\n    # If nearest, ensure points are returned at the requested positions\n    if self.sel_method == \"nearest\":\n        xbnd, ybnd = self._boundary_points(grid=grid)\n        ds[\"lon\"].values = xbnd\n        ds[\"lat\"].values = ybnd\n\n    filename = Path(destdir) / f\"{self.id}.bnd\"\n    ds.spec.to_swan(filename)\n    cmd = f\"BOUNDNEST1 NEST '{filename.name}' {self.rectangle.upper()}\"\n    return filename, cmd\n</code></pre>"},{"location":"api-reference/data/#interfaces","title":"Interfaces","text":""},{"location":"api-reference/data/#rompy_swan.interface.DataInterface","title":"DataInterface","text":"<p>               Bases: <code>RompyBaseModel</code></p> <p>SWAN forcing data interface.</p>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.interface import DataInterface\n</code></pre> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>class DataInterface(RompyBaseModel):\n    \"\"\"SWAN forcing data interface.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.interface import DataInterface\n\n    \"\"\"\n\n    model_type: Literal[\"data_interface\", \"DATA_INTERFACE\"] = Field(\n        default=\"data_interface\", description=\"Model type discriminator\"\n    )\n    bottom: Optional[SwanDataGrid] = Field(default=None, description=\"Bathymetry data\")\n    input: list[SwanDataGrid] = Field(default=[], description=\"Input grid data\")\n\n    @field_validator(\"input\")\n    @classmethod\n    def ensure_unique_var(\n        cls, input: list[SwanDataGrid], info: ValidationInfo\n    ) -&gt; list[SwanDataGrid]:\n        \"\"\"Ensure that each input var is unique.\"\"\"\n        vars = []\n        if info.data[\"bottom\"] is not None:\n            vars.append(info.data[\"bottom\"].var)\n        vars.extend([inp.var for inp in input])\n        if len(vars) != len(set(vars)):\n            raise ValueError(\"Each var must be unique in input\")\n        return input\n\n    def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n        inputs = []\n        if self.bottom is not None:\n            inputs.append(self.bottom)\n        inputs.extend(self.input)\n        cmds = []\n        for input in inputs:\n            cmds.append(input.get(destdir=staging_dir, grid=grid, time=period))\n        return \"\\n\".join(cmds)\n\n    def render(self, *args, **kwargs):\n        \"\"\"Make this class consistent with the components API.\"\"\"\n        return self.get(*args, **kwargs)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['data_interface', 'DATA_INTERFACE'] = Field(default='data_interface', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.bottom","title":"bottom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bottom: Optional[SwanDataGrid] = Field(default=None, description='Bathymetry data')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.input","title":"input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input: list[SwanDataGrid] = Field(default=[], description='Input grid data')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.ensure_unique_var","title":"ensure_unique_var  <code>classmethod</code>","text":"<pre><code>ensure_unique_var(input: list[SwanDataGrid], info: ValidationInfo) -&gt; list[SwanDataGrid]\n</code></pre> <p>Ensure that each input var is unique.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>@field_validator(\"input\")\n@classmethod\ndef ensure_unique_var(\n    cls, input: list[SwanDataGrid], info: ValidationInfo\n) -&gt; list[SwanDataGrid]:\n    \"\"\"Ensure that each input var is unique.\"\"\"\n    vars = []\n    if info.data[\"bottom\"] is not None:\n        vars.append(info.data[\"bottom\"].var)\n    vars.extend([inp.var for inp in input])\n    if len(vars) != len(set(vars)):\n        raise ValueError(\"Each var must be unique in input\")\n    return input\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.get","title":"get","text":"<pre><code>get(staging_dir: Path, grid: SwanGrid, period: TimeRange)\n</code></pre> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n    inputs = []\n    if self.bottom is not None:\n        inputs.append(self.bottom)\n    inputs.extend(self.input)\n    cmds = []\n    for input in inputs:\n        cmds.append(input.get(destdir=staging_dir, grid=grid, time=period))\n    return \"\\n\".join(cmds)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.DataInterface.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Make this class consistent with the components API.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>def render(self, *args, **kwargs):\n    \"\"\"Make this class consistent with the components API.\"\"\"\n    return self.get(*args, **kwargs)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface","title":"BoundaryInterface","text":"<p>               Bases: <code>RompyBaseModel</code></p> <p>SWAN forcing boundary interface.</p>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.interface import BoundaryInterface\n</code></pre> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>class BoundaryInterface(RompyBaseModel):\n    \"\"\"SWAN forcing boundary interface.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.interface import BoundaryInterface\n\n    \"\"\"\n\n    model_type: Literal[\"boundary_interface\", \"BOUNDARY_INTERFACE\"] = Field(\n        default=\"boundary_interface\", description=\"Model type discriminator\"\n    )\n    kind: Union[Boundnest1, BoundspecSide, BoundspecSegmentXY] = Field(\n        default=None, description=\"Boundary data object\"\n    )\n\n    def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n        filename, cmd = self.kind.get(destdir=staging_dir, grid=grid, time=period)\n        logger.info(f\"Generating boundary file: {filename}\")\n        return cmd\n\n    def render(self, *args, **kwargs):\n        \"\"\"Make this class consistent with the components API.\"\"\"\n        return self.get(*args, **kwargs)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundary_interface', 'BOUNDARY_INTERFACE'] = Field(default='boundary_interface', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Union[Boundnest1, BoundspecSide, BoundspecSegmentXY] = Field(default=None, description='Boundary data object')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface.get","title":"get","text":"<pre><code>get(staging_dir: Path, grid: SwanGrid, period: TimeRange)\n</code></pre> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n    filename, cmd = self.kind.get(destdir=staging_dir, grid=grid, time=period)\n    logger.info(f\"Generating boundary file: {filename}\")\n    return cmd\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.BoundaryInterface.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Make this class consistent with the components API.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>def render(self, *args, **kwargs):\n    \"\"\"Make this class consistent with the components API.\"\"\"\n    return self.get(*args, **kwargs)\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface","title":"OutputInterface","text":"<p>               Bases: <code>TimeInterface</code></p> <p>Output group component with consistent times.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>class OutputInterface(TimeInterface):\n    \"\"\"Output group component with consistent times.\"\"\"\n\n    model_type: Literal[\"outputinterface\", \"OUTPUTINTERFACE\"] = Field(\n        default=\"outputinterface\", description=\"Model type discriminator\"\n    )\n\n    @model_validator(mode=\"after\")\n    def time_interface(self) -&gt; \"OutputInterface\":\n        \"\"\"Set the time parameter for all WRITE components.\n\n        Note\n        ----\n        * tbeg is set to the Config runtime start\n        * delt is set from the component's times if defined, otherwise from the runtime interval\n        * tfmt is set from the component's times if defined, otherwise from TimeRange default\n        * dfmt is set from the component's times if defined, otherwise from TimeRange default\n        * suffix is set to the suffix of the component\n\n        \"\"\"\n        for component in self.group._write_fields:\n            obj = getattr(self.group, component)\n            if obj is not None:\n                times = obj.times or TimeRangeOpen()\n                obj.times = TimeRangeOpen(\n                    tbeg=self.period.start,\n                    delt=times.delt if obj.times else self.period.interval,\n                    tfmt=times.tfmt,\n                    dfmt=times.dfmt,\n                    suffix=obj.suffix,\n                )\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['outputinterface', 'OUTPUTINTERFACE'] = Field(default='outputinterface', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface.time_interface","title":"time_interface","text":"<pre><code>time_interface() -&gt; OutputInterface\n</code></pre> <p>Set the time parameter for all WRITE components.</p>"},{"location":"api-reference/data/#rompy_swan.interface.OutputInterface.time_interface--note","title":"Note","text":"<ul> <li>tbeg is set to the Config runtime start</li> <li>delt is set from the component's times if defined, otherwise from the runtime interval</li> <li>tfmt is set from the component's times if defined, otherwise from TimeRange default</li> <li>dfmt is set from the component's times if defined, otherwise from TimeRange default</li> <li>suffix is set to the suffix of the component</li> </ul> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>@model_validator(mode=\"after\")\ndef time_interface(self) -&gt; \"OutputInterface\":\n    \"\"\"Set the time parameter for all WRITE components.\n\n    Note\n    ----\n    * tbeg is set to the Config runtime start\n    * delt is set from the component's times if defined, otherwise from the runtime interval\n    * tfmt is set from the component's times if defined, otherwise from TimeRange default\n    * dfmt is set from the component's times if defined, otherwise from TimeRange default\n    * suffix is set to the suffix of the component\n\n    \"\"\"\n    for component in self.group._write_fields:\n        obj = getattr(self.group, component)\n        if obj is not None:\n            times = obj.times or TimeRangeOpen()\n            obj.times = TimeRangeOpen(\n                tbeg=self.period.start,\n                delt=times.delt if obj.times else self.period.interval,\n                tfmt=times.tfmt,\n                dfmt=times.dfmt,\n                suffix=obj.suffix,\n            )\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.LockupInterface","title":"LockupInterface","text":"<p>               Bases: <code>TimeInterface</code></p> <p>Lockup group component with consistent times.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>class LockupInterface(TimeInterface):\n    \"\"\"Lockup group component with consistent times.\"\"\"\n\n    model_type: Literal[\"lockupinterface\", \"LOCKUPINTERFACE\"] = Field(\n        default=\"lockupinterface\", description=\"Model type discriminator\"\n    )\n\n    def _nonstationary(self, tfmt: str, dfmt: str) -&gt; NONSTATIONARY:\n        return NONSTATIONARY(\n            tbeg=self.period.start,\n            tend=self.period.end,\n            delt=self.period.interval,\n            tfmt=tfmt,\n            dfmt=dfmt,\n            suffix=\"c\",\n        )\n\n    def _stationary(self, tfmt: str) -&gt; STATIONARY:\n        return STATIONARY(time=self.period.start, tfmt=tfmt)\n\n    @model_validator(mode=\"after\")\n    def time_interface(self) -&gt; \"LockupInterface\":\n        \"\"\"Set the time parameter for COMPUTE components.\"\"\"\n        times = self.group.compute.times or NONSTATIONARY()\n        if isinstance(times, NONSTATIONARY):\n            times = self._nonstationary(times.tfmt, times.dfmt)\n        elif isinstance(times, STATIONARY):\n            times = self._stationary(times.tfmt)\n        else:\n            raise ValueError(f\"Unknown time type {type(times)}\")\n        self.group.compute.times = times\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.LockupInterface-attributes","title":"Attributes","text":""},{"location":"api-reference/data/#rompy_swan.interface.LockupInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lockupinterface', 'LOCKUPINTERFACE'] = Field(default='lockupinterface', description='Model type discriminator')\n</code></pre>"},{"location":"api-reference/data/#rompy_swan.interface.LockupInterface-functions","title":"Functions","text":""},{"location":"api-reference/data/#rompy_swan.interface.LockupInterface.time_interface","title":"time_interface","text":"<pre><code>time_interface() -&gt; LockupInterface\n</code></pre> <p>Set the time parameter for COMPUTE components.</p> Source code in <code>src/rompy_swan/interface.py</code> <pre><code>@model_validator(mode=\"after\")\ndef time_interface(self) -&gt; \"LockupInterface\":\n    \"\"\"Set the time parameter for COMPUTE components.\"\"\"\n    times = self.group.compute.times or NONSTATIONARY()\n    if isinstance(times, NONSTATIONARY):\n        times = self._nonstationary(times.tfmt, times.dfmt)\n    elif isinstance(times, STATIONARY):\n        times = self._stationary(times.tfmt)\n    else:\n        raise ValueError(f\"Unknown time type {type(times)}\")\n    self.group.compute.times = times\n</code></pre>"},{"location":"api-reference/types/","title":"Types API","text":"<p>SWAN types provide valid values for specific SWAN command line arguments.</p>"},{"location":"api-reference/types/#enum-types","title":"Enum Types","text":""},{"location":"api-reference/types/#rompy_swan.types.IDLA","title":"IDLA","text":"<p>               Bases: <code>IntEnum</code></p> <p>Order of values in the input files.</p>"},{"location":"api-reference/types/#rompy_swan.types.IDLA--attributes","title":"Attributes","text":"<p>ONE: 1     SWAN reads the map from left to right starting in the upper-left-hand corner of     the map. A new line in the map should start on a new line in the file. TWO: 2     As <code>1</code> but a new line in the map need not start on a new line in the file. THREE: 3     SWAN reads the map from left to right starting in the lower-left-hand corner of     the map. A new line in the map should start on a new line in the file. FOUR: 4     As <code>3</code> but a new line in the map need not start on a new line in the file. FIVE: 5     SWAN reads the map from top to bottom starting in the lower-left-hand corner of     the map. A new column in the map should start on a new line in the file. SIX: 6     As <code>5</code> but a new column in the map need not start on a new line in the file.</p>"},{"location":"api-reference/types/#rompy_swan.types.IDLA--notes","title":"Notes","text":"<p>It is assumed that the x-axis of the grid is pointing to the right and the y-axis upwards.</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class IDLA(IntEnum):\n    \"\"\"Order of values in the input files.\n\n    Attributes\n    ----------\n    ONE: 1\n        SWAN reads the map from left to right starting in the upper-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    TWO: 2\n        As `1` but a new line in the map need not start on a new line in the file.\n    THREE: 3\n        SWAN reads the map from left to right starting in the lower-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    FOUR: 4\n        As `3` but a new line in the map need not start on a new line in the file.\n    FIVE: 5\n        SWAN reads the map from top to bottom starting in the lower-left-hand corner of\n        the map. A new column in the map should start on a new line in the file.\n    SIX: 6\n        As `5` but a new column in the map need not start on a new line in the file.\n\n    Notes\n    -----\n    It is assumed that the x-axis of the grid is pointing to the right and the y-axis\n    upwards.\n\n    \"\"\"\n\n    ONE = 1\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.IDLA.ONE","title":"ONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ONE = 1\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA.TWO","title":"TWO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TWO = 2\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA.THREE","title":"THREE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THREE = 3\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA.FOUR","title":"FOUR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOUR = 4\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA.FIVE","title":"FIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIVE = 5\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.IDLA.SIX","title":"SIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIX = 6\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions","title":"GridOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the input grid type.</p>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions--attributes","title":"Attributes","text":"<p>BOTTOM: \"bottom\"     Bottom level grid. WLEVEL: \"wlevel\"     Water level grid. CURRENT: \"current\"     Current field grid. VX: \"vx\"     Current field x-component grid. VY: \"vy\"     Current field y-component grid. WIND: \"wind\"     Wind velocity grid. WX: \"wx\"     Wind velocity x-component grid. WY: \"wy\"     Wind velocity y-component grid. FRICTION: \"friction\"     Bottom friction grid. NPLANTS: \"nplants\"     Horizontally varying vegetation density grid. TURBVISC: \"turbvisc\"     Horizontally varying turbulent viscosity grid. MUDLAYER: \"mudlayer\"     Horizontally varying mud layer thickness grid. AICE: \"aice\"     Areal ice fraction grid, a number between 0 and 1. HICE: \"hice\"     Ice thickness grid. HSS: \"hss\"     Sea-swell significant wave height grid. TSS: \"tss\"     Sea-swell mean wave period.</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class GridOptions(str, Enum):\n    \"\"\"Valid options for the input grid type.\n\n    Attributes\n    ----------\n    BOTTOM: \"bottom\"\n        Bottom level grid.\n    WLEVEL: \"wlevel\"\n        Water level grid.\n    CURRENT: \"current\"\n        Current field grid.\n    VX: \"vx\"\n        Current field x-component grid.\n    VY: \"vy\"\n        Current field y-component grid.\n    WIND: \"wind\"\n        Wind velocity grid.\n    WX: \"wx\"\n        Wind velocity x-component grid.\n    WY: \"wy\"\n        Wind velocity y-component grid.\n    FRICTION: \"friction\"\n        Bottom friction grid.\n    NPLANTS: \"nplants\"\n        Horizontally varying vegetation density grid.\n    TURBVISC: \"turbvisc\"\n        Horizontally varying turbulent viscosity grid.\n    MUDLAYER: \"mudlayer\"\n        Horizontally varying mud layer thickness grid.\n    AICE: \"aice\"\n        Areal ice fraction grid, a number between 0 and 1.\n    HICE: \"hice\"\n        Ice thickness grid.\n    HSS: \"hss\"\n        Sea-swell significant wave height grid.\n    TSS: \"tss\"\n        Sea-swell mean wave period.\n\n    \"\"\"\n\n    BOTTOM = \"bottom\"\n    WLEVEL = \"wlevel\"\n    CURRENT = \"current\"\n    VX = \"vx\"\n    VY = \"vy\"\n    WIND = \"wind\"\n    WX = \"wx\"\n    WY = \"wy\"\n    FRICTION = \"friction\"\n    NPLANTS = \"nplants\"\n    TURBVISC = \"turbvisc\"\n    MUDLAYER = \"mudlayer\"\n    AICE = \"aice\"\n    HICE = \"hice\"\n    HSS = \"hss\"\n    TSS = \"tss\"\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.GridOptions.BOTTOM","title":"BOTTOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTTOM = 'bottom'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.WLEVEL","title":"WLEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLEVEL = 'wlevel'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.CURRENT","title":"CURRENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT = 'current'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.VX","title":"VX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VX = 'vx'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.VY","title":"VY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VY = 'vy'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.WX","title":"WX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WX = 'wx'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.WY","title":"WY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WY = 'wy'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.FRICTION","title":"FRICTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRICTION = 'friction'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.TURBVISC","title":"TURBVISC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TURBVISC = 'turbvisc'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.MUDLAYER","title":"MUDLAYER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUDLAYER = 'mudlayer'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.HICE","title":"HICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HICE = 'hice'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.HSS","title":"HSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSS = 'hss'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.GridOptions.TSS","title":"TSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSS = 'tss'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions","title":"BoundShapeOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions--attributes","title":"Attributes","text":"<p>JONSWAP: \"jonswap\"     JONSWAP spectrum. PM: \"pm\"     Pierson-Moskowitz spectrum. GAUSS: \"gauss\"     Gaussian spectrum. BIN: \"bin\"     Energy at a single bin spectrum. TMA: \"tma\"     TMA spectrum.</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class BoundShapeOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    JONSWAP: \"jonswap\"\n        JONSWAP spectrum.\n    PM: \"pm\"\n        Pierson-Moskowitz spectrum.\n    GAUSS: \"gauss\"\n        Gaussian spectrum.\n    BIN: \"bin\"\n        Energy at a single bin spectrum.\n    TMA: \"tma\"\n        TMA spectrum.\n\n    \"\"\"\n\n    JONSWAP = \"jonswap\"\n    PM = \"pm\"\n    GAUSS = \"gauss\"\n    BIN = \"bin\"\n    TMA = \"tma\"\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions.JONSWAP","title":"JONSWAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JONSWAP = 'jonswap'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions.PM","title":"PM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PM = 'pm'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions.GAUSS","title":"GAUSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAUSS = 'gauss'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions.BIN","title":"BIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIN = 'bin'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BoundShapeOptions.TMA","title":"TMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMA = 'tma'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions","title":"SideOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions--attributes","title":"Attributes","text":"<p>NORTH: \"north\"     North side. NW: \"nw\"     North-west side. WEST: \"west\"     West side. SW: \"sw\"     South-west side. SOUTH: \"south\"     South side. SE: \"se\"     South-east side. EAST: \"east\"     East side. NE: \"ne\"     North-east side.</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class SideOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    NORTH: \"north\"\n        North side.\n    NW: \"nw\"\n        North-west side.\n    WEST: \"west\"\n        West side.\n    SW: \"sw\"\n        South-west side.\n    SOUTH: \"south\"\n        South side.\n    SE: \"se\"\n        South-east side.\n    EAST: \"east\"\n        East side.\n    NE: \"ne\"\n        North-east side.\n\n    \"\"\"\n\n    NORTH = \"north\"\n    NW = \"nw\"\n    WEST = \"west\"\n    SW = \"sw\"\n    SOUTH = \"south\"\n    SE = \"se\"\n    EAST = \"east\"\n    NE = \"ne\"\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.SideOptions.NORTH","title":"NORTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NORTH = 'north'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.NW","title":"NW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NW = 'nw'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.WEST","title":"WEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEST = 'west'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.SW","title":"SW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SW = 'sw'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.SOUTH","title":"SOUTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOUTH = 'south'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.SE","title":"SE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SE = 'se'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.EAST","title":"EAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EAST = 'east'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.SideOptions.NE","title":"NE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NE = 'ne'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff","title":"PhysicsOff","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Physics commands to be switched off.</p>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff--attributes","title":"Attributes","text":"<p>WINDGROWTH : str = \"windgrowth\"     Switches off wind growth (in commands GEN1, GEN2, GEN3). QUADRUPL : str = \"quadrupl\"     Switches off quadruplet wave interactions (in command GEN3). WCAPPING : str = \"wcapping\"     Switches off whitecapping (in command GEN3). BREAKING : str = \"breaking\"     Switches off wave breaking dissipation. REFRAC : str = \"refrac\"     Switches off wave refraction (action transport in theta space). FSHIFT : str = \"fshift\"     Switches off frequency shifting (action transport in sigma space). BNDCHK : str = \"bndchk\"     Switches off the checking of the delta imposed and computed Hs at the boundary.</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class PhysicsOff(str, Enum):\n    \"\"\"Physics commands to be switched off.\n\n    Attributes\n    ----------\n    WINDGROWTH : str = \"windgrowth\"\n        Switches off wind growth (in commands GEN1, GEN2, GEN3).\n    QUADRUPL : str = \"quadrupl\"\n        Switches off quadruplet wave interactions (in command GEN3).\n    WCAPPING : str = \"wcapping\"\n        Switches off whitecapping (in command GEN3).\n    BREAKING : str = \"breaking\"\n        Switches off wave breaking dissipation.\n    REFRAC : str = \"refrac\"\n        Switches off wave refraction (action transport in theta space).\n    FSHIFT : str = \"fshift\"\n        Switches off frequency shifting (action transport in sigma space).\n    BNDCHK : str = \"bndchk\"\n        Switches off the checking of the delta imposed and computed Hs at the boundary.\n\n    \"\"\"\n\n    WINDGROWTH = \"windgrowth\"\n    QUADRUPL = \"quadrupl\"\n    WCAPPING = \"wcapping\"\n    BREAKING = \"breaking\"\n    REFRAC = \"refrac\"\n    FSHIFT = \"fshift\"\n    BNDCHK = \"bndchk\"\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.WINDGROWTH","title":"WINDGROWTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDGROWTH = 'windgrowth'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.QUADRUPL","title":"QUADRUPL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUADRUPL = 'quadrupl'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.WCAPPING","title":"WCAPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WCAPPING = 'wcapping'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.BREAKING","title":"BREAKING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BREAKING = 'breaking'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.REFRAC","title":"REFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REFRAC = 'refrac'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.FSHIFT","title":"FSHIFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSHIFT = 'fshift'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.PhysicsOff.BNDCHK","title":"BNDCHK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BNDCHK = 'bndchk'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions","title":"BlockOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for block output parameters.</p>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions--attributes","title":"Attributes","text":"<p>HSIGN: \"hsign\"     Significant wave height (in m). HSEA: \"hsea\"     Sea wave height (in m). HSWELL: \"hswell\"     Swell wave height (in m). DIR: \"dir\"     Mean wave direction (in degrees). DPM: \"dpm\"     Mean wave direction at the peak frequency (in degrees). DPMSEA: \"dpmsea\"     Sea mean wave direction at the peak frequency (in degrees). DPMSWE: \"dpmswe\"     Swell mean wave direction at the peak frequency (in degrees). PDIR: \"pdir\"     Peak wave direction (in degrees). TDIR: \"tdir\"     Direction of energy transport (in degrees). TM01: \"tm01\"     Mean absolute wave period (in s). RTM01: \"rtm01\"     Mean relative wave period (in s). RTP: \"rtp\"     Peak period of the (relative frequency) variance density spectrum (in s). TPS: \"tps\"     Smoothed peak period (in s). TPSSEA: \"tpssea\"     Sea smoothed peak period (in s). TPSSWE: \"tpsswe\"     Swell smoothed peak period (in s). PER: \"per\"     Mean absolute wave period (in s). RPER: \"rper\"     Mean relative wave period (in s). TMM10: \"tmm10\"     Mean absolute wave period (in s). RTMM10: \"rtmm10\"     Mean relative wave period (in s). TM02: \"tm02\"     Mean absolute zero-crossing period (in s). FSPR: \"fspr\"     The normalised width of the frequency spectrum. DSPR: \"dspr\"     Directional spreading of the waves (in degrees). QP: \"qp\"     Peakedness of the wave spectrum (dimensionless). DEPTH: \"depth\"     Water depth (in m). WATLEV: \"watlev\"     Water level (in m). BOTLEV: \"botlev\"     Bottom level (in m). VEL: \"vel\"     Current velocity (vector; in m/s). FRCOEF: \"frcoef\"     Friction coefficient (equal to <code>cfw</code> or <code>kn</code> in command <code>FRICTION</code>). WIND: \"wind\"     Wind velocity (vector; in m/s). AICE: \"aice\"     Ice concentration (as a fraction from 0 to 1). PROPAGAT: \"propagat\"     Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s). PROPXY: \"propxy\"     Energy propagation in geographic space; sum of x- and y-direction     (in W/m2 or m2/s). PROPTHETA: \"proptheta\"     Energy propagation in theta space (in W/m2 or m2/s). PROPSIGMA: \"propsigma\"     Energy propagation in sigma space (in W/m2 or m2/s). GENERAT: \"generat\"     Total energy generation (in W/m2 or m2/s). GENWIND: \"genwind\"     Energy generation due to wind (in W/m2 or m2/s). REDIST: \"redist\"     Total energy redistribution (in W/m2 or m2/s). REDQUAD: \"redquad\"     Energy redistribution due to quadruplets (in W/m2 or m2/s). REDTRIAD: \"redtriad\"     Energy redistribution due to triads (in W/m2 or m2/s). DISSIP: \"dissip\"     Total energy dissipation (in W/m2 or m2/s). DISBOT: \"disbot\"     Energy dissipation due to bottom friction (in W/m2 or m2/s). DISSURF: \"dissurf\"     Energy dissipation due to surf breaking (in W/m2 or m2/s). DISWCAP: \"diswcap\"     Energy dissipation due to whitecapping (in W/m2 or m2/s). DISSWELL: \"disswell\"     Energy dissipation due to swell dissipation (in W/m2 or m2/s). DISVEG: \"disveg\"     Energy dissipation due to vegetation (in W/m2 or m2/s). DISMUD: \"dismud\"     Energy dissipation due to mud (in W/m2 or m2/s). DISICE: \"disice\"     Energy dissipation due to sea ice (in W/m2 or m2/s). RADSTR: \"radstr\"     Energy transfer between waves and currents due to radiation stress     (in W/m2 or m2/s). QB: \"qb\"     Fraction of breaking waves due to depth-induced breaking. TRANSP: \"transp\"     Transport of energy (vector; in W/m2 or m2/s). FORCE: \"force\"     Wave-induced force per unit surface area (vector; in N/m2). UBOT: \"ubot\"     The rms-value of the maxima of the orbital velocity near the bottom (in m/s). URMS: \"urms\"     The rms-value of the orbital velocity near the bottom (in m/s). TMBOT: \"tmbot\"     The bottom wave period (in s). WLENGTH: \"wlength\"     Average wave length (in m). LWAVP: \"lwavp\"     Peak wave length (in m). STEEPNESS: \"steepness\"     Average wave steepness (dimensionless). BFI: \"bfi\"     Benjamin-Feir index (dimensionless). NPLANTS: \"nplants\"     Number of plants per square meter. DHSIGN: \"dhsign\"     Difference in significant wave height from the last two iterations (in m). DRTM01: \"drtm01\"     Difference in average wave period (RTM01) from the last two iterations (in s). LEAK: \"leak\"     Numerical loss of energy equal to <code>cthetaE(omega,theta)</code> across boundaries. TIME: \"time\"     Full date-time string as part of line used in TABLE only. TSEC: \"tsec\"     Time in seconds with respect to a reference time (see command QUANTITY). XP: \"xp\"     The x-coordinate in the problem coordinate system of the output location. YP: \"yp\"     The y-coordinate in the problem coordinate system of the output location. DIST: \"dist\"     If output has been requested along a curve then the distance along the curve     can be obtained with the command TABLE. DIST is the distance along the curve     measured from teh first point on the curve to the output location on the curve     in meters (also in the case of spherical coordinates). SETUP: \"setup\"     Set-up due to waves (in m). PTHSIGN: \"pthsign\"     Watershed partitions of the significant wave height (in m). PTRTP: \"ptrtp\"     Watershed partitions of the relative peak period (in s). PTWLEN: \"ptwlen\"     Watershed partitions of the average wave length (in m). PTDIR: \"ptdir\"     Watershed partitions of the peak wave direction (in degrees). PTDSPR: \"ptdspr\"     Watershed partitions of the directional spreading (in degrees). PTWFRAC: \"ptwfrac\"     Watershed partitions of the wind fraction (dimensionless). PTSTEEPNE: \"ptsteepne\"     Watershed partition of the wave steepness (dimensionless). PARTITION: \"partition\"     The raw spectral partition for wave system tracking post-processing.</p>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions--note","title":"Note","text":"<p>Energy given in W/m2 or m2/s depending on command SET.</p>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions--note_1","title":"Note","text":"<p>UBOT and URMS required command <code>FRICTION</code> to be used. If friction is ignored in the computation, then one should use the command <code>FRICTION</code> with the value of the friction set to zero (e.g., <code>FRICTION COLLINS 0</code>).</p> Source code in <code>src/rompy_swan/types.py</code> <pre><code>class BlockOptions(str, Enum):\n    \"\"\"Valid options for block output parameters.\n\n    Attributes\n    ----------\n    HSIGN: \"hsign\"\n        Significant wave height (in m).\n    HSEA: \"hsea\"\n        Sea wave height (in m).\n    HSWELL: \"hswell\"\n        Swell wave height (in m).\n    DIR: \"dir\"\n        Mean wave direction (in degrees).\n    DPM: \"dpm\"\n        Mean wave direction at the peak frequency (in degrees).\n    DPMSEA: \"dpmsea\"\n        Sea mean wave direction at the peak frequency (in degrees).\n    DPMSWE: \"dpmswe\"\n        Swell mean wave direction at the peak frequency (in degrees).\n    PDIR: \"pdir\"\n        Peak wave direction (in degrees).\n    TDIR: \"tdir\"\n        Direction of energy transport (in degrees).\n    TM01: \"tm01\"\n        Mean absolute wave period (in s).\n    RTM01: \"rtm01\"\n        Mean relative wave period (in s).\n    RTP: \"rtp\"\n        Peak period of the (relative frequency) variance density spectrum (in s).\n    TPS: \"tps\"\n        Smoothed peak period (in s).\n    TPSSEA: \"tpssea\"\n        Sea smoothed peak period (in s).\n    TPSSWE: \"tpsswe\"\n        Swell smoothed peak period (in s).\n    PER: \"per\"\n        Mean absolute wave period (in s).\n    RPER: \"rper\"\n        Mean relative wave period (in s).\n    TMM10: \"tmm10\"\n        Mean absolute wave period (in s).\n    RTMM10: \"rtmm10\"\n        Mean relative wave period (in s).\n    TM02: \"tm02\"\n        Mean absolute zero-crossing period (in s).\n    FSPR: \"fspr\"\n        The normalised width of the frequency spectrum.\n    DSPR: \"dspr\"\n        Directional spreading of the waves (in degrees).\n    QP: \"qp\"\n        Peakedness of the wave spectrum (dimensionless).\n    DEPTH: \"depth\"\n        Water depth (in m).\n    WATLEV: \"watlev\"\n        Water level (in m).\n    BOTLEV: \"botlev\"\n        Bottom level (in m).\n    VEL: \"vel\"\n        Current velocity (vector; in m/s).\n    FRCOEF: \"frcoef\"\n        Friction coefficient (equal to `cfw` or `kn` in command `FRICTION`).\n    WIND: \"wind\"\n        Wind velocity (vector; in m/s).\n    AICE: \"aice\"\n        Ice concentration (as a fraction from 0 to 1).\n    PROPAGAT: \"propagat\"\n        Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s).\n    PROPXY: \"propxy\"\n        Energy propagation in geographic space; sum of x- and y-direction\n        (in W/m2 or m2/s).\n    PROPTHETA: \"proptheta\"\n        Energy propagation in theta space (in W/m2 or m2/s).\n    PROPSIGMA: \"propsigma\"\n        Energy propagation in sigma space (in W/m2 or m2/s).\n    GENERAT: \"generat\"\n        Total energy generation (in W/m2 or m2/s).\n    GENWIND: \"genwind\"\n        Energy generation due to wind (in W/m2 or m2/s).\n    REDIST: \"redist\"\n        Total energy redistribution (in W/m2 or m2/s).\n    REDQUAD: \"redquad\"\n        Energy redistribution due to quadruplets (in W/m2 or m2/s).\n    REDTRIAD: \"redtriad\"\n        Energy redistribution due to triads (in W/m2 or m2/s).\n    DISSIP: \"dissip\"\n        Total energy dissipation (in W/m2 or m2/s).\n    DISBOT: \"disbot\"\n        Energy dissipation due to bottom friction (in W/m2 or m2/s).\n    DISSURF: \"dissurf\"\n        Energy dissipation due to surf breaking (in W/m2 or m2/s).\n    DISWCAP: \"diswcap\"\n        Energy dissipation due to whitecapping (in W/m2 or m2/s).\n    DISSWELL: \"disswell\"\n        Energy dissipation due to swell dissipation (in W/m2 or m2/s).\n    DISVEG: \"disveg\"\n        Energy dissipation due to vegetation (in W/m2 or m2/s).\n    DISMUD: \"dismud\"\n        Energy dissipation due to mud (in W/m2 or m2/s).\n    DISICE: \"disice\"\n        Energy dissipation due to sea ice (in W/m2 or m2/s).\n    RADSTR: \"radstr\"\n        Energy transfer between waves and currents due to radiation stress\n        (in W/m2 or m2/s).\n    QB: \"qb\"\n        Fraction of breaking waves due to depth-induced breaking.\n    TRANSP: \"transp\"\n        Transport of energy (vector; in W/m2 or m2/s).\n    FORCE: \"force\"\n        Wave-induced force per unit surface area (vector; in N/m2).\n    UBOT: \"ubot\"\n        The rms-value of the maxima of the orbital velocity near the bottom (in m/s).\n    URMS: \"urms\"\n        The rms-value of the orbital velocity near the bottom (in m/s).\n    TMBOT: \"tmbot\"\n        The bottom wave period (in s).\n    WLENGTH: \"wlength\"\n        Average wave length (in m).\n    LWAVP: \"lwavp\"\n        Peak wave length (in m).\n    STEEPNESS: \"steepness\"\n        Average wave steepness (dimensionless).\n    BFI: \"bfi\"\n        Benjamin-Feir index (dimensionless).\n    NPLANTS: \"nplants\"\n        Number of plants per square meter.\n    DHSIGN: \"dhsign\"\n        Difference in significant wave height from the last two iterations (in m).\n    DRTM01: \"drtm01\"\n        Difference in average wave period (RTM01) from the last two iterations (in s).\n    LEAK: \"leak\"\n        Numerical loss of energy equal to `cthetaE(omega,theta)` across boundaries.\n    TIME: \"time\"\n        Full date-time string as part of line used in TABLE only.\n    TSEC: \"tsec\"\n        Time in seconds with respect to a reference time (see command QUANTITY).\n    XP: \"xp\"\n        The x-coordinate in the problem coordinate system of the output location.\n    YP: \"yp\"\n        The y-coordinate in the problem coordinate system of the output location.\n    DIST: \"dist\"\n        If output has been requested along a curve then the distance along the curve\n        can be obtained with the command TABLE. DIST is the distance along the curve\n        measured from teh first point on the curve to the output location on the curve\n        in meters (also in the case of spherical coordinates).\n    SETUP: \"setup\"\n        Set-up due to waves (in m).\n    PTHSIGN: \"pthsign\"\n        Watershed partitions of the significant wave height (in m).\n    PTRTP: \"ptrtp\"\n        Watershed partitions of the relative peak period (in s).\n    PTWLEN: \"ptwlen\"\n        Watershed partitions of the average wave length (in m).\n    PTDIR: \"ptdir\"\n        Watershed partitions of the peak wave direction (in degrees).\n    PTDSPR: \"ptdspr\"\n        Watershed partitions of the directional spreading (in degrees).\n    PTWFRAC: \"ptwfrac\"\n        Watershed partitions of the wind fraction (dimensionless).\n    PTSTEEPNE: \"ptsteepne\"\n        Watershed partition of the wave steepness (dimensionless).\n    PARTITION: \"partition\"\n        The raw spectral partition for wave system tracking post-processing.\n\n    Note\n    ----\n    Energy given in W/m2 or m2/s depending on command SET.\n\n    Note\n    ----\n    UBOT and URMS required command `FRICTION` to be used. If friction is ignored in the\n    computation, then one should use the command `FRICTION` with the value of the\n    friction set to zero (e.g., `FRICTION COLLINS 0`).\n\n    \"\"\"\n\n    HSIGN = \"hsign\"\n    HSEA = \"hsea\"\n    HSWELL = \"hswell\"\n    DIR = \"dir\"\n    DPM = \"dpm\"\n    DPMSEA = \"dpmsea\"\n    DPMSWE = \"dpmswe\"\n    PDIR = \"pdir\"\n    TDIR = \"tdir\"\n    TM01 = \"tm01\"\n    RTM01 = \"rtm01\"\n    RTP = \"rtp\"\n    TPS = \"tps\"\n    TPSSEA = \"tpssea\"\n    TPSSWE = \"tpsswe\"\n    PER = \"per\"\n    RPER = \"rper\"\n    TMM10 = \"tmm10\"\n    RTMM10 = \"rtmm10\"\n    TM02 = \"tm02\"\n    FSPR = \"fspr\"\n    DSPR = \"dspr\"\n    QP = \"qp\"\n    DEPTH = \"depth\"\n    WATLEV = \"watlev\"\n    BOTLEV = \"botlev\"\n    VEL = \"vel\"\n    FRCOEF = \"frcoef\"\n    WIND = \"wind\"\n    AICE = \"aice\"\n    PROPAGAT = \"propagat\"\n    PROPXY = \"propxy\"\n    PROPTHETA = \"proptheta\"\n    PROPSIGMA = \"propsigma\"\n    GENERAT = \"generat\"\n    GENWIND = \"genwind\"\n    REDIST = \"redist\"\n    REDQUAD = \"redquad\"\n    REDTRIAD = \"redtriad\"\n    DISSIP = \"dissip\"\n    DISBOT = \"disbot\"\n    DISSURF = \"dissurf\"\n    DISWCAP = \"diswcap\"\n    DISSWELL = \"disswell\"\n    DISVEG = \"disveg\"\n    DISMUD = \"dismud\"\n    DISICE = \"disice\"\n    RADSTR = \"radstr\"\n    QB = \"qb\"\n    TRANSP = \"transp\"\n    FORCE = \"force\"\n    UBOT = \"ubot\"\n    URMS = \"urms\"\n    TMBOT = \"tmbot\"\n    WLENGTH = \"wlength\"\n    LWAVP = \"lwavp\"\n    STEEPNESS = \"steepness\"\n    BFI = \"bfi\"\n    NPLANTS = \"nplants\"\n    DHSIGN = \"dhsign\"\n    DRTM01 = \"drtm01\"\n    LEAK = \"leak\"\n    TIME = \"time\"\n    TSEC = \"tsec\"\n    XP = \"xp\"\n    YP = \"yp\"\n    DIST = \"dist\"\n    SETUP = \"setup\"\n    PTHSIGN = \"pthsign\"\n    PTRTP = \"ptrtp\"\n    PTWLEN = \"ptwlen\"\n    PTDIR = \"ptdir\"\n    PTDSPR = \"ptdspr\"\n    PTWFRAC = \"ptwfrac\"\n    PTSTEEPNE = \"ptsteepne\"\n    PARTITION = \"partition\"\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.HSIGN","title":"HSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSIGN = 'hsign'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.HSEA","title":"HSEA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSEA = 'hsea'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.HSWELL","title":"HSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSWELL = 'hswell'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DIR","title":"DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIR = 'dir'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DPM","title":"DPM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DPM = 'dpm'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DPMSEA","title":"DPMSEA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DPMSEA = 'dpmsea'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DPMSWE","title":"DPMSWE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DPMSWE = 'dpmswe'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PDIR","title":"PDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PDIR = 'pdir'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TDIR","title":"TDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TDIR = 'tdir'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TM01","title":"TM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM01 = 'tm01'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.RTM01","title":"RTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTM01 = 'rtm01'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.RTP","title":"RTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTP = 'rtp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TPS","title":"TPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TPS = 'tps'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TPSSEA","title":"TPSSEA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TPSSEA = 'tpssea'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TPSSWE","title":"TPSSWE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TPSSWE = 'tpsswe'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PER","title":"PER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PER = 'per'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.RPER","title":"RPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RPER = 'rper'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TMM10","title":"TMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMM10 = 'tmm10'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.RTMM10","title":"RTMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTMM10 = 'rtmm10'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TM02","title":"TM02  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM02 = 'tm02'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.FSPR","title":"FSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSPR = 'fspr'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DSPR","title":"DSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DSPR = 'dspr'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.QP","title":"QP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QP = 'qp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DEPTH","title":"DEPTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEPTH = 'depth'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.WATLEV","title":"WATLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WATLEV = 'watlev'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.BOTLEV","title":"BOTLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTLEV = 'botlev'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.VEL","title":"VEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VEL = 'vel'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.FRCOEF","title":"FRCOEF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRCOEF = 'frcoef'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PROPAGAT","title":"PROPAGAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPAGAT = 'propagat'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PROPXY","title":"PROPXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPXY = 'propxy'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PROPTHETA","title":"PROPTHETA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPTHETA = 'proptheta'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PROPSIGMA","title":"PROPSIGMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPSIGMA = 'propsigma'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.GENERAT","title":"GENERAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAT = 'generat'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.GENWIND","title":"GENWIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENWIND = 'genwind'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.REDIST","title":"REDIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDIST = 'redist'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.REDQUAD","title":"REDQUAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDQUAD = 'redquad'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.REDTRIAD","title":"REDTRIAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDTRIAD = 'redtriad'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISSIP","title":"DISSIP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSIP = 'dissip'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISBOT","title":"DISBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISBOT = 'disbot'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISSURF","title":"DISSURF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSURF = 'dissurf'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISWCAP","title":"DISWCAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISWCAP = 'diswcap'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISSWELL","title":"DISSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSWELL = 'disswell'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISVEG","title":"DISVEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISVEG = 'disveg'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISMUD","title":"DISMUD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISMUD = 'dismud'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DISICE","title":"DISICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISICE = 'disice'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.RADSTR","title":"RADSTR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RADSTR = 'radstr'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.QB","title":"QB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QB = 'qb'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TRANSP","title":"TRANSP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSP = 'transp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.FORCE","title":"FORCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCE = 'force'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.UBOT","title":"UBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UBOT = 'ubot'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.URMS","title":"URMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>URMS = 'urms'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TMBOT","title":"TMBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMBOT = 'tmbot'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.WLENGTH","title":"WLENGTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLENGTH = 'wlength'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.LWAVP","title":"LWAVP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LWAVP = 'lwavp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.STEEPNESS","title":"STEEPNESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STEEPNESS = 'steepness'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.BFI","title":"BFI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BFI = 'bfi'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DHSIGN","title":"DHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DHSIGN = 'dhsign'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DRTM01","title":"DRTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRTM01 = 'drtm01'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.LEAK","title":"LEAK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LEAK = 'leak'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TIME","title":"TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME = 'time'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.TSEC","title":"TSEC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSEC = 'tsec'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.XP","title":"XP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XP = 'xp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.YP","title":"YP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YP = 'yp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.DIST","title":"DIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIST = 'dist'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.SETUP","title":"SETUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SETUP = 'setup'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTHSIGN","title":"PTHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTHSIGN = 'pthsign'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTRTP","title":"PTRTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTRTP = 'ptrtp'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTWLEN","title":"PTWLEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWLEN = 'ptwlen'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTDIR","title":"PTDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDIR = 'ptdir'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTDSPR","title":"PTDSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDSPR = 'ptdspr'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTWFRAC","title":"PTWFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWFRAC = 'ptwfrac'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PTSTEEPNE","title":"PTSTEEPNE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTSTEEPNE = 'ptsteepne'\n</code></pre>"},{"location":"api-reference/types/#rompy_swan.types.BlockOptions.PARTITION","title":"PARTITION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTITION = 'partition'\n</code></pre>"},{"location":"components/","title":"Components Overview","text":"<p>Rompy-swan organises SWAN commands into components \u2014 Pydantic models that mirror the structure of SWAN commands. This design makes the Python interface familiar to existing SWAN users while providing validation and discoverability for new users.</p>"},{"location":"components/#design-principle","title":"Design Principle","text":"<p>Components are modelled after the way commands are structured in the SWAN command file:</p> <ul> <li>Commands \u2192 Component classes (e.g., <code>GEN3</code>, <code>CGRID</code>, <code>BOUNDSPEC</code>)</li> <li>Branching options \u2192 Subcomponent classes (e.g., <code>SIDE</code> vs <code>SEGMENT</code> for boundary location)</li> <li>Mutually exclusive choices \u2192 Discriminated unions (type-safe selection)</li> </ul> <p>This means if you know SWAN command syntax, you'll recognise the structure in rompy-swan. And if you're new to SWAN, the type validation and IDE autocomplete will guide you to valid configurations.</p>"},{"location":"components/#component-hierarchy","title":"Component Hierarchy","text":"<pre><code>SwanConfig\n\u251c\u2500\u2500 cgrid              # Computational grid definition\n\u251c\u2500\u2500 startup            # Startup commands (PROJECT, SET, MODE, etc.)\n\u251c\u2500\u2500 inpgrid            # Input grids (bathymetry, wind, currents, etc.)\n\u251c\u2500\u2500 boundary           # Boundary conditions\n\u251c\u2500\u2500 initial            # Initial conditions\n\u251c\u2500\u2500 physics            # Physics commands (generation, breaking, friction, etc.)\n\u251c\u2500\u2500 prop               # Propagation scheme\n\u251c\u2500\u2500 numeric            # Numerical settings\n\u251c\u2500\u2500 output             # Output configuration\n\u2514\u2500\u2500 lockup             # Compute and stop commands\n</code></pre>"},{"location":"components/#quick-reference","title":"Quick Reference","text":"Component Purpose Key Commands CGRID Computational grid REGULAR, CURVILINEAR, UNSTRUCTURED Startup Model setup PROJECT, SET, MODE, COORDINATES INPGRID Input grids INPGRID, READINP Boundary Boundary conditions BOUNDSPEC, BOUNDNEST1-3 Physics Physical processes GEN3, BREAKING, FRICTION, TRIAD Numerics Numerical schemes PROP, NUMERIC Output Output configuration BLOCK, TABLE, SPECOUT Lockup Execution control COMPUTE, STOP Group Component aggregators STARTUP, PHYSICS, OUTPUT"},{"location":"components/#using-components","title":"Using Components","text":""},{"location":"components/#direct-instantiation","title":"Direct Instantiation","text":"<pre><code>from rompy_swan.config import SwanConfig\nfrom rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT\nfrom rompy_swan.components.group import PHYSICS\n\nconfig = SwanConfig(\n    cgrid=REGULAR(\n        spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n    ),\n    physics=PHYSICS(\n        gen=GEN3(),\n        breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    ),\n)\n</code></pre>"},{"location":"components/#from-yaml","title":"From YAML","text":"<pre><code>cgrid:\n  model_type: regular\n  spectrum:\n    mdc: 36\n    flow: 0.04\n    fhigh: 1.0\n  grid:\n    xp: 0\n    yp: 0\n    alp: 0\n    xlen: 100000\n    ylen: 50000\n    mx: 100\n    my: 50\n\nphysics:\n  gen:\n    model_type: gen3\n  breaking:\n    model_type: constant\n    alpha: 1.0\n    gamma: 0.73\n</code></pre>"},{"location":"components/#component-patterns","title":"Component Patterns","text":""},{"location":"components/#discriminated-unions","title":"Discriminated Unions","text":"<p>When a SWAN command has mutually exclusive options, rompy-swan uses discriminated unions with <code>model_type</code>:</p> <pre><code># Breaking can be CONSTANT or BKD - each has different parameters\nfrom rompy_swan.components.physics import BREAKING_CONSTANT, BREAKING_BKD\n\n# Using CONSTANT formulation\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\n\n# Using BKD formulation  \nbreaking = BREAKING_BKD(alpha=1.0, gamma0=0.73, a1=0.5)\n</code></pre> <p>In YAML, use <code>model_type</code> to select which variant:</p> <pre><code>breaking:\n  model_type: constant\n  alpha: 1.0\n  gamma: 0.73\n</code></pre>"},{"location":"components/#group-components","title":"Group Components","text":"<p>Group components aggregate related commands that typically appear together:</p> <pre><code>from rompy_swan.components.group import PHYSICS\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_JONSWAP\n\nphysics = PHYSICS(\n    gen=GEN3(),\n    breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    friction=FRICTION_JONSWAP(cfjon=0.067),\n)\n</code></pre>"},{"location":"components/#optional-components","title":"Optional Components","text":"<p>Most components are optional with sensible defaults:</p> <pre><code># Minimal config - only cgrid is required\nconfig = SwanConfig(\n    cgrid=REGULAR(...),\n)\n\n# Add components as needed\nconfig = SwanConfig(\n    cgrid=REGULAR(...),\n    physics=PHYSICS(gen=GEN3()),\n    output=OUTPUT(block=BLOCK(...)),\n)\n</code></pre>"},{"location":"components/#subcomponents","title":"Subcomponents","text":"<p>Subcomponents represent branching options within SWAN commands. When a command has options that each accept different parameters, these become separate subcomponent classes:</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nfrom rompy_swan.subcomponents.boundary import SIDE, CONSTANTPAR\n\n# SIDE is one way to specify location (by domain side)\n# CONSTANTPAR is one way to specify data (constant parameters)\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"jonswap\", gamma=3.3),\n    location=SIDE(side=\"west\"),\n    data=CONSTANTPAR(hs=2.0, per=10.0, dir=270.0, dd=30.0),\n)\n</code></pre> <p>See the Subcomponents section for details.</p>"},{"location":"components/#component-reference","title":"Component Reference","text":"<p>Browse the component pages for detailed documentation:</p> <ul> <li>CGRID \u2014 Computational grid definition</li> <li>Startup \u2014 Model setup commands</li> <li>INPGRID \u2014 Input grid commands</li> <li>Boundary \u2014 Boundary condition commands</li> <li>Physics \u2014 Physical process commands</li> <li>Numerics \u2014 Numerical scheme commands</li> <li>Output \u2014 Output configuration commands</li> <li>Lockup \u2014 Execution control commands</li> <li>Group \u2014 Component aggregators</li> </ul>"},{"location":"components/boundary/","title":"Boundary and Initial Conditions","text":"<p>Boundary conditions specify wave energy entering the computational domain. Initial conditions define the starting wave field for non-stationary simulations.</p> <p>Boundary Types</p> <ul> <li>BOUNDSPEC \u2014 Parametric or spectral boundary conditions at domain edges</li> <li>BOUNDNEST1/2/3 \u2014 Nested boundary conditions from coarser SWAN runs (different nesting levels)</li> </ul>"},{"location":"components/boundary/#boundary-conditions","title":"Boundary Conditions","text":""},{"location":"components/boundary/#boundspec","title":"BOUNDSPEC","text":"<p>Specifies wave conditions at the boundary using parametric (Hs, Tp, direction) or spectral data.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC","title":"BOUNDSPEC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary along sides or segment.</p> <p>.. code-block:: text</p> <pre><code>BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n</code></pre> <p>This command BOUNDSPEC defines parametric spectra at the boundary. It consists of two parts, the first part defines the boundary side or segment where the spectra will be given, the second part defines the spectral parameters of these spectra. Note that in fact only the incoming wave components of these spectra are used by SWAN. The fact that complete spectra are calculated at the model boundaries from the spectral parameters should not be misinterpreted. Only the incoming components are effective in the computation.</p> <p>TODO: Add support for unstructured grid (k).</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(\n        model_type=\"segment\",\n        points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n    ),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDSPEC(BaseComponent):\n    \"\"\"Boundary along sides or segment.\n\n    .. code-block:: text\n\n        BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n\n    This command BOUNDSPEC defines parametric spectra at the boundary. It consists of\n    two parts, the first part defines the boundary side or segment where the spectra\n    will be given, the second part defines the spectral parameters of these spectra.\n    Note that in fact only the incoming wave components of these spectra are used by\n    SWAN. The fact that complete spectra are calculated at the model boundaries from\n    the spectral parameters should not be misinterpreted. Only the incoming components\n    are effective in the computation.\n\n    TODO: Add support for unstructured grid (k).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDSPEC\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(\n                model_type=\"segment\",\n                points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n            ),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundspec\", \"BOUNDSPEC\"] = Field(\n        default=\"boundspec\",\n        description=\"Model type discriminator\",\n    )\n    shapespec: SHAPESPEC = Field(\n        default_factory=SHAPESPEC,\n        description=\"Spectral shape specification\",\n    )\n    location: SIDE | SEGMENT = Field(\n        description=\"Location to apply the boundary\",\n    )\n    data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(\n        description=\"Spectral data\",\n    )\n\n    def cmd(self) -&gt; list:\n        repr = [f\"{self.shapespec.render()}\"]\n        repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundspec', 'BOUNDSPEC'] = Field(default='boundspec', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.shapespec","title":"shapespec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shapespec: SHAPESPEC = Field(default_factory=SHAPESPEC, description='Spectral shape specification')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SIDE | SEGMENT = Field(description='Location to apply the boundary')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(description='Spectral data')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = [f\"{self.shapespec.render()}\"]\n    repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n    return repr\n</code></pre>"},{"location":"components/boundary/#nested-boundaries","title":"Nested Boundaries","text":"<p>For nested simulations, use output from a coarser SWAN run as boundary input.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1","title":"BOUNDNEST1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from a coarser SWAN nest.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid SWAN run (generated in that previous SWAN run with command NESTOUT). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid run, use command NGRID. For the nested run, use the command CGRID with identical geographical information except the number of meshes (which will be much higher for the nested run). This BOUNDNEST1 command is not available for 1D computations; in such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A nested SWAN run must use the same coordinate system as the coarse grid SWAN run. For a curvilinear grid, it is advised to use the commands POINTS or CURVE and SPECOUT instead of NGRID and NESTOUT.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST1\nboundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST1(BaseComponent):\n    \"\"\"Boundary spectra from a coarser SWAN nest.\n\n    .. code-block:: text\n\n        BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid SWAN run (generated in that previous SWAN\n    run with command NESTOUT). The spectral frequencies and directions of the coarse\n    grid run do not have to coincide with the frequencies and directions used in the\n    nested SWAN run; SWAN will interpolate to these frequencies and directions in the\n    nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid\n    run, use command NGRID. For the nested run, use the command CGRID with identical\n    geographical information except the number of meshes (which will be much higher for\n    the nested run). This BOUNDNEST1 command is not available for 1D computations; in\n    such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A\n    nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n    For a curvilinear grid, it is advised to use the commands POINTS or CURVE and\n    SPECOUT instead of NGRID and NESTOUT.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST1\n        boundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest1\", \"BOUNDNEST1\"] = Field(\n        default=\"boundnest1\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"Name of the file containing the boundary conditions for the present run, \"\n            \"created by the previous SWAN coarse grid run. This file is structured \"\n            \"according to the rules given in Appendix D for 2D spectra\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest1', 'BOUNDNEST1'] = Field(default='boundnest1', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the boundary conditions for the present run, created by the previous SWAN coarse grid run. This file is structured according to the rules given in Appendix D for 2D spectra', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2","title":"BOUNDNEST2","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAM.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n</code></pre> <p>With this optional command (not fully tested) a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5, source code as distributed by the Max Planck Institute in Hamburg). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). Note that SWAN will accept output of a WAM output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAM output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAM output locations. This BOUNDNEST2 command is not available for 1D computations. Only boundary conditions generated by WAM Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries. WAM output files are unformatted (binary); this usually implies that WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN run on different types of machines (binary files do not transfer properly), the option FREE is available in this command. The distributed version of WAM does not support the required free format nesting output; WAM users who modify WAM such that it can make formatted output, must modify WAM such that the files made by WAM can be read in free format, i.e. with at least a blank or comma between numbers.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2--note","title":"Note","text":"<p>the contents of 'fname' file could look like:</p> <p>.. code-block:: text</p> <pre><code>CBO9212010000\nCBO9212020000\nCBO9212030000\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST2\nboundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST2(BaseComponent):\n    \"\"\"Boundary spectra from WAM.\n\n    .. code-block:: text\n\n        BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n\n    With this optional command (not fully tested) a nested SWAN run can be carried out\n    with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5,\n    source code as distributed by the Max Planck Institute in Hamburg). The spectral\n    frequencies and directions of the coarse grid run do not have to coincide with the\n    frequencies and directions used in the nested SWAN run; SWAN will interpolate to\n    these frequencies and directions in the nested run (see Section 2.6.3). Note that\n    SWAN will accept output of a WAM output location only if the SWAN grid point on the\n    nest boundary lies within a rectangle between two consecutive WAM output locations\n    with a width equal to 0.1 times the distance between these output locations on\n    either side of the line between these WAM output locations. This BOUNDNEST2 command\n    is not available for 1D computations. Only boundary conditions generated by WAM\n    Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian\n    or spherical coordinates. A curvilinear grid may be used in the nested grid but the\n    boundaries of this nest should conform to the rectangular course grid nest\n    boundaries. WAM output files are unformatted (binary); this usually implies that\n    WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN\n    run on different types of machines (binary files do not transfer properly), the\n    option FREE is available in this command. The distributed version of WAM does not\n    support the required free format nesting output; WAM users who modify WAM such that\n    it can make formatted output, must modify WAM such that the files made by WAM can\n    be read in free format, i.e. with at least a blank or comma between numbers.\n\n    Note\n    ----\n    the contents of 'fname' file could look like:\n\n    .. code-block:: text\n\n        CBO9212010000\n        CBO9212020000\n        CBO9212030000\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST2\n        boundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest2\", \"BOUNDNEST2\"] = Field(\n        default=\"boundnest2\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"A file name that contains all the names of WAM files containing the \"\n            \"nested boundary conditions in time-sequence (usually one file per day)\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"cray\", \"wkstat\", \"free\"] = Field(\n        description=(\n            \"Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: \"\n            \"WORKSTATION version of WAM, `free`: Free format (these files are not \"\n            \"generated standard by WAM)\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    lwdate: Literal[10, 12, 14] = Field(\n        default=12,\n        description=(\n            \"Length of character string for date-time as used in the WAM files. \"\n            \"Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) \"\n            \"or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)\"\n        ),\n    )\n\n    @property\n    def format_str(self):\n        if self.format == \"cray\":\n            return \"UNFORMATTED CRAY\"\n        elif self.format == \"wkstat\":\n            return \"UNFORMATTED WKSTAT\"\n        elif self.format == \"free\":\n            return \"FREE\"\n        else:\n            raise ValueError(f\"Unknown format {self.format}\")\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        repr += f\" lwdate={self.lwdate}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest2', 'BOUNDNEST2'] = Field(default='boundnest2', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='A file name that contains all the names of WAM files containing the nested boundary conditions in time-sequence (usually one file per day)', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['cray', 'wkstat', 'free'] = Field(description='Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: WORKSTATION version of WAM, `free`: Free format (these files are not generated standard by WAM)')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.lwdate","title":"lwdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lwdate: Literal[10, 12, 14] = Field(default=12, description='Length of character string for date-time as used in the WAM files. Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.format_str","title":"format_str  <code>property</code>","text":"<pre><code>format_str\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    repr += f\" lwdate={self.lwdate}\"\n    return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3","title":"BOUNDNEST3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAVEWATCHIII.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). The output files of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub type 3) at the locations along the nest boundary (i.e. computational grid points in WAVEWATCH III). These locations are equal to the corner points of the SWAN nested grid and optionally also distributed between the corner points of the SWAN nested grid (the boundary of the WAVEWATCH III nested grid need not be closed and may cover land). The locations should be output by WAVEWATCH III in sequence (going along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept output of a WAVEWATCH III output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAVEWATCH III output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAVEWATCH III output locations. This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST3\nboundary = BOUNDNEST3(\n    fname=\"boundary.ww3\",\n    format=\"free\",\n    rectangle=\"closed\",\n)\nprint(boundary.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST3(BaseComponent):\n    \"\"\"Boundary spectra from WAVEWATCHIII.\n\n    .. code-block:: text\n\n        BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies\n    and directions of the coarse grid run do not have to coincide with the frequencies\n    and directions used in the nested SWAN run; SWAN will interpolate to these\n    frequencies and directions in the nested run (see Section 2.6.3). The output files\n    of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as\n    output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub\n    type 3) at the locations along the nest boundary (i.e. computational grid points in\n    WAVEWATCH III). These locations are equal to the corner points of the SWAN nested\n    grid and optionally also distributed between the corner points of the SWAN nested\n    grid (the boundary of the WAVEWATCH III nested grid need not be closed and may\n    cover land). The locations should be output by WAVEWATCH III in sequence (going\n    along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept\n    output of a WAVEWATCH III output location only if the SWAN grid point on the nest\n    boundary lies within a rectangle between two consecutive WAVEWATCH III output\n    locations with a width equal to 0.1 times the distance between these output\n    locations on either side of the line between these WAVEWATCH III output locations.\n    This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may\n    use either Cartesian or spherical coordinates. A curvilinear grid may be used in\n    the nested grid but the boundaries of this nest should conform to the rectangular\n    course grid nest boundaries.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST3\n        boundary = BOUNDNEST3(\n            fname=\"boundary.ww3\",\n            format=\"free\",\n            rectangle=\"closed\",\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest3\", \"BOUNDNEST3\"] = Field(\n        default=\"boundnest3\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"The name of the file that contains the spectra computed by WAVEWATCH III\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"unformatted\", \"free\"] = Field(\n        description=(\n            \"Format of the WW3 file. `unformatted`: The input WW3 files are binary, \"\n            \"`free`: The input WW3 files are formatted\"\n        ),\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n        repr += f\"{self.rectangle.upper()}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest3', 'BOUNDNEST3'] = Field(default='boundnest3', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='The name of the file that contains the spectra computed by WAVEWATCH III', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['unformatted', 'free'] = Field(description='Format of the WW3 file. `unformatted`: The input WW3 files are binary, `free`: The input WW3 files are formatted')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n    repr += f\"{self.rectangle.upper()}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    return repr\n</code></pre>"},{"location":"components/boundary/#initial-conditions","title":"Initial Conditions","text":"<p>For non-stationary runs, the initial wave field can significantly affect early results. SWAN can start from rest, use a JONSWAP spectrum, or read from a previous run.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL","title":"INITIAL","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Initial conditions.</p> <p>.. code-block:: text</p> <pre><code>INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n</code></pre> <p>This command can be used to specify the initial values for a stationary (INITIAL HOTSTART only) or nonstationary computation. The initial values thus specified override the default initialization (see Section 2.6.3). Note that it is possible to obtain an initial state by carrying out a previous stationary or nonstationary computation.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import INITIAL\ninit = INITIAL()\nprint(init.render())\ninit = INITIAL(\n    kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n)\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>class INITIAL(BaseComponent):\n    \"\"\"Initial conditions.\n\n    .. code-block:: text\n\n        INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n\n    This command can be used to specify the initial values for a stationary (INITIAL\n    HOTSTART only) or nonstationary computation. The initial values thus specified\n    override the default initialization (see Section 2.6.3). Note that it is possible\n    to obtain an initial state by carrying out a previous stationary or nonstationary\n    computation.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import INITIAL\n        init = INITIAL()\n        print(init.render())\n        init = INITIAL(\n            kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n        )\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"initial\", \"INITIAL\"] = Field(\n        default=\"initial\",\n        description=\"Model type discriminator\",\n    )\n    kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(\n        default_factory=DEFAULT,\n        description=\"Initial condition type\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"INITIAL {self.kind.render()}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['initial', 'INITIAL'] = Field(default='initial', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(default_factory=DEFAULT, description='Initial condition type')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"INITIAL {self.kind.render()}\"\n    return repr\n</code></pre>"},{"location":"components/cgrid/","title":"Computational Grid","text":"<p>The computational grid (CGRID) defines the spatial and spectral discretization for SWAN calculations. It specifies where wave action densities are computed.</p> <p>Grid Types</p> <p>SWAN supports three grid types:</p> <ul> <li>Regular \u2014 Rectangular grid with uniform spacing</li> <li>Curvilinear \u2014 Grid with curved coordinate lines (e.g., following coastlines)</li> <li>Unstructured \u2014 Triangular mesh for complex geometries</li> </ul> <p>The CGRID command also defines the spectral resolution (number of directions and frequency range).</p>"},{"location":"components/cgrid/#regular-grid","title":"Regular Grid","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR","title":"REGULAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN regular computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR--note","title":"Note","text":"<p>In 1D-mode, <code>alpc</code> should be equal to the direction <code>alpinp</code>.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import REGULAR\ncgrid = REGULAR(\n    grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class REGULAR(CGRID):\n    \"\"\"SWAN regular computational grid.\n\n    .. code-block:: text\n\n        CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Note\n    ----\n    In 1D-mode, `alpc` should be equal to the direction `alpinp`.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import REGULAR\n        cgrid = REGULAR(\n            grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"regular\", \"REGULAR\"] = Field(\n        default=\"regular\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"Computational grid definition\")\n\n    @model_validator(mode=\"after\")\n    def grid_suffix(self) -&gt; \"REGULAR\":\n        \"\"\"Set expected grid suffix.\"\"\"\n        if self.grid.suffix != \"c\":\n            logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n            self.grid.suffix = \"c\"\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['regular', 'REGULAR'] = Field(default='regular', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='Computational grid definition')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.grid_suffix","title":"grid_suffix","text":"<pre><code>grid_suffix() -&gt; REGULAR\n</code></pre> <p>Set expected grid suffix.</p> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef grid_suffix(self) -&gt; \"REGULAR\":\n    \"\"\"Set expected grid suffix.\"\"\"\n    if self.grid.suffix != \"c\":\n        logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n        self.grid.suffix = \"c\"\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n    return repr\n</code></pre>"},{"location":"components/cgrid/#curvilinear-grid","title":"Curvilinear Grid","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR","title":"CURVILINEAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN curvilinear computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n    FREE|FORMAT ('form'|[idfm])\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import CURVILINEAR\ncgrid = CURVILINEAR(\n    mxc=199,\n    myc=199,\n    readcoord=dict(fname=\"./coords.txt\"),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class CURVILINEAR(CGRID):\n    \"\"\"SWAN curvilinear computational grid.\n\n    .. code-block:: text\n\n        CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n            FREE|FORMAT ('form'|[idfm])\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import CURVILINEAR\n        cgrid = CURVILINEAR(\n            mxc=199,\n            myc=199,\n            readcoord=dict(fname=\"./coords.txt\"),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curvilinear\", \"CURVILINEAR\"] = Field(\n        default=\"curvilinear\", description=\"Model type discriminator\"\n    )\n    mxc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03be-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    myc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03b7-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    xexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the x-coordinate considered in the file of the \"\n            \"x-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    yexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the y-coordinate considered in the file of the \"\n            \"y-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    readcoord: READCOORD = Field(\n        description=\"Grid coordinates reader.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n        if [self.xexc, self.yexc].count(None) == 1:\n            raise ValueError(\"xexc and yexc must be specified together\")\n        return self\n\n    @property\n    def exception(self):\n        if self.xexc is not None:\n            return f\"EXCEPTION xexc={self.xexc} xexc={self.yexc}\"\n        else:\n            return \"\"\n\n    @property\n    def format_repr(self):\n        if self.format == \"free\":\n            repr = \"FREE\"\n        elif self.format == \"fixed\" and self.form:\n            repr = f\"FORMAT form='{self.form}'\"\n        elif self.format == \"fixed\" and self.idfm:\n            repr = f\"FORMAT idfm={self.idfm}\"\n        elif self.format == \"unformatted\":\n            repr = \"UNFORMATTED\"\n        return repr\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n        if self.exception:\n            repr += f\" {self.exception}\"\n        repr += f\" {self.spectrum.render()}\"\n        repr = [repr] + [self.readcoord.render()]\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curvilinear', 'CURVILINEAR'] = Field(default='curvilinear', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.mxc","title":"mxc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxc: int = Field(description='Number of meshes in computational grid in \u03be-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.myc","title":"myc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myc: int = Field(description='Number of meshes in computational grid in \u03b7-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.xexc","title":"xexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the x-coordinate considered in the file of the x-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.yexc","title":"yexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the y-coordinate considered in the file of the y-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.readcoord","title":"readcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readcoord: READCOORD = Field(description='Grid coordinates reader.')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.exception","title":"exception  <code>property</code>","text":"<pre><code>exception\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.format_repr","title":"format_repr  <code>property</code>","text":"<pre><code>format_repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.xexc_and_yexc_or_neither","title":"xexc_and_yexc_or_neither","text":"<pre><code>xexc_and_yexc_or_neither() -&gt; CURVILINEAR\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n    if [self.xexc, self.yexc].count(None) == 1:\n        raise ValueError(\"xexc and yexc must be specified together\")\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n    if self.exception:\n        repr += f\" {self.exception}\"\n    repr += f\" {self.spectrum.render()}\"\n    repr = [repr] + [self.readcoord.render()]\n    return repr\n</code></pre>"},{"location":"components/cgrid/#unstructured-grid","title":"Unstructured Grid","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED","title":"UNSTRUCTURED","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN unstructured computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID UNSTRUCTURED [grid_type] ('fname')\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import UNSTRUCTURED\ncgrid = UNSTRUCTURED(\n    grid_type=\"adcirc\",\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>class UNSTRUCTURED(CGRID):\n    \"\"\"SWAN unstructured computational grid.\n\n    .. code-block:: text\n\n        CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID UNSTRUCTURED [grid_type] ('fname')\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import UNSTRUCTURED\n        cgrid = UNSTRUCTURED(\n            grid_type=\"adcirc\",\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"unstructured\"] = Field(\n        default=\"unstructured\", description=\"Model type discriminator\"\n    )\n    grid_type: Literal[\"adcirc\", \"triangle\", \"easymesh\"] = Field(\n        default=\"adcirc\",\n        description=\"Unstructured grid type\",\n    )\n    fname: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file containing the unstructured grid\",\n        max_length=36,\n    )\n\n    @model_validator(mode=\"after\")\n    def check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n        \"\"\"Check that fname needs to be provided.\"\"\"\n        if self.grid_type == \"adcirc\" and self.fname is not None:\n            raise ValueError(\"fname must not be specified for ADCIRC grid\")\n        elif self.grid_type != \"adcirc\" and self.fname is None:\n            raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n        repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n        if self.grid_type in [\"triangle\", \"easymesh\"]:\n            repr[-1] += f\" fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['unstructured'] = Field(default='unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['adcirc', 'triangle', 'easymesh'] = Field(default='adcirc', description='Unstructured grid type')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: Optional[str] = Field(default=None, description='Name of the file containing the unstructured grid', max_length=36)\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.check_fname_required","title":"check_fname_required","text":"<pre><code>check_fname_required() -&gt; UNSTRUCTURED\n</code></pre> <p>Check that fname needs to be provided.</p> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n    \"\"\"Check that fname needs to be provided.\"\"\"\n    if self.grid_type == \"adcirc\" and self.fname is not None:\n        raise ValueError(\"fname must not be specified for ADCIRC grid\")\n    elif self.grid_type != \"adcirc\" and self.fname is None:\n        raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n    repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n    if self.grid_type in [\"triangle\", \"easymesh\"]:\n        repr[-1] += f\" fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/group/","title":"Group","text":"<p>SWAN group commands</p>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent","title":"BaseGroupComponent","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Base group component.</p> <p>Base class for SWAN group components. This base class modifies the <code>render()</code> method to allow rendering of a list of components. It is not intended to be used directly but to be subclassed by other group components.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class BaseGroupComponent(BaseComponent):\n    \"\"\"Base group component.\n\n    Base class for SWAN group components. This base class modifies the `render()`\n    method to allow rendering of a list of components. It is not intended to be used\n    directly but to be subclassed by other group components.\n\n    \"\"\"\n\n    model_type: Literal[\"group\", \"GROUP\"] = Field(\n        default=\"group\", description=\"Model type discriminator\"\n    )\n\n    def render(self, *args, **kwargs) -&gt; str:\n        \"\"\"Override base class to allow rendering list of components.\"\"\"\n        cmds = []\n        for cmd in self.cmd():\n            cmds.append(super().render(cmd))\n        return \"\\n\\n\".join(cmds)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['group', 'GROUP'] = Field(default='group', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent.render","title":"render","text":"<pre><code>render(*args, **kwargs) -&gt; str\n</code></pre> <p>Override base class to allow rendering list of components.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; str:\n    \"\"\"Override base class to allow rendering list of components.\"\"\"\n    cmds = []\n    for cmd in self.cmd():\n        cmds.append(super().render(cmd))\n    return \"\\n\\n\".join(cmds)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP","title":"STARTUP","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Startup group component.</p> <p>.. code-block:: text</p> <pre><code>PROJECT ...\nSET ...\nMODE ...\nCOORDINATES ...\n</code></pre> <p>This group component is used to group individual startup components. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"components/group/#rompy_swan.components.group.STARTUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.group import STARTUP\nproj = PROJECT(nr=\"01\")\nset = SET(level=0.5, direction_convention=\"nautical\")\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\ncoords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\nstartup = STARTUP(\n    project=proj,\n    set=set,\n    mode=mode,\n    coordinates=coords,\n)\nprint(startup.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class STARTUP(BaseGroupComponent):\n    \"\"\"Startup group component.\n\n    .. code-block:: text\n\n        PROJECT ...\n        SET ...\n        MODE ...\n        COORDINATES ...\n\n    This group component is used to group individual startup components. Only fields\n    that are explicitly prescribed are rendered by this group component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\n        from rompy_swan.components.group import STARTUP\n        proj = PROJECT(nr=\"01\")\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        coords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\n        startup = STARTUP(\n            project=proj,\n            set=set,\n            mode=mode,\n            coordinates=coords,\n        )\n        print(startup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"startup\", \"STARTUP\"] = Field(\n        default=\"startup\", description=\"Model type discriminator\"\n    )\n    project: Optional[PROJECT_TYPE] = Field(default=None)\n    set: Optional[SET_TYPE] = Field(default=None)\n    mode: Optional[MODE_TYPE] = Field(default=None)\n    coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.project is not None:\n            repr += [f\"{self.project.cmd()}\"]\n        if self.set is not None:\n            repr += [f\"{self.set.cmd()}\"]\n        if self.mode is not None:\n            repr += [f\"{self.mode.cmd()}\"]\n        if self.coordinates is not None:\n            repr += [f\"{self.coordinates.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.STARTUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['startup', 'STARTUP'] = Field(default='startup', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.project","title":"project  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project: Optional[PROJECT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.set","title":"set  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set: Optional[SET_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[MODE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.coordinates","title":"coordinates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.STARTUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.project is not None:\n        repr += [f\"{self.project.cmd()}\"]\n    if self.set is not None:\n        repr += [f\"{self.set.cmd()}\"]\n    if self.mode is not None:\n        repr += [f\"{self.mode.cmd()}\"]\n    if self.coordinates is not None:\n        repr += [f\"{self.coordinates.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS","title":"INPGRIDS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>SWAN input grids group component.</p> <p>.. code-block:: text</p> <pre><code>INPGRID ...\nREADGRID ...\n\nINPGRID ...\nREADGRID ...\n\n...\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of input grid components.</p>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR, ICE\nfrom rompy_swan.components.group import INPGRIDS\ninpgrid_bottom = REGULAR(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"bottom.txt\"),\n)\ninpgrid_wind = REGULAR(\n    grid_type=\"wind\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\ninpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\ninpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\nprint(inpgrids.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class INPGRIDS(BaseGroupComponent):\n    \"\"\"SWAN input grids group component.\n\n    .. code-block:: text\n\n        INPGRID ...\n        READGRID ...\n\n        INPGRID ...\n        READGRID ...\n\n        ...\n\n    This group component is a convenience to allow defining and rendering\n    a list of input grid components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import REGULAR, ICE\n        from rompy_swan.components.group import INPGRIDS\n        inpgrid_bottom = REGULAR(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"bottom.txt\"),\n        )\n        inpgrid_wind = REGULAR(\n            grid_type=\"wind\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        inpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\n        inpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\n        print(inpgrids.render())\n\n    \"\"\"\n\n    model_type: Literal[\"inpgrids\"] = Field(\n        default=\"inpgrids\", description=\"Model type discriminator\"\n    )\n    inpgrids: list[INPGRID_TYPE] = Field(\n        min_length=1,\n        description=\"List of input grid components\",\n    )\n\n    @field_validator(\"inpgrids\")\n    @classmethod\n    def ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n        \"\"\"Ensure that each grid type is unique.\"\"\"\n        grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n        if len(grid_types) != len(set(grid_types)):\n            raise ValueError(\"Each grid type must be unique\")\n        return inpgrids\n\n    def cmd(self) -&gt; str | list:\n        repr = []\n        for inpgrid in self.inpgrids:\n            repr += [inpgrid.cmd()]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['inpgrids'] = Field(default='inpgrids', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.inpgrids","title":"inpgrids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inpgrids: list[INPGRID_TYPE] = Field(min_length=1, description='List of input grid components')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.ensure_unique_grid_type","title":"ensure_unique_grid_type  <code>classmethod</code>","text":"<pre><code>ensure_unique_grid_type(inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE\n</code></pre> <p>Ensure that each grid type is unique.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@field_validator(\"inpgrids\")\n@classmethod\ndef ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n    \"\"\"Ensure that each grid type is unique.\"\"\"\n    grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n    if len(grid_types) != len(set(grid_types)):\n        raise ValueError(\"Each grid type must be unique\")\n    return inpgrids\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str | list\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str | list:\n    repr = []\n    for inpgrid in self.inpgrids:\n        repr += [inpgrid.cmd()]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS","title":"PHYSICS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Physics group component.</p> <p>The physics group component is a convenience to allow specifying several individual components in a single command and check for consistency between them.</p>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS--exemples","title":"Exemples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import PHYSICS\ngen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\nphys = PHYSICS(gen=gen)\nprint(phys.render())\nphys = PHYSICS(\n    gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n    negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n    sswell={\"model_type\": \"zieger\"},\n    breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n    friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n)\nprint(phys.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class PHYSICS(BaseGroupComponent):\n    \"\"\"Physics group component.\n\n    The physics group component is a convenience to allow specifying several individual\n    components in a single command and check for consistency between them.\n\n    Exemples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import PHYSICS\n        gen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\n        phys = PHYSICS(gen=gen)\n        print(phys.render())\n        phys = PHYSICS(\n            gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n            negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n            sswell={\"model_type\": \"zieger\"},\n            breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n            friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n        )\n        print(phys.render())\n\n    \"\"\"\n\n    model_type: Literal[\"physics\", \"PHYSICS\"] = Field(\n        default=\"physics\", description=\"Model type discriminator\"\n    )\n    gen: Optional[GEN_TYPE] = Field(default=None)\n    sswell: Optional[SSWELL_TYPE] = Field(default=None)\n    negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n    wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n    quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n    breaking: Optional[BREAKING_TYPE] = Field(default=None)\n    friction: Optional[FRICTION_TYPE] = Field(default=None)\n    triad: Optional[TRIAD_TYPE] = Field(default=None)\n    vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n    mud: Optional[MUD_TYPE] = Field(default=None)\n    sice: Optional[SICE_TYPE] = Field(default=None)\n    turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n    bragg: Optional[BRAGG_TYPE] = Field(default=None)\n    limiter: Optional[LIMITER_TYPE] = Field(default=None)\n    obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n    setup: Optional[SETUP_TYPE] = Field(default=None)\n    diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n    surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n    scat: Optional[SCAT_TYPE] = Field(default=None)\n    deactivate: Optional[OFF_TYPE] = Field(default=None)\n\n    @field_validator(\"deactivate\")\n    @classmethod\n    def deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n        \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n        for phys in PhysicsOff:\n            print(phys.value)\n        return off\n\n    @model_validator(mode=\"after\")\n    def negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n        \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n        if self.negatinp is None:\n            return self\n        elif self.sswell is None:\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n            )\n        elif self.sswell.model_type != \"zieger\":\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n                f\"{self.sswell.model_type.upper()} has been specified.\"\n            )\n        return self\n\n    def cmd(self):\n        repr = []\n        if self.gen is not None:\n            repr += [self.gen.cmd()]\n        if self.sswell is not None:\n            repr += [f\"{self.sswell.cmd()}\"]\n        if self.negatinp is not None:\n            repr += [self.negatinp.cmd()]\n        if self.wcapping is not None:\n            repr += [self.wcapping.cmd()]\n        if self.quadrupl is not None:\n            repr += [self.quadrupl.cmd()]\n        if self.breaking is not None:\n            repr += [self.breaking.cmd()]\n        if self.friction is not None:\n            repr += [self.friction.cmd()]\n        if self.triad is not None:\n            repr += [self.triad.cmd()]\n        if self.vegetation is not None:\n            repr += [self.vegetation.cmd()]\n        if self.mud is not None:\n            repr += [self.mud.cmd()]\n        if self.sice is not None:\n            repr += [self.sice.cmd()]\n        if self.turbulence is not None:\n            repr += [self.turbulence.cmd()]\n        if self.bragg is not None:\n            repr += [self.bragg.cmd()]\n        if self.limiter is not None:\n            repr += [self.limiter.cmd()]\n        if self.obstacle is not None:\n            repr += self.obstacle.cmd()  # Object returns a list of components\n        if self.setup is not None:\n            repr += [self.setup.cmd()]\n        if self.diffraction is not None:\n            repr += [self.diffraction.cmd()]\n        if self.surfbeat is not None:\n            repr += [self.surfbeat.cmd()]\n        if self.scat is not None:\n            repr += [self.scat.cmd()]\n        if self.deactivate is not None:\n            repr += self.deactivate.cmd()  # Object returns a list of components\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.PHYSICS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['physics', 'PHYSICS'] = Field(default='physics', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.gen","title":"gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gen: Optional[GEN_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.sswell","title":"sswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sswell: Optional[SSWELL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.negatinp","title":"negatinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.wcapping","title":"wcapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.quadrupl","title":"quadrupl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.breaking","title":"breaking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>breaking: Optional[BREAKING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>friction: Optional[FRICTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.triad","title":"triad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>triad: Optional[TRIAD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.vegetation","title":"vegetation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.mud","title":"mud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mud: Optional[MUD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.sice","title":"sice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sice: Optional[SICE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.turbulence","title":"turbulence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.bragg","title":"bragg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bragg: Optional[BRAGG_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[LIMITER_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.obstacle","title":"obstacle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.diffraction","title":"diffraction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.surfbeat","title":"surfbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.scat","title":"scat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scat: Optional[SCAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.deactivate","title":"deactivate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deactivate: Optional[OFF_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.PHYSICS.deactivate_physics","title":"deactivate_physics  <code>classmethod</code>","text":"<pre><code>deactivate_physics(off: OFF_TYPE) -&gt; OFF_TYPE\n</code></pre> <p>Convert OFF to OFFS so list is rendered.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@field_validator(\"deactivate\")\n@classmethod\ndef deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n    \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n    for phys in PhysicsOff:\n        print(phys.value)\n    return off\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.negatinp_only_with_zieger","title":"negatinp_only_with_zieger","text":"<pre><code>negatinp_only_with_zieger() -&gt; PHYSICS\n</code></pre> <p>Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n    \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n    if self.negatinp is None:\n        return self\n    elif self.sswell is None:\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n        )\n    elif self.sswell.model_type != \"zieger\":\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n            f\"{self.sswell.model_type.upper()} has been specified.\"\n        )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self):\n    repr = []\n    if self.gen is not None:\n        repr += [self.gen.cmd()]\n    if self.sswell is not None:\n        repr += [f\"{self.sswell.cmd()}\"]\n    if self.negatinp is not None:\n        repr += [self.negatinp.cmd()]\n    if self.wcapping is not None:\n        repr += [self.wcapping.cmd()]\n    if self.quadrupl is not None:\n        repr += [self.quadrupl.cmd()]\n    if self.breaking is not None:\n        repr += [self.breaking.cmd()]\n    if self.friction is not None:\n        repr += [self.friction.cmd()]\n    if self.triad is not None:\n        repr += [self.triad.cmd()]\n    if self.vegetation is not None:\n        repr += [self.vegetation.cmd()]\n    if self.mud is not None:\n        repr += [self.mud.cmd()]\n    if self.sice is not None:\n        repr += [self.sice.cmd()]\n    if self.turbulence is not None:\n        repr += [self.turbulence.cmd()]\n    if self.bragg is not None:\n        repr += [self.bragg.cmd()]\n    if self.limiter is not None:\n        repr += [self.limiter.cmd()]\n    if self.obstacle is not None:\n        repr += self.obstacle.cmd()  # Object returns a list of components\n    if self.setup is not None:\n        repr += [self.setup.cmd()]\n    if self.diffraction is not None:\n        repr += [self.diffraction.cmd()]\n    if self.surfbeat is not None:\n        repr += [self.surfbeat.cmd()]\n    if self.scat is not None:\n        repr += [self.scat.cmd()]\n    if self.deactivate is not None:\n        repr += self.deactivate.cmd()  # Object returns a list of components\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT","title":"OUTPUT","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Output group component.</p> <p>.. code-block:: text</p> <pre><code>FRAME 'sname' ...\nGROUP 'sname' ...\nCURVE 'sname' ...\nRAY 'rname' ...\nISOLINE 'sname' 'rname' ...\nPOINTS 'sname ...\nNGRID 'sname' ...\nQUANTITY ...\nOUTPUT OPTIONS ...\nBLOCK 'sname' ...\nTABLE 'sname' ...\nSPECOUT 'sname' ...\nNESTOUT 'sname ...\n</code></pre> <p>This group component is used to define multiple types of output locations and write components in a single model. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT--note","title":"Note","text":"<p>The components prescribed are validated according to some constraints as defined in the SWAN manual:</p> <ul> <li>The name <code>'sname'</code> of each Locations component must be unique.</li> <li>The Locations <code>'sname'</code> assigned to each write component must be defined.</li> <li>The BLOCK component must be associated with either a <code>FRAME</code> or <code>GROUP</code>.</li> <li>The ISOLINE write component must be associated with a <code>RAY</code> component.</li> <li>The NGRID and NESTOUT components must be defined together.</li> </ul>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\nfrom rompy_swan.components.group import OUTPUT\npoints = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\nquantity = QUANTITIES(\n    quantities=[\n        dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n    ]\n)\ntimes = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\nblock = BLOCK(\n    model_type=\"block\",\n    sname=\"COMPGRID\",\n    fname=\"./swangrid.nc\",\n    output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n    times=times,\n)\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./swantable.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=times,\n)\nout = OUTPUT(\n    points=points,\n    quantity=quantity,\n    block=block,\n    table=table,\n)\nprint(out.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class OUTPUT(BaseGroupComponent):\n    \"\"\"Output group component.\n\n    .. code-block:: text\n\n        FRAME 'sname' ...\n        GROUP 'sname' ...\n        CURVE 'sname' ...\n        RAY 'rname' ...\n        ISOLINE 'sname' 'rname' ...\n        POINTS 'sname ...\n        NGRID 'sname' ...\n        QUANTITY ...\n        OUTPUT OPTIONS ...\n        BLOCK 'sname' ...\n        TABLE 'sname' ...\n        SPECOUT 'sname' ...\n        NESTOUT 'sname ...\n\n    This group component is used to define multiple types of output locations and\n    write components in a single model. Only fields that are explicitly prescribed are\n    rendered by this group component.\n\n    Note\n    ----\n    The components prescribed are validated according to some constraints as defined\n    in the SWAN manual:\n\n    - The name `'sname'` of each Locations component must be unique.\n    - The Locations `'sname'` assigned to each write component must be defined.\n    - The BLOCK component must be associated with either a `FRAME` or `GROUP`.\n    - The ISOLINE write component must be associated with a `RAY` component.\n    - The NGRID and NESTOUT components must be defined together.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\n        from rompy_swan.components.group import OUTPUT\n        points = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n        quantity = QUANTITIES(\n            quantities=[\n                dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n            ]\n        )\n        times = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\n        block = BLOCK(\n            model_type=\"block\",\n            sname=\"COMPGRID\",\n            fname=\"./swangrid.nc\",\n            output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n            times=times,\n        )\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./swantable.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=times,\n        )\n        out = OUTPUT(\n            points=points,\n            quantity=quantity,\n            block=block,\n            table=table,\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"output\", \"OUTPUT\"] = Field(\n        default=\"output\", description=\"Model type discriminator\"\n    )\n    frame: Optional[FRAME_TYPE] = Field(default=None)\n    group: Optional[GROUP_TYPE] = Field(default=None)\n    curve: Optional[CURVE_TYPE] = Field(default=None)\n    ray: Optional[RAY_TYPE] = Field(default=None)\n    isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n    points: Optional[POINTS_TYPE] = Field(default=None)\n    ngrid: Optional[NGRID_TYPE] = Field(default=None)\n    quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n    output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n    block: Optional[BLOCK_TYPE] = Field(default=None)\n    table: Optional[TABLE_TYPE] = Field(default=None)\n    specout: Optional[SPECOUT_TYPE] = Field(default=None)\n    nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n    test: Optional[TEST_TYPE] = Field(default=None)\n    _location_fields: list = [\"frame\", \"group\", \"curve\", \"isoline\", \"points\", \"ngrid\"]\n    _write_fields: list = [\"block\", \"table\", \"specout\", \"nestout\"]\n\n    @model_validator(mode=\"after\")\n    def write_locations_exists(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n        for write in self.write_set:\n            obj = getattr(self, write)\n            if obj is None:\n                continue\n            snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for sname in snames:\n                if sname in SPECIAL_NAMES:\n                    return self\n                try:\n                    self._filter_location(sname)\n                except ValueError as err:\n                    raise ValueError(\n                        f\"Write component '{write}' specified with sname='{sname}' but \"\n                        f\"no location component with sname='{sname}' has been defined\"\n                    ) from err\n        return self\n\n    @model_validator(mode=\"after\")\n    def locations_sname_unique(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n        duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n        if duplicates:\n            raise ValueError(\n                \"The following snames are used to define more than one set of output \"\n                f\"components: {duplicates}, please ensure each location component has \"\n                \"a unique `sname`\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n        if self.block is not None:\n            snames = self.block.sname\n            if isinstance(snames, str):\n                snames = [self.block.sname]\n            for sname in snames:\n                if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                    location = self._filter_location(sname)\n                    component = location.model_type.upper().split(\"_\")[0]\n                    if component not in [\"FRAME\", \"GROUP\"]:\n                        raise ValueError(\n                            f\"Block sname='{sname}' specified with {component} \"\n                            \"location component but only only FRAME or GROUP \"\n                            \"components are supported\"\n                        )\n        return self\n\n    @model_validator(mode=\"after\")\n    def isoline_ray_defined(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the isoline ray has been defined.\"\"\"\n        if self.isoline is not None:\n            if self.ray is None:\n                raise ValueError(\n                    f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                    \" but no RAY component has been defined\"\n                )\n            elif self.ray.rname != self.isoline.rname:\n                raise ValueError(\n                    f\"Isoline rname='{self.isoline.rname}' does not match \"\n                    f\"the ray rname='{self.ray.rname}'\"\n                )\n        return self\n\n    @model_validator(mode=\"after\")\n    def ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n        if self.ngrid is not None and self.nestout is None:\n            raise ValueError(\n                \"NGRID component specified but no NESTOUT component has been defined\"\n            )\n        elif self.ngrid is None and self.nestout is not None:\n            raise ValueError(\n                \"NESTOUT component specified but no NGRID component has been defined\"\n            )\n        elif self.ngrid is not None and self.nestout is not None:\n            if self.ngrid.sname != self.nestout.sname:\n                raise ValueError(\n                    f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                    f\"the NESTOUT sname='{self.nestout.sname}'\"\n                )\n        return self\n\n    @property\n    def locations_set(self):\n        \"\"\"List of specified location fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._location_fields]\n\n    @property\n    def write_set(self):\n        \"\"\"List of specified write fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._write_fields]\n\n    @property\n    def snames(self):\n        \"\"\"List of snames from specified location components.\"\"\"\n        snames = []\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            sname = obj.sname\n            if isinstance(sname, str):\n                sname = [sname]\n            snames.extend(sname)\n        return snames\n\n    def _filter_location(self, sname):\n        \"\"\"Filter the location component defined with the specified sname.\"\"\"\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            obj_snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for obj_sname in obj_snames:\n                if obj_sname == sname:\n                    return obj\n        raise ValueError(f\"Location component with sname='{sname}' not found\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.frame is not None:\n            repr += [f\"{self.frame.cmd()}\"]\n        if self.group is not None:\n            repr += [f\"{self.group.cmd()}\"]\n        if self.curve is not None:\n            # Component renders a list\n            repr += self.curve.cmd()\n        if self.ray is not None:\n            repr += [f\"{self.ray.cmd()}\"]\n        if self.isoline is not None:\n            repr += [f\"{self.isoline.cmd()}\"]\n        if self.points is not None:\n            repr += [f\"{self.points.cmd()}\"]\n        if self.ngrid is not None:\n            repr += [f\"{self.ngrid.cmd()}\"]\n        if self.quantity is not None:\n            # Component renders a list\n            repr += self.quantity.cmd()\n        if self.output_options is not None:\n            repr += [f\"{self.output_options.cmd()}\"]\n        if self.block is not None:\n            # Component may or may not render a list, handles both\n            cmds = self.block.cmd()\n            if not isinstance(cmds, list):\n                cmds = [cmds]\n            for cmd in cmds:\n                repr += [f\"{cmd}\"]\n        if self.table is not None:\n            repr += [f\"{self.table.cmd()}\"]\n        if self.specout is not None:\n            repr += [f\"{self.specout.cmd()}\"]\n        if self.nestout is not None:\n            repr += [f\"{self.nestout.cmd()}\"]\n        if self.test is not None:\n            repr += [f\"{self.test.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.OUTPUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['output', 'OUTPUT'] = Field(default='output', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.frame","title":"frame  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame: Optional[FRAME_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: Optional[GROUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curve: Optional[CURVE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ray","title":"ray  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ray: Optional[RAY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.isoline","title":"isoline  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Optional[POINTS_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ngrid","title":"ngrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ngrid: Optional[NGRID_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.output_options","title":"output_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Optional[BLOCK_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: Optional[TABLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.specout","title":"specout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specout: Optional[SPECOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.nestout","title":"nestout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.test","title":"test  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>test: Optional[TEST_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.locations_set","title":"locations_set  <code>property</code>","text":"<pre><code>locations_set\n</code></pre> <p>List of specified location fields.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.write_set","title":"write_set  <code>property</code>","text":"<pre><code>write_set\n</code></pre> <p>List of specified write fields.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.snames","title":"snames  <code>property</code>","text":"<pre><code>snames\n</code></pre> <p>List of snames from specified location components.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.OUTPUT.write_locations_exists","title":"write_locations_exists","text":"<pre><code>write_locations_exists() -&gt; OUTPUT\n</code></pre> <p>Ensure the location component requested by a write component exists.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef write_locations_exists(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n    for write in self.write_set:\n        obj = getattr(self, write)\n        if obj is None:\n            continue\n        snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n        for sname in snames:\n            if sname in SPECIAL_NAMES:\n                return self\n            try:\n                self._filter_location(sname)\n            except ValueError as err:\n                raise ValueError(\n                    f\"Write component '{write}' specified with sname='{sname}' but \"\n                    f\"no location component with sname='{sname}' has been defined\"\n                ) from err\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.locations_sname_unique","title":"locations_sname_unique","text":"<pre><code>locations_sname_unique() -&gt; OUTPUT\n</code></pre> <p>Ensure same <code>sname</code> isn't used in more than one set of output locations.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef locations_sname_unique(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n    duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n    if duplicates:\n        raise ValueError(\n            \"The following snames are used to define more than one set of output \"\n            f\"components: {duplicates}, please ensure each location component has \"\n            \"a unique `sname`\"\n        )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.block_with_frame_or_group","title":"block_with_frame_or_group","text":"<pre><code>block_with_frame_or_group() -&gt; OUTPUT\n</code></pre> <p>Ensure Block is only defined for FRAME or GROUP locations.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n    if self.block is not None:\n        snames = self.block.sname\n        if isinstance(snames, str):\n            snames = [self.block.sname]\n        for sname in snames:\n            if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                location = self._filter_location(sname)\n                component = location.model_type.upper().split(\"_\")[0]\n                if component not in [\"FRAME\", \"GROUP\"]:\n                    raise ValueError(\n                        f\"Block sname='{sname}' specified with {component} \"\n                        \"location component but only only FRAME or GROUP \"\n                        \"components are supported\"\n                    )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.isoline_ray_defined","title":"isoline_ray_defined","text":"<pre><code>isoline_ray_defined() -&gt; OUTPUT\n</code></pre> <p>Ensure the isoline ray has been defined.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef isoline_ray_defined(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the isoline ray has been defined.\"\"\"\n    if self.isoline is not None:\n        if self.ray is None:\n            raise ValueError(\n                f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                \" but no RAY component has been defined\"\n            )\n        elif self.ray.rname != self.isoline.rname:\n            raise ValueError(\n                f\"Isoline rname='{self.isoline.rname}' does not match \"\n                f\"the ray rname='{self.ray.rname}'\"\n            )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ngrid_and_nestout","title":"ngrid_and_nestout","text":"<pre><code>ngrid_and_nestout() -&gt; OUTPUT\n</code></pre> <p>Ensure NGRID and NESTOUT are specified together.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n    if self.ngrid is not None and self.nestout is None:\n        raise ValueError(\n            \"NGRID component specified but no NESTOUT component has been defined\"\n        )\n    elif self.ngrid is None and self.nestout is not None:\n        raise ValueError(\n            \"NESTOUT component specified but no NGRID component has been defined\"\n        )\n    elif self.ngrid is not None and self.nestout is not None:\n        if self.ngrid.sname != self.nestout.sname:\n            raise ValueError(\n                f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                f\"the NESTOUT sname='{self.nestout.sname}'\"\n            )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.frame is not None:\n        repr += [f\"{self.frame.cmd()}\"]\n    if self.group is not None:\n        repr += [f\"{self.group.cmd()}\"]\n    if self.curve is not None:\n        # Component renders a list\n        repr += self.curve.cmd()\n    if self.ray is not None:\n        repr += [f\"{self.ray.cmd()}\"]\n    if self.isoline is not None:\n        repr += [f\"{self.isoline.cmd()}\"]\n    if self.points is not None:\n        repr += [f\"{self.points.cmd()}\"]\n    if self.ngrid is not None:\n        repr += [f\"{self.ngrid.cmd()}\"]\n    if self.quantity is not None:\n        # Component renders a list\n        repr += self.quantity.cmd()\n    if self.output_options is not None:\n        repr += [f\"{self.output_options.cmd()}\"]\n    if self.block is not None:\n        # Component may or may not render a list, handles both\n        cmds = self.block.cmd()\n        if not isinstance(cmds, list):\n            cmds = [cmds]\n        for cmd in cmds:\n            repr += [f\"{cmd}\"]\n    if self.table is not None:\n        repr += [f\"{self.table.cmd()}\"]\n    if self.specout is not None:\n        repr += [f\"{self.specout.cmd()}\"]\n    if self.nestout is not None:\n        repr += [f\"{self.nestout.cmd()}\"]\n    if self.test is not None:\n        repr += [f\"{self.test.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP","title":"LOCKUP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Lockup group component.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE ...\nHOTFILE ...\nCOMPUTE ...\nHOTFILE ...\n...\nSTOP\n</code></pre> <p>This is a group component to specify SWAN \"Lockup\" commands including multiple <code>COMPUTE</code> commands that may or may not be interleaved with <code>HOTFILE</code> commands, and a final <code>STOP</code> command.</p>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import LOCKUP\nlockup = LOCKUP(\n    compute=dict(\n        model_type=\"stat\",\n        times=dict(\n            model_type=\"nonstationary\",\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-01-01T03:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        ),\n        hotfile=dict(fname=\"hotfile\"),\n        hottimes=[-1],\n    ),\n)\nprint(lockup.render())\n</code></pre> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>class LOCKUP(BaseComponent):\n    \"\"\"Lockup group component.\n\n    .. code-block:: text\n\n        COMPUTE ...\n        HOTFILE ...\n        COMPUTE ...\n        HOTFILE ...\n        ...\n        STOP\n\n    This is a group component to specify SWAN \"Lockup\" commands including multiple\n    `COMPUTE` commands that may or may not be interleaved with `HOTFILE` commands,\n    and a final `STOP` command.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import LOCKUP\n        lockup = LOCKUP(\n            compute=dict(\n                model_type=\"stat\",\n                times=dict(\n                    model_type=\"nonstationary\",\n                    tbeg=\"1990-01-01T00:00:00\",\n                    tend=\"1990-01-01T03:00:00\",\n                    delt=\"PT1H\",\n                    dfmt=\"hr\",\n                ),\n                hotfile=dict(fname=\"hotfile\"),\n                hottimes=[-1],\n            ),\n        )\n        print(lockup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"lockup\", \"LOCKUP\"] = Field(\n        default=\"lockup\", description=\"Model type discriminator\"\n    )\n    compute: COMPUTE_TYPE = Field(description=\"Compute components\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.LOCKUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lockup', 'LOCKUP'] = Field(default='lockup', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP.compute","title":"compute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compute: COMPUTE_TYPE = Field(description='Compute components')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.LOCKUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>src/rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"components/inpgrid/","title":"Input Grids","text":"<p>Input grids (INPGRID) define the spatial grids for external forcing data such as bathymetry, wind, currents, water level, and friction. Each input grid can have different resolution and extent from the computational grid.</p> <p>Input Grid Types</p> <ul> <li>BOTTOM \u2014 Bathymetry (water depth)</li> <li>WIND \u2014 Wind velocity components</li> <li>CURRENT \u2014 Current velocity components</li> <li>WLEVEL \u2014 Water level variations</li> <li>FRICTION \u2014 Spatially varying bottom friction</li> <li>ICE \u2014 Sea ice coverage</li> </ul>"},{"location":"components/inpgrid/#grid-types","title":"Grid Types","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR","title":"REGULAR","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN regular input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] REGULAR [xpinp] [ypinp] [alpinp] [mxinp] [myinp] &amp;\n    [dxinp] [dyinp] (EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR\ninpgrid = REGULAR(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"bottom.txt\"),\n)\nprint(inpgrid.render())\ninpgrid = REGULAR(\n    grid_type=\"wind\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> <p>TODO: Use grid object, requires different grid parameters to be allowed.</p> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>class REGULAR(INPGRID):\n    \"\"\"SWAN regular input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] REGULAR [xpinp] [ypinp] [alpinp] [mxinp] [myinp] &amp;\n            [dxinp] [dyinp] (EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import REGULAR\n        inpgrid = REGULAR(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"bottom.txt\"),\n        )\n        print(inpgrid.render())\n        inpgrid = REGULAR(\n            grid_type=\"wind\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    TODO: Use grid object, requires different grid parameters to be allowed.\n\n    \"\"\"\n\n    model_type: Literal[\"regular\", \"REGULAR\"] = Field(\n        default=\"regular\",\n        description=\"Model type discriminator\",\n    )\n    xpinp: float = Field(\n        description=(\n            \"Geographic location (x-coordinate) of the origin of the input grid in \"\n            \"problem coordinates (in m) if Cartesian coordinates are used or in \"\n            \"degrees if spherical coordinates are used. In case of spherical \"\n            \"coordinates there is no default\"\n        ),\n    )\n    ypinp: float = Field(\n        description=(\n            \"Geographic location (y-coordinate) of the origin of the input grid in \"\n            \"problem coordinates (in m) if Cartesian coordinates are used or in \"\n            \"degrees if spherical coordinates are used. In case of spherical \"\n            \"coordinates there is no default\"\n        ),\n    )\n    alpinp: Optional[float] = Field(\n        default=0.0,\n        description=(\n            \"Direction of the positive x-axis of the input grid \"\n            \"(in degrees, Cartesian convention)\"\n        ),\n    )\n    mxinp: int = Field(\n        description=(\n            \"Number of meshes in x-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n    myinp: int = Field(\n        description=(\n            \"Number of meshes in y-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction). In 1D-mode, \"\n            \"`myinp` should be 0\"\n        ),\n    )\n    dxinp: float = Field(\n        description=(\n            \"Mesh size in x-direction of the input grid, in m in case of Cartesian \"\n            \"coordinates or in degrees if spherical coordinates are used\"\n        ),\n    )\n    dyinp: float = Field(\n        description=(\n            \"Mesh size in y-direction of the input grid, in m in case of Cartesian \"\n            \"coordinates or in degrees if spherical coordinates are used. \"\n            \"In 1D-mode, `dyinp` may have any value\"\n        ),\n    )\n\n    def cmd(self) -&gt; list:\n        repr = (\n            f\"{super().cmd()} REGULAR xpinp={self.xpinp} ypinp={self.ypinp} \"\n            f\"alpinp={self.alpinp} mxinp={self.mxinp} myinp={self.myinp} \"\n            f\"dxinp={self.dxinp} dyinp={self.dyinp}\"\n        )\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['regular', 'REGULAR'] = Field(default='regular', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.xpinp","title":"xpinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xpinp: float = Field(description='Geographic location (x-coordinate) of the origin of the input grid in problem coordinates (in m) if Cartesian coordinates are used or in degrees if spherical coordinates are used. In case of spherical coordinates there is no default')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.ypinp","title":"ypinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ypinp: float = Field(description='Geographic location (y-coordinate) of the origin of the input grid in problem coordinates (in m) if Cartesian coordinates are used or in degrees if spherical coordinates are used. In case of spherical coordinates there is no default')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.alpinp","title":"alpinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpinp: Optional[float] = Field(default=0.0, description='Direction of the positive x-axis of the input grid (in degrees, Cartesian convention)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.mxinp","title":"mxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxinp: int = Field(description='Number of meshes in x-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.myinp","title":"myinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myinp: int = Field(description='Number of meshes in y-direction of the input grid (this number is one less than the number of grid points in this direction). In 1D-mode, `myinp` should be 0')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.dxinp","title":"dxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dxinp: float = Field(description='Mesh size in x-direction of the input grid, in m in case of Cartesian coordinates or in degrees if spherical coordinates are used')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.dyinp","title":"dyinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dyinp: float = Field(description='Mesh size in y-direction of the input grid, in m in case of Cartesian coordinates or in degrees if spherical coordinates are used. In 1D-mode, `dyinp` may have any value')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = (\n        f\"{super().cmd()} REGULAR xpinp={self.xpinp} ypinp={self.ypinp} \"\n        f\"alpinp={self.alpinp} mxinp={self.mxinp} myinp={self.myinp} \"\n        f\"dxinp={self.dxinp} dyinp={self.dyinp}\"\n    )\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR","title":"CURVILINEAR","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN curvilinear input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] CURVILINEAR [stagrx] [stagry] [mxinp] [myinp] &amp;\n    (EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import CURVILINEAR\ninpgrid = CURVILINEAR(\n    grid_type=\"wind\",\n    stagrx=0.0,\n    stagry=0.0,\n    mxinp=199,\n    myinp=199,\n    excval=-99.0,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> <p>TODO: Handle (or not) setting default values for mxinp and myinp from cgrid.</p> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>class CURVILINEAR(INPGRID):\n    \"\"\"SWAN curvilinear input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] CURVILINEAR [stagrx] [stagry] [mxinp] [myinp] &amp;\n            (EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import CURVILINEAR\n        inpgrid = CURVILINEAR(\n            grid_type=\"wind\",\n            stagrx=0.0,\n            stagry=0.0,\n            mxinp=199,\n            myinp=199,\n            excval=-99.0,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    TODO: Handle (or not) setting default values for mxinp and myinp from cgrid.\n\n    \"\"\"\n\n    model_type: Literal[\"curvilinear\", \"CURVILINEAR\"] = Field(\n        default=\"curvilinear\", description=\"Model type discriminator\"\n    )\n    stagrx: float = Field(\n        default=0.0,\n        description=(\n            \"Staggered x'-direction with respect to computational grid, e.g., \"\n            \"`stagrx=0.5` means that the input grid points are shifted a half step \"\n            \"in x'-direction; in many flow models x-velocities are defined in points \"\n            \"shifted a half step in x'-direction\"\n        ),\n    )\n    stagry: float = Field(\n        default=0.0,\n        description=(\n            \"Staggered y'-direction with respect to computational grid, e.g., \"\n            \"`stagry=0.5` means that the input grid points are shifted a half step \"\n            \"in y'-direction; in many flow models y-velocities are defined in points \"\n            \"shifted a half step in y'-direction\"\n        ),\n    )\n    mxinp: int = Field(\n        description=(\n            \"Number of meshes in \u03be-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n    myinp: int = Field(\n        description=(\n            \"Number of meshes in \u03b7-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"{super().cmd()} CURVILINEAR stagrx={self.stagrx} \"\n            f\"stagry={self.stagry} mxinp={self.mxinp} myinp={self.myinp} \"\n        )\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curvilinear', 'CURVILINEAR'] = Field(default='curvilinear', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.stagrx","title":"stagrx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stagrx: float = Field(default=0.0, description=\"Staggered x'-direction with respect to computational grid, e.g., `stagrx=0.5` means that the input grid points are shifted a half step in x'-direction; in many flow models x-velocities are defined in points shifted a half step in x'-direction\")\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.stagry","title":"stagry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stagry: float = Field(default=0.0, description=\"Staggered y'-direction with respect to computational grid, e.g., `stagry=0.5` means that the input grid points are shifted a half step in y'-direction; in many flow models y-velocities are defined in points shifted a half step in y'-direction\")\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.mxinp","title":"mxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxinp: int = Field(description='Number of meshes in \u03be-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.myinp","title":"myinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myinp: int = Field(description='Number of meshes in \u03b7-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"{super().cmd()} CURVILINEAR stagrx={self.stagrx} \"\n        f\"stagry={self.stagry} mxinp={self.mxinp} myinp={self.myinp} \"\n    )\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED","title":"UNSTRUCTURED","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN unstructured input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] UNSTRUCTURED EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import UNSTRUCTURED\ninpgrid = UNSTRUCTURED(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    readinp=dict(fname1=\"bottom.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>class UNSTRUCTURED(INPGRID):\n    \"\"\"SWAN unstructured input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] UNSTRUCTURED EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import UNSTRUCTURED\n        inpgrid = UNSTRUCTURED(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            readinp=dict(fname1=\"bottom.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"unstructured\", \"UNSTRUCTURED\"] = Field(\n        default=\"unstructured\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"{super().cmd()} UNSTRUCTURED\"\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['unstructured', 'UNSTRUCTURED'] = Field(default='unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"{super().cmd()} UNSTRUCTURED\"\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#specialized-grids","title":"Specialized Grids","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND","title":"WIND","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wind input field.</p> <p>.. code-block:: text</p> <pre><code>WIND [vel] [dir]\n</code></pre> <p>With this optional command, the user indicates that the wind field is constant.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import WIND\nwind = WIND(vel=10.0, dir=270.0)\nprint(wind.render())\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>class WIND(BaseComponent):\n    \"\"\"Constant wind input field.\n\n    .. code-block:: text\n\n        WIND [vel] [dir]\n\n    With this optional command, the user indicates that the wind field is constant.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import WIND\n        wind = WIND(vel=10.0, dir=270.0)\n        print(wind.render())\n\n    \"\"\"\n\n    model_type: Literal[\"wind\", \"WIND\"] = Field(\n        default=\"wind\", description=\"Model type discriminator\"\n    )\n    vel: float = Field(description=\"Wind velocity at 10 m elevation (m/s)\", ge=0.0)\n    dir: float = Field(\n        description=(\n            \"Wind direction at 10 m elevation (in degrees, Cartesian or Nautical \"\n            \"convention, see command SET)\"\n        ),\n        ge=-180.0,\n        le=360.0,\n    )\n\n    def cmd(self):\n        return f\"WIND vel={self.vel} dir={self.dir}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['wind', 'WIND'] = Field(default='wind', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.vel","title":"vel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vel: float = Field(description='Wind velocity at 10 m elevation (m/s)', ge=0.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: float = Field(description='Wind direction at 10 m elevation (in degrees, Cartesian or Nautical convention, see command SET)', ge=-180.0, le=360.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self):\n    return f\"WIND vel={self.vel} dir={self.dir}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE","title":"ICE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wind input field.</p> <p>.. code-block:: text</p> <pre><code>ICE [aice] [hice]\n</code></pre> <p>With this optional command, the user indicates that one or more ice fields are constant.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import ICE\nice = ICE(aice=0.1, hice=0.1)\nprint(ice.render())\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>class ICE(BaseComponent):\n    \"\"\"Constant wind input field.\n\n    .. code-block:: text\n\n        ICE [aice] [hice]\n\n    With this optional command, the user indicates that one or more ice fields are\n    constant.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import ICE\n        ice = ICE(aice=0.1, hice=0.1)\n        print(ice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ice\", \"ICE\"] = Field(\n        default=\"ice\", description=\"Model type discriminator\"\n    )\n    aice: float = Field(\n        description=\"Areal ice fraction, a number from 0 to 1\", ge=0.0, le=1.0\n    )\n    hice: float = Field(description=\"Ice thickness (m)\", ge=0.0)\n\n    def cmd(self):\n        return f\"ICE aice={self.aice} hice={self.hice}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ice', 'ICE'] = Field(default='ice', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.aice","title":"aice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aice: float = Field(description='Areal ice fraction, a number from 0 to 1', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.hice","title":"hice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hice: float = Field(description='Ice thickness (m)', ge=0.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>src/rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self):\n    return f\"ICE aice={self.aice} hice={self.hice}\"\n</code></pre>"},{"location":"components/lockup/","title":"Lock-up","text":"<p>Lock-up commands control the execution of SWAN calculations. They must appear at the end of the input file after all other commands.</p> <p>Required Commands</p> <p>Every SWAN input file must end with a <code>COMPUTE</code> command (to start the calculation) and a <code>STOP</code> command (to terminate SWAN).</p> <p>Time Control for COMPUTE Components</p> <p>When using the rompy API, COMPUTE commands have their time values (<code>tbeg</code>, <code>tend</code>, <code>delt</code>) set from the <code>ModelRun.period</code> runtime parameter. However, you can override the time and interval formatting (<code>tfmt</code>, <code>dfmt</code>) by specifying a <code>times</code> field in the component. The actual computational timestep (<code>deltc</code>) is always determined by the runtime interval.</p> <p>Example: <pre><code>compute=dict(\n    model_type=\"nonstat\",\n    times=dict(\n        tfmt=2,      # HP compiler format: '01-Jan-24 00:00:00'\n        dfmt=\"min\",  # Minutes format\n    ),\n)\n</code></pre></p> <p>See the Configuration Guide for more details.</p>"},{"location":"components/lockup/#compute","title":"COMPUTE","text":"<p>Starts the wave computation. For non-stationary runs, specifies the time stepping.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE","title":"COMPUTE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Start SWAN computation.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE STATIONARY|NONSTATIONARY\n</code></pre> <p>If the SWAN mode is stationary (see command <code>MODE</code>), then only the command <code>COMPUTE</code> should be given here.</p> <p>If the SWAN mode is nonstationary (see command <code>MODE</code>), then the computation can be:</p> <ul> <li>stationary (at the specified time: option STATIONARY here).</li> <li>nonstationary (over the specified period of time.</li> </ul> <p>To verify input to SWAN (e.g., all input fields such as water depth, wind fields, etc), SWAN can be run without computations (that is: zero iterations by using command <code>NUM ACCUR MXITST=0</code>).</p> <p>In the case <code>MODE NONSTATIONARY</code> several commands COMPUTE can appear, where the wave state at the end of one computation is used as initial state for the next one, unless a command <code>INIT</code> appears in between the two COMPUTE commands. This enables the user to make a stationary computation to obtain the initial state for a nonstationary computation and/or to change the computational time step during a computation, to change a boundary condition etc. This also has the advantage of not using a hotfile since, it can be very large in size.</p> <p>For small domains, i.e. less than 100 km or 1 deg, a stationary computation is recommended. Otherwise, a nonstationary computation is advised.</p> <p>For a nonstationary computation, a time step of at most 10 minutes is advised (when you are choosing a time step larger than 10 minutes, the action density limiter (see command <code>NUM</code>) becomes probably a part of the physics).</p> <p>Also, the time step should be chosen such that the Courant number is smaller than 10 for the fastest (or dominant) wave. Otherwise, a first order upwind scheme is recommended in that case; see command <code>PROP BSBT</code>. If you want to run a high resolution model with a very large time step, e.g. 1 hour, you may apply multiple COMPUT STAT commands. For a small time step (&lt;= 10 minutes), no more than 1 iteration per time step is recommended (see command <code>NUM ... NONSTAT mxitns</code>).</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import COMPUTE\ncomp = COMPUTE()\nprint(comp.render())\ncomp = COMPUTE(\n    times=dict(model_type=\"stationary\", time=\"1990-01-01T00:00:00\", tfmt=2)\n)\nprint(comp.render())\ncomp = COMPUTE(\n    times=dict(\n        model_type=\"nonstationary\",\n        tbeg=\"1990-01-01T00:00:00\",\n        tend=\"1990-02-01T00:00:00\",\n        delt=\"PT1H\",\n        tfmt=1,\n        dfmt=\"hr\",\n    ),\n)\nprint(comp.render())\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE(BaseComponent):\n    \"\"\"Start SWAN computation.\n\n    .. code-block:: text\n\n        COMPUTE STATIONARY|NONSTATIONARY\n\n    If the SWAN mode is stationary (see command `MODE`), then only the command\n    `COMPUTE` should be given here.\n\n    If the SWAN mode is nonstationary (see command `MODE`), then the computation can\n    be:\n\n    * stationary (at the specified time: option STATIONARY here).\n    * nonstationary (over the specified period of time.\n\n    To verify input to SWAN (e.g., all input fields such as water depth, wind fields,\n    etc), SWAN can be run without computations (that is: zero iterations by using\n    command `NUM ACCUR MXITST=0`).\n\n    In the case `MODE NONSTATIONARY` several commands COMPUTE can appear, where the\n    wave state at the end of one computation is used as initial state for the next one,\n    unless a command `INIT` appears in between the two COMPUTE commands. This enables\n    the user to make a stationary computation to obtain the initial state for a\n    nonstationary computation and/or to change the computational time step during a\n    computation, to change a boundary condition etc. This also has the advantage of not\n    using a hotfile since, it can be very large in size.\n\n    For small domains, i.e. less than 100 km or 1 deg, a stationary computation is\n    recommended. Otherwise, a nonstationary computation is advised.\n\n    For a nonstationary computation, a time step of at most 10 minutes is advised (when\n    you are choosing a time step larger than 10 minutes, the action density limiter\n    (see command `NUM`) becomes probably a part of the physics).\n\n    Also, the time step should be chosen such that the Courant number is smaller than\n    10 for the fastest (or dominant) wave. Otherwise, a first order upwind scheme is\n    recommended in that case; see command `PROP BSBT`. If you want to run a high\n    resolution model with a very large time step, e.g. 1 hour, you may apply multiple\n    COMPUT STAT commands. For a small time step (&lt;= 10 minutes), no more than 1\n    iteration per time step is recommended (see command `NUM ... NONSTAT mxitns`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import COMPUTE\n        comp = COMPUTE()\n        print(comp.render())\n        comp = COMPUTE(\n            times=dict(model_type=\"stationary\", time=\"1990-01-01T00:00:00\", tfmt=2)\n        )\n        print(comp.render())\n        comp = COMPUTE(\n            times=dict(\n                model_type=\"nonstationary\",\n                tbeg=\"1990-01-01T00:00:00\",\n                tend=\"1990-02-01T00:00:00\",\n                delt=\"PT1H\",\n                tfmt=1,\n                dfmt=\"hr\",\n            ),\n        )\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"compute\", \"COMPUTE\"] = Field(\n        default=\"compute\", description=\"Model type discriminator\"\n    )\n    times: Optional[TIMES_TYPE] = Field(\n        default=None,\n        description=\"Times for the stationary or nonstationary computation\",\n        discriminator=\"model_type\",\n    )\n    i0: Optional[int] = Field(\n        default=None,\n        description=\"Time index of the initial time step\",\n    )\n    i1: Optional[int] = Field(\n        default=None,\n        description=\"Time index of the final time step\",\n    )\n\n    @field_validator(\"times\")\n    @classmethod\n    def times_suffix(cls, times: TIMES_TYPE) -&gt; TIMES_TYPE:\n        if isinstance(times, NONSTATIONARY):\n            times.suffix = \"c\"\n        return times\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"COMPUTE\"\n        if self.times is not None:\n            repr += f\" {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['compute', 'COMPUTE'] = Field(default='compute', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: Optional[TIMES_TYPE] = Field(default=None, description='Times for the stationary or nonstationary computation', discriminator='model_type')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.i0","title":"i0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i0: Optional[int] = Field(default=None, description='Time index of the initial time step')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.i1","title":"i1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i1: Optional[int] = Field(default=None, description='Time index of the final time step')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.times_suffix","title":"times_suffix  <code>classmethod</code>","text":"<pre><code>times_suffix(times: TIMES_TYPE) -&gt; TIMES_TYPE\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"times\")\n@classmethod\ndef times_suffix(cls, times: TIMES_TYPE) -&gt; TIMES_TYPE:\n    if isinstance(times, NONSTATIONARY):\n        times.suffix = \"c\"\n    return times\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"COMPUTE\"\n    if self.times is not None:\n        repr += f\" {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT","title":"COMPUTE_STAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Multiple SWAN stationary computations.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE STATIONARY [time]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\nCOMPUTE STATIONARY [time]\nCOMPUTE STATIONARY [time]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\n.\n.\n</code></pre> <p>This component can be used to define multiple stationary compute commands and write intermediate results as hotfiles between then.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT--note","title":"Note","text":"<p>The field <code>times</code> is optional to allow for the case where the user wants to set times dynamically after instantiating this component.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import STATIONARY, NONSTATIONARY\nfrom rompy_swan.components.lockup import COMPUTE_STAT\ntime = STATIONARY(time=\"1990-01-01T00:00:00\")\ncomp = COMPUTE_STAT(times=time)\nprint(comp.render())\ntimes = NONSTATIONARY(\n    tbeg=\"1990-01-01T00:00:00\",\n    tend=\"1990-01-01T03:00:00\",\n    delt=\"PT1H\",\n)\ncomp = COMPUTE_STAT(times=times)\nprint(comp.render())\nhotfile = dict(fname=\"./hotfile.swn\")\nhottimes=[\"1990-01-01T03:00:00\"]\ncomp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=hottimes)\nprint(comp.render())\ncomp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=[2, -1])\nprint(comp.render())\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE_STAT(BaseComponent):\n    \"\"\"Multiple SWAN stationary computations.\n\n    .. code-block:: text\n\n        COMPUTE STATIONARY [time]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        COMPUTE STATIONARY [time]\n        COMPUTE STATIONARY [time]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        .\n        .\n\n    This component can be used to define multiple stationary compute commands and\n    write intermediate results as hotfiles between then.\n\n    Note\n    ----\n    The field `times` is optional to allow for the case where the user wants to set\n    times dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import STATIONARY, NONSTATIONARY\n        from rompy_swan.components.lockup import COMPUTE_STAT\n        time = STATIONARY(time=\"1990-01-01T00:00:00\")\n        comp = COMPUTE_STAT(times=time)\n        print(comp.render())\n        times = NONSTATIONARY(\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-01-01T03:00:00\",\n            delt=\"PT1H\",\n        )\n        comp = COMPUTE_STAT(times=times)\n        print(comp.render())\n        hotfile = dict(fname=\"./hotfile.swn\")\n        hottimes=[\"1990-01-01T03:00:00\"]\n        comp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=hottimes)\n        print(comp.render())\n        comp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=[2, -1])\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stat\", \"STAT\"] = Field(\n        default=\"stat\", description=\"Model type discriminator\"\n    )\n    times: TIMES_TYPE = Field(\n        default_factory=STATIONARY,\n        description=\"Compute times\",\n        discriminator=\"model_type\",\n    )\n    hotfile: Optional[HOTFILE] = Field(\n        default=None,\n        description=\"Write results to restart files\",\n    )\n    hottimes: HOTTIMES_TYPE = Field(\n        default=[],\n        description=(\n            \"Times to write hotfiles, can be a list of datetimes or times indices\"\n        ),\n    )\n    suffix: str = Field(\n        default=\"_%Y%m%dT%H%M%S\",\n        description=(\"Time-template suffix to add to hotfile fname\"),\n    )\n\n    @field_validator(\"hottimes\")\n    @classmethod\n    def timestamp_to_datetime(cls, hottimes: TIMES_TYPE) -&gt; TIMES_TYPE:\n        \"\"\"Ensure pandas.Timestamp entries are coerced into datatime.\"\"\"\n        if hottimes and isinstance(hottimes[0], Timestamp):\n            hottimes = [t.to_pydatetime() for t in hottimes]\n        return hottimes\n\n    @model_validator(mode=\"after\")\n    def hotfile_with_hottimes(self) -&gt; \"COMPUTE_NONSTAT\":\n        if self.hottimes and self.hotfile is None:\n            logger.warning(\"hotfile not specified, hottimes will be ignored\")\n        elif self.hotfile is not None and not self.hottimes:\n            logger.warning(\"hottimes not specified, hotfile will be ignored\")\n        return self\n\n    @property\n    def hotids(self) -&gt; list:\n        \"\"\"List time ids at which to write hotfiles.\"\"\"\n        if self.hottimes and isinstance(self.hottimes[0], datetime):\n            ids = []\n            for t in self.hottimes:\n                try:\n                    ids.append(self.times().index(t))\n                except ValueError as e:\n                    raise ValueError(f\"hottime {t} not in times {self.times}\") from e\n        else:\n            ids = [i if i &gt;= 0 else i + len(self.times) for i in self.hottimes]\n            for i in ids:\n                if i &gt;= len(self.times):\n                    raise ValueError(\n                        f\"Hotfile requested for time {i} but times have \"\n                        f\"only {len(self.times)} values: {self.times} \"\n                    )\n        return ids\n\n    def _hotfile(self, time):\n        \"\"\"Set timestamp to hotfile fname.\"\"\"\n        timestamp = time.strftime(self.suffix)\n        fname = self.hotfile.fname.parent / (\n            f\"{self.hotfile.fname.stem}{timestamp}\" f\"{self.hotfile.fname.suffix}\"\n        )\n        return HOTFILE(fname=fname, format=self.hotfile.format)\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        for ind, time in enumerate(self.times()):\n            repr += [f\"COMPUTE {STATIONARY(time=time, tfmt=self.times.tfmt).render()}\"]\n            if ind in self.hotids and self.hotfile is not None:\n                repr += [f\"{self._hotfile(time).render()}\"]\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stat', 'STAT'] = Field(default='stat', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: TIMES_TYPE = Field(default_factory=STATIONARY, description='Compute times', discriminator='model_type')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotfile","title":"hotfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hotfile: Optional[HOTFILE] = Field(default=None, description='Write results to restart files')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hottimes","title":"hottimes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hottimes: HOTTIMES_TYPE = Field(default=[], description='Times to write hotfiles, can be a list of datetimes or times indices')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: str = Field(default='_%Y%m%dT%H%M%S', description='Time-template suffix to add to hotfile fname')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotids","title":"hotids  <code>property</code>","text":"<pre><code>hotids: list\n</code></pre> <p>List time ids at which to write hotfiles.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.timestamp_to_datetime","title":"timestamp_to_datetime  <code>classmethod</code>","text":"<pre><code>timestamp_to_datetime(hottimes: TIMES_TYPE) -&gt; TIMES_TYPE\n</code></pre> <p>Ensure pandas.Timestamp entries are coerced into datatime.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"hottimes\")\n@classmethod\ndef timestamp_to_datetime(cls, hottimes: TIMES_TYPE) -&gt; TIMES_TYPE:\n    \"\"\"Ensure pandas.Timestamp entries are coerced into datatime.\"\"\"\n    if hottimes and isinstance(hottimes[0], Timestamp):\n        hottimes = [t.to_pydatetime() for t in hottimes]\n    return hottimes\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotfile_with_hottimes","title":"hotfile_with_hottimes","text":"<pre><code>hotfile_with_hottimes() -&gt; COMPUTE_NONSTAT\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>@model_validator(mode=\"after\")\ndef hotfile_with_hottimes(self) -&gt; \"COMPUTE_NONSTAT\":\n    if self.hottimes and self.hotfile is None:\n        logger.warning(\"hotfile not specified, hottimes will be ignored\")\n    elif self.hotfile is not None and not self.hottimes:\n        logger.warning(\"hottimes not specified, hotfile will be ignored\")\n    return self\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    for ind, time in enumerate(self.times()):\n        repr += [f\"COMPUTE {STATIONARY(time=time, tfmt=self.times.tfmt).render()}\"]\n        if ind in self.hotids and self.hotfile is not None:\n            repr += [f\"{self._hotfile(time).render()}\"]\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT","title":"COMPUTE_NONSTAT","text":"<p>               Bases: <code>COMPUTE_STAT</code></p> <p>Multiple SWAN nonstationary computations.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\nCOMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\n.\n.\n</code></pre> <p>This component can be used to define multiple nonstationary compute commands and write intermediate results as hotfiles between then.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT--note","title":"Note","text":"<p>The field <code>times</code> is optional to allow for the case where the user wants to set times dynamically after instantiating this component.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import NONSTATIONARY\nfrom rompy_swan.components.lockup import COMPUTE_NONSTAT\ntimes = NONSTATIONARY(\n    tbeg=\"1990-01-01T00:00:00\",\n    tend=\"1990-02-01T00:00:00\",\n    delt=\"PT1H\",\n    dfmt=\"hr\",\n)\ncomp = COMPUTE_NONSTAT(times=times)\nprint(comp.render())\ncomp = COMPUTE_NONSTAT(\n    times=times,\n    hotfile=dict(fname=\"hotfile.swn\", format=\"free\"),\n    hottimes=[\"1990-02-01T00:00:00\"],\n)\nprint(comp.render())\ncomp = COMPUTE_NONSTAT(\n    times=times,\n    initstat=True,\n    hotfile=dict(fname=\"hotfile\", format=\"free\"),\n    hottimes=[6, 12, 18, -1],\n)\nprint(comp.render())\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE_NONSTAT(COMPUTE_STAT):\n    \"\"\"Multiple SWAN nonstationary computations.\n\n    .. code-block:: text\n\n        COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        .\n        .\n\n    This component can be used to define multiple nonstationary compute commands and\n    write intermediate results as hotfiles between then.\n\n    Note\n    ----\n    The field `times` is optional to allow for the case where the user wants to set\n    times dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import NONSTATIONARY\n        from rompy_swan.components.lockup import COMPUTE_NONSTAT\n        times = NONSTATIONARY(\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-02-01T00:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        )\n        comp = COMPUTE_NONSTAT(times=times)\n        print(comp.render())\n        comp = COMPUTE_NONSTAT(\n            times=times,\n            hotfile=dict(fname=\"hotfile.swn\", format=\"free\"),\n            hottimes=[\"1990-02-01T00:00:00\"],\n        )\n        print(comp.render())\n        comp = COMPUTE_NONSTAT(\n            times=times,\n            initstat=True,\n            hotfile=dict(fname=\"hotfile\", format=\"free\"),\n            hottimes=[6, 12, 18, -1],\n        )\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nonstat\", \"NONSTAT\"] = Field(\n        default=\"nonstat\", description=\"Model type discriminator\"\n    )\n    times: NONSTATIONARY = Field(\n        default_factory=NONSTATIONARY, description=\"Compute times\"\n    )\n    initstat: bool = Field(\n        default=False,\n        description=(\n            \"Run a STATIONARY computation at the initial time prior to the \"\n            \"NONSTATIONARY computation(s) to prescribe initial conditions\"\n        ),\n    )\n\n    @field_validator(\"times\")\n    @classmethod\n    def times_suffix(cls, times: NONSTATIONARY) -&gt; NONSTATIONARY:\n        times.suffix = \"c\"\n        return times\n\n    def _times(self, tbeg, tend):\n        return NONSTATIONARY(\n            tbeg=tbeg,\n            tend=tend,\n            delt=self.times.delt,\n            tfmt=self.times.tfmt,\n            dfmt=self.times.dfmt,\n            suffix=self.times.suffix,\n        )\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        ind = -inf\n        tbeg = self.times.tbeg\n        if self.initstat:\n            repr += [f\"COMPUTE {STATIONARY(time=tbeg, tfmt=self.times.tfmt).render()}\"]\n        for ind in self.hotids:\n            tend = self.times()[ind]\n            times = self._times(tbeg, tend)\n            repr += [f\"COMPUTE {times.render()}\"]\n            if self.hotfile is not None:\n                repr += [f\"{self._hotfile(tend).render()}\"]\n            tbeg = tend\n        if ind &lt; len(self.times) - 1:\n            times = self._times(tbeg, self.times.tend)\n            repr += [f\"COMPUTE {times.render()}\"]\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstat', 'NONSTAT'] = Field(default='nonstat', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: NONSTATIONARY = Field(default_factory=NONSTATIONARY, description='Compute times')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.initstat","title":"initstat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initstat: bool = Field(default=False, description='Run a STATIONARY computation at the initial time prior to the NONSTATIONARY computation(s) to prescribe initial conditions')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.times_suffix","title":"times_suffix  <code>classmethod</code>","text":"<pre><code>times_suffix(times: NONSTATIONARY) -&gt; NONSTATIONARY\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"times\")\n@classmethod\ndef times_suffix(cls, times: NONSTATIONARY) -&gt; NONSTATIONARY:\n    times.suffix = \"c\"\n    return times\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    ind = -inf\n    tbeg = self.times.tbeg\n    if self.initstat:\n        repr += [f\"COMPUTE {STATIONARY(time=tbeg, tfmt=self.times.tfmt).render()}\"]\n    for ind in self.hotids:\n        tend = self.times()[ind]\n        times = self._times(tbeg, tend)\n        repr += [f\"COMPUTE {times.render()}\"]\n        if self.hotfile is not None:\n            repr += [f\"{self._hotfile(tend).render()}\"]\n        tbeg = tend\n    if ind &lt; len(self.times) - 1:\n        times = self._times(tbeg, self.times.tend)\n        repr += [f\"COMPUTE {times.render()}\"]\n    return repr\n</code></pre>"},{"location":"components/lockup/#hotfile","title":"HOTFILE","text":"<p>Writes a hotstart file for continuing simulations later.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE","title":"HOTFILE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Write intermediate results.</p> <p>.. code-block:: text</p> <pre><code>HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n</code></pre> <p>This command can be used to write the entire wave field at the end of a computation to a so-called hotfile, to be used as initial condition in a subsequent SWAN run (see command <code>INITIAL HOTSTART</code>). This command must be entered immediately after a <code>COMPUTE</code> command.</p> <p>The user may choose the format of the hotfile to be written either as free or unformatted. If the free format is chosen, then this format is identical to the format of the files written by the <code>SPECOUT</code> command (option <code>SPEC2D</code>). This hotfile is therefore an ASCII file which is human readable.</p> <p>An unformatted (or binary) file usually requires less space on your computer than an ASCII file. Moreover, it can be readed by a subsequent SWAN run much faster than an ASCII file. Especially, when the hotfile might become a big file, the choice for unformatted is preferable. Note that your compiler and OS should follow the same ABI (Application Binary Interface) conventions (e.g. word size, endianness), so that unformatted hotfiles may transfer properly between different OS or platforms. This implies that the present and subsequent SWAN runs do not have to be carried out on the same operating system (e.g. Windows, Linux) or on the same computer, provided that distinct ABI conventions have been followed.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE--note","title":"Note","text":"<p>For parallel MPI runs, more than one hotfile will be generated depending on the number of processors (<code>fname-001</code>, <code>fname-002</code>, etc).</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import HOTFILE\nhotfile = HOTFILE(fname=\"hotfile.swn\")\nprint(hotfile.render())\nhotfile = HOTFILE(fname=\"hotfile.dat\", format=\"unformatted\")\nprint(hotfile.render())\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>class HOTFILE(BaseComponent):\n    \"\"\"Write intermediate results.\n\n    .. code-block:: text\n\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n\n    This command can be used to write the entire wave field at the end of a computation\n    to a so-called hotfile, to be used as initial condition in a subsequent SWAN run\n    (see command `INITIAL HOTSTART`). This command must be entered immediately after a\n    `COMPUTE` command.\n\n    The user may choose the format of the hotfile to be written either as free or\n    unformatted. If the free format is chosen, then this format is identical to the\n    format of the files written by the `SPECOUT` command (option `SPEC2D`). This\n    hotfile is therefore an ASCII file which is human readable.\n\n    An unformatted (or binary) file usually requires less space on your computer than\n    an ASCII file. Moreover, it can be readed by a subsequent SWAN run much faster than\n    an ASCII file. Especially, when the hotfile might become a big file, the choice for\n    unformatted is preferable. Note that your compiler and OS should follow the same\n    ABI (Application Binary Interface) conventions (e.g. word size, endianness), so\n    that unformatted hotfiles may transfer properly between different OS or platforms.\n    This implies that the present and subsequent SWAN runs do not have to be carried\n    out on the same operating system (e.g. Windows, Linux) or on the same computer,\n    provided that distinct ABI conventions have been followed.\n\n    Note\n    ----\n    For parallel MPI runs, more than one hotfile will be generated depending on the\n    number of processors (`fname-001`, `fname-002`, etc).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import HOTFILE\n        hotfile = HOTFILE(fname=\"hotfile.swn\")\n        print(hotfile.render())\n        hotfile = HOTFILE(fname=\"hotfile.dat\", format=\"unformatted\")\n        print(hotfile.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotfile\", \"HOTFILE\"] = Field(\n        default=\"hotfile\", description=\"Model type discriminator\"\n    )\n    fname: Path = Field(\n        description=\"Name of the file to which the wave field is written\",\n    )\n    format: Optional[Literal[\"free\", \"unformatted\"]] = Field(\n        default=None,\n        description=(\"Choose between free (SWAN ASCII) or unformatted (binary) format\"),\n    )\n\n    @field_validator(\"fname\")\n    @classmethod\n    def max_length(cls, fname: Path) -&gt; Path:\n        if len(str(fname)) &gt; 36:\n            raise ValueError(\"fname must be less than 36 characters\")\n        return fname\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"HOTFILE fname='{self.fname}'\"\n        if self.format is not None:\n            repr += f\" {self.format.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotfile', 'HOTFILE'] = Field(default='hotfile', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: Path = Field(description='Name of the file to which the wave field is written')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[Literal['free', 'unformatted']] = Field(default=None, description='Choose between free (SWAN ASCII) or unformatted (binary) format')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.max_length","title":"max_length  <code>classmethod</code>","text":"<pre><code>max_length(fname: Path) -&gt; Path\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"fname\")\n@classmethod\ndef max_length(cls, fname: Path) -&gt; Path:\n    if len(str(fname)) &gt; 36:\n        raise ValueError(\"fname must be less than 36 characters\")\n    return fname\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"HOTFILE fname='{self.fname}'\"\n    if self.format is not None:\n        repr += f\" {self.format.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/lockup/#stop","title":"STOP","text":"<p>Terminates SWAN execution.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP","title":"STOP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>End of commands.</p> <p>.. code-block:: text</p> <pre><code>STOP\n</code></pre> <p>This required command marks the end of the commands in the command file. Note that the command <code>STOP</code> may be the last command in the input file; any information in the input file beyond this command is ignored.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import STOP\nstop = STOP()\nprint(stop.render())\n</code></pre> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>class STOP(BaseComponent):\n    \"\"\"End of commands.\n\n    .. code-block:: text\n\n        STOP\n\n    This required command marks the end of the commands in the command file. Note that\n    the command `STOP` may be the last command in the input file; any information in\n    the input file beyond this command is ignored.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import STOP\n        stop = STOP()\n        print(stop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stop\", \"STOP\"] = Field(\n        default=\"stop\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"STOP\"\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.STOP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stop', 'STOP'] = Field(default='stop', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.STOP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"STOP\"\n</code></pre>"},{"location":"components/numerics/","title":"Numerics","text":"<p>Numerics commands control the numerical schemes used for wave propagation and source term integration.</p> <p>Default Numerics</p> <p>SWAN uses robust default numerical settings. Only modify these if you understand the implications for accuracy and stability.</p>"},{"location":"components/numerics/#prop","title":"PROP","text":"<p>Specifies the propagation scheme for geographic and spectral space.</p>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP","title":"PROP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Propagation scheme.</p> <p>.. code-block:: text</p> <pre><code>PROP BSTB|GSE\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP--notes","title":"Notes","text":"<ul> <li>The scheme defaults to <code>S&amp;L</code> and <code>SORDUP</code> for nonstationary and stationary   simulations if not specified.</li> <li>All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear   grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a   gradually varying grid otherwise there may be a severe loss of accuracy. If sharp   transitions in the grid cannot be avoided it is safer to use the BSBT scheme.</li> <li>In the computation with unstructured meshes, a lowest order upwind scheme will be   employed. This scheme is very robust but rather diffusive. This may only be   significant for the case when swell waves propagate over relative large distances   (in the order of thousands of kilometers) within the model domain. However and   most fortunately, in such a case this will alleviate the garden-sprinkler effect.</li> <li>Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN   computation conditionally stable. You can either use (i) a smaller time step,   (ii) a lower value of <code>waveage</code>, (iii) better resolution in the directional   space, or (iv) worse resolution in the geographic space, in order of preference,   to make the model stable when necessary.</li> </ul>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import PROP\nprop = PROP()\nprint(prop.render())\nprop = PROP(scheme=dict(model_type=\"bsbt\"))\nprint(prop.render())\nprop = PROP(\n    scheme=dict(\n        model_type=\"gse\",\n        waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n    ),\n)\nprint(prop.render())\n</code></pre> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>class PROP(BaseComponent):\n    \"\"\"Propagation scheme.\n\n    .. code-block:: text\n\n        PROP BSTB|GSE\n\n    Notes\n    -----\n    * The scheme defaults to `S&amp;L` and `SORDUP` for nonstationary and stationary\n      simulations if not specified.\n    * All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear\n      grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a\n      gradually varying grid otherwise there may be a severe loss of accuracy. If sharp\n      transitions in the grid cannot be avoided it is safer to use the BSBT scheme.\n    * In the computation with unstructured meshes, a lowest order upwind scheme will be\n      employed. This scheme is very robust but rather diffusive. This may only be\n      significant for the case when swell waves propagate over relative large distances\n      (in the order of thousands of kilometers) within the model domain. However and\n      most fortunately, in such a case this will alleviate the garden-sprinkler effect.\n    * Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN\n      computation conditionally stable. You can either use (i) a smaller time step,\n      (ii) a lower value of `waveage`, (iii) better resolution in the directional\n      space, or (iv) worse resolution in the geographic space, in order of preference,\n      to make the model stable when necessary.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import PROP\n        prop = PROP()\n        print(prop.render())\n        prop = PROP(scheme=dict(model_type=\"bsbt\"))\n        print(prop.render())\n        prop = PROP(\n            scheme=dict(\n                model_type=\"gse\",\n                waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n            ),\n        )\n        print(prop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"prop\", \"PROP\"] = Field(\n        default=\"prop\", description=\"Model type discriminator\"\n    )\n    scheme: Optional[PROP_TYPE] = Field(\n        default=None,\n        description=(\n            \"Propagation scheme, by default S&amp;L for nonstationary and SORDUP for \"\n            \"stationary computation.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"PROP\"\n        if self.scheme is not None:\n            repr += f\" {self.scheme.render()}\"\n        return repr\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP-attributes","title":"Attributes","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['prop', 'PROP'] = Field(default='prop', description='Model type discriminator')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.scheme","title":"scheme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scheme: Optional[PROP_TYPE] = Field(default=None, description='Propagation scheme, by default S&amp;L for nonstationary and SORDUP for stationary computation.')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP-functions","title":"Functions","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"PROP\"\n    if self.scheme is not None:\n        repr += f\" {self.scheme.render()}\"\n    return repr\n</code></pre>"},{"location":"components/numerics/#numeric","title":"NUMERIC","text":"<p>Controls iteration settings, accuracy criteria, and limiter options.</p>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC","title":"NUMERIC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Numerical properties.</p> <p>.. code-block:: text</p> <pre><code>NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n    ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n    ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import NUMERIC\nnumeric = NUMERIC()\nprint(numeric.render())\nnumeric = NUMERIC(\n    stop=dict(\n        model_type=\"stopc\",\n        dabs=0.05,\n        drel=0.01,\n        curvat=0.05,\n        npnts=99.5,\n    ),\n    dirimpl=dict(cdd=0.5),\n    sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n    ctheta=dict(cfl=0.9),\n    csigma=dict(cfl=0.9),\n    setup=dict(eps2=1e-4, outp=0, niter=20),\n)\nprint(numeric.render())\n</code></pre> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>class NUMERIC(BaseComponent):\n    \"\"\"Numerical properties.\n\n    .. code-block:: text\n\n        NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n            ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n            ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import NUMERIC\n        numeric = NUMERIC()\n        print(numeric.render())\n        numeric = NUMERIC(\n            stop=dict(\n                model_type=\"stopc\",\n                dabs=0.05,\n                drel=0.01,\n                curvat=0.05,\n                npnts=99.5,\n            ),\n            dirimpl=dict(cdd=0.5),\n            sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n            ctheta=dict(cfl=0.9),\n            csigma=dict(cfl=0.9),\n            setup=dict(eps2=1e-4, outp=0, niter=20),\n        )\n        print(numeric.render())\n\n    \"\"\"\n\n    model_type: Literal[\"numeric\", \"NUMERIC\"] = Field(\n        default=\"numeric\", description=\"Model type discriminator\"\n    )\n    stop: Optional[Union[STOPC, ACCUR]] = Field(\n        default=None,\n        description=\"Iteration termination criteria\",\n        discriminator=\"model_type\",\n    )\n    dirimpl: Optional[DIRIMPL] = Field(\n        default=None,\n        description=\"Numerical scheme for refraction\",\n    )\n    sigimpl: Optional[SIGIMPL] = Field(\n        default=None,\n        description=\"Frequency shifting accuracy\",\n    )\n    ctheta: Optional[CTHETA] = Field(\n        default=None,\n        description=\"Prevents excessive directional turning\",\n    )\n    csigma: Optional[CSIGMA] = Field(\n        default=None,\n        description=\"Prevents excessive frequency shifting\",\n    )\n    setup: Optional[SETUP] = Field(\n        default=None,\n        description=\"Stop criteria in the computation of wave setup\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NUMERIC\"\n        if self.stop is not None:\n            repr += f\" {self.stop.render()}\"\n        if self.dirimpl is not None:\n            repr += f\" {self.dirimpl.render()}\"\n        if self.sigimpl is not None:\n            repr += f\" {self.sigimpl.render()}\"\n        if self.ctheta is not None:\n            repr += f\" {self.ctheta.render()}\"\n        return repr\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC-attributes","title":"Attributes","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['numeric', 'NUMERIC'] = Field(default='numeric', description='Model type discriminator')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.stop","title":"stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop: Optional[Union[STOPC, ACCUR]] = Field(default=None, description='Iteration termination criteria', discriminator='model_type')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.dirimpl","title":"dirimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirimpl: Optional[DIRIMPL] = Field(default=None, description='Numerical scheme for refraction')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.sigimpl","title":"sigimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigimpl: Optional[SIGIMPL] = Field(default=None, description='Frequency shifting accuracy')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.ctheta","title":"ctheta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctheta: Optional[CTHETA] = Field(default=None, description='Prevents excessive directional turning')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.csigma","title":"csigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csigma: Optional[CSIGMA] = Field(default=None, description='Prevents excessive frequency shifting')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP] = Field(default=None, description='Stop criteria in the computation of wave setup')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC-functions","title":"Functions","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NUMERIC\"\n    if self.stop is not None:\n        repr += f\" {self.stop.render()}\"\n    if self.dirimpl is not None:\n        repr += f\" {self.dirimpl.render()}\"\n    if self.sigimpl is not None:\n        repr += f\" {self.sigimpl.render()}\"\n    if self.ctheta is not None:\n        repr += f\" {self.ctheta.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/","title":"Output","text":"<p>Output commands define where and what SWAN writes as results. Output can be written at specific locations (points, curves, grids) and in various formats (tables, blocks, spectra).</p> <p>Output Types</p> <ul> <li>Locations \u2014 Define where to extract output (points, curves, frames, nested grids)</li> <li>Quantities \u2014 Configure output variable settings (units, exceptions)</li> <li>Write commands \u2014 Specify output format and file names (BLOCK, TABLE, SPECOUT)</li> </ul> <p>Time Control for Output Components</p> <p>When using the rompy API, output write commands (BLOCK, TABLE, SPECOUT, NESTOUT) have their start time (<code>tbeg</code>) set from the <code>ModelRun.period.start</code>. However, you can override the time interval (<code>delt</code>) and formatting (<code>tfmt</code>, <code>dfmt</code>) by specifying a <code>times</code> field in the component. If no <code>times</code> field is provided, the component uses the runtime interval.</p> <p>Example: <pre><code>block=dict(\n    sname=\"COMPGRID\",\n    fname=\"output.nc\",\n    output=[\"hsign\"],\n    times=dict(\n        delt=timedelta(minutes=30),  # Custom interval\n        tfmt=1,                       # ISO format\n        dfmt=\"min\",                   # Minutes\n    ),\n)\n</code></pre></p> <p>See the Configuration Guide for more details.</p>"},{"location":"components/output/#locations","title":"Locations","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation","title":"BaseLocation","text":"<p>               Bases: <code>BaseComponent</code>, <code>ABC</code></p> <p>Base class for SWAN output locations.</p> <p>.. code-block:: text</p> <pre><code>{MODEL_TYPE} sname='sname'\n</code></pre> <p>This is the base class for all locations components. It is not meant to be used directly.</p>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation--note","title":"Note","text":"<p>The name of the set of output locations <code>sname</code> cannot be longer than 8 characters and must not match any SWAN special names such as <code>BOTTGRID</code> (define output over the bottom/current grid) or <code>COMPGRID</code> (define output over the computational grid).</p>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BaseLocation\nloc = BaseLocation(sname=\"outsites\")\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class BaseLocation(BaseComponent, ABC):\n    \"\"\"Base class for SWAN output locations.\n\n    .. code-block:: text\n\n        {MODEL_TYPE} sname='sname'\n\n    This is the base class for all locations components. It is not meant to be used\n    directly.\n\n    Note\n    ----\n    The name of the set of output locations `sname` cannot be longer than 8 characters\n    and must not match any SWAN special names such as `BOTTGRID` (define output over\n    the bottom/current grid) or `COMPGRID` (define output over the computational grid).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BaseLocation\n        loc = BaseLocation(sname=\"outsites\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"locations\", \"LOCATIONS\"] = Field(\n        default=\"locations\",\n        description=\"Model type discriminator\",\n    )\n    sname: str = Field(\n        description=\"Name of the set of output locations defined by this command\",\n        max_length=8,\n    )\n\n    @field_validator(\"sname\")\n    @classmethod\n    def not_special_name(cls, sname: str) -&gt; str:\n        \"\"\"Ensure sname is not defined as one of the special names.\"\"\"\n        for name in SPECIAL_NAMES:\n            if sname.upper().startswith(name):\n                raise ValueError(f\"sname {sname} is a special name and cannot be used\")\n        return sname\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"{self.model_type.upper()} sname='{self.sname}'\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['locations', 'LOCATIONS'] = Field(default='locations', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation.sname","title":"sname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sname: str = Field(description='Name of the set of output locations defined by this command', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation.not_special_name","title":"not_special_name  <code>classmethod</code>","text":"<pre><code>not_special_name(sname: str) -&gt; str\n</code></pre> <p>Ensure sname is not defined as one of the special names.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"sname\")\n@classmethod\ndef not_special_name(cls, sname: str) -&gt; str:\n    \"\"\"Ensure sname is not defined as one of the special names.\"\"\"\n    for name in SPECIAL_NAMES:\n        if sname.upper().startswith(name):\n            raise ValueError(f\"sname {sname} is a special name and cannot be used\")\n    return sname\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"{self.model_type.upper()} sname='{self.sname}'\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME","title":"FRAME","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations on a regular grid.</p> <p>.. code-block:: text</p> <pre><code>FRAME 'sname' [xpfr] [ypfr] [alpfr] [xlenfr] [ylenfr] [mxfr] [myfr]\n</code></pre> <p>With this optional command the user defines output on a rectangular, uniform grid in a regular frame.</p> <p>If the set of output locations is identical to a part of the computational grid, then the user can use the alternative command GROUP.</p>"},{"location":"components/output/#rompy_swan.components.output.FRAME--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.FRAME--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import FRAME\nloc = FRAME(\n    sname=\"outgrid\",\n    grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class FRAME(BaseLocation):\n    \"\"\"Output locations on a regular grid.\n\n    .. code-block:: text\n\n        FRAME 'sname' [xpfr] [ypfr] [alpfr] [xlenfr] [ylenfr] [mxfr] [myfr]\n\n    With this optional command the user defines output on a rectangular, uniform grid\n    in a regular frame.\n\n    If the set of output locations is identical to a part of the computational grid,\n    then the user can use the alternative command GROUP.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import FRAME\n        loc = FRAME(\n            sname=\"outgrid\",\n            grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"frame\", \"FRAME\"] = Field(\n        default=\"frame\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"Frame grid definition\")\n\n    @field_validator(\"grid\")\n    @classmethod\n    def grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n        grid.suffix = \"fr\"\n        return grid\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.grid.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.FRAME.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['frame', 'FRAME'] = Field(default='frame', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='Frame grid definition')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.FRAME.grid_suffix","title":"grid_suffix  <code>classmethod</code>","text":"<pre><code>grid_suffix(grid: GRIDREGULAR) -&gt; GRIDREGULAR\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"grid\")\n@classmethod\ndef grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n    grid.suffix = \"fr\"\n    return grid\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.grid.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP","title":"GROUP","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations on subset of a grid.</p> <p>.. code-block:: text</p> <pre><code>GROUP 'sname' SUBGRID [ix1] [ix2] [iy1] [iy2]\n</code></pre> <p>With this optional command the user defines a group of output locations on a rectangular or curvilinear grid that is identical with (part of) the computational grid (rectilinear or curvilinear). Such a group may be convenient for the user to obtain output that is not affected by interpolation errors.</p> <p>The subgrid contains those points (<code>ix</code>,<code>iy</code>) of the computational grid for which: <code>ix1</code> &lt;= <code>ix</code> &lt;= <code>ix2</code> and <code>iy1</code> &lt;= <code>iy</code> &lt;= <code>iy2</code> (The origin of the computational grid is <code>ix=0</code>, <code>iy=0</code>)</p> <p>Limitations: <code>ix1&gt;=0</code>, <code>ix2&lt;=mxc</code>, <code>iy1&gt;=0</code>, <code>iy2&lt;=myc</code> (<code>mxc</code> and <code>myc</code> as defined in the command <code>CGRID</code> which should always precede this command <code>GROUP</code>)</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--note","title":"Note","text":"<p>Cannot be used in 1D-mode or in case of unstructured grids.</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--note_1","title":"Note","text":"<p>Regular and curvilinear grids are supported.</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import GROUP\nloc = GROUP(sname=\"subgrid\", ix1=20, iy1=0, ix2=50, iy2=100)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class GROUP(BaseLocation):\n    \"\"\"Output locations on subset of a grid.\n\n    .. code-block:: text\n\n        GROUP 'sname' SUBGRID [ix1] [ix2] [iy1] [iy2]\n\n    With this optional command the user defines a group of output locations on a\n    rectangular or curvilinear grid that is identical with (part of) the computational\n    grid (rectilinear or curvilinear). Such a group may be convenient for the user to\n    obtain output that is not affected by interpolation errors.\n\n    The subgrid contains those points (`ix`,`iy`) of the computational grid for which:\n    `ix1` &lt;= `ix` &lt;= `ix2` and `iy1` &lt;= `iy` &lt;= `iy2` (The origin of the computational\n    grid is `ix=0`, `iy=0`)\n\n    Limitations: `ix1&gt;=0`, `ix2&lt;=mxc`, `iy1&gt;=0`, `iy2&lt;=myc` (`mxc` and `myc` as\n    defined in the command `CGRID` which should always precede this command `GROUP`)\n\n    Note\n    ----\n    Cannot be used in 1D-mode or in case of unstructured grids.\n\n    Note\n    ----\n    Regular and curvilinear grids are supported.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import GROUP\n        loc = GROUP(sname=\"subgrid\", ix1=20, iy1=0, ix2=50, iy2=100)\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"group\", \"GROUP\"] = Field(\n        default=\"group\", description=\"Model type discriminator\"\n    )\n    ix1: int = Field(\n        description=\"Lowest index of the computational grid in the ix-direction\",\n        ge=0,\n    )\n    iy1: int = Field(\n        description=\"Lowest index of the computational grid in the iy-direction\",\n        ge=0,\n    )\n    ix2: int = Field(\n        description=\"Highest index of the computational grid in the ix-direction\",\n    )\n    iy2: int = Field(\n        description=\"Highest index of the computational grid in the ix-direction\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()}\"\n        repr += f\" SUBGRID ix1={self.ix1} iy1={self.iy1} ix2={self.ix2} iy2={self.iy2}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.GROUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['group', 'GROUP'] = Field(default='group', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.ix1","title":"ix1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ix1: int = Field(description='Lowest index of the computational grid in the ix-direction', ge=0)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.iy1","title":"iy1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iy1: int = Field(description='Lowest index of the computational grid in the iy-direction', ge=0)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.ix2","title":"ix2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ix2: int = Field(description='Highest index of the computational grid in the ix-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.iy2","title":"iy2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iy2: int = Field(description='Highest index of the computational grid in the ix-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.GROUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()}\"\n    repr += f\" SUBGRID ix1={self.ix1} iy1={self.iy1} ix2={self.ix2} iy2={self.iy2}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE","title":"CURVE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations along a curve.</p> <p>.. code-block:: text</p> <pre><code>CURVE 'sname' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user defines output along a curved line. Actually this curve is a broken line, defined by the user with its corner points. The values of the output quantities along the curve are interpolated from the computational grid. This command may be used more than once to define more curves.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note","title":"Note","text":"<p>The following pre-defined curves are available and could be used instead of a CURVE component: 'BOUNDARY' and <code>BOUND_0N</code> where <code>N</code> is boundary part number.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note_2","title":"Note","text":"<p>Repeat the group <code>&lt; int xp yp</code> &gt; in proper order if there are more corner points on the curve.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import CURVE\nloc = CURVE(\n    sname=\"outcurve\",\n    xp1=172,\n    yp1=-40,\n    npts=[3, 3],\n    xp=[172.0, 174.0],\n    yp=[-38.0, -38.0],\n)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class CURVE(BaseLocation):\n    \"\"\"Output locations along a curve.\n\n    .. code-block:: text\n\n        CURVE 'sname' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n\n    With this optional command the user defines output along a curved line. Actually\n    this curve is a broken line, defined by the user with its corner points. The values\n    of the output quantities along the curve are interpolated from the computational\n    grid. This command may be used more than once to define more curves.\n\n    Note\n    ----\n    The following pre-defined curves are available and could be used instead of a CURVE\n    component: 'BOUNDARY' and `BOUND_0N` where `N` is boundary part number.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Note\n    ----\n    Repeat the group `&lt; int xp yp` &gt; in proper order if there are more corner points\n    on the curve.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import CURVE\n        loc = CURVE(\n            sname=\"outcurve\",\n            xp1=172,\n            yp1=-40,\n            npts=[3, 3],\n            xp=[172.0, 174.0],\n            yp=[-38.0, -38.0],\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curve\", \"CURVE\"] = Field(\n        default=\"curve\", description=\"Model type discriminator\"\n    )\n    xp1: float = Field(\n        description=(\n            \"Problem coordinate of the first point of the curve in the x-direction\"\n        ),\n    )\n    yp1: float = Field(\n        description=(\n            \"Problem coordinate of the first point of the curve in the y-direction\"\n        ),\n    )\n    npts: list[int] = Field(\n        description=(\n            \"The `int` CURVE parameter, SWAN will generate `npts-1` equidistant \"\n            \"locations between two subsequent corner points of the curve \"\n            \"including the two corner points\"\n        ),\n        min_length=1,\n    )\n    xp: list[float] = Field(\n        description=(\n            \"problem coordinates of a corner point of the curve in the x-direction\"\n        ),\n        min_length=1,\n    )\n    yp: list[float] = Field(\n        description=(\n            \"problem coordinates of a corner point of the curve in the y-direction\"\n        ),\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"CURVE\":\n        for key in [\"xp\", \"yp\"]:\n            if len(getattr(self, key)) != len(self.npts):\n                raise ValueError(f\"Size of npts and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} xp1={self.xp1} yp1={self.yp1}\"\n        for npts, xp, yp in zip(self.npts, self.xp, self.yp):\n            repr += f\"\\nint={npts} xp={xp} yp={yp}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.CURVE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curve', 'CURVE'] = Field(default='curve', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.xp1","title":"xp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp1: float = Field(description='Problem coordinate of the first point of the curve in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.yp1","title":"yp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp1: float = Field(description='Problem coordinate of the first point of the curve in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.npts","title":"npts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npts: list[int] = Field(description='The `int` CURVE parameter, SWAN will generate `npts-1` equidistant locations between two subsequent corner points of the curve including the two corner points', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='problem coordinates of a corner point of the curve in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='problem coordinates of a corner point of the curve in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.CURVE.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; CURVE\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"CURVE\":\n    for key in [\"xp\", \"yp\"]:\n        if len(getattr(self, key)) != len(self.npts):\n            raise ValueError(f\"Size of npts and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} xp1={self.xp1} yp1={self.yp1}\"\n    for npts, xp, yp in zip(self.npts, self.xp, self.yp):\n        repr += f\"\\nint={npts} xp={xp} yp={yp}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES","title":"CURVES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Output locations along multiple curves.</p> <p>.. code-block:: text</p> <pre><code>CURVE 'sname1' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\nCURVE 'sname2' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n..\n</code></pre> <p>This component can be used to prescribe and render multiple CURVE components.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import CURVE, CURVES\nloc1 = CURVE(\n    sname=\"c1\", xp1=7, yp1=-40, npts=[3, 3], xp=[7, 9], yp=[-38, -38],\n)\nloc2 = CURVE(\n    sname=\"c2\", xp1=3, yp1=-37, npts=[5, 5], xp=[4, 5], yp=[-37, -36],\n)\nlocs = CURVES(curves=[loc1, loc2])\nprint(locs.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class CURVES(BaseComponent):\n    \"\"\"Output locations along multiple curves.\n\n    .. code-block:: text\n\n        CURVE 'sname1' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n        CURVE 'sname2' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n        ..\n\n    This component can be used to prescribe and render multiple CURVE components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import CURVE, CURVES\n        loc1 = CURVE(\n            sname=\"c1\", xp1=7, yp1=-40, npts=[3, 3], xp=[7, 9], yp=[-38, -38],\n        )\n        loc2 = CURVE(\n            sname=\"c2\", xp1=3, yp1=-37, npts=[5, 5], xp=[4, 5], yp=[-37, -36],\n        )\n        locs = CURVES(curves=[loc1, loc2])\n        print(locs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curves\", \"CURVES\"] = Field(\n        default=\"curves\", description=\"Model type discriminator\"\n    )\n    curves: list[CURVE] = Field(description=\"CURVE components\")\n\n    @property\n    def sname(self) -&gt; list[str]:\n        return [curve.sname for curve in self.curves]\n\n    def cmd(self) -&gt; list[str]:\n        repr = []\n        for curve in self.curves:\n            repr += [curve.cmd()]\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.CURVES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curves', 'CURVES'] = Field(default='curves', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES.curves","title":"curves  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curves: list[CURVE] = Field(description='CURVE components')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES.sname","title":"sname  <code>property</code>","text":"<pre><code>sname: list[str]\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.CURVES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list[str]\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; list[str]:\n    repr = []\n    for curve in self.curves:\n        repr += [curve.cmd()]\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY","title":"RAY","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Output locations along a depth contour.</p> <p>.. code-block:: text</p> <pre><code>RAY 'rname' [xp1] [yp1] [xq1] [yq1] &lt; [int] [xp] [yp] [xq] [yq] &gt;\n</code></pre> <p>With this optional command the user provides SWAN with information to determine output locations along the depth contour line(s) defined subsequently in command <code>ISOLINE</code> (see below).</p> <p>These locations are determined by SWAN as the intersections of the depth contour line(s) and the set of straight rays defined in this command RAY. These rays are characterized by a set of master rays defined by their start and end positions (<code>xp</code>,<code>yp</code>) and (<code>xq</code>,<code>yq</code>). Between each pair of sequential master rays thus defined SWAN generates <code>int-1</code> intermediate rays by linear interpolation of the start and end positions.</p> <p>Rays defined by this component have nothing in common with wave rays (e.g. as obtained from conventional refraction computations).</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note_2","title":"Note","text":"<p>When using rays the input grid for bottom and water level should not be curvilinear.</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import RAY\nloc = RAY(\n    rname=\"outray\",\n    xp1=171.9,\n    yp1=-40.1,\n    xq1=172.1,\n    yq1=-39.9,\n    npts=[3, 3],\n    xp=[171.9, 173.9],\n    yp=[-38.1, -38.1],\n    xq=[172.1, 174.1],\n    yq=[-37.9, -37.9],\n)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class RAY(BaseComponent):\n    \"\"\"Output locations along a depth contour.\n\n    .. code-block:: text\n\n        RAY 'rname' [xp1] [yp1] [xq1] [yq1] &lt; [int] [xp] [yp] [xq] [yq] &gt;\n\n    With this optional command the user provides SWAN with information to determine\n    output locations along the depth contour line(s) defined subsequently in command\n    `ISOLINE` (see below).\n\n    These locations are determined by SWAN as the intersections of the depth contour\n    line(s) and the set of straight rays defined in this command RAY. These rays are\n    characterized by a set of master rays defined by their start and end positions\n    (`xp`,`yp`) and (`xq`,`yq`). Between each pair of sequential master rays thus\n    defined SWAN generates `int-1` intermediate rays by linear interpolation of the\n    start and end positions.\n\n    Rays defined by this component have nothing in common with wave rays (e.g. as\n    obtained from conventional refraction computations).\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command `COORD`).\n\n    Note\n    ----\n    When using rays the input grid for bottom and water level should not be curvilinear.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import RAY\n        loc = RAY(\n            rname=\"outray\",\n            xp1=171.9,\n            yp1=-40.1,\n            xq1=172.1,\n            yq1=-39.9,\n            npts=[3, 3],\n            xp=[171.9, 173.9],\n            yp=[-38.1, -38.1],\n            xq=[172.1, 174.1],\n            yq=[-37.9, -37.9],\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ray\", \"RAY\"] = Field(\n        default=\"ray\", description=\"Model type discriminator\"\n    )\n    rname: str = Field(\n        description=\"Name of the set of rays defined by this command\",\n        max_length=32,\n    )\n    xp1: float = Field(\n        description=(\n            \"Problem coordinate of the begin point of the first master ray \"\n            \"in the x-direction\"\n        ),\n    )\n    yp1: float = Field(\n        description=(\n            \"Problem coordinate of the begin point of the first master ray \"\n            \"in the y-direction\"\n        ),\n    )\n    xq1: float = Field(\n        description=(\n            \"Problem coordinate of the end point of the first master ray \"\n            \"in the x-direction\"\n        ),\n    )\n    yq1: float = Field(\n        description=(\n            \"Problem coordinate of the end point of the first master ray \"\n            \"in the y-direction\"\n        ),\n    )\n    npts: list[int] = Field(\n        description=(\n            \"The `int` RAY parameter, number of subdivisions between the previous \"\n            \"master ray and the following master ray defined by the following data \"\n            \"(number of subdivisions is one morethan the number of interpolated rays)\"\n        ),\n        min_length=1,\n    )\n    xp: list[float] = Field(\n        description=(\n            \"problem coordinates of the begin of each subsequent master ray in the \"\n            \"x-direction\"\n        ),\n        min_length=1,\n    )\n    yp: list[float] = Field(\n        description=(\n            \"problem coordinates of the begin of each subsequent master ray in the \"\n            \"y-direction\"\n        ),\n        min_length=1,\n    )\n    xq: list[float] = Field(\n        description=(\n            \"problem coordinates of the end of each subsequent master ray in the \"\n            \"x-direction\"\n        ),\n        min_length=1,\n    )\n    yq: list[float] = Field(\n        description=(\n            \"problem coordinates of the end of each subsequent master ray in the \"\n            \"y-direction\"\n        ),\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"CURVE\":\n        for key in [\"xp\", \"yp\", \"xq\", \"yq\"]:\n            if len(getattr(self, key)) != len(self.npts):\n                raise ValueError(f\"Size of npts and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"RAY rname='{self.rname}'\"\n        repr += f\" xp1={self.xp1} yp1={self.yp1} xq1={self.xq1} yq1={self.yq1}\"\n        for npts, xp, yp, xq, yq in zip(self.npts, self.xp, self.yp, self.xq, self.yq):\n            repr += f\"\\nint={npts} xp={xp} yp={yp} xq={xq} yq={yq}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.RAY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ray', 'RAY'] = Field(default='ray', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.rname","title":"rname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rname: str = Field(description='Name of the set of rays defined by this command', max_length=32)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xp1","title":"xp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp1: float = Field(description='Problem coordinate of the begin point of the first master ray in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yp1","title":"yp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp1: float = Field(description='Problem coordinate of the begin point of the first master ray in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xq1","title":"xq1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xq1: float = Field(description='Problem coordinate of the end point of the first master ray in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yq1","title":"yq1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yq1: float = Field(description='Problem coordinate of the end point of the first master ray in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.npts","title":"npts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npts: list[int] = Field(description='The `int` RAY parameter, number of subdivisions between the previous master ray and the following master ray defined by the following data (number of subdivisions is one morethan the number of interpolated rays)', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='problem coordinates of the begin of each subsequent master ray in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='problem coordinates of the begin of each subsequent master ray in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xq","title":"xq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xq: list[float] = Field(description='problem coordinates of the end of each subsequent master ray in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yq","title":"yq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yq: list[float] = Field(description='problem coordinates of the end of each subsequent master ray in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.RAY.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; CURVE\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"CURVE\":\n    for key in [\"xp\", \"yp\", \"xq\", \"yq\"]:\n        if len(getattr(self, key)) != len(self.npts):\n            raise ValueError(f\"Size of npts and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"RAY rname='{self.rname}'\"\n    repr += f\" xp1={self.xp1} yp1={self.yp1} xq1={self.xq1} yq1={self.yq1}\"\n    for npts, xp, yp, xq, yq in zip(self.npts, self.xp, self.yp, self.xq, self.yq):\n        repr += f\"\\nint={npts} xp={xp} yp={yp} xq={xq} yq={yq}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE","title":"ISOLINE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations along a depth contour.</p> <p>.. code-block:: text</p> <pre><code>ISOLINE 'sname' 'rname' DEPTH|BOTTOM [dep]\n</code></pre> <p>With this optional command the user defines a set of output locations along one depth or bottom level contour line (in combination with command RAY).</p>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import ISOLINE\nloc = ISOLINE(sname=\"outcurve\", rname=\"outray\", dep_type=\"depth\", dep=12.0)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class ISOLINE(BaseLocation):\n    \"\"\"Output locations along a depth contour.\n\n    .. code-block:: text\n\n        ISOLINE 'sname' 'rname' DEPTH|BOTTOM [dep]\n\n    With this optional command the user defines a set of output locations along one\n    depth or bottom level contour line (in combination with command RAY).\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import ISOLINE\n        loc = ISOLINE(sname=\"outcurve\", rname=\"outray\", dep_type=\"depth\", dep=12.0)\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"isoline\", \"ISOLINE\"] = Field(\n        default=\"isoline\", description=\"Model type discriminator\"\n    )\n    rname: str = Field(\n        description=\"Name of the set of rays defined by this command\",\n        max_length=8,\n    )\n    dep: float = Field(\n        description=(\n            \"The depth (in m) of the depth contour line along which output locations \"\n            \"are generated by SWAN.\"\n        ),\n    )\n    dep_type: Optional[Literal[\"depth\", \"bottom\"]] = Field(\n        default=None,\n        description=(\n            \"Define if the depth contour is extracted from the DEPTH output (the \"\n            \"stationary water depth) or from the BOTTOM output (the depth relative \"\n            \"to the datum level with the water level ignored) (SWAN default: DEPTH)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} rname='{self.rname}'\"\n        if self.dep_type is not None:\n            repr += f\" {self.dep_type.upper()}\"\n        repr += f\" dep={self.dep}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.ISOLINE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['isoline', 'ISOLINE'] = Field(default='isoline', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.rname","title":"rname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rname: str = Field(description='Name of the set of rays defined by this command', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.dep","title":"dep  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dep: float = Field(description='The depth (in m) of the depth contour line along which output locations are generated by SWAN.')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.dep_type","title":"dep_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dep_type: Optional[Literal['depth', 'bottom']] = Field(default=None, description='Define if the depth contour is extracted from the DEPTH output (the stationary water depth) or from the BOTTOM output (the depth relative to the datum level with the water level ignored) (SWAN default: DEPTH)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.ISOLINE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} rname='{self.rname}'\"\n    if self.dep_type is not None:\n        repr += f\" {self.dep_type.upper()}\"\n    repr += f\" dep={self.dep}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS","title":"POINTS","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Isolated output locations.</p> <p>.. code-block:: text</p> <pre><code>POINTS 'sname' &lt; [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user defines a set of individual output point locations.</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS--note","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS\nloc = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class POINTS(BaseLocation):\n    \"\"\"Isolated output locations.\n\n    .. code-block:: text\n\n        POINTS 'sname' &lt; [xp] [yp] &gt;\n\n    With this optional command the user defines a set of individual output point\n    locations.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS\n        loc = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"points\", \"POINTS\"] = Field(\n        default=\"points\", description=\"Model type discriminator\"\n    )\n    xp: Optional[list[float]] = Field(\n        description=\"problem coordinates of the points in the x-direction\",\n        min_length=1,\n    )\n    yp: Optional[list[float]] = Field(\n        description=\"problem coordinates of the points in the y-direction\",\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"POINTS\":\n        if len(self.xp) != len(self.yp):\n            raise ValueError(\"xp and yp must be the same size\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()}\"\n        for xp, yp in zip(self.xp, self.yp):\n            repr += f\"\\nxp={xp} yp={yp}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['points', 'POINTS'] = Field(default='points', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: Optional[list[float]] = Field(description='problem coordinates of the points in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: Optional[list[float]] = Field(description='problem coordinates of the points in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; POINTS\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"POINTS\":\n    if len(self.xp) != len(self.yp):\n        raise ValueError(\"xp and yp must be the same size\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()}\"\n    for xp, yp in zip(self.xp, self.yp):\n        repr += f\"\\nxp={xp} yp={yp}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE","title":"POINTS_FILE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Isolated output locations.</p> <p>.. code-block:: text</p> <pre><code>POINTS 'sname' FILE 'fname'\n</code></pre> <p>With this optional command the user defines a set of individual output point locations from text file. The file should have one point per row with x-coordinates and y-coordinates in the first and second columns respectively.</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE--note","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS_FILE\nloc = POINTS_FILE(sname=\"outpts\", fname=\"./output_locations.txt\")\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class POINTS_FILE(BaseLocation):\n    \"\"\"Isolated output locations.\n\n    .. code-block:: text\n\n        POINTS 'sname' FILE 'fname'\n\n    With this optional command the user defines a set of individual output point\n    locations from text file. The file should have one point per row with x-coordinates\n    and y-coordinates in the first and second columns respectively.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS_FILE\n        loc = POINTS_FILE(sname=\"outpts\", fname=\"./output_locations.txt\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"points_file\", \"POINTS_FILE\"] = Field(\n        default=\"points_file\", description=\"Model type discriminator\"\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the output locations\",\n        max_length=36,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"POINTS sname='{self.sname}' fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['points_file', 'POINTS_FILE'] = Field(default='points_file', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the output locations', max_length=36)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"POINTS sname='{self.sname}' fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID","title":"NGRID","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations for a nested grid.</p> <p>.. code-block:: text</p> <pre><code>NGRID 'sname' [xpn] [ypn] [alpn] [xlenn] [ylenn] [mxn] [myn]\n</code></pre> <p>If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run is required. With this optional command <code>NGRID</code>, the user defines in the present coarse-grid run, a set of output locations along the boundary of the subsequent nested computational grid. The set of output locations thus defined is of the type NGRID.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--note","title":"Note","text":"<p>Command <code>NESTOUT</code> is required after this command <code>NGRID</code> to generate some data for the (subsequent) nested run.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--note_1","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NGRID\nloc = NGRID(\n    sname=\"outnest\",\n    grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n)\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class NGRID(BaseLocation):\n    \"\"\"Output locations for a nested grid.\n\n    .. code-block:: text\n\n        NGRID 'sname' [xpn] [ypn] [alpn] [xlenn] [ylenn] [mxn] [myn]\n\n    If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run\n    is required. With this optional command `NGRID`, the user defines in the present\n    coarse-grid run, a set of output locations along the boundary of the subsequent\n    nested computational grid. The set of output locations thus defined is of the type\n    NGRID.\n\n    Note\n    ----\n    Command `NESTOUT` is required after this command `NGRID` to generate some data for\n    the (subsequent) nested run.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NGRID\n        loc = NGRID(\n            sname=\"outnest\",\n            grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ngrid\", \"NGRID\"] = Field(\n        default=\"ngrid\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"NGRID grid definition\")\n\n    @field_validator(\"grid\")\n    @classmethod\n    def grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n        grid.suffix = \"n\"\n        return grid\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.grid.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ngrid', 'NGRID'] = Field(default='ngrid', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='NGRID grid definition')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID.grid_suffix","title":"grid_suffix  <code>classmethod</code>","text":"<pre><code>grid_suffix(grid: GRIDREGULAR) -&gt; GRIDREGULAR\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"grid\")\n@classmethod\ndef grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n    grid.suffix = \"n\"\n    return grid\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.grid.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED","title":"NGRID_UNSTRUCTURED","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations for a nested grid.</p> <p>.. code-block:: text</p> <pre><code>NGRID 'sname' UNSTRUCTURED -&gt;TRIANGLE|EASYMESH 'fname'\n</code></pre> <p>If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run is required. With this optional command <code>NGRID</code>, the user defines in the present coarse-grid run, a set of output locations along the boundary of the subsequent nested computational grid. The set of output locations thus defined is of the type NGRID.</p> <p>With this option the user indicates that the subsequent nested grid is unstructured Only grids generated by Triangle and Easymesh are supported by SWAN.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED--note","title":"Note","text":"<p>Command <code>NESTOUT</code> is required after this command <code>NGRID</code> to generate some data for the (subsequent) nested run.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NGRID_UNSTRUCTURED\nloc = NGRID_UNSTRUCTURED(sname=\"outnest\", kind=\"triangle\", fname=\"ngrid.txt\")\nprint(loc.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class NGRID_UNSTRUCTURED(BaseLocation):\n    \"\"\"Output locations for a nested grid.\n\n    .. code-block:: text\n\n        NGRID 'sname' UNSTRUCTURED -&gt;TRIANGLE|EASYMESH 'fname'\n\n    If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run\n    is required. With this optional command `NGRID`, the user defines in the present\n    coarse-grid run, a set of output locations along the boundary of the subsequent\n    nested computational grid. The set of output locations thus defined is of the type\n    NGRID.\n\n    With this option the user indicates that the subsequent nested grid is unstructured\n    Only grids generated by Triangle and Easymesh are supported by SWAN.\n\n    Note\n    ----\n    Command `NESTOUT` is required after this command `NGRID` to generate some data for\n    the (subsequent) nested run.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NGRID_UNSTRUCTURED\n        loc = NGRID_UNSTRUCTURED(sname=\"outnest\", kind=\"triangle\", fname=\"ngrid.txt\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ngrid_unstructured\", \"NGRID_UNSTRUCTURED\"] = Field(\n        default=\"ngrid_unstructured\", description=\"Model type discriminator\"\n    )\n    kind: Optional[Literal[\"triangle\", \"easymesh\"]] = Field(\n        default=\"triangle\",\n        description=(\n            \"Indicate if nested grid is generated by Triangle or Easymesh. The base \"\n            \"name of the grid specified in the `fname` parameter is used internally \"\n            \"by SWAN to define the `.node` and `.ele` files in case of the former or \"\n            \"the `.n` and `.e` files in case of the latter.\"\n        ),\n    )\n    fname: str = Field(\n        description=\"Basename of the required files, i.e. without extension\",\n        max_length=32,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"NGRID sname='{self.sname}' UNSTRUCTURED\"\n        if self.kind is not None:\n            repr += f\" {self.kind.upper()}\"\n        repr += f\" fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ngrid_unstructured', 'NGRID_UNSTRUCTURED'] = Field(default='ngrid_unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Optional[Literal['triangle', 'easymesh']] = Field(default='triangle', description='Indicate if nested grid is generated by Triangle or Easymesh. The base name of the grid specified in the `fname` parameter is used internally by SWAN to define the `.node` and `.ele` files in case of the former or the `.n` and `.e` files in case of the latter.')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Basename of the required files, i.e. without extension', max_length=32)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"NGRID sname='{self.sname}' UNSTRUCTURED\"\n    if self.kind is not None:\n        repr += f\" {self.kind.upper()}\"\n    repr += f\" fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/output/#settings","title":"Settings","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY","title":"QUANTITY","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Define output settings.</p> <p>.. code-block:: text</p> <pre><code>QUANTITY &lt; output &gt; 'short' 'long' [lexp] [hexp] [excv] [power] [ref] &amp;\n    [fswell] [fmin] [fmax] -&gt;PROBLEMCOORD|FRAME\n\nExamples:\n---------\nQUANTITY Xp hexp=100.\nQUANTITY HS TM01 RTMM10 excv=-9.\nQUANTITY HS TM02 FSPR fmin=0.03 fmax=0.5\nQUANTITY Hswell fswell=0.08\nQUANTITY Per short='Tm-1,0' power=0.\nQUANTITY Transp Force Frame\n</code></pre> <p>With this command the user can influence:</p> <ul> <li>The naming of output quantities</li> <li>The accuracy of writing output quantities</li> <li>The definition of some output quantities</li> <li>Reference direction for vectors</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note","title":"Note","text":"<p>The following data are accepted only in combination with some specific quantities:</p> <ul> <li>power</li> <li>ref</li> <li>fswell</li> <li>fmin</li> <li>fmax</li> <li>PROBLEMCOORD</li> <li>FRAME</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note_1","title":"Note","text":"<p>PROBLEMCOORD: Vector components are relative to the x- and y-axes of the problem coordinate system (see command <code>SET</code>):</p> <ul> <li>Directions are counterclockwise relative to the positive x-axis of the problem   coordinate system if Cartesian direction convention is used.</li> <li>Directions are relative to North (clockwise) if Nautical direction convention is   used.</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note_2","title":"Note","text":"<p>FRAME: If output is requested on sets created by command FRAME or automatically (see command <code>SET</code>) (<code>COMPGRID</code> or <code>BOTTGRID</code>):</p> <ul> <li>Vector components are relative to the x- and y-axes of the frame coordinate   system.</li> <li>Directions are counterclockwise relative to the positive x-axis of the frame   coordinate system if Cartesian direction convention is used.</li> <li>Directions are relative to North (clockwise) if Nautical direction convention   is used.</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import QUANTITY\nquant = QUANTITY(output=[\"xp\"], hexp=100)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\"], fswell=0.08)\nprint(quant.render())\nquant = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\nprint(quant.render())\nquant = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\nprint(quant.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class QUANTITY(BaseComponent):\n    \"\"\"Define output settings.\n\n    .. code-block:: text\n\n        QUANTITY &lt; output &gt; 'short' 'long' [lexp] [hexp] [excv] [power] [ref] &amp;\n            [fswell] [fmin] [fmax] -&gt;PROBLEMCOORD|FRAME\n\n        Examples:\n        ---------\n        QUANTITY Xp hexp=100.\n        QUANTITY HS TM01 RTMM10 excv=-9.\n        QUANTITY HS TM02 FSPR fmin=0.03 fmax=0.5\n        QUANTITY Hswell fswell=0.08\n        QUANTITY Per short='Tm-1,0' power=0.\n        QUANTITY Transp Force Frame\n\n    With this command the user can influence:\n\n    * The naming of output quantities\n    * The accuracy of writing output quantities\n    * The definition of some output quantities\n    * Reference direction for vectors\n\n    Note\n    ----\n    The following data are accepted only in combination with some specific quantities:\n\n    * power\n    * ref\n    * fswell\n    * fmin\n    * fmax\n    * PROBLEMCOORD\n    * FRAME\n\n    Note\n    ----\n    **PROBLEMCOORD**: Vector components are relative to the x- and y-axes of the\n    problem coordinate system (see command `SET`):\n\n    * Directions are counterclockwise relative to the positive x-axis of the problem\n      coordinate system if Cartesian direction convention is used.\n    * Directions are relative to North (clockwise) if Nautical direction convention is\n      used.\n\n    Note\n    ----\n    **FRAME**: If output is requested on sets created by command FRAME or\n    automatically (see command `SET`) (`COMPGRID` or `BOTTGRID`):\n\n    * Vector components are relative to the x- and y-axes of the frame coordinate\n      system.\n    * Directions are counterclockwise relative to the positive x-axis of the frame\n      coordinate system if Cartesian direction convention is used.\n    * Directions are relative to North (clockwise) if Nautical direction convention\n      is used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import QUANTITY\n        quant = QUANTITY(output=[\"xp\"], hexp=100)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\"], fswell=0.08)\n        print(quant.render())\n        quant = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\n        print(quant.render())\n        quant = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\n        print(quant.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quantity\", \"QUANTITY\"] = Field(\n        default=\"quantity\", description=\"Model type discriminator\"\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to define settings for\",\n        min_length=1,\n    )\n    short: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Short name of the output quantity (e.g. the name in the heading of a \"\n            \"table written by SWAN). If this option is not used, SWAN will use a \"\n            \"realistic name\"\n        ),\n        max_length=16,\n    )\n    long: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Long name of the output quantity (e.g. the name in the heading of a \"\n            \"block output written by SWAN). If this option is not used, SWAN will \"\n            \"use a realistic name\"\n        ),\n        max_length=16,\n    )\n    lexp: Optional[float] = Field(\n        default=None,\n        description=\"Lowest expected value of the output quantity\",\n    )\n    hexp: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Highest expected value of the output quantity; the highest expected \"\n            \"value is used by SWAN to determine the number of decimals in a table \"\n            \"with heading. So the `QUANTITY` command can be used in case the default \"\n            \"number of decimals in a table is unsatisfactory\"\n        ),\n    )\n    excv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"In case there is no valid value (e.g. wave height in a dry point) this \"\n            \"exception value is written in a table or block output\"\n        ),\n    )\n    power: Optional[float] = Field(\n        default=None,\n        description=(\n            \"power `p` appearing in the definition of `PER`, `RPER` and `WLEN`. Note \"\n            \"that the value for `power` given for `PER` affects also the value of \"\n            \"`RPER`; the power for `WLEN` is independent of that of `PER` or `RPER` \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    ref: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Reference time used for the quantity `TSEC`. Default value: starting \"\n            \"time of the first computation, except in cases where this is later than \"\n            \"the time of the earliest input. In these cases, the time of the earliest \"\n            \"input is used\"\n        ),\n    )\n    fswell: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit of frequency range used for computing the quantity HSWELL \"\n            \"(SWAN default: 0.1 Hz)\"\n        ),\n    )\n    noswll: Optional[int] = Field(\n        default=None,\n        description=(\"Number of swells to output for watershed quantities \"),\n    )\n    fmin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Lower limit of frequency range used for computing integral parameters \"\n            \"(SWAN Default: 0.0 Hz)\"\n        ),\n    )\n    fmax: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit of frequency range used for computing integral parameters \"\n            \"(SWAN default: 1000.0 Hz, acts as infinity)\"\n        ),\n    )\n    coord: Optional[Literal[\"problemcoord\", \"frame\"]] = Field(\n        default=None,\n        description=(\n            \"Define if vectors and directions refer to the problem coordinate system \"\n            \"('problemcoord') or sets created by command FRAME ('frame') \"\n            \"(SWAN default: problemcoord)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"QUANTITY\"\n        for output in self.output:\n            repr += f\" {output.upper()}\"\n        if self.short is not None:\n            repr += f\" short='{self.short}'\"\n        if self.long is not None:\n            repr += f\" long='{self.long}'\"\n        if self.lexp is not None:\n            repr += f\" lexp={self.lexp}\"\n        if self.hexp is not None:\n            repr += f\" hexp={self.hexp}\"\n        if self.excv is not None:\n            repr += f\" excv={self.excv}\"\n        if self.power is not None:\n            repr += f\" power={self.power}\"\n        if self.ref is not None:\n            repr += f\" ref='{self.ref}'\"\n        if self.fswell is not None:\n            repr += f\" fswell={self.fswell}\"\n        if self.noswll is not None:\n            repr += f\" noswll={self.noswll}\"\n        if self.fmin is not None:\n            repr += f\" fmin={self.fmin}\"\n        if self.fmax is not None:\n            repr += f\" fmax={self.fmax}\"\n        if self.coord is not None:\n            repr += f\" {self.coord.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quantity', 'QUANTITY'] = Field(default='quantity', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to define settings for', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.short","title":"short  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short: Optional[str] = Field(default=None, description='Short name of the output quantity (e.g. the name in the heading of a table written by SWAN). If this option is not used, SWAN will use a realistic name', max_length=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.long","title":"long  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>long: Optional[str] = Field(default=None, description='Long name of the output quantity (e.g. the name in the heading of a block output written by SWAN). If this option is not used, SWAN will use a realistic name', max_length=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.lexp","title":"lexp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lexp: Optional[float] = Field(default=None, description='Lowest expected value of the output quantity')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.hexp","title":"hexp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hexp: Optional[float] = Field(default=None, description='Highest expected value of the output quantity; the highest expected value is used by SWAN to determine the number of decimals in a table with heading. So the `QUANTITY` command can be used in case the default number of decimals in a table is unsatisfactory')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.excv","title":"excv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>excv: Optional[float] = Field(default=None, description='In case there is no valid value (e.g. wave height in a dry point) this exception value is written in a table or block output')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.power","title":"power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>power: Optional[float] = Field(default=None, description='power `p` appearing in the definition of `PER`, `RPER` and `WLEN`. Note that the value for `power` given for `PER` affects also the value of `RPER`; the power for `WLEN` is independent of that of `PER` or `RPER` (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref: Optional[str] = Field(default=None, description='Reference time used for the quantity `TSEC`. Default value: starting time of the first computation, except in cases where this is later than the time of the earliest input. In these cases, the time of the earliest input is used')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fswell","title":"fswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fswell: Optional[float] = Field(default=None, description='Upper limit of frequency range used for computing the quantity HSWELL (SWAN default: 0.1 Hz)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.noswll","title":"noswll  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>noswll: Optional[int] = Field(default=None, description='Number of swells to output for watershed quantities ')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fmin","title":"fmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmin: Optional[float] = Field(default=None, description='Lower limit of frequency range used for computing integral parameters (SWAN Default: 0.0 Hz)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fmax","title":"fmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmax: Optional[float] = Field(default=None, description='Upper limit of frequency range used for computing integral parameters (SWAN default: 1000.0 Hz, acts as infinity)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.coord","title":"coord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coord: Optional[Literal['problemcoord', 'frame']] = Field(default=None, description=\"Define if vectors and directions refer to the problem coordinate system ('problemcoord') or sets created by command FRAME ('frame') (SWAN default: problemcoord)\")\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"QUANTITY\"\n    for output in self.output:\n        repr += f\" {output.upper()}\"\n    if self.short is not None:\n        repr += f\" short='{self.short}'\"\n    if self.long is not None:\n        repr += f\" long='{self.long}'\"\n    if self.lexp is not None:\n        repr += f\" lexp={self.lexp}\"\n    if self.hexp is not None:\n        repr += f\" hexp={self.hexp}\"\n    if self.excv is not None:\n        repr += f\" excv={self.excv}\"\n    if self.power is not None:\n        repr += f\" power={self.power}\"\n    if self.ref is not None:\n        repr += f\" ref='{self.ref}'\"\n    if self.fswell is not None:\n        repr += f\" fswell={self.fswell}\"\n    if self.noswll is not None:\n        repr += f\" noswll={self.noswll}\"\n    if self.fmin is not None:\n        repr += f\" fmin={self.fmin}\"\n    if self.fmax is not None:\n        repr += f\" fmax={self.fmax}\"\n    if self.coord is not None:\n        repr += f\" {self.coord.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES","title":"QUANTITIES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Define output settings for multiple output.</p> <p>.. code-block:: text</p> <pre><code>QUANTITY &lt; output &gt; ...\nQUANTITY &lt; output &gt; ...\n..\n</code></pre> <p>This component can be used to prescribe and render multiple QUANTITY components.</p>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import QUANTITY, QUANTITIES\nq1 = QUANTITY(output=[\"xp\"], hexp=100)\nq2 = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\nq3 = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\nq4 = QUANTITY(output=[\"hsign\"], fswell=0.08)\nq5 = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\nq6 = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\nquantities = QUANTITIES(quantities=[q1, q2, q3, q4, q5, q6])\nprint(quantities.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class QUANTITIES(BaseComponent):\n    \"\"\"Define output settings for multiple output.\n\n    .. code-block:: text\n\n        QUANTITY &lt; output &gt; ...\n        QUANTITY &lt; output &gt; ...\n        ..\n\n    This component can be used to prescribe and render multiple QUANTITY components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import QUANTITY, QUANTITIES\n        q1 = QUANTITY(output=[\"xp\"], hexp=100)\n        q2 = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\n        q3 = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\n        q4 = QUANTITY(output=[\"hsign\"], fswell=0.08)\n        q5 = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\n        q6 = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\n        quantities = QUANTITIES(quantities=[q1, q2, q3, q4, q5, q6])\n        print(quantities.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quantities\", \"QUANTITIES\"] = Field(\n        default=\"quantities\", description=\"Model type discriminator\"\n    )\n    quantities: list[QUANTITY] = Field(description=\"QUANTITY components\")\n\n    def cmd(self) -&gt; list:\n        repr = []\n        for quantity in self.quantities:\n            repr += [quantity.cmd()]\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quantities', 'QUANTITIES'] = Field(default='quantities', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.quantities","title":"quantities  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantities: list[QUANTITY] = Field(description='QUANTITY components')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = []\n    for quantity in self.quantities:\n        repr += [quantity.cmd()]\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS","title":"OUTPUT_OPTIONS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Set format of output.</p> <p>.. code-block:: text</p> <pre><code>OUTPUT OPTIons 'comment' (TABLE [field]) (BLOCK [ndec] [len]) (SPEC [ndec])\n</code></pre> <p>This command enables the user to influence the format of block, table and spectral output.</p>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import OUTPUT_OPTIONS\nopts = OUTPUT_OPTIONS(\n    comment=\"!\", field=10, ndec_block=4, len=20, ndec_spec=6,\n)\nprint(opts.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class OUTPUT_OPTIONS(BaseComponent):\n    \"\"\"Set format of output.\n\n    .. code-block:: text\n\n        OUTPUT OPTIons 'comment' (TABLE [field]) (BLOCK [ndec] [len]) (SPEC [ndec])\n\n    This command enables the user to influence the format of block, table and spectral\n    output.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import OUTPUT_OPTIONS\n        opts = OUTPUT_OPTIONS(\n            comment=\"!\", field=10, ndec_block=4, len=20, ndec_spec=6,\n        )\n        print(opts.render())\n\n    \"\"\"\n\n    model_type: Literal[\"block\", \"BLOCK\"] = Field(\n        default=\"block\", description=\"Model type discriminator\"\n    )\n    comment: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Comment character used in comment lines in the output (SWAN default: %)\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    field: Optional[int] = Field(\n        default=None,\n        description=\"Length of one data field in a table (SWAN default: 12)\",\n        ge=8,\n        le=16,\n    )\n    ndec_block: Optional[int] = Field(\n        default=None,\n        description=\"Number of decimals in block output (SWAN default: 4)\",\n        ge=0,\n        le=9,\n    )\n    len: Optional[int] = Field(\n        default=None,\n        description=\"Number of data on one line of block output (SWAN default: 6)\",\n        ge=1,\n        le=9999,\n    )\n    ndec_spec: Optional[int] = Field(\n        default=None,\n        description=\"Number of decimals in spectra output (SWAN default: 4)\",\n        ge=0,\n        le=9,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"OUTPUT OPTIONS\"\n        if self.comment is not None:\n            repr += f\" comment='{self.comment}'\"\n        if self.field is not None:\n            repr += f\" TABLE field={self.field}\"\n        if self.ndec_block is not None or self.len is not None:\n            repr += \" BLOCK\"\n            if self.ndec_block is not None:\n                repr += f\" ndec={self.ndec_block}\"\n            if self.len is not None:\n                repr += f\" len={self.len}\"\n        if self.ndec_spec is not None:\n            repr += f\" SPEC ndec={self.ndec_spec}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['block', 'BLOCK'] = Field(default='block', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: Optional[str] = Field(default=None, description='Comment character used in comment lines in the output (SWAN default: %)', min_length=1, max_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[int] = Field(default=None, description='Length of one data field in a table (SWAN default: 12)', ge=8, le=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.ndec_block","title":"ndec_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ndec_block: Optional[int] = Field(default=None, description='Number of decimals in block output (SWAN default: 4)', ge=0, le=9)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.len","title":"len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>len: Optional[int] = Field(default=None, description='Number of data on one line of block output (SWAN default: 6)', ge=1, le=9999)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.ndec_spec","title":"ndec_spec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ndec_spec: Optional[int] = Field(default=None, description='Number of decimals in spectra output (SWAN default: 4)', ge=0, le=9)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"OUTPUT OPTIONS\"\n    if self.comment is not None:\n        repr += f\" comment='{self.comment}'\"\n    if self.field is not None:\n        repr += f\" TABLE field={self.field}\"\n    if self.ndec_block is not None or self.len is not None:\n        repr += \" BLOCK\"\n        if self.ndec_block is not None:\n            repr += f\" ndec={self.ndec_block}\"\n        if self.len is not None:\n            repr += f\" len={self.len}\"\n    if self.ndec_spec is not None:\n        repr += f\" SPEC ndec={self.ndec_spec}\"\n    return repr\n</code></pre>"},{"location":"components/output/#write","title":"Write","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite","title":"BaseWrite","text":"<p>               Bases: <code>BaseComponent</code>, <code>ABC</code></p> <p>Base class for SWAN output writing.</p> <p>.. code-block:: text</p> <pre><code>{MODEL_TYPE} sname='sname'\n</code></pre> <p>This is the base class for all write components. It is not meant to be used directly.</p>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BaseWrite\nwrite = BaseWrite(\n    sname=\"outgrid\",\n    fname=\"./output-grid.nc\",\n    times=dict(\n        tbeg=\"2012-01-01T00:00:00\",\n        delt=\"PT30M\",\n        tfmt=1,\n        dfmt=\"min\",\n        suffix=\"\",\n    )\n)\nprint(write.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class BaseWrite(BaseComponent, ABC):\n    \"\"\"Base class for SWAN output writing.\n\n    .. code-block:: text\n\n        {MODEL_TYPE} sname='sname'\n\n    This is the base class for all write components. It is not meant to be used\n    directly.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BaseWrite\n        write = BaseWrite(\n            sname=\"outgrid\",\n            fname=\"./output-grid.nc\",\n            times=dict(\n                tbeg=\"2012-01-01T00:00:00\",\n                delt=\"PT30M\",\n                tfmt=1,\n                dfmt=\"min\",\n                suffix=\"\",\n            )\n        )\n        print(write.render())\n\n    \"\"\"\n\n    model_type: Literal[\"write\", \"WRITE\"] = Field(\n        default=\"write\",\n        description=\"Model type discriminator\",\n    )\n    sname: str = Field(\n        description=(\n            \"Name of the set of output locations in which the output is to be written\"\n        ),\n        max_length=8,\n    )\n    fname: str = Field(\n        description=(\n            \"Name of the data file where the output is written to The file format is \"\n            \"defined by the file extension, use `.mat` for MATLAB binary (single \"\n            \"precision) or `.nc` for netCDF format. If any other extension is used \"\n            \"the ASCII format is assumed\"\n        ),\n    )\n    times: Optional[TimeRangeOpen] = Field(\n        default=None,\n        description=(\n            \"Time specification if the user requires output at various times. If this \"\n            \"option is not specified data will be written for the last time step of \"\n            \"the computation\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_special_names(self) -&gt; \"BaseWrite\":\n        special_names = (\"COMPGRID\", \"BOTTGRID\")\n        snames = self.sname if isinstance(self.sname, list) else [self.sname]\n        for sname in snames:\n            if sname in special_names and self.model_type.upper() != \"BLOCK\":\n                raise ValueError(f\"Special name {sname} is only supported with BLOCK\")\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_times(self) -&gt; \"BaseWrite\":\n        if self.times is not None:\n            self.times.suffix = self.suffix\n        return self\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['write', 'WRITE'] = Field(default='write', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.sname","title":"sname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sname: str = Field(description='Name of the set of output locations in which the output is to be written', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the data file where the output is written to The file format is defined by the file extension, use `.mat` for MATLAB binary (single precision) or `.nc` for netCDF format. If any other extension is used the ASCII format is assumed')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: Optional[TimeRangeOpen] = Field(default=None, description='Time specification if the user requires output at various times. If this option is not specified data will be written for the last time step of the computation')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite.validate_special_names","title":"validate_special_names","text":"<pre><code>validate_special_names() -&gt; BaseWrite\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_special_names(self) -&gt; \"BaseWrite\":\n    special_names = (\"COMPGRID\", \"BOTTGRID\")\n    snames = self.sname if isinstance(self.sname, list) else [self.sname]\n    for sname in snames:\n        if sname in special_names and self.model_type.upper() != \"BLOCK\":\n            raise ValueError(f\"Special name {sname} is only supported with BLOCK\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.validate_times","title":"validate_times","text":"<pre><code>validate_times() -&gt; BaseWrite\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_times(self) -&gt; \"BaseWrite\":\n    if self.times is not None:\n        self.times.suffix = self.suffix\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK","title":"BLOCK","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n    [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that one or more spatial distributions should be written to a file.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note","title":"Note","text":"<p>The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the <code>sname</code> field.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note_1","title":"Note","text":"<p>The text of the header indicates run identification (see command <code>PROJECT</code>), time, frame or group name ('sname'), variable and unit. The number of header lines is 8.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note_2","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BLOCK\nblock = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\nprint(block.render())\nblock = BLOCK(\n    sname=\"COMPGRID\",\n    header=False,\n    fname=\"./output-grid.nc\",\n    idla=3,\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(\n        tbeg=\"2012-01-01T00:00:00\",\n        delt=\"PT30M\",\n        tfmt=1,\n        dfmt=\"min\",\n        suffix=\"\",\n    )\n)\nprint(block.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class BLOCK(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n            [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that one or more spatial\n    distributions should be written to a file.\n\n    Note\n    ----\n    The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the `sname` field.\n\n    Note\n    ----\n    The text of the header indicates run identification (see command `PROJECT`), time,\n    frame or group name ('sname'), variable and unit. The number of header lines is 8.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BLOCK\n        block = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\n        print(block.render())\n        block = BLOCK(\n            sname=\"COMPGRID\",\n            header=False,\n            fname=\"./output-grid.nc\",\n            idla=3,\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(\n                tbeg=\"2012-01-01T00:00:00\",\n                delt=\"PT30M\",\n                tfmt=1,\n                dfmt=\"min\",\n                suffix=\"\",\n            )\n        )\n        print(block.render())\n\n    \"\"\"\n\n    model_type: Literal[\"block\", \"BLOCK\"] = Field(\n        default=\"block\", description=\"Model type discriminator\"\n    )\n    header: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Indicate if the output should be written to a file with header lines \"\n            \"(SWAN default: True)\"\n        ),\n    )\n    idla: Optional[IDLA] = Field(\n        default=None,\n        description=(\n            \"Prescribe the lay-out of the output to file (supported options here are \"\n            \"1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by \"\n            \"MATLAB, however option 3 is recommended in case of binary MATLAB output \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n    unit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of the output. The program divides computed values \"\n            \"by `unit` before writing to file, so the user should multiply the \"\n            \"written value by `unit` to obtain the proper value. By default, if \"\n            \"HEADER is selected, value is written as a 5 position integer. SWAN takes \"\n            \"`unit` such that the largest number occurring in the block can be \"\n            \"printed. If NOHEADER is selected, values are printed in floating-point \"\n            \"format by default (`unit=1`)\"\n        ),\n    )\n\n    @field_validator(\"idla\")\n    @classmethod\n    def validate_idla(cls, idla: IDLA) -&gt; IDLA:\n        if idla is not None and idla not in (1, 3, 4):\n            raise ValueError(\n                f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n            )\n        return idla\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"blk\"\n\n    @property\n    def _header(self) -&gt; str:\n        \"\"\"Render the header instruction.\"\"\"\n        if self.header:\n            return \"HEADER\"\n        else:\n            return \"NOHEADER\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"BLOCK sname='{self.sname}'\"\n        if self.header is not None:\n            repr += f\" {self._header}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.idla is not None:\n            repr += f\" LAYOUT idla={self.idla}\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.unit is not None:\n            repr += f\"\\nunit={self.unit}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BLOCK.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['block', 'BLOCK'] = Field(default='block', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: Optional[bool] = Field(default=None, description='Indicate if the output should be written to a file with header lines (SWAN default: True)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[IDLA] = Field(default=None, description='Prescribe the lay-out of the output to file (supported options here are 1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by MATLAB, however option 3 is recommended in case of binary MATLAB output (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: Optional[float] = Field(default=None, description='Controls the scaling of the output. The program divides computed values by `unit` before writing to file, so the user should multiply the written value by `unit` to obtain the proper value. By default, if HEADER is selected, value is written as a 5 position integer. SWAN takes `unit` such that the largest number occurring in the block can be printed. If NOHEADER is selected, values are printed in floating-point format by default (`unit=1`)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BLOCK.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(idla: IDLA) -&gt; IDLA\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"idla\")\n@classmethod\ndef validate_idla(cls, idla: IDLA) -&gt; IDLA:\n    if idla is not None and idla not in (1, 3, 4):\n        raise ValueError(\n            f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n        )\n    return idla\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"BLOCK sname='{self.sname}'\"\n    if self.header is not None:\n        repr += f\" {self._header}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.idla is not None:\n        repr += f\" LAYOUT idla={self.idla}\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.unit is not None:\n        repr += f\"\\nunit={self.unit}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE","title":"TABLE","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n    (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) one or more variables should be written to a file. The keywords <code>HEADER</code> and <code>NOHEADER</code> determine the appearance of the table; the filename determines the destination of the data.</p>"},{"location":"components/output/#rompy_swan.components.output.TABLE--note","title":"Note","text":"<p>HEADER: output is written in fixed format to file with headers giving name of variable and unit per column (numbers too large to be written will be shown as <code>****</code>. The number of header lines is 4.</p> <p>NOHEADER: output is written in floating point format to file and has no headers.</p> <p>INDEXED: output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should give two TABLE commands, one to produce one file with <code>XP</code> and <code>YP</code> as output quantities, the other with <code>HS</code>, <code>RTM01</code> or other output quantities.</p>"},{"location":"components/output/#rompy_swan.components.output.TABLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import TABLE\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./output_table.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(table.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class TABLE(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n            (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) one or\n    more variables should be written to a file. The keywords `HEADER` and `NOHEADER`\n    determine the appearance of the table; the filename determines the destination of\n    the data.\n\n    Note\n    ----\n    **HEADER**:\n    output is written in fixed format to file with headers giving name of variable\n    and unit per column (numbers too large to be written will be shown as `****`.\n    The number of header lines is 4.\n\n    **NOHEADER**:\n    output is written in floating point format to file and has no headers.\n\n    **INDEXED**:\n    output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should\n    give two TABLE commands, one to produce one file with `XP` and `YP` as output\n    quantities, the other with `HS`, `RTM01` or other output quantities.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import TABLE\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./output_table.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(table.render())\n\n    \"\"\"\n\n    model_type: Literal[\"table\", \"TABLE\"] = Field(\n        default=\"table\", description=\"Model type discriminator\"\n    )\n    format: Optional[Literal[\"header\", \"noheader\", \"indexed\"]] = Field(\n        default=None,\n        description=(\n            \"Indicate if the table should be written to a file as a HEADER, NOHEADER \"\n            \"or INDEXED table format (SWAN default: HEADER)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"tbl\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"TABLE sname='{self.sname}'\"\n        if self.format is not None:\n            repr += f\" {self.format.upper()}\"\n        repr += f\" fname='{self.fname}'\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.TABLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['table', 'TABLE'] = Field(default='table', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[Literal['header', 'noheader', 'indexed']] = Field(default=None, description='Indicate if the table should be written to a file as a HEADER, NOHEADER or INDEXED table format (SWAN default: HEADER)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.TABLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"TABLE sname='{self.sname}'\"\n    if self.format is not None:\n        repr += f\" {self.format.upper()}\"\n    repr += f\" fname='{self.fname}'\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT","title":"SPECOUT","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write to data file the wave spectra.</p> <p>.. code-block:: text</p> <pre><code>SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n    (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) the 1D or 2D variance / energy (see command <code>SET</code>) density spectrum (either the relative frequency or the absolute frequency spectrum) is to be written to a data file.</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--note","title":"Note","text":"<p>This write command supports the following location types: <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> and <code>GROUP</code>.</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--note_1","title":"Note","text":"<p>This output file can be used for defining boundary conditions for subsequent SWAN runs (command <code>BOUNDSPEC</code>).</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import SPECOUT\nout = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\nprint(out.render())\nout = SPECOUT(\n    sname=\"outpts\",\n    dim=dict(model_type=\"spec2d\"),\n    freq=dict(model_type=\"rel\"),\n    fname=\"./specout.nc\",\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(out.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class SPECOUT(BaseWrite):\n    \"\"\"Write to data file the wave spectra.\n\n    .. code-block:: text\n\n        SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n            (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) the 1D\n    or 2D variance / energy (see command `SET`) density spectrum (either the relative\n    frequency or the absolute frequency spectrum) is to be written to a data file.\n\n    Note\n    ----\n    This write command supports the following location types: `POINTS`, `CURVE`,\n    `FRAME` and `GROUP`.\n\n    Note\n    ----\n    This output file can be used for defining boundary conditions for subsequent SWAN\n    runs (command `BOUNDSPEC`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import SPECOUT\n        out = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\n        print(out.render())\n        out = SPECOUT(\n            sname=\"outpts\",\n            dim=dict(model_type=\"spec2d\"),\n            freq=dict(model_type=\"rel\"),\n            fname=\"./specout.nc\",\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"specout\", \"SPECOUT\"] = Field(\n        default=\"specout\", description=\"Model type discriminator\"\n    )\n    dim: Optional[DIM_TYPE] = Field(default=None)\n    freq: Optional[FREQ_TYPE] = Field(default=None)\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"spc\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"SPECOUT sname='{self.sname}'\"\n        if self.dim is not None:\n            repr += f\" {self.dim.render()}\"\n        if self.freq is not None:\n            repr += f\" {self.freq.render()}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.times is not None:\n            repr += f\" OUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.SPECOUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['specout', 'SPECOUT'] = Field(default='specout', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Optional[DIM_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.freq","title":"freq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freq: Optional[FREQ_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.SPECOUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"SPECOUT sname='{self.sname}'\"\n    if self.dim is not None:\n        repr += f\" {self.dim.render()}\"\n    if self.freq is not None:\n        repr += f\" {self.freq.render()}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.times is not None:\n        repr += f\" OUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT","title":"NESTOUT","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write to 2D boundary spectra.</p> <p>.. code-block:: text</p> <pre><code>NESTOUT 'sname' 'fname' (OUTPUT [tbegnst] [deltnst] -&gt;SEC|MIN|HR|DAY)\n</code></pre> <p>Write to data file two-dimensional action density spectra (relative frequency) along the boundary of a nested grid (see command NGRID) to be used in a subsequent SWAN run.</p>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NESTOUT\nout = NESTOUT(\n    sname=\"outnest\",\n    fname=\"./nestout.swn\",\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(out.render())\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class NESTOUT(BaseWrite):\n    \"\"\"Write to 2D boundary spectra.\n\n    .. code-block:: text\n\n        NESTOUT 'sname' 'fname' (OUTPUT [tbegnst] [deltnst] -&gt;SEC|MIN|HR|DAY)\n\n    Write to data file two-dimensional action density spectra (relative frequency)\n    along the boundary of a nested grid (see command NGRID) to be used in a subsequent\n    SWAN run.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NESTOUT\n        out = NESTOUT(\n            sname=\"outnest\",\n            fname=\"./nestout.swn\",\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nestout\", \"NESTOUT\"] = Field(\n        default=\"nestout\", description=\"Model type discriminator\"\n    )\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"nst\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"NESTOUT sname='{self.sname}' fname='{self.fname}'\"\n        if self.times is not None:\n            repr += f\" OUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NESTOUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nestout', 'NESTOUT'] = Field(default='nestout', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NESTOUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"NESTOUT sname='{self.sname}' fname='{self.fname}'\"\n    if self.times is not None:\n        repr += f\" OUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST","title":"TEST","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Write intermediate results.</p> <p>.. code-block:: text</p> <pre><code>TEST [itest] [itrace] POINTS XY|IJ (PAR 'fname') (S1D 'fname') (S2D 'fname')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST--note","title":"Note","text":"<p>The 6 source terms written due to the presence of the keyword S1D or S2D are: wind input, whitecapping, bottom friction, breaking, 3- and 4- wave interactions.</p>"},{"location":"components/output/#rompy_swan.components.output.TEST--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import TEST\ntest = TEST(\n    itest=10,\n    points=dict(model_type=\"ij\", i=[0, 0], j=[10, 20]),\n    fname_par=\"integral_parameters.test\",\n    fname_s1d=\"1d_variance_density.test\",\n    fname_s2d=\"2d_variance_density.test\",\n)\nprint(test.render())\nimport numpy as np\ntest = TEST(\n    points=dict(\n        model_type=\"xy\",\n        x=np.linspace(172.5, 174.0, 25),\n        y=25*[-38],\n    ),\n    fname_s2d=\"2d_variance_density.test\",\n)\nprint(test.render())\n</code></pre> <p>TODO: Support <code>k</code> in POINTS IJ.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>class TEST(BaseComponent):\n    \"\"\"Write intermediate results.\n\n    .. code-block:: text\n\n        TEST [itest] [itrace] POINTS XY|IJ (PAR 'fname') (S1D 'fname') (S2D 'fname')\n\n    Note\n    ----\n    The 6 source terms written due to the presence of the keyword S1D or S2D are: wind\n    input, whitecapping, bottom friction, breaking, 3- and 4- wave interactions.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import TEST\n        test = TEST(\n            itest=10,\n            points=dict(model_type=\"ij\", i=[0, 0], j=[10, 20]),\n            fname_par=\"integral_parameters.test\",\n            fname_s1d=\"1d_variance_density.test\",\n            fname_s2d=\"2d_variance_density.test\",\n        )\n        print(test.render())\n        import numpy as np\n        test = TEST(\n            points=dict(\n                model_type=\"xy\",\n                x=np.linspace(172.5, 174.0, 25),\n                y=25*[-38],\n            ),\n            fname_s2d=\"2d_variance_density.test\",\n        )\n        print(test.render())\n\n    TODO: Support `k` in POINTS IJ.\n\n    \"\"\"\n\n    model_type: Literal[\"test\", \"TEST\"] = Field(\n        default=\"test\", description=\"Model type discriminator\"\n    )\n    itest: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The level of test output, for values under 100 the amount is usually \"\n            \"reasonable, for values above 200 it can be very large. Values of up to \"\n            \"50 can be interpreted by the user (SWAN default: 1)\"\n        ),\n    )\n    itrace: Optional[int] = Field(\n        default=None,\n        description=(\n            \"SWAN writes a message (name of subroutine) to the PRINT file at the \"\n            \"first `itrace` entries of each subroutine (SWAN default: 0)\"\n        ),\n    )\n    points: Union[XY, IJ] = Field(\n        description=\"Points where detailed print output is produced (max of 50 points)\",\n        discriminator=\"model_type\",\n    )\n    fname_par: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file where the integral parameters are written to\",\n    )\n    fname_par: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file where the integral parameters are written to\",\n    )\n    fname_s1d: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the file where the 1D variance density and 6 source terms are \"\n            \"written to\"\n        ),\n    )\n    fname_s2d: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the file where the 2D variance density and 6 source terms are \"\n            \"written to\"\n        ),\n    )\n\n    @field_validator(\"points\")\n    @classmethod\n    def validate_points(cls, points: Union[XY, IJ]) -&gt; Union[XY, IJ]:\n        if points.size &gt; 50:\n            raise ValueError(f\"Maximum of 50 points allowed in TEST, got {points.size}\")\n        return points\n\n    @model_validator(mode=\"after\")\n    def at_least_one(self) -&gt; \"TEST\":\n        \"\"\"Warns if no test file is being specified.\"\"\"\n        if all(v is None for v in [self.fname_par, self.fname_s1d, self.fname_s2d]):\n            logger.warning(\n                \"TEST command prescribed with no output files, please ensure at least \"\n                \"one of ()`fname_par`, `fname_s1d` or `fname_s2d`) is specified\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TEST\"\n        if self.itest is not None:\n            repr += f\" itest={self.itest}\"\n        if self.itrace is not None:\n            repr += f\" itrace={self.itrace}\"\n        repr += f\" POINTS {self.points.model_type.upper()}{self.points.render()}\"\n        if self.fname_par is not None:\n            repr += f\"PAR fname='{self.fname_par}' \"\n        if self.fname_s1d is not None:\n            repr += f\"S1D fname='{self.fname_s1d}' \"\n        if self.fname_s2d is not None:\n            repr += f\"S2D fname='{self.fname_s2d}' \"\n        return repr.rstrip()\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.TEST.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['test', 'TEST'] = Field(default='test', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.itest","title":"itest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itest: Optional[int] = Field(default=None, description='The level of test output, for values under 100 the amount is usually reasonable, for values above 200 it can be very large. Values of up to 50 can be interpreted by the user (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.itrace","title":"itrace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itrace: Optional[int] = Field(default=None, description='SWAN writes a message (name of subroutine) to the PRINT file at the first `itrace` entries of each subroutine (SWAN default: 0)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Union[XY, IJ] = Field(description='Points where detailed print output is produced (max of 50 points)', discriminator='model_type')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_par","title":"fname_par  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_par: Optional[str] = Field(default=None, description='Name of the file where the integral parameters are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_s1d","title":"fname_s1d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_s1d: Optional[str] = Field(default=None, description='Name of the file where the 1D variance density and 6 source terms are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_s2d","title":"fname_s2d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_s2d: Optional[str] = Field(default=None, description='Name of the file where the 2D variance density and 6 source terms are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.TEST.validate_points","title":"validate_points  <code>classmethod</code>","text":"<pre><code>validate_points(points: Union[XY, IJ]) -&gt; Union[XY, IJ]\n</code></pre> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@field_validator(\"points\")\n@classmethod\ndef validate_points(cls, points: Union[XY, IJ]) -&gt; Union[XY, IJ]:\n    if points.size &gt; 50:\n        raise ValueError(f\"Maximum of 50 points allowed in TEST, got {points.size}\")\n    return points\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.at_least_one","title":"at_least_one","text":"<pre><code>at_least_one() -&gt; TEST\n</code></pre> <p>Warns if no test file is being specified.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef at_least_one(self) -&gt; \"TEST\":\n    \"\"\"Warns if no test file is being specified.\"\"\"\n    if all(v is None for v in [self.fname_par, self.fname_s1d, self.fname_s2d]):\n        logger.warning(\n            \"TEST command prescribed with no output files, please ensure at least \"\n            \"one of ()`fname_par`, `fname_s1d` or `fname_s2d`) is specified\"\n        )\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TEST\"\n    if self.itest is not None:\n        repr += f\" itest={self.itest}\"\n    if self.itrace is not None:\n        repr += f\" itrace={self.itrace}\"\n    repr += f\" POINTS {self.points.model_type.upper()}{self.points.render()}\"\n    if self.fname_par is not None:\n        repr += f\"PAR fname='{self.fname_par}' \"\n    if self.fname_s1d is not None:\n        repr += f\"S1D fname='{self.fname_s1d}' \"\n    if self.fname_s2d is not None:\n        repr += f\"S2D fname='{self.fname_s2d}' \"\n    return repr.rstrip()\n</code></pre>"},{"location":"components/physics/","title":"Physics","text":"<p>SWAN physics commands control the physical processes in wave simulations. These include wave generation by wind, energy dissipation (whitecapping, bottom friction, depth-induced breaking), and nonlinear wave-wave interactions.</p> <p>Default Physics</p> <p>By default, SWAN activates third-generation physics (<code>GEN3</code>) which includes wind input, whitecapping, quadruplet interactions, and bottom friction. You can selectively disable processes using the <code>OFF</code> commands or customize individual formulations.</p>"},{"location":"components/physics/#generation","title":"Generation","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1","title":"GEN1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>First generation source terms GEN1.</p> <p>.. code-block:: text</p> <pre><code>GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in first-generation mode (see Scientific/Technical documentation).</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN1\ngen = GEN1()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN1(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN1(BaseComponent):\n    \"\"\"First generation source terms GEN1.\n\n    .. code-block:: text\n\n        GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in first-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN1\n        gen = GEN1()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN1(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen1\", \"GEN1\"] = Field(\n        default=\"gen1\", description=\"Model type discriminator\"\n    )\n    cf10: Optional[float] = Field(\n        default=None,\n        description=\"Controls the linear wave growth (SWAN default: 188.0)\",\n    )\n    cf20: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.59)\",\n    )\n    cf30: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.12)\",\n    )\n    cf40: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the dissipation rate, i.e., the time decay scale \"\n            \"(SWAN default: 250.0)\"\n        ),\n    )\n    edmlpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum non-dimensionless energy density of the wind sea part of the \"\n            \"spectrum according to Pierson Moskowitz (SWAN default: 0.0036)\"\n        ),\n    )\n    cdrag: Optional[float] = Field(\n        default=None, description=\"Drag coefficient (SWAN default: 0.0012)\"\n    )\n    umin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Minimum wind velocity (relative to current; all wind speeds \"\n            \"are taken at 10 m above sea level) (SWAN default: 1)\"\n        ),\n    )\n    cfpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the Pierson Moskowitz frequency: \"\n            \"`delta_PM = 2pi g / U_10` (SWAN default: 0.13)\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN1\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen1', 'GEN1'] = Field(default='gen1', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf10","title":"cf10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf10: Optional[float] = Field(default=None, description='Controls the linear wave growth (SWAN default: 188.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf20","title":"cf20  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf20: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.59)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf30","title":"cf30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf30: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.12)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf40","title":"cf40  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf40: Optional[float] = Field(default=None, description='Controls the dissipation rate, i.e., the time decay scale (SWAN default: 250.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.edmlpm","title":"edmlpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>edmlpm: Optional[float] = Field(default=None, description='Maximum non-dimensionless energy density of the wind sea part of the spectrum according to Pierson Moskowitz (SWAN default: 0.0036)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cdrag","title":"cdrag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdrag: Optional[float] = Field(default=None, description='Drag coefficient (SWAN default: 0.0012)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.umin","title":"umin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>umin: Optional[float] = Field(default=None, description='Minimum wind velocity (relative to current; all wind speeds are taken at 10 m above sea level) (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cfpm","title":"cfpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfpm: Optional[float] = Field(default=None, description='Coefficient which determines the Pierson Moskowitz frequency: `delta_PM = 2pi g / U_10` (SWAN default: 0.13)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN1\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2","title":"GEN2","text":"<p>               Bases: <code>GEN1</code></p> <p>Second generation source terms GEN2.</p> <p>.. code-block:: text</p> <pre><code>GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in second-generation mode (see Scientific/Technical documentation).</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN2\ngen = GEN2()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    cf50=0.0023,\n    cf60=-0.223,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN2(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN2(GEN1):\n    \"\"\"Second generation source terms GEN2.\n\n    .. code-block:: text\n\n        GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in second-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN2\n        gen = GEN2()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            cf50=0.0023,\n            cf60=-0.223,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN2(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen2\", \"GEN2\"] = Field(\n        default=\"gen2\", description=\"Model type discriminator\"\n    )\n    cf50: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: 0.0023)\"\n        ),\n    )\n    cf60: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Ccontrols the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: -0.223\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN2\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.cf50 is not None:\n            repr += f\" cf50={self.cf50}\"\n        if self.cf60 is not None:\n            repr += f\" cf60={self.cf60}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen2', 'GEN2'] = Field(default='gen2', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cf50","title":"cf50  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf50: Optional[float] = Field(default=None, description='Controls the spectral energy scale of the limit spectrum (SWAN default: 0.0023)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cf60","title":"cf60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf60: Optional[float] = Field(default=None, description='Ccontrols the spectral energy scale of the limit spectrum (SWAN default: -0.223')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN2\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.cf50 is not None:\n        repr += f\" cf50={self.cf50}\"\n    if self.cf60 is not None:\n        repr += f\" cf60={self.cf60}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3","title":"GEN3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Third generation source terms GEN3.</p> <p>.. code-block:: text</p> <pre><code>GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n</code></pre> <p>With this command the user indicates that SWAN should run in third-generation mode for wind input, quadruplet interactions and whitecapping.</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN3\ngen = GEN3(\n    source_terms=dict(\n        model_type=\"westhuysen\",\n        wind_drag=\"wu\",\n        agrow=True,\n    ),\n)\nprint(gen.render())\nfrom rompy_swan.subcomponents.physics import ST6C1\ngen = GEN3(source_terms=ST6C1())\nprint(gen.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class GEN3(BaseComponent):\n    \"\"\"Third generation source terms GEN3.\n\n    .. code-block:: text\n\n        GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n\n    With this command the user indicates that SWAN should run in third-generation mode\n    for wind input, quadruplet interactions and whitecapping.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN3\n        gen = GEN3(\n            source_terms=dict(\n                model_type=\"westhuysen\",\n                wind_drag=\"wu\",\n                agrow=True,\n            ),\n        )\n        print(gen.render())\n        from rompy_swan.subcomponents.physics import ST6C1\n        gen = GEN3(source_terms=ST6C1())\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen3\", \"GEN3\"] = Field(\n        default=\"gen3\", description=\"Model type discriminator\"\n    )\n    source_terms: SOURCE_TERMS = Field(\n        default_factory=WESTHUYSEN,\n        description=\"SWAN source terms to be used (SWAN default: WESTHUYSEN)\",\n        discriminator=\"model_type\",\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = f\"GEN3 {self.source_terms.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen3', 'GEN3'] = Field(default='gen3', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3.source_terms","title":"source_terms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_terms: SOURCE_TERMS = Field(default_factory=WESTHUYSEN, description='SWAN source terms to be used (SWAN default: WESTHUYSEN)', discriminator='model_type')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN3.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = f\"GEN3 {self.source_terms.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#swell-dissipation","title":"Swell dissipation","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP","title":"NEGATINP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Negative wind input.</p> <p>.. code-block:: text</p> <pre><code>NEGATINP [rdcoef]\n</code></pre> <p>With this optional command the user activates negative wind input. This is intended only for use with non-breaking swell dissipation SSWELL ZIEGER. Parameter <code>rdcoef</code> is a fraction between 0 and 1, representing the strength of negative wind input. As an example, with [rdcoef]=0.04, for a spectral bin that is opposed to the wind direction, the wind input factor W(k, \u03b8) is negative, and its magnitude is 4% of the corresponding value of the spectral bin that is in the opposite direction (i.e. in the wind direction). See Zieger et al. (2015) eq. 11, where a0 is their notation for [rdcoef]. Default [rdcoef]=0.0 and <code>rdcoef=0.04</code> is recommended, though as implied by Zieger et al. (2015), this value is not well-established, so the user is encouraged to experiment with other values.</p>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP--references","title":"References","text":"<p>Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96, pp.2-25.</p>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import NEGATINP\nnegatinp = NEGATINP()\nprint(negatinp.render())\nnegatinp = NEGATINP(rdcoef=0.04)\nprint(negatinp.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class NEGATINP(BaseComponent):\n    \"\"\"Negative wind input.\n\n    .. code-block:: text\n\n        NEGATINP [rdcoef]\n\n    With this optional command the user activates negative wind input. **This is\n    intended only for use with non-breaking swell dissipation SSWELL ZIEGER**.\n    Parameter `rdcoef` is a fraction between 0 and 1, representing the strength of\n    negative wind input. As an example, with [rdcoef]=0.04, for a spectral bin that is\n    opposed to the wind direction, the wind input factor W(k, \u03b8) is negative, and its\n    magnitude is 4% of the corresponding value of the spectral bin that is in the\n    opposite direction (i.e. in the wind direction). See Zieger et al. (2015) eq. 11,\n    where a0 is their notation for [rdcoef]. Default [rdcoef]=0.0 and `rdcoef=0.04` is\n    recommended, though as implied by Zieger et al. (2015), this value is not\n    well-established, so the user is encouraged to experiment with other values.\n\n    References\n    ----------\n    Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based\n    source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96,\n    pp.2-25.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import NEGATINP\n        negatinp = NEGATINP()\n        print(negatinp.render())\n        negatinp = NEGATINP(rdcoef=0.04)\n        print(negatinp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"negatinp\", \"NEGATINP\"] = Field(\n        default=\"negatinp\", description=\"Model type discriminator\"\n    )\n    rdcoef: Optional[float] = Field(\n        default=None,\n        description=\"Coefficient representing the strength of negative wind input\",\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NEGATINP\"\n        if self.rdcoef is not None:\n            repr += f\" rdcoef={self.rdcoef}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['negatinp', 'NEGATINP'] = Field(default='negatinp', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.rdcoef","title":"rdcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rdcoef: Optional[float] = Field(default=None, description='Coefficient representing the strength of negative wind input', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NEGATINP\"\n    if self.rdcoef is not None:\n        repr += f\" rdcoef={self.rdcoef}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN","title":"SSWELL_ARDHUIN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Ardhuin et al. (2010).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ARDHUIN [cdsv]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN--references","title":"References","text":"<p>Ardhuin, F., Rogers, E., Babanin, A.V., Filipot, J.F., Magne, R., Roland, A., Van Der Westhuysen, A., Queffeulou, P., Lefevre, J.M., Aouf, L. and Collard, F., 2010. Semiempirical dissipation source functions for ocean waves. Part I: Definition, calibration, and validation. Journal of Physical Oceanography, 40(9), pp.1917-1941.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ARDHUIN\nsswell = SSWELL_ARDHUIN()\nprint(sswell.render())\nsswell = SSWELL_ARDHUIN(cdsv=1.2)\nprint(sswell.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ARDHUIN(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Ardhuin et al. (2010).\n\n    .. code-block:: text\n\n        SSWELL ARDHUIN [cdsv]\n\n    References\n    ----------\n    Ardhuin, F., Rogers, E., Babanin, A.V., Filipot, J.F., Magne, R., Roland, A.,\n    Van Der Westhuysen, A., Queffeulou, P., Lefevre, J.M., Aouf, L. and Collard, F.,\n    2010. Semiempirical dissipation source functions for ocean waves. Part I:\n    Definition, calibration, and validation. Journal of Physical Oceanography, 40(9),\n    pp.1917-1941.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ARDHUIN\n        sswell = SSWELL_ARDHUIN()\n        print(sswell.render())\n        sswell = SSWELL_ARDHUIN(cdsv=1.2)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ardhuin\", \"ARDHUIN\"] = Field(\n        default=\"ardhuin\", description=\"Model type discriminator\"\n    )\n    cdsv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient related to laminar atmospheric boundary layer \"\n            \"(SWAN default: 1.2)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ARDHUIN\"\n        if self.cdsv is not None:\n            repr += f\" cdsv={self.cdsv}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ardhuin', 'ARDHUIN'] = Field(default='ardhuin', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.cdsv","title":"cdsv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdsv: Optional[float] = Field(default=None, description='Coefficient related to laminar atmospheric boundary layer (SWAN default: 1.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ARDHUIN\"\n    if self.cdsv is not None:\n        repr += f\" cdsv={self.cdsv}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER","title":"SSWELL_ZIEGER","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Zieger et al. (2015).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ZIEGER [b1]\n</code></pre> <p>Swell dissipation of Young et al. (2013) updated by Zieger et al. (2015). The Zieger option is intended for use with negative wind input via the NEGATINP command. Zieger non-breaking dissipation follows the method used in WAVEWATCH III version 4 and does not include the steepness-dependent swell coefficient introduced in WAVEWATCH III version 5.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER--references","title":"References","text":"<p>Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96, pp.2-25.</p> <p>Young, I.R., Babanin, A.V. and Zieger, S., 2013. The decay rate of ocean swell observed by altimeter. Journal of physical oceanography, 43(11), pp.2322-2333.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ZIEGER\nsswell = SSWELL_ZIEGER()\nprint(sswell.render())\nsswell = SSWELL_ZIEGER(b1=0.00025)\nprint(sswell.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ZIEGER(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Zieger et al. (2015).\n\n    .. code-block:: text\n\n        SSWELL ZIEGER [b1]\n\n    Swell dissipation of Young et al. (2013) updated by Zieger et al. (2015). The\n    Zieger option is intended for use with negative wind input via the NEGATINP\n    command. Zieger non-breaking dissipation follows the method used in WAVEWATCH III\n    version 4 and does not include the steepness-dependent swell coefficient introduced\n    in WAVEWATCH III version 5.\n\n    References\n    ----------\n    Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based\n    source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96,\n    pp.2-25.\n\n    Young, I.R., Babanin, A.V. and Zieger, S., 2013. The decay rate of ocean swell\n    observed by altimeter. Journal of physical oceanography, 43(11), pp.2322-2333.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ZIEGER\n        sswell = SSWELL_ZIEGER()\n        print(sswell.render())\n        sswell = SSWELL_ZIEGER(b1=0.00025)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"zieger\", \"ZIEGER\"] = Field(\n        default=\"zieger\", description=\"Model type discriminator\"\n    )\n    b1: Optional[float] = Field(\n        default=None,\n        description=\"Non-dimensional proportionality coefficient \"\n        \"(SWAN default: 0.00025)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ZIEGER\"\n        if self.b1 is not None:\n            repr += f\" b1={self.b1}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['zieger', 'ZIEGER'] = Field(default='zieger', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.b1","title":"b1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b1: Optional[float] = Field(default=None, description='Non-dimensional proportionality coefficient (SWAN default: 0.00025)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ZIEGER\"\n    if self.b1 is not None:\n        repr += f\" b1={self.b1}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS","title":"SSWELL_ROGERS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Rogers et al. (2012).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ROGERS [cdsv] [feswell]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS--references","title":"References","text":"<p>Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and whitecapping dissipation in a model for wind-generated surface waves: Description and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9), pp.1329-1346.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ROGERS\nsswell = SSWELL_ROGERS()\nprint(sswell.render())\nsswell = SSWELL_ROGERS(cdsv=1.2, feswell=0.5)\nprint(sswell.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ROGERS(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Rogers et al. (2012).\n\n    .. code-block:: text\n\n        SSWELL ROGERS [cdsv] [feswell]\n\n    References\n    ----------\n    Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and\n    whitecapping dissipation in a model for wind-generated surface waves: Description\n    and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9),\n    pp.1329-1346.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ROGERS\n        sswell = SSWELL_ROGERS()\n        print(sswell.render())\n        sswell = SSWELL_ROGERS(cdsv=1.2, feswell=0.5)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rogers\", \"ROGERS\"] = Field(\n        default=\"rogers\", description=\"Model type discriminator\"\n    )\n    cdsv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient related to laminar atmospheric boundary layer \"\n            \"(SWAN default: 1.2)\"\n        ),\n    )\n    feswell: Optional[float] = Field(\n        default=None, description=\"Swell dissipation factor\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ROGERS\"\n        if self.cdsv is not None:\n            repr += f\" cdsv={self.cdsv}\"\n        if self.feswell is not None:\n            repr += f\" feswell={self.feswell}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rogers', 'ROGERS'] = Field(default='rogers', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.cdsv","title":"cdsv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdsv: Optional[float] = Field(default=None, description='Coefficient related to laminar atmospheric boundary layer (SWAN default: 1.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.feswell","title":"feswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>feswell: Optional[float] = Field(default=None, description='Swell dissipation factor')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ROGERS\"\n    if self.cdsv is not None:\n        repr += f\" cdsv={self.cdsv}\"\n    if self.feswell is not None:\n        repr += f\" feswell={self.feswell}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#whitecapping","title":"Whitecapping","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN","title":"WCAPPING_KOMEN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Whitecapping according to Komen (1984).</p> <p>.. code-block:: text</p> <pre><code>WCAPPING KOMEN [cds2] [stpm] [powst] [delta] [powk]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--notes","title":"Notes","text":"<p>The SWAN default for <code>delta</code> has been changed since version 40.91A. The setting <code>delta = 1</code> will improve the prediction of the wave energy at low frequencies, and hence the mean wave period. The original default was <code>delta = 0</code>, which corresponds to WAM Cycle 3. See the Scientific/Technical documentation for further details.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--references","title":"References","text":"<p>Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import WCAPPING_KOMEN\nwcapping = WCAPPING_KOMEN()\nprint(wcapping.render())\nwcapping = WCAPPING_KOMEN(cds2=2.36e-5, stpm=3.02e-3, powst=2, delta=1, powk=2)\nprint(wcapping.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class WCAPPING_KOMEN(BaseComponent):\n    \"\"\"Whitecapping according to Komen (1984).\n\n    .. code-block:: text\n\n        WCAPPING KOMEN [cds2] [stpm] [powst] [delta] [powk]\n\n    Notes\n    -----\n    The SWAN default for `delta` has been changed since version 40.91A. The setting\n    `delta = 1` will improve the prediction of the wave energy at low frequencies, and\n    hence the mean wave period. The original default was `delta = 0`, which corresponds\n    to WAM Cycle 3. See the Scientific/Technical documentation for further details.\n\n    References\n    ----------\n    Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully\n    developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import WCAPPING_KOMEN\n        wcapping = WCAPPING_KOMEN()\n        print(wcapping.render())\n        wcapping = WCAPPING_KOMEN(cds2=2.36e-5, stpm=3.02e-3, powst=2, delta=1, powk=2)\n        print(wcapping.render())\n\n    \"\"\"\n\n    model_type: Literal[\"komen\", \"KOMEN\"] = Field(\n        default=\"komen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation ($Cds$) \"\n            \"(SWAN default: 2.36e-5)\"\n        ),\n    )\n    stpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Value of the wave steepness for a Pierson-Moskowitz spectrum \"\n            \"($s^2_{PM}$) (SWAN default: 3.02e-3)\"\n        ),\n    )\n    powst: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power of steepness normalized with the wave steepness \"\n            \"of a Pierson-Moskowitz spectrum (SWAN default: 2)\"\n        ),\n    )\n    delta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the dependency of the whitecapping \"\n            \"on wave number (SWAN default: 1)\"\n        ),\n    )\n    powk: Optional[float] = Field(\n        default=None,\n        description=(\n            \"power of wave number normalized with the mean wave number \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"WCAPPING KOMEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.stpm is not None:\n            repr += f\" stpm={self.stpm}\"\n        if self.powst is not None:\n            repr += f\" powst={self.powst}\"\n        if self.delta is not None:\n            repr += f\" delta={self.delta}\"\n        if self.powk is not None:\n            repr += f\" powk={self.powk}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['komen', 'KOMEN'] = Field(default='komen', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation ($Cds$) (SWAN default: 2.36e-5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.stpm","title":"stpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stpm: Optional[float] = Field(default=None, description='Value of the wave steepness for a Pierson-Moskowitz spectrum ($s^2_{PM}$) (SWAN default: 3.02e-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.powst","title":"powst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>powst: Optional[float] = Field(default=None, description='Power of steepness normalized with the wave steepness of a Pierson-Moskowitz spectrum (SWAN default: 2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: Optional[float] = Field(default=None, description='Coefficient which determines the dependency of the whitecapping on wave number (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.powk","title":"powk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>powk: Optional[float] = Field(default=None, description='power of wave number normalized with the mean wave number (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"WCAPPING KOMEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.stpm is not None:\n        repr += f\" stpm={self.stpm}\"\n    if self.powst is not None:\n        repr += f\" powst={self.powst}\"\n    if self.delta is not None:\n        repr += f\" delta={self.delta}\"\n    if self.powk is not None:\n        repr += f\" powk={self.powk}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB","title":"WCAPPING_AB","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Whitecapping according to Alves and Banner (2003).</p> <p>.. code-block:: text</p> <pre><code>WCAPPING AB [cds2] [br] CURRENT [cds3]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB--references","title":"References","text":"<p>Alves, J.H.G. and Banner, M.L., 2003. Performance of a saturation-based dissipation-rate source term in modeling the fetch-limited evolution of wind waves. Journal of Physical Oceanography, 33(6), pp.1274-1298.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import WCAPPING_AB\nwcapping = WCAPPING_AB()\nprint(wcapping.render())\nwcapping = WCAPPING_AB(cds2=5.0e-5, br=1.75e-3, current=True, cds3=0.8)\nprint(wcapping.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class WCAPPING_AB(BaseComponent):\n    \"\"\"Whitecapping according to Alves and Banner (2003).\n\n    .. code-block:: text\n\n        WCAPPING AB [cds2] [br] CURRENT [cds3]\n\n    References\n    ----------\n    Alves, J.H.G. and Banner, M.L., 2003. Performance of a saturation-based\n    dissipation-rate source term in modeling the fetch-limited evolution of wind waves.\n    Journal of Physical Oceanography, 33(6), pp.1274-1298.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import WCAPPING_AB\n        wcapping = WCAPPING_AB()\n        print(wcapping.render())\n        wcapping = WCAPPING_AB(cds2=5.0e-5, br=1.75e-3, current=True, cds3=0.8)\n        print(wcapping.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ab\", \"AB\"] = Field(\n        default=\"ab\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"proportionality coefficient due to Alves and Banner (2003) \"\n            \"(SWAN default: 5.0e-5)\"\n        ),\n    )\n    br: Optional[float] = Field(\n        default=None, description=\"Threshold saturation level\t(SWAN default: 1.75e-3)\"\n    )\n    current: bool = Field(\n        default=False,\n        description=(\n            \"Indicates that enhanced current-induced dissipation \"\n            \"as proposed by Van der Westhuysen (2012) is to be added\"\n        ),\n    )\n    cds3: Optional[float] = Field(\n        default=None, description=\"Proportionality coefficient (SWAN default: 0.8)\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"WCAPPING AB\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.br is not None:\n            repr += f\" br={self.br}\"\n        if self.current:\n            repr += \" CURRENT\"\n        if self.cds3 is not None:\n            repr += f\" cds3={self.cds3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ab', 'AB'] = Field(default='ab', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='proportionality coefficient due to Alves and Banner (2003) (SWAN default: 5.0e-5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.br","title":"br  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>br: Optional[float] = Field(default=None, description='Threshold saturation level\\t(SWAN default: 1.75e-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.current","title":"current  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current: bool = Field(default=False, description='Indicates that enhanced current-induced dissipation as proposed by Van der Westhuysen (2012) is to be added')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cds3","title":"cds3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds3: Optional[float] = Field(default=None, description='Proportionality coefficient (SWAN default: 0.8)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"WCAPPING AB\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.br is not None:\n        repr += f\" br={self.br}\"\n    if self.current:\n        repr += \" CURRENT\"\n    if self.cds3 is not None:\n        repr += f\" cds3={self.cds3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#quadruplet-interactions","title":"Quadruplet interactions","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL","title":"QUADRUPL","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonlinear quadruplet wave interactions.</p> <p>.. code-block:: text</p> <pre><code>QUADRUPL [iquad] [lambda] [cnl4] [Csh1] [Csh2] [Csh3]\n</code></pre> <p>With this option the user can influence the computation of nonlinear quadruplet wave interactions which are usually included in the computations. Can be de-activated with command OFF QUAD. Note that the DIA approximation of the quadruplet interactions is a poor approximation for long-crested waves and frequency resolutions that are deviating much more than 10% (see command CGRID). Note that DIA is usually updated per sweep, either semi-implicit (<code>iquad = 1</code>) or explicit (<code>iquad = 2</code>). However, when ambient current is included, the bounds of the directional sector within a sweep may be different for each frequency bin (particularly the higher frequencies are modified by the current). So there may be some overlap of frequency bins between the sweeps, implying non-conservation of wave energy. To prevent this the user is advised to choose the integration of DIA per iteration instead of per sweep, i.e. <code>iquad = 3</code>. If you want to speed up your computation a bit more, than the choice <code>iquad = 8</code> is a good choice.</p>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import QUADRUPL\nquadrupl = QUADRUPL()\nprint(quadrupl.render())\nkwargs = dict(\n    iquad=3, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833333, csh3=-1.25\n)\nquadrupl = QUADRUPL(**kwargs)\nprint(quadrupl.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class QUADRUPL(BaseComponent):\n    \"\"\"Nonlinear quadruplet wave interactions.\n\n    .. code-block:: text\n\n        QUADRUPL [iquad] [lambda] [cnl4] [Csh1] [Csh2] [Csh3]\n\n    With this option the user can influence the computation of nonlinear quadruplet\n    wave interactions which are usually included in the computations. Can be\n    de-activated with command OFF QUAD. Note that the DIA approximation of the\n    quadruplet interactions is a poor approximation for long-crested waves and\n    frequency resolutions that are deviating much more than 10% (see command CGRID).\n    Note that DIA is usually updated per sweep, either semi-implicit (`iquad = 1`) or\n    explicit (`iquad = 2`). However, when ambient current is included, the bounds of\n    the directional sector within a sweep may be different for each frequency bin\n    (particularly the higher frequencies are modified by the current). So there may be\n    some overlap of frequency bins between the sweeps, implying non-conservation of\n    wave energy. To prevent this the user is advised to choose the integration of DIA\n    per iteration instead of per sweep, i.e. `iquad = 3`. If you want to speed up your\n    computation a bit more, than the choice `iquad = 8` is a good choice.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import QUADRUPL\n        quadrupl = QUADRUPL()\n        print(quadrupl.render())\n        kwargs = dict(\n            iquad=3, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833333, csh3=-1.25\n        )\n        quadrupl = QUADRUPL(**kwargs)\n        print(quadrupl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quadrupl\", \"QUADRUPL\"] = Field(\n        default=\"quadrupl\", description=\"Model type discriminator\"\n    )\n    iquad: Optional[Literal[1, 2, 3, 8, 4, 51, 52, 53]] = Field(\n        default=None,\n        description=(\n            \"Numerical procedures for integrating the quadruplets: 1 = semi-implicit \"\n            \"per sweep, 2 = explicit per sweep, 3 = explicit per iteration, \"\n            \"8 = explicit per iteration, but with a more efficient implementation, \"\n            \"4 = multiple DIA, 51 = XNL (deep water transfer), 52 = XNL (deep water \"\n            \"transfer with WAM depth scaling), 53  XNL (finite depth transfer) (SWAN \"\n            \"default: 2)\"\n        ),\n    )\n    lambd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for quadruplet configuration in case of DIA \"\n            \"(SWAN default: 0.25)\"\n        ),\n    )\n    cnl4: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient for quadruplet interactions in case of DIA \"\n            \"(SWAN default: 3.0e7\"\n        ),\n    )\n    csh1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA (SWAN default: 5.5)\"\n        ),\n    )\n    csh2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA \"\n            \"(SWAN default: 0.833333)\"\n        ),\n    )\n    csh3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA \"\n            \"(SWAN default: -1.25)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"QUADRUPL\"\n        if self.iquad is not None:\n            repr += f\" iquad={self.iquad}\"\n        if self.lambd is not None:\n            repr += f\" lambda={self.lambd}\"\n        if self.cnl4 is not None:\n            repr += f\" cnl4={self.cnl4}\"\n        if self.csh1 is not None:\n            repr += f\" csh1={self.csh1}\"\n        if self.csh2 is not None:\n            repr += f\" csh2={self.csh2}\"\n        if self.csh3 is not None:\n            repr += f\" csh3={self.csh3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quadrupl', 'QUADRUPL'] = Field(default='quadrupl', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.iquad","title":"iquad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iquad: Optional[Literal[1, 2, 3, 8, 4, 51, 52, 53]] = Field(default=None, description='Numerical procedures for integrating the quadruplets: 1 = semi-implicit per sweep, 2 = explicit per sweep, 3 = explicit per iteration, 8 = explicit per iteration, but with a more efficient implementation, 4 = multiple DIA, 51 = XNL (deep water transfer), 52 = XNL (deep water transfer with WAM depth scaling), 53  XNL (finite depth transfer) (SWAN default: 2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.lambd","title":"lambd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambd: Optional[float] = Field(default=None, description='Coefficient for quadruplet configuration in case of DIA (SWAN default: 0.25)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.cnl4","title":"cnl4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cnl4: Optional[float] = Field(default=None, description='Proportionality coefficient for quadruplet interactions in case of DIA (SWAN default: 3.0e7')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh1","title":"csh1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh1: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: 5.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh2","title":"csh2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh2: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: 0.833333)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh3","title":"csh3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh3: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: -1.25)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"QUADRUPL\"\n    if self.iquad is not None:\n        repr += f\" iquad={self.iquad}\"\n    if self.lambd is not None:\n        repr += f\" lambda={self.lambd}\"\n    if self.cnl4 is not None:\n        repr += f\" cnl4={self.cnl4}\"\n    if self.csh1 is not None:\n        repr += f\" csh1={self.csh1}\"\n    if self.csh2 is not None:\n        repr += f\" csh2={self.csh2}\"\n    if self.csh3 is not None:\n        repr += f\" csh3={self.csh3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-breaking","title":"Wave breaking","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT","title":"BREAKING_CONSTANT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING CONSTANT [alpha] [gamma]\n</code></pre> <p>Indicates that a constant breaker index is to be used.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_CONSTANT\nbreaking = BREAKING_CONSTANT()\nprint(breaking.render())\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\nprint(breaking.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BREAKING_CONSTANT(BaseComponent):\n    \"\"\"Constant wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING CONSTANT [alpha] [gamma]\n\n    Indicates that a constant breaker index is to be used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_CONSTANT\n        breaking = BREAKING_CONSTANT()\n        print(breaking.render())\n        breaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constant\", \"CONSTANT\"] = Field(\n        default=\"constant\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The breaker index, i.e. the ratio of maximum individual wave height \"\n            \"over depth (SWAN default: 0.73)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING CONSTANT\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma is not None:\n            repr += f\" gamma={self.gamma}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constant', 'CONSTANT'] = Field(default='constant', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.gamma","title":"gamma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma: Optional[float] = Field(default=None, description='The breaker index, i.e. the ratio of maximum individual wave height over depth (SWAN default: 0.73)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING CONSTANT\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma is not None:\n        repr += f\" gamma={self.gamma}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD","title":"BREAKING_BKD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Variable wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n</code></pre> <p>Indicates that the breaker index scales with both the bottom slope (<code>beta</code>) and the dimensionless depth (kd).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_BKD\nbreaking = BREAKING_BKD()\nprint(breaking.render())\nbreaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\nprint(breaking.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BREAKING_BKD(BaseComponent):\n    \"\"\"Variable wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n\n    Indicates that the breaker index scales with both the bottom slope (`beta`)\n    and the dimensionless depth (kd).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_BKD\n        breaking = BREAKING_BKD()\n        print(breaking.render())\n        breaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bkd\", \"BKD\"] = Field(\n        default=\"bkd\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma0: Optional[float] = Field(\n        default=None,\n        description=\"The reference $gamma$ for horizontal slopes (SWAN default: 0.54)\",\n    )\n    a1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First tunable coefficient for the breaker index (SWAN default: 7.59)\"\n        ),\n    )\n    a2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second tunable coefficient for the breaker index (SWAN default: -8.06)\"\n        ),\n    )\n    a3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Third tunable coefficient for the breaker index (SWAN default: 8.09)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING BKD\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma0 is not None:\n            repr += f\" gamma0={self.gamma0}\"\n        if self.a1 is not None:\n            repr += f\" a1={self.a1}\"\n        if self.a2 is not None:\n            repr += f\" a2={self.a2}\"\n        if self.a3 is not None:\n            repr += f\" a3={self.a3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bkd', 'BKD'] = Field(default='bkd', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.gamma0","title":"gamma0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma0: Optional[float] = Field(default=None, description='The reference $gamma$ for horizontal slopes (SWAN default: 0.54)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a1","title":"a1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1: Optional[float] = Field(default=None, description='First tunable coefficient for the breaker index (SWAN default: 7.59)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a2","title":"a2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2: Optional[float] = Field(default=None, description='Second tunable coefficient for the breaker index (SWAN default: -8.06)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a3","title":"a3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a3: Optional[float] = Field(default=None, description='Third tunable coefficient for the breaker index (SWAN default: 8.09)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING BKD\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma0 is not None:\n        repr += f\" gamma0={self.gamma0}\"\n    if self.a1 is not None:\n        repr += f\" a1={self.a1}\"\n    if self.a2 is not None:\n        repr += f\" a2={self.a2}\"\n    if self.a3 is not None:\n        repr += f\" a3={self.a3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#bottom-friction","title":"Bottom friction","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP","title":"FRICTION_JONSWAP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Hasselmann et al. (1973) Jonswap friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION JONSWAP CONSTANT [cfjon]\n</code></pre> <p>Indicates that the semi-empirical expression derived from the JONSWAP results for bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated. This option is default.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP--references","title":"References","text":"<p>Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K., Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973. Measurements of wind-wave growth and swell decay during the Joint North Sea Wave Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany, Rep. No. 12, 95 pp.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_JONSWAP\nfriction = FRICTION_JONSWAP()\nprint(friction.render())\nfriction = FRICTION_JONSWAP(cfjon=0.038)\nprint(friction.render())\n</code></pre> <p>TODO: Implement VARIABLE option?</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_JONSWAP(BaseComponent):\n    \"\"\"Hasselmann et al. (1973) Jonswap friction.\n\n    .. code-block:: text\n\n        FRICTION JONSWAP CONSTANT [cfjon]\n\n    Indicates that the semi-empirical expression derived from the JONSWAP results for\n    bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated.\n    This option is default.\n\n    References\n    ----------\n    Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K.,\n    Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973.\n    Measurements of wind-wave growth and swell decay during the Joint North Sea Wave\n    Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany,\n    Rep. No. 12, 95 pp.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_JONSWAP\n        friction = FRICTION_JONSWAP()\n        print(friction.render())\n        friction = FRICTION_JONSWAP(cfjon=0.038)\n        print(friction.render())\n\n    TODO: Implement VARIABLE option?\n\n    \"\"\"\n\n    model_type: Literal[\"jonswap\", \"JONSWAP\"] = Field(\n        default=\"jonswap\", description=\"Model type discriminator\"\n    )\n    cfjon: Optional[float] = Field(\n        default=None,\n        description=\"Coefficient of the JONSWAP formulation (SWAN default: 0.038)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION JONSWAP CONSTANT\"\n        if self.cfjon is not None:\n            repr += f\" cfjon={self.cfjon}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['jonswap', 'JONSWAP'] = Field(default='jonswap', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.cfjon","title":"cfjon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfjon: Optional[float] = Field(default=None, description='Coefficient of the JONSWAP formulation (SWAN default: 0.038)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION JONSWAP CONSTANT\"\n    if self.cfjon is not None:\n        repr += f\" cfjon={self.cfjon}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS","title":"FRICTION_COLLINS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Collins (1972) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION COLLINS [cfw]\n</code></pre> <p>Note that <code>cfw</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>cfw</code> in this command is then not required (it will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS--references","title":"References","text":"<p>Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical Research, 77(15), pp.2693-2707.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_COLLINS\nfriction = FRICTION_COLLINS()\nprint(friction.render())\nfriction = FRICTION_COLLINS(cfw=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_COLLINS(BaseComponent):\n    \"\"\"Collins (1972) friction.\n\n    .. code-block:: text\n\n        FRICTION COLLINS [cfw]\n\n    Note that `cfw` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `cfw` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical\n    Research, 77(15), pp.2693-2707.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_COLLINS\n        friction = FRICTION_COLLINS()\n        print(friction.render())\n        friction = FRICTION_COLLINS(cfw=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"collins\", \"COLLINS\"] = Field(\n        default=\"collins\", description=\"Model type discriminator\"\n    )\n    cfw: Optional[float] = Field(\n        default=None,\n        description=\"Collins bottom friction coefficient (SWAN default: 0.015)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION COLLINS\"\n        if self.cfw is not None:\n            repr += f\" cfw={self.cfw}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['collins', 'COLLINS'] = Field(default='collins', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.cfw","title":"cfw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfw: Optional[float] = Field(default=None, description='Collins bottom friction coefficient (SWAN default: 0.015)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION COLLINS\"\n    if self.cfw is not None:\n        repr += f\" cfw={self.cfw}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN","title":"FRICTION_MADSEN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Madsen et al (1988) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION MADSEN [kn]\n</code></pre> <p>Note that <code>kn</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>kn</code> in this command is then not required (it will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN--references","title":"References","text":"<p>Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).</p> <p>Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_MADSEN\nfriction = FRICTION_MADSEN()\nprint(friction.render())\nfriction = FRICTION_MADSEN(kn=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_MADSEN(BaseComponent):\n    \"\"\"Madsen et al (1988) friction.\n\n    .. code-block:: text\n\n        FRICTION MADSEN [kn]\n\n    Note that `kn` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `kn` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by\n    bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).\n\n    Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom\n    friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_MADSEN\n        friction = FRICTION_MADSEN()\n        print(friction.render())\n        friction = FRICTION_MADSEN(kn=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"madsen\", \"MADSEN\"] = Field(\n        default=\"madsen\", description=\"Model type discriminator\"\n    )\n    kn: Optional[float] = Field(\n        default=None,\n        description=(\n            \"equivalent roughness length scale of the bottom (in m) \"\n            \"(SWAN default: 0.05)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION MADSEN\"\n        if self.kn is not None:\n            repr += f\" kn={self.kn}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['madsen', 'MADSEN'] = Field(default='madsen', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.kn","title":"kn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kn: Optional[float] = Field(default=None, description='equivalent roughness length scale of the bottom (in m) (SWAN default: 0.05)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION MADSEN\"\n    if self.kn is not None:\n        repr += f\" kn={self.kn}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES","title":"FRICTION_RIPPLES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Smith et al. (2011) Ripples friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION RIPPLES [S] [D]\n</code></pre> <p>Indicates that the expression of Smith et al. (2011) should be activated. Here friction depends on the formation of bottom ripples and sediment size.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES--references","title":"References","text":"<p>Smith, G.A., Babanin, A.V., Riedel, P., Young, I.R., Oliver, S. and Hubbert, G., 2011. Introduction of a new friction routine into the SWAN model that evaluates roughness due to bedform and sediment size changes. Coastal Engineering, 58(4), pp.317-326.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_RIPPLES\nfriction = FRICTION_RIPPLES()\nprint(friction.render())\nfriction = FRICTION_RIPPLES(s=2.65, d=0.0001)\nprint(friction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class FRICTION_RIPPLES(BaseComponent):\n    \"\"\"Smith et al. (2011) Ripples friction.\n\n    .. code-block:: text\n\n        FRICTION RIPPLES [S] [D]\n\n    Indicates that the expression of Smith et al. (2011) should be activated. Here\n    friction depends on the formation of bottom ripples and sediment size.\n\n    References\n    ----------\n    Smith, G.A., Babanin, A.V., Riedel, P., Young, I.R., Oliver, S. and Hubbert, G.,\n    2011. Introduction of a new friction routine into the SWAN model that evaluates\n    roughness due to bedform and sediment size changes. Coastal Engineering, 58(4),\n    pp.317-326.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_RIPPLES\n        friction = FRICTION_RIPPLES()\n        print(friction.render())\n        friction = FRICTION_RIPPLES(s=2.65, d=0.0001)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ripples\", \"RIPPLES\"] = Field(\n        default=\"ripples\", description=\"Model type discriminator\"\n    )\n    s: Optional[float] = Field(\n        default=None,\n        description=\"The specific gravity of the sediment (SWAN default: 2.65)\",\n    )\n    d: Optional[float] = Field(\n        default=None, description=\"The sediment diameter (in m) (SWAN default: 0.0001)\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION RIPPLES\"\n        if self.s is not None:\n            repr += f\" S={self.s}\"\n        if self.d is not None:\n            repr += f\" D={self.d}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ripples', 'RIPPLES'] = Field(default='ripples', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.s","title":"s  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>s: Optional[float] = Field(default=None, description='The specific gravity of the sediment (SWAN default: 2.65)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.d","title":"d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>d: Optional[float] = Field(default=None, description='The sediment diameter (in m) (SWAN default: 0.0001)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION RIPPLES\"\n    if self.s is not None:\n        repr += f\" S={self.s}\"\n    if self.d is not None:\n        repr += f\" D={self.d}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-triads","title":"Wave triads","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD","title":"TRIAD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave triad interactions.</p> <p>.. code-block:: text</p> <pre><code>TRIAD [itriad] [trfac] [cutfr] [a] [b] [urcrit] [urslim]\n</code></pre> <p>With this command the user can activate the triad wave-wave interactions. If this command is not used, SWAN will not account for triads.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD--note","title":"Note","text":"<p>This is the TRIAD specification in SWAN &lt; 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD\ntriad = TRIAD()\nprint(triad.render())\ntriad = TRIAD(\n    itriad=1,\n    trfac=0.8,\n    cutfr=2.5,\n    a=0.95,\n    b=-0.75,\n    ucrit=0.2,\n    urslim=0.01,\n)\nprint(triad.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class TRIAD(BaseComponent):\n    \"\"\"Wave triad interactions.\n\n    .. code-block:: text\n\n        TRIAD [itriad] [trfac] [cutfr] [a] [b] [urcrit] [urslim]\n\n    With this command the user can activate the triad wave-wave interactions. If this\n    command is not used, SWAN will not account for triads.\n\n    Note\n    ----\n    This is the TRIAD specification in SWAN &lt; 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD\n        triad = TRIAD()\n        print(triad.render())\n        triad = TRIAD(\n            itriad=1,\n            trfac=0.8,\n            cutfr=2.5,\n            a=0.95,\n            b=-0.75,\n            ucrit=0.2,\n            urslim=0.01,\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"triad\", \"TRIAD\"] = Field(\n        default=\"triad\", description=\"Model type discriminator\"\n    )\n    itriad: Optional[Literal[1, 2]] = Field(\n        default=None,\n        description=(\n            \"Approximation method for the triad computation: \\n\\n* 1: the LTA method \"\n            \"of Eldeberky (1996) \\n* 2: the SPB method of Becq-Girard et al. (1999) \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient (SWAN default: 0.8 in case of LTA method, \"\n            \"0.9 in case of SPB method)\"\n        ),\n    )\n    cutfr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the maximum frequency that is considered in the LTA \"\n            \"computation. The value of `cutfr` is the ratio of this maximum \"\n            \"frequency over the mean frequency (SWAN default: 2.5)\"\n        ),\n    )\n    a: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et \"\n            \"al. (1999). This parameter is associated with broadening of the \"\n            \"resonance condition (SWAN default: 0.95)\"\n        ),\n    )\n    b: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard \"\n            \"et al. (1999). This parameter is associated with broadening of the \"\n            \"resonance condition (SWAN default: -0.75 for 1D, 0.0 for 2D\"\n        ),\n    )\n    ucrit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The critical Ursell number appearing in the expression for the biphase \"\n            \"(SWAN default: 0.2)\"\n        ),\n    )\n    urslim: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The lower threshold for Ursell number, if the actual Ursell number is \"\n            \"below this value triad interactions are be computed (SWAN default: 0.01)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD\"\n        if self.itriad is not None:\n            repr += f\" itriad={self.itriad}\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.cutfr is not None:\n            repr += f\" cutfr={self.cutfr}\"\n        if self.a is not None:\n            repr += f\" a={self.a}\"\n        if self.b is not None:\n            repr += f\" b={self.b}\"\n        if self.ucrit is not None:\n            repr += f\" urcrit={self.ucrit}\"\n        if self.urslim is not None:\n            repr += f\" urslim={self.urslim}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['triad', 'TRIAD'] = Field(default='triad', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.itriad","title":"itriad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itriad: Optional[Literal[1, 2]] = Field(default=None, description='Approximation method for the triad computation: \\n\\n* 1: the LTA method of Eldeberky (1996) \\n* 2: the SPB method of Becq-Girard et al. (1999) (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Proportionality coefficient (SWAN default: 0.8 in case of LTA method, 0.9 in case of SPB method)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.cutfr","title":"cutfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutfr: Optional[float] = Field(default=None, description='Controls the maximum frequency that is considered in the LTA computation. The value of `cutfr` is the ratio of this maximum frequency over the mean frequency (SWAN default: 2.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: Optional[float] = Field(default=None, description='First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition (SWAN default: 0.95)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: Optional[float] = Field(default=None, description='Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition (SWAN default: -0.75 for 1D, 0.0 for 2D')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.ucrit","title":"ucrit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ucrit: Optional[float] = Field(default=None, description='The critical Ursell number appearing in the expression for the biphase (SWAN default: 0.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.urslim","title":"urslim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urslim: Optional[float] = Field(default=None, description='The lower threshold for Ursell number, if the actual Ursell number is below this value triad interactions are be computed (SWAN default: 0.01)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD\"\n    if self.itriad is not None:\n        repr += f\" itriad={self.itriad}\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.cutfr is not None:\n        repr += f\" cutfr={self.cutfr}\"\n    if self.a is not None:\n        repr += f\" a={self.a}\"\n    if self.b is not None:\n        repr += f\" b={self.b}\"\n    if self.ucrit is not None:\n        repr += f\" urcrit={self.ucrit}\"\n    if self.urslim is not None:\n        repr += f\" urslim={self.urslim}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA","title":"TRIAD_DCTA","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the DCTA method of Booij et al. (2009).</p> <p>.. code-block:: text</p> <pre><code>TRIAD DCTA [trfac] [p] COLL|NONC BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--references","title":"References","text":"<p>Booij, N., Holthuijsen, L.H. and B\u00e9nit, M.P., 2009. A distributed collinear triad approximation in SWAN. In Proceedings Of Coastal Dynamics 2009: Impacts of Human Activities on Dynamic Coastal Processes (With CD-ROM) (pp. 1-10).</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--note","title":"Note","text":"<p>This is the default method to compute the triad interactions in SWAN &gt;= 41.45, it is not supported in earlier versions of the model.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_DCTA\ntriad = TRIAD_DCTA()\nprint(triad.render())\ntriad = TRIAD_DCTA(\n    trfac=4.4,\n    p=1.3,\n    noncolinear=True,\n    biphase={\"model_type\": \"dewit\", \"lpar\": 0.0},\n)\nprint(triad.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class TRIAD_DCTA(BaseComponent):\n    \"\"\"Triad interactions with the DCTA method of Booij et al. (2009).\n\n    .. code-block:: text\n\n        TRIAD DCTA [trfac] [p] COLL|NONC BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Booij, N., Holthuijsen, L.H. and B\u00e9nit, M.P., 2009. A distributed collinear triad\n    approximation in SWAN. In Proceedings Of Coastal Dynamics 2009: Impacts of Human\n    Activities on Dynamic Coastal Processes (With CD-ROM) (pp. 1-10).\n\n    Note\n    ----\n    This is the default method to compute the triad interactions in SWAN &gt;= 41.45, it\n    is not supported in earlier versions of the model.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_DCTA\n        triad = TRIAD_DCTA()\n        print(triad.render())\n        triad = TRIAD_DCTA(\n            trfac=4.4,\n            p=1.3,\n            noncolinear=True,\n            biphase={\"model_type\": \"dewit\", \"lpar\": 0.0},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dcta\", \"DCTA\"] = Field(\n        default=\"dcta\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to DCTA (SWAN default: 4.4)\"\n        ),\n    )\n    p: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape coefficient to force the high-frequency tail\" \"(SWAN default: 4/3)\"\n        ),\n    )\n    noncolinear: bool = Field(\n        default=False,\n        description=(\n            \"If True, the noncolinear triad interactions \"\n            \"with the DCTA framework are accounted for\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD DCTA\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.p is not None:\n            repr += f\" p={self.p}\"\n        if self.noncolinear:\n            repr += \" NONC\"\n        else:\n            repr += \" COLL\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dcta', 'DCTA'] = Field(default='dcta', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to DCTA (SWAN default: 4.4)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: Optional[float] = Field(default=None, description='Shape coefficient to force the high-frequency tail(SWAN default: 4/3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.noncolinear","title":"noncolinear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>noncolinear: bool = Field(default=False, description='If True, the noncolinear triad interactions with the DCTA framework are accounted for')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD DCTA\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.p is not None:\n        repr += f\" p={self.p}\"\n    if self.noncolinear:\n        repr += \" NONC\"\n    else:\n        repr += \" COLL\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA","title":"TRIAD_LTA","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the LTA method of Eldeberky (1996).</p> <p>.. code-block:: text</p> <pre><code>TRIAD LTA [trfac] [cutfr] BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--references","title":"References","text":"<p>Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for modeling triad interactions in dispersive waves. In Coastal Engineering 1996 (pp. 1088-1101).</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--note","title":"Note","text":"<p>This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_LTA\ntriad = TRIAD_LTA()\nprint(triad.render())\ntriad = TRIAD_LTA(\n    trfac=0.8,\n    cutfr=2.5,\n    biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n)\nprint(triad.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class TRIAD_LTA(BaseComponent):\n    \"\"\"Triad interactions with the LTA method of Eldeberky (1996).\n\n    .. code-block:: text\n\n        TRIAD LTA [trfac] [cutfr] BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for\n    modeling triad interactions in dispersive waves. In Coastal Engineering 1996\n    (pp. 1088-1101).\n\n    Note\n    ----\n    This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_LTA\n        triad = TRIAD_LTA()\n        print(triad.render())\n        triad = TRIAD_LTA(\n            trfac=0.8,\n            cutfr=2.5,\n            biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"lta\", \"LTA\"] = Field(\n        default=\"lta\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to LTA (SWAN default: 0.8)\"\n        ),\n    )\n    cutfr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the maximum frequency that is considered in the LTA \"\n            \"computation. The value of `cutfr` is the ratio of this maximum \"\n            \"frequency over the mean frequency (SWAN default: 2.5)\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD LTA\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.cutfr is not None:\n            repr += f\" cutfr={self.cutfr}\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lta', 'LTA'] = Field(default='lta', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to LTA (SWAN default: 0.8)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.cutfr","title":"cutfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutfr: Optional[float] = Field(default=None, description='Controls the maximum frequency that is considered in the LTA computation. The value of `cutfr` is the ratio of this maximum frequency over the mean frequency (SWAN default: 2.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD LTA\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.cutfr is not None:\n        repr += f\" cutfr={self.cutfr}\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB","title":"TRIAD_SPB","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the SPB method of Becq-Girard et al. (1999).</p> <p>.. code-block:: text</p> <pre><code>TRIAD SPB [trfac] [a] [b] BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--references","title":"References","text":"<p>Becq-Girard, F., Forget, P. and Benoit, M., 1999. Non-linear propagation of unidirectional wave fields over varying topography. Coastal Engineering, 38(2), pp.91-113.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--note","title":"Note","text":"<p>This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_SPB\ntriad = TRIAD_SPB()\nprint(triad.render())\ntriad = TRIAD_SPB(\n    trfac=0.9,\n    a=0.95,\n    b=0.0,\n    biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n)\nprint(triad.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class TRIAD_SPB(BaseComponent):\n    \"\"\"Triad interactions with the SPB method of Becq-Girard et al. (1999).\n\n    .. code-block:: text\n\n        TRIAD SPB [trfac] [a] [b] BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Becq-Girard, F., Forget, P. and Benoit, M., 1999. Non-linear propagation of\n    unidirectional wave fields over varying topography. Coastal Engineering, 38(2),\n    pp.91-113.\n\n    Note\n    ----\n    This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_SPB\n        triad = TRIAD_SPB()\n        print(triad.render())\n        triad = TRIAD_SPB(\n            trfac=0.9,\n            a=0.95,\n            b=0.0,\n            biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spb\", \"SPB\"] = Field(\n        default=\"spb\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to SPB (SWAN default: 0.9)\"\n        ),\n    )\n    a: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First calibration parameter for tuning K in Eq. (5.1) of \"\n            \"Becq-Girard et al. (1999). This parameter is associated with broadening \"\n            \"of the resonance condition. The default value is 0.95 and is calibrated \"\n            \"by means of laboratory experiments (SWAN default: 0.95)\"\n        ),\n    )\n    b: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second calibration parameter for tuning K in Eq. (5.1) of \"\n            \"Becq-Girard et al. (1999). This parameter is associated with broadening \"\n            \"of the resonance condition. The default value is -0.75 and is calibrated \"\n            \"by means of laboratory experiments. However, it may not be appropriate \"\n            \"for true 2D field cases as it does not scale with the wave field \"\n            \"characteristics. Hence, this parameter is set to zero (SWAN default: 0.0)\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD SPB\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.a is not None:\n            repr += f\" a={self.a}\"\n        if self.b is not None:\n            repr += f\" b={self.b}\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spb', 'SPB'] = Field(default='spb', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to SPB (SWAN default: 0.9)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: Optional[float] = Field(default=None, description='First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition. The default value is 0.95 and is calibrated by means of laboratory experiments (SWAN default: 0.95)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: Optional[float] = Field(default=None, description='Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition. The default value is -0.75 and is calibrated by means of laboratory experiments. However, it may not be appropriate for true 2D field cases as it does not scale with the wave field characteristics. Hence, this parameter is set to zero (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD SPB\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.a is not None:\n        repr += f\" a={self.a}\"\n    if self.b is not None:\n        repr += f\" b={self.b}\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#vegetation-damping","title":"Vegetation damping","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION","title":"VEGETATION","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Vegetation dumping.</p> <p>.. code-block:: text</p> <pre><code>VEGETATION [iveg] &lt; [height] [diamtr] [nstems] [drag] &gt;\n</code></pre> <p>With this command the user can activate wave damping due to vegetation based on the Dalrymple's formula (1984) as implemented by Suzuki et al. (2011). This damping is uniform over the wave frequencies. An alternative is the frequency-dependent (canopy) dissipation model of Jacobsen et al. (2019). If this command is not used, SWAN will not account for vegetation effects.</p> <p>The vegetation (rigid plants) can be divided over a number of vertical segments and so, the possibility to vary the vegetation vertically is included. Each vertical layer represents some characteristics of the plants. These variables as indicated below can be repeated as many vertical layers to be chosen.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--references","title":"References","text":"<p>Dalrymple, R.A., Kirby, J.T. and Hwang, P.A., 1984. Wave diffraction due to areas of energy dissipation. Journal of waterway, port, coastal, and ocean engineering, 110(1), pp.67-79.</p> <p>Jacobsen, N.G., Bakker, W., Uijttewaal, W.S. and Uittenbogaard, R., 2019. Experimental investigation of the wave-induced motion of and force distribution along a flexible stem. Journal of Fluid Mechanics, 880, pp.1036-1069.</p> <p>Suzuki, T., Zijlema, M., Burger, B., Meijer, M.C. and Narayan, S., 2012. Wave dissipation by vegetation with layer schematization in SWAN. Coastal Engineering, 59(1), pp.64-71.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--notes","title":"Notes","text":"<p>Vertical layering of the vegetation is not yet implemented for the Jacobsen et al. (2019) method.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import VEGETATION\n# Single layer\nvegetation = VEGETATION(\n    height=1.2,\n    diamtr=0.1,\n    drag=0.5,\n    nstems=10,\n)\nprint(vegetation.render())\n# 2 vertical layers\nvegetation = VEGETATION(\n    iveg=1,\n    height=[1.2, 0.8],\n    diamtr=[0.1, 0.1],\n    drag=[0.5, 0.5],\n    nstems=[10, 5],\n)\nprint(vegetation.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class VEGETATION(BaseComponent):\n    \"\"\"Vegetation dumping.\n\n    .. code-block:: text\n\n        VEGETATION [iveg] &lt; [height] [diamtr] [nstems] [drag] &gt;\n\n    With this command the user can activate wave damping due to vegetation based on the\n    Dalrymple's formula (1984) as implemented by Suzuki et al. (2011). This damping is\n    uniform over the wave frequencies. An alternative is the frequency-dependent\n    (canopy) dissipation model of Jacobsen et al. (2019). If this command is not used,\n    SWAN will not account for vegetation effects.\n\n    The vegetation (rigid plants) can be divided over a number of vertical segments and\n    so, the possibility to vary the vegetation vertically is included. Each vertical\n    layer represents some characteristics of the plants. These variables as indicated\n    below can be repeated as many vertical layers to be chosen.\n\n    References\n    ----------\n    Dalrymple, R.A., Kirby, J.T. and Hwang, P.A., 1984. Wave diffraction due to areas\n    of energy dissipation. Journal of waterway, port, coastal, and ocean engineering,\n    110(1), pp.67-79.\n\n    Jacobsen, N.G., Bakker, W., Uijttewaal, W.S. and Uittenbogaard, R., 2019.\n    Experimental investigation of the wave-induced motion of and force distribution\n    along a flexible stem. Journal of Fluid Mechanics, 880, pp.1036-1069.\n\n    Suzuki, T., Zijlema, M., Burger, B., Meijer, M.C. and Narayan, S., 2012. Wave\n    dissipation by vegetation with layer schematization in SWAN. Coastal Engineering,\n    59(1), pp.64-71.\n\n    Notes\n    -----\n    Vertical layering of the vegetation is not yet implemented for the\n    Jacobsen et al. (2019) method.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import VEGETATION\n        # Single layer\n        vegetation = VEGETATION(\n            height=1.2,\n            diamtr=0.1,\n            drag=0.5,\n            nstems=10,\n        )\n        print(vegetation.render())\n        # 2 vertical layers\n        vegetation = VEGETATION(\n            iveg=1,\n            height=[1.2, 0.8],\n            diamtr=[0.1, 0.1],\n            drag=[0.5, 0.5],\n            nstems=[10, 5],\n        )\n        print(vegetation.render())\n\n    \"\"\"\n\n    model_type: Literal[\"vegetation\", \"VEGETATION\"] = Field(\n        default=\"vegetation\", description=\"Model type discriminator\"\n    )\n    iveg: Literal[1, 2] = Field(\n        default=1,\n        description=(\n            \"Indicates the method for the vegetation computation (SWAN default: 1):\\n\"\n            \"\\n* 1: Suzuki et al. (2011)\\n* 2: Jacobsen et al. (2019)\\n\"\n        ),\n    )\n    height: Union[float, list[float]] = Field(\n        description=\"The plant height per layer (in m)\"\n    )\n    diamtr: Union[float, list[float]] = Field(\n        description=\"The diameter of each plant stand per layer (in m)\"\n    )\n    drag: Union[float, list[float]] = Field(\n        description=\"The drag coefficient per layer\"\n    )\n    nstems: Union[int, list[int]] = Field(\n        default=1,\n        description=(\n            \"The number of plant stands per square meter for each layer. Note that \"\n            \"`nstems` is allowed to vary over the computational region to account for \"\n            \"the zonation of vegetation. In that case use the commands \"\n            \"`IMPGRID NPLANTS` and `READINP NPLANTS` to define and read the \"\n            \"vegetation density. The (vertically varying) value of `nstems` in this \"\n            \"command will be multiplied by this horizontally varying plant density \"\n            \"(SWAN default: 1)\"\n        ),\n        validate_default=True,\n    )\n\n    @field_validator(\"height\", \"diamtr\", \"drag\", \"nstems\")\n    @classmethod\n    def number_of_layers(cls, v: Any, info: ValidationInfo) -&gt; Any:\n        if v is None:\n            return v\n        elif not isinstance(v, list):\n            v = [v]\n        sizes = {k: len(v) for k, v in info.data.items() if isinstance(v, list)}\n        if len(set(sizes.values())) &gt; 1:\n            raise ValueError(\n                \"The number of layers must be the same for all variables. \"\n                f\"Got these number of layers: {sizes}\"\n            )\n        return v\n\n    @model_validator(mode=\"after\")\n    def jacomsen_layering_not_implemented(self) -&gt; \"VEGETATION\":\n        if self.iveg == 2 and len(self.nstems) &gt; 1:\n            raise NotImplementedError(\n                \"Vertical layering of the vegetation is not yet implemented for the \"\n                \"Jacobsen et al. (2019) method, please define single layer\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"VEGETATION iveg={self.iveg}\"\n        for h, d, dr, n in zip(self.height, self.diamtr, self.drag, self.nstems):\n            repr += f\" height={h} diamtr={d} nstems={n} drag={dr}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['vegetation', 'VEGETATION'] = Field(default='vegetation', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.iveg","title":"iveg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iveg: Literal[1, 2] = Field(default=1, description='Indicates the method for the vegetation computation (SWAN default: 1):\\n\\n* 1: Suzuki et al. (2011)\\n* 2: Jacobsen et al. (2019)\\n')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height: Union[float, list[float]] = Field(description='The plant height per layer (in m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.diamtr","title":"diamtr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diamtr: Union[float, list[float]] = Field(description='The diameter of each plant stand per layer (in m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.drag","title":"drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drag: Union[float, list[float]] = Field(description='The drag coefficient per layer')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.nstems","title":"nstems  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nstems: Union[int, list[int]] = Field(default=1, description='The number of plant stands per square meter for each layer. Note that `nstems` is allowed to vary over the computational region to account for the zonation of vegetation. In that case use the commands `IMPGRID NPLANTS` and `READINP NPLANTS` to define and read the vegetation density. The (vertically varying) value of `nstems` in this command will be multiplied by this horizontally varying plant density (SWAN default: 1)', validate_default=True)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.number_of_layers","title":"number_of_layers  <code>classmethod</code>","text":"<pre><code>number_of_layers(v: Any, info: ValidationInfo) -&gt; Any\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>@field_validator(\"height\", \"diamtr\", \"drag\", \"nstems\")\n@classmethod\ndef number_of_layers(cls, v: Any, info: ValidationInfo) -&gt; Any:\n    if v is None:\n        return v\n    elif not isinstance(v, list):\n        v = [v]\n    sizes = {k: len(v) for k, v in info.data.items() if isinstance(v, list)}\n    if len(set(sizes.values())) &gt; 1:\n        raise ValueError(\n            \"The number of layers must be the same for all variables. \"\n            f\"Got these number of layers: {sizes}\"\n        )\n    return v\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.jacomsen_layering_not_implemented","title":"jacomsen_layering_not_implemented","text":"<pre><code>jacomsen_layering_not_implemented() -&gt; VEGETATION\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef jacomsen_layering_not_implemented(self) -&gt; \"VEGETATION\":\n    if self.iveg == 2 and len(self.nstems) &gt; 1:\n        raise NotImplementedError(\n            \"Vertical layering of the vegetation is not yet implemented for the \"\n            \"Jacobsen et al. (2019) method, please define single layer\"\n        )\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"VEGETATION iveg={self.iveg}\"\n    for h, d, dr, n in zip(self.height, self.diamtr, self.drag, self.nstems):\n        repr += f\" height={h} diamtr={d} nstems={n} drag={dr}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#mud-damping","title":"Mud damping","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD","title":"MUD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Mud dumping.</p> <p>.. code-block:: text</p> <pre><code>MUD [layer] [rhom] [viscm]\n</code></pre> <p>With this command the user can activate wave damping due to mud based on Ng (2000). If this command or the commands INPGRID MUDLAY and READINP MUDLAY are not used, SWAN will not account for muddy bottom effects.</p>"},{"location":"components/physics/#rompy_swan.components.physics.MUD--references","title":"References","text":"<p>Ng, C., 2000, Water waves over a muddy bed: A two layer Stokes' boundary layer model, Coastal Eng., 40, 221-242.</p>"},{"location":"components/physics/#rompy_swan.components.physics.MUD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import MUD\nmud = MUD()\nprint(mud.render())\nmud = MUD(\n    layer=2.0,\n    rhom=1300,\n    viscm=0.0076,\n)\nprint(mud.render())\n</code></pre> <p>TODO: Validate <code>layer</code> must be prescribed if <code>INPGRID MUDLAY</code> isn't used.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class MUD(BaseComponent):\n    \"\"\"Mud dumping.\n\n    .. code-block:: text\n\n        MUD [layer] [rhom] [viscm]\n\n    With this command the user can activate wave damping due to mud based on Ng (2000).\n    If this command or the commands INPGRID MUDLAY and READINP MUDLAY are not used,\n    SWAN will not account for muddy bottom effects.\n\n    References\n    ----------\n    Ng, C., 2000, Water waves over a muddy bed: A two layer Stokes' boundary layer\n    model, Coastal Eng., 40, 221-242.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import MUD\n        mud = MUD()\n        print(mud.render())\n        mud = MUD(\n            layer=2.0,\n            rhom=1300,\n            viscm=0.0076,\n        )\n        print(mud.render())\n\n    TODO: Validate `layer` must be prescribed if `INPGRID MUDLAY` isn't used.\n\n    \"\"\"\n\n    model_type: Literal[\"mud\", \"MUD\"] = Field(\n        default=\"mud\", description=\"Model type discriminator\"\n    )\n    layer: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The thickness of the mud layer (in m). Note that `layer` is allowed to \"\n            \"vary over the computational region to account for the zonation of muddy \"\n            \"bottom. In that case use the commands `INPGRID MUDLAY` and `READINP \"\n            \"MUDLAY` to define and read the layer thickness of mud. The value of \"\n            \"`layer` in this command is then not required (it will be ignored)\"\n        ),\n    )\n    rhom: Optional[float] = Field(\n        default=None,\n        description=\"The density of the mud layer (in kg/m3) (SWAN default: 1300)\",\n    )\n    viscm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The kinematic viscosity of the mud layer (in m2/s) (SWAN default: 0.0076)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"MUD\"\n        if self.layer is not None:\n            repr += f\" layer={self.layer}\"\n        if self.rhom is not None:\n            repr += f\" rhom={self.rhom}\"\n        if self.viscm is not None:\n            repr += f\" viscm={self.viscm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['mud', 'MUD'] = Field(default='mud', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.layer","title":"layer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layer: Optional[float] = Field(default=None, description='The thickness of the mud layer (in m). Note that `layer` is allowed to vary over the computational region to account for the zonation of muddy bottom. In that case use the commands `INPGRID MUDLAY` and `READINP MUDLAY` to define and read the layer thickness of mud. The value of `layer` in this command is then not required (it will be ignored)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.rhom","title":"rhom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhom: Optional[float] = Field(default=None, description='The density of the mud layer (in kg/m3) (SWAN default: 1300)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.viscm","title":"viscm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>viscm: Optional[float] = Field(default=None, description='The kinematic viscosity of the mud layer (in m2/s) (SWAN default: 0.0076)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"MUD\"\n    if self.layer is not None:\n        repr += f\" layer={self.layer}\"\n    if self.rhom is not None:\n        repr += f\" rhom={self.rhom}\"\n    if self.viscm is not None:\n        repr += f\" viscm={self.viscm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#sea-ice-dissipation","title":"Sea ice dissipation","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE","title":"SICE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Sea ice dissipation.</p> <p>.. code-block:: text</p> <pre><code>SICE [aice]\n</code></pre> <p>Using this command, the user activates a sink term to represent the dissipation of wave energy by sea ice. The default method is R19 empirical/parametric: a polynomial based on wave frequency (Rogers, 2019). This polynomial (in 1/m) has seven dimensional coefficients; see Scientific/Technical documentation for details. If this command is not used, SWAN will not account for sea ice effects.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--references","title":"References","text":"<p>Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015. Relating wave attenuation to pancake ice thickness, using field measurements and model results. Geophysical Research Letters, 42(11), pp.4473-4481.</p> <p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science and Technology, 182, p.103198.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--notes","title":"Notes","text":"<p>Iis also necessary to describe the ice, using the <code>ICE</code> command (for uniform and stationary ice) or <code>INPGRID</code>/<code>READINP</code> commands (for variable ice).</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE\nsice = SICE()\nprint(sice.render())\nsice = SICE(aice=0.5)\nprint(sice.render())\n</code></pre> <p>TODO: Verify if the <code>aice</code> parameter should be used with SICE command, it is not shown in the command tree but it is described as an option in the description.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SICE(BaseComponent):\n    \"\"\"Sea ice dissipation.\n\n    .. code-block:: text\n\n        SICE [aice]\n\n    Using this command, the user activates a sink term to represent the dissipation of\n    wave energy by sea ice. The default method is R19 empirical/parametric: a\n    polynomial based on wave frequency (Rogers, 2019). This polynomial (in 1/m) has\n    seven dimensional coefficients; see Scientific/Technical documentation for details.\n    If this command is not used, SWAN will not account for sea ice effects.\n\n    References\n    ----------\n    Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015.\n    Relating wave attenuation to pancake ice thickness, using field measurements and\n    model results. Geophysical Research Letters, 42(11), pp.4473-4481.\n\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of\n    dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of\n    the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave\n    attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science\n    and Technology, 182, p.103198.\n\n    Notes\n    -----\n    Iis also necessary to describe the ice, using the `ICE` command (for uniform and\n    stationary ice) or `INPGRID`/`READINP` commands (for variable ice).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE\n        sice = SICE()\n        print(sice.render())\n        sice = SICE(aice=0.5)\n        print(sice.render())\n\n    TODO: Verify if the `aice` parameter should be used with SICE command, it is not\n    shown in the command tree but it is described as an option in the description.\n\n    \"\"\"\n\n    model_type: Literal[\"sice\", \"SICE\"] = Field(\n        default=\"sice\", description=\"Model type discriminator\"\n    )\n    aice: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Ice concentration as a fraction from 0 to 1. Note that `aice` is allowed \"\n            \"to vary over the computational region to account for the zonation of ice \"\n            \"concentration. In that case use the commands `INPGRID AICE` and `READINP \"\n            \"AICE` to define and read the sea concentration. The value of `aice` in \"\n            \"this command is then not required (it will be ignored)\"\n        ),\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SICE\"\n        if self.aice is not None:\n            repr += f\" aice={self.aice}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['sice', 'SICE'] = Field(default='sice', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE.aice","title":"aice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aice: Optional[float] = Field(default=None, description='Ice concentration as a fraction from 0 to 1. Note that `aice` is allowed to vary over the computational region to account for the zonation of ice concentration. In that case use the commands `INPGRID AICE` and `READINP AICE` to define and read the sea concentration. The value of `aice` in this command is then not required (it will be ignored)', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SICE\"\n    if self.aice is not None:\n        repr += f\" aice={self.aice}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19","title":"SICE_R19","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Rogers et al (2019).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] R19 [c0] [c1] [c2] [c3] [c4] [c5] [c6]\n</code></pre> <p>The default options recover the polynomial of Meylan et al. (2014), calibrated for a case of ice floes, mostly 10 to 25 m in diameter, in the marginal ice zone near Antarctica. Examples for other calibrations can be found in the Scientific/Technical documentation.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19--references","title":"References","text":"<p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_R19\nsice = SICE_R19()\nprint(sice.render())\nkwargs = dict(\n    aice=0.5,\n    c0=0.0,\n    c1=0.0,\n    c2=1.06e-3,\n    c3=0.0,\n    c4=0.0,\n    c5=0.0,\n    c6=0.0,\n)\nsice = SICE_R19(**kwargs)\nprint(sice.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SICE_R19(SICE):\n    \"\"\"Sea ice dissipation based on the method of Rogers et al (2019).\n\n    .. code-block:: text\n\n        SICE [aice] R19 [c0] [c1] [c2] [c3] [c4] [c5] [c6]\n\n    The default options recover the polynomial of Meylan et al. (2014), calibrated for\n    a case of ice floes, mostly 10 to 25 m in diameter, in the marginal ice zone near\n    Antarctica. Examples for other calibrations can be found in the\n    Scientific/Technical documentation.\n\n    References\n    ----------\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of\n    dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of\n    the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_R19\n        sice = SICE_R19()\n        print(sice.render())\n        kwargs = dict(\n            aice=0.5,\n            c0=0.0,\n            c1=0.0,\n            c2=1.06e-3,\n            c3=0.0,\n            c4=0.0,\n            c5=0.0,\n            c6=0.0,\n        )\n        sice = SICE_R19(**kwargs)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"r19\", \"R19\"] = Field(\n        default=\"r19\", description=\"Model type discriminator\"\n    )\n    c0: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in 1/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s2/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 1.06E-3)\"\n        ),\n    )\n    c3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s3/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c4: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s4/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 2.3E-2)\"\n        ),\n    )\n    c5: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s5/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c6: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s6/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.c0 is not None:\n            repr += f\" c0={self.c0}\"\n        if self.c1 is not None:\n            repr += f\" c1={self.c1}\"\n        if self.c2 is not None:\n            repr += f\" c2={self.c2}\"\n        if self.c3 is not None:\n            repr += f\" c3={self.c3}\"\n        if self.c4 is not None:\n            repr += f\" c4={self.c4}\"\n        if self.c5 is not None:\n            repr += f\" c5={self.c5}\"\n        if self.c6 is not None:\n            repr += f\" c6={self.c6}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['r19', 'R19'] = Field(default='r19', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c0","title":"c0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0: Optional[float] = Field(default=None, description='Polynomial coefficient (in 1/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c1","title":"c1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c1: Optional[float] = Field(default=None, description='Polynomial coefficient (in s/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c2","title":"c2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c2: Optional[float] = Field(default=None, description='Polynomial coefficient (in s2/m) for determining the rate of sea ice dissipation (SWAN default: 1.06E-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c3","title":"c3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c3: Optional[float] = Field(default=None, description='Polynomial coefficient (in s3/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c4","title":"c4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c4: Optional[float] = Field(default=None, description='Polynomial coefficient (in s4/m) for determining the rate of sea ice dissipation (SWAN default: 2.3E-2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c5","title":"c5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c5: Optional[float] = Field(default=None, description='Polynomial coefficient (in s5/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c6","title":"c6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c6: Optional[float] = Field(default=None, description='Polynomial coefficient (in s6/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.c0 is not None:\n        repr += f\" c0={self.c0}\"\n    if self.c1 is not None:\n        repr += f\" c1={self.c1}\"\n    if self.c2 is not None:\n        repr += f\" c2={self.c2}\"\n    if self.c3 is not None:\n        repr += f\" c3={self.c3}\"\n    if self.c4 is not None:\n        repr += f\" c4={self.c4}\"\n    if self.c5 is not None:\n        repr += f\" c5={self.c5}\"\n    if self.c6 is not None:\n        repr += f\" c6={self.c6}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15","title":"SICE_D15","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Doble et al. (2015).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] D15 [chf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15--references","title":"References","text":"<p>Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015. Relating wave attenuation to pancake ice thickness, using field measurements and model results. Geophysical Research Letters, 42(11), pp.4473-4481.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_D15\nsice = SICE_D15()\nprint(sice.render())\nsice = SICE_D15(aice=0.2, chf=0.1)\nprint(sice.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SICE_D15(SICE):\n    \"\"\"Sea ice dissipation based on the method of Doble et al. (2015).\n\n    .. code-block:: text\n\n        SICE [aice] D15 [chf]\n\n    References\n    ----------\n    Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015.\n    Relating wave attenuation to pancake ice thickness, using field measurements and\n    model results. Geophysical Research Letters, 42(11), pp.4473-4481.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_D15\n        sice = SICE_D15()\n        print(sice.render())\n        sice = SICE_D15(aice=0.2, chf=0.1)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"d15\", \"D15\"] = Field(\n        default=\"d15\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 0.1)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['d15', 'D15'] = Field(default='d15', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 0.1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18","title":"SICE_M18","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Meylan et al. (2018).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] M18 [chf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18--references","title":"References","text":"<p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_M18\nsice = SICE_M18()\nprint(sice.render())\nsice = SICE_M18(aice=0.8, chf=0.059)\nprint(sice.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SICE_M18(SICE):\n    \"\"\"Sea ice dissipation based on the method of Meylan et al. (2018).\n\n    .. code-block:: text\n\n        SICE [aice] M18 [chf]\n\n    References\n    ----------\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_M18\n        sice = SICE_M18()\n        print(sice.render())\n        sice = SICE_M18(aice=0.8, chf=0.059)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"m18\", \"M18\"] = Field(\n        default=\"m18\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 0.059)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['m18', 'M18'] = Field(default='m18', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 0.059)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B","title":"SICE_R21B","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Rogers et al. (2021).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] R21B [chf] [npf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B--references","title":"References","text":"<p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science and Technology, 182, p.103198.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_R21B\nsice = SICE_R21B()\nprint(sice.render())\nsice = SICE_R21B(aice=0.8, chf=2.9, npf=4.5)\nprint(sice.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SICE_R21B(SICE):\n    \"\"\"Sea ice dissipation based on the method of Rogers et al. (2021).\n\n    .. code-block:: text\n\n        SICE [aice] R21B [chf] [npf]\n\n    References\n    ----------\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave\n    attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science\n    and Technology, 182, p.103198.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_R21B\n        sice = SICE_R21B()\n        print(sice.render())\n        sice = SICE_R21B(aice=0.8, chf=2.9, npf=4.5)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"r21b\", \"R21B\"] = Field(\n        default=\"r21b\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 2.9)\",\n    )\n    npf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the degree of dependence on frequency and ice thickness \"\n            \"(SWAN default: 4.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        if self.npf is not None:\n            repr += f\" npf={self.npf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['r21b', 'R21B'] = Field(default='r21b', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 2.9)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.npf","title":"npf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npf: Optional[float] = Field(default=None, description='Controls the degree of dependence on frequency and ice thickness (SWAN default: 4.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    if self.npf is not None:\n        repr += f\" npf={self.npf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#turbulent-viscosity","title":"Turbulent viscosity","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE","title":"TURBULENCE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Turbulent viscosity.</p> <p>.. code-block:: text</p> <pre><code>TURBULENCE [ctb] (CURRENT [tbcur])\n</code></pre> <p>With this optional command the user can activate turbulent viscosity. This physical effect is also activated by reading values of the turbulent viscosity using the <code>READGRID TURB</code> command, but then with the default value of <code>ctb</code>. The command <code>READGRID TURB</code> is necessary if this command <code>TURB</code> is used since the value of the viscosity is assumed to vary over space.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TURBULENCE\nturbulence = TURBULENCE(current=False)\nprint(turbulence.render())\nturbulence = TURBULENCE(ctb=0.01, current=True, tbcur=0.004)\nprint(turbulence.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class TURBULENCE(BaseComponent):\n    \"\"\"Turbulent viscosity.\n\n    .. code-block:: text\n\n        TURBULENCE [ctb] (CURRENT [tbcur])\n\n    With this optional command the user can activate turbulent viscosity. This physical\n    effect is also activated by reading values of the turbulent viscosity using the\n    `READGRID TURB` command, but then with the default value of `ctb`. The command\n    `READGRID TURB` is necessary if this command `TURB` is used since the value of the\n    viscosity is assumed to vary over space.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TURBULENCE\n        turbulence = TURBULENCE(current=False)\n        print(turbulence.render())\n        turbulence = TURBULENCE(ctb=0.01, current=True, tbcur=0.004)\n        print(turbulence.render())\n\n    \"\"\"\n\n    model_type: Literal[\"turbulence\", \"TURBULENCE\"] = Field(\n        default=\"turbulence\", description=\"Model type discriminator\"\n    )\n    ctb: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The value of the proportionality coefficient appearing in the energy \"\n            \"dissipation term (SWAN default: 0.01)\"\n        ),\n    )\n    current: Optional[bool] = Field(\n        default=True,\n        description=(\n            \"If this keyword is present the turbulent viscosity will be derived from \"\n            \"the product of the depth and the absolute value of the current velocity. \"\n            \"If the command `READGRID TURB` is used, this option is ignored; \"\n            \"the values read from file will prevail\"\n        ),\n    )\n    tbcur: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The factor by which depth x current velocity is multiplied in order to \"\n            \"get the turbulent viscosity (SWAN default: 0.004)\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def tbcur_only_with_current(self) -&gt; \"TURBULENCE\":\n        if not self.current and self.tbcur is not None:\n            raise ValueError(\"`tbcur` can only be defined if `current` is True\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TURBULENCE\"\n        if self.ctb is not None:\n            repr += f\" ctb={self.ctb}\"\n        if self.current:\n            repr += \" CURRENT\"\n        if self.tbcur is not None:\n            repr += f\" tbcur={self.tbcur}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['turbulence', 'TURBULENCE'] = Field(default='turbulence', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.ctb","title":"ctb  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctb: Optional[float] = Field(default=None, description='The value of the proportionality coefficient appearing in the energy dissipation term (SWAN default: 0.01)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.current","title":"current  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current: Optional[bool] = Field(default=True, description='If this keyword is present the turbulent viscosity will be derived from the product of the depth and the absolute value of the current velocity. If the command `READGRID TURB` is used, this option is ignored; the values read from file will prevail')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.tbcur","title":"tbcur  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbcur: Optional[float] = Field(default=None, description='The factor by which depth x current velocity is multiplied in order to get the turbulent viscosity (SWAN default: 0.004)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.tbcur_only_with_current","title":"tbcur_only_with_current","text":"<pre><code>tbcur_only_with_current() -&gt; TURBULENCE\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef tbcur_only_with_current(self) -&gt; \"TURBULENCE\":\n    if not self.current and self.tbcur is not None:\n        raise ValueError(\"`tbcur` can only be defined if `current` is True\")\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TURBULENCE\"\n    if self.ctb is not None:\n        repr += f\" ctb={self.ctb}\"\n    if self.current:\n        repr += \" CURRENT\"\n    if self.tbcur is not None:\n        repr += f\" tbcur={self.tbcur}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#bragg-scattering","title":"Bragg scattering","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG","title":"BRAGG","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Bragg scattering.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff]\n</code></pre> <p>Using this optional command, the user activates a source term to represent the scattering of waves due to changes in the small-scale bathymetry based on the theory of Ardhuin and Herbers (2002). If this command is not used, SWAN will not account for Bragg scattering.</p> <p>The underlying process is related to the bed elevation spectrum that describes the random variability of the bathymetry at the scale of the wave length on top of a slowly varying depth. To input this spectrum in the model, two options are available. One option is to read a spectrum from a file. This single bottom spectrum will subsequently be applied in all active grid points. The assumption being made here is that the inputted bottom is gently sloping. Note that the bottom spectrum must be given as a function of the wave number <code>k</code>.</p> <p>Another option is to compute the spectrum by a Fourier transform from <code>x</code> to <code>k</code> of the bed modulations around a computational grid point. First, one must define a square region with a fixed size around the grid point in order to perform the Fourier transform. The size should correspond to a multiple of the wave length at which refraction is resolved (i.e. consistent with the mild slope assumption). Next, the amplitude modulation of the small-scale bathymetry is obtained by substracting a slowly varying bed level from the inputted high-resolution bathymetric data within this square region. Here, the smooth bed level is achieved using a bilinear fit. During the computation, however, SWAN employs the gently sloping bed as the mean of the original bathymetry within the given square around each computational grid point. Finally, the corresponding bottom spectrum is computed with an FFT.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG--notes","title":"Notes","text":"<p>The Bragg scattering source term to the action balance equation gives rise to a fairly stiff equation. The best remedy is to run SWAN in the nonstationary mode with a relatively small time step or in the stationary mode with some under relaxation (see command <code>NUM STAT [alfa]</code>).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG\nbragg = BRAGG(nreg=200)\nprint(bragg.render())\nbragg = BRAGG(ibrag=1, nreg=200, cutoff=5.0)\nprint(bragg.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BRAGG(BaseComponent):\n    \"\"\"Bragg scattering.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff]\n\n    Using this optional command, the user activates a source term to represent the\n    scattering of waves due to changes in the small-scale bathymetry based on the\n    theory of Ardhuin and Herbers (2002). If this command is not used, SWAN will not\n    account for Bragg scattering.\n\n    The underlying process is related to the bed elevation spectrum that describes the\n    random variability of the bathymetry at the scale of the wave length on top of a\n    slowly varying depth. To input this spectrum in the model, two options are\n    available. One option is to read a spectrum from a file. This single bottom\n    spectrum will subsequently be applied in all active grid points. The assumption\n    being made here is that the inputted bottom is gently sloping. Note that the bottom\n    spectrum must be given as a function of the wave number `k`.\n\n    Another option is to compute the spectrum by a Fourier transform from `x` to `k` of\n    the bed modulations around a computational grid point. First, one must define a\n    square region with a fixed size around the grid point in order to perform the\n    Fourier transform. The size should correspond to a multiple of the wave length at\n    which refraction is resolved (i.e. consistent with the mild slope assumption).\n    Next, the amplitude modulation of the small-scale bathymetry is obtained by\n    substracting a slowly varying bed level from the inputted high-resolution\n    bathymetric data within this square region. Here, the smooth bed level is achieved\n    using a bilinear fit. During the computation, however, SWAN employs the gently\n    sloping bed as the mean of the original bathymetry within the given square around\n    each computational grid point. Finally, the corresponding bottom spectrum is\n    computed with an FFT.\n\n    Notes\n    -----\n    The Bragg scattering source term to the action balance equation gives rise to a\n    fairly stiff equation. The best remedy is to run SWAN in the nonstationary mode\n    with a relatively small time step or in the stationary mode with some under\n    relaxation (see command `NUM STAT [alfa]`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG\n        bragg = BRAGG(nreg=200)\n        print(bragg.render())\n        bragg = BRAGG(ibrag=1, nreg=200, cutoff=5.0)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bragg\", \"BRAGG\"] = Field(\n        default=\"bragg\", description=\"Model type discriminator\"\n    )\n    ibrag: Optional[Literal[1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Indicates the computation of Bragg scattering term:\\n\\n* 1: source term \"\n            \"is calculated per sweep and bottom spectrum is interpolated at the \"\n            \"difference wave number a priori (thus requiring storage)\\n* 2: source \"\n            \"term is calculated per sweep and bottom spectrum is interpolated at the \"\n            \"difference wave number per sweep (no storage)\\n* 3: source term is \"\n            \"calculated per iteration and bottom spectrum is interpolated at the \"\n            \"difference wave number per iteration (no storage)\\n\\n(SWAN default: 1)\"\n        ),\n    )\n    nreg: int = Field(\n        description=(\n            \"Size of square region around computational grid point (centered) for \"\n            \"computing the mean depth and, if desired, the bed elevation spectrum. It \"\n            \"is expressed in terms of the number of grid points (per direction) \"\n            \"of the inputted bottom grid\"\n        ),\n    )\n    cutoff: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Cutoff to the ratio between surface and bottom wave numbers. Note: see\"\n            \"the Scientific/Technical documentation for details (SWAN default: 5.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BRAGG\"\n        if self.ibrag is not None:\n            repr += f\" ibrag={self.ibrag}\"\n        if self.nreg is not None:\n            repr += f\" nreg={self.nreg}\"\n        if self.cutoff is not None:\n            repr += f\" cutoff={self.cutoff}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bragg', 'BRAGG'] = Field(default='bragg', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.ibrag","title":"ibrag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ibrag: Optional[Literal[1, 2, 3]] = Field(default=None, description='Indicates the computation of Bragg scattering term:\\n\\n* 1: source term is calculated per sweep and bottom spectrum is interpolated at the difference wave number a priori (thus requiring storage)\\n* 2: source term is calculated per sweep and bottom spectrum is interpolated at the difference wave number per sweep (no storage)\\n* 3: source term is calculated per iteration and bottom spectrum is interpolated at the difference wave number per iteration (no storage)\\n\\n(SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.nreg","title":"nreg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nreg: int = Field(description='Size of square region around computational grid point (centered) for computing the mean depth and, if desired, the bed elevation spectrum. It is expressed in terms of the number of grid points (per direction) of the inputted bottom grid')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutoff: Optional[float] = Field(default=None, description='Cutoff to the ratio between surface and bottom wave numbers. Note: seethe Scientific/Technical documentation for details (SWAN default: 5.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BRAGG\"\n    if self.ibrag is not None:\n        repr += f\" ibrag={self.ibrag}\"\n    if self.nreg is not None:\n        repr += f\" nreg={self.nreg}\"\n    if self.cutoff is not None:\n        repr += f\" cutoff={self.cutoff}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT","title":"BRAGG_FT","text":"<p>               Bases: <code>BRAGG</code></p> <p>Bragg scattering with bottom spectrum computed from FFT.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff] FT\n</code></pre> <p>If this keyword is present the bottom spectrum will be computed in each active grid point using a Fast Fourier Transform (FFT).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT--notes","title":"Notes","text":"<p>The depth in each computational grid point is computed as the average of the inputted (high-resolution) bed levels within the square region.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG_FT\nbragg = BRAGG_FT(nreg=350)\nprint(bragg.render())\nbragg = BRAGG_FT(ibrag=2, nreg=350, cutoff=5.0)\nprint(bragg.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BRAGG_FT(BRAGG):\n    \"\"\"Bragg scattering with bottom spectrum computed from FFT.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff] FT\n\n    If this keyword is present the bottom spectrum will be computed in each active\n    grid point using a Fast Fourier Transform (FFT).\n\n    Notes\n    -----\n    The depth in each computational grid point is computed as the average of the\n    inputted (high-resolution) bed levels within the square region.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG_FT\n        bragg = BRAGG_FT(nreg=350)\n        print(bragg.render())\n        bragg = BRAGG_FT(ibrag=2, nreg=350, cutoff=5.0)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ft\", \"FT\"] = Field(\n        default=\"ft\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"{super().cmd()} FT\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ft', 'FT'] = Field(default='ft', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"{super().cmd()} FT\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE","title":"BRAGG_FILE","text":"<p>               Bases: <code>BRAGG</code></p> <p>Bragg scattering with bottom spectrum from file.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff] FILE 'fname' [idla] [mkx] [mky] [dkx] [dky]\n</code></pre> <p>The bed elevation spectrum <code>FB(kx, ky)</code> is read from a file.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE--notes","title":"Notes","text":"<p>This spectrum is taken to be uniform over the entire computational domain.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG_FILE\nbragg = BRAGG_FILE(fname=\"bottom_spectrum.txt\", nreg=500, mkx=99, dkx=0.1)\nprint(bragg.render())\nkwargs = dict(\n    ibrag=3,\n    nreg=500,\n    cutoff=5.0,\n    fname=\"bottom_spectrum.txt\",\n    mkx=99,\n    mky=149,\n    dkx=0.1,\n    dky=0.1,\n)\nbragg = BRAGG_FILE(**kwargs)\nprint(bragg.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class BRAGG_FILE(BRAGG):\n    \"\"\"Bragg scattering with bottom spectrum from file.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff] FILE 'fname' [idla] [mkx] [mky] [dkx] [dky]\n\n    The bed elevation spectrum `FB(kx, ky)` is read from a file.\n\n    Notes\n    -----\n    This spectrum is taken to be uniform over the entire computational domain.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG_FILE\n        bragg = BRAGG_FILE(fname=\"bottom_spectrum.txt\", nreg=500, mkx=99, dkx=0.1)\n        print(bragg.render())\n        kwargs = dict(\n            ibrag=3,\n            nreg=500,\n            cutoff=5.0,\n            fname=\"bottom_spectrum.txt\",\n            mkx=99,\n            mky=149,\n            dkx=0.1,\n            dky=0.1,\n        )\n        bragg = BRAGG_FILE(**kwargs)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"file\", \"FILE\"] = Field(\n        default=\"file\", description=\"Model type discriminator\"\n    )\n    fname: str = Field(\n        description=\"Name of file containing the bottom spectrum\",\n        max_length=36,\n    )\n    idla: Optional[IDLA] = Field(\n        default=None,\n        description=(\"Order in which the values should be given in the input files\"),\n    )\n    mkx: int = Field(\n        description=(\n            \"Number of cells in x-direction of the wave number grid related to bottom \"\n            \"spectrum (this is one less than the number of points in this direction)\"\n        ),\n    )\n    mky: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Number of cells in y-direction of the wave number grid related to bottom \"\n            \"spectrum (this is one less than the number of points in this direction)\"\n            \"(SWAN default: `mky = mkx`)\"\n        ),\n    )\n    dkx: float = Field(\n        description=(\n            \"Mesh size in x-direction of the wave number grid related to bottom \"\n            \"spectrum (1/m)\"\n        ),\n    )\n    dky: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Mesh size in y-direction of the wave number grid related to bottom \"\n            \"spectrum (1/m) (SWAN default: `dky = dkx`)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} FILE fname='{self.fname}'\"\n        if self.idla is not None:\n            repr += f\" idla={self.idla.value}\"\n        repr += f\" mkx={self.mkx}\"\n        if self.mky is not None:\n            repr += f\" mky={self.mky}\"\n        repr += f\" dkx={self.dkx}\"\n        if self.dky is not None:\n            repr += f\" dky={self.dky}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['file', 'FILE'] = Field(default='file', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of file containing the bottom spectrum', max_length=36)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[IDLA] = Field(default=None, description='Order in which the values should be given in the input files')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.mkx","title":"mkx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mkx: int = Field(description='Number of cells in x-direction of the wave number grid related to bottom spectrum (this is one less than the number of points in this direction)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.mky","title":"mky  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mky: Optional[int] = Field(default=None, description='Number of cells in y-direction of the wave number grid related to bottom spectrum (this is one less than the number of points in this direction)(SWAN default: `mky = mkx`)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.dkx","title":"dkx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dkx: float = Field(description='Mesh size in x-direction of the wave number grid related to bottom spectrum (1/m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.dky","title":"dky  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dky: Optional[float] = Field(default=None, description='Mesh size in y-direction of the wave number grid related to bottom spectrum (1/m) (SWAN default: `dky = dkx`)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} FILE fname='{self.fname}'\"\n    if self.idla is not None:\n        repr += f\" idla={self.idla.value}\"\n    repr += f\" mkx={self.mkx}\"\n    if self.mky is not None:\n        repr += f\" mky={self.mky}\"\n    repr += f\" dkx={self.dkx}\"\n    if self.dky is not None:\n        repr += f\" dky={self.dky}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#limiter","title":"Limiter","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER","title":"LIMITER","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Physics limiter.</p> <p>.. code-block:: text</p> <pre><code>LIMITER [ursell] [qb]\n</code></pre> <p>With this command the user can de-activate permanently the quadruplets when the actual Ursell number exceeds <code>ursell</code>. Moreover, as soon as the actual fraction of breaking waves exceeds <code>qb</code> then the action limiter will not be used in case of decreasing action density.</p>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import LIMITER\nlimiter = LIMITER()\nprint(limiter.render())\nlimiter = LIMITER(ursell=10.0, qb=1.0)\nprint(limiter.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class LIMITER(BaseComponent):\n    \"\"\"Physics limiter.\n\n    .. code-block:: text\n\n        LIMITER [ursell] [qb]\n\n    With this command the user can de-activate permanently the quadruplets when\n    the actual Ursell number exceeds `ursell`. Moreover, as soon as the actual\n    fraction of breaking waves exceeds `qb` then the action limiter will not be\n    used in case of decreasing action density.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import LIMITER\n        limiter = LIMITER()\n        print(limiter.render())\n        limiter = LIMITER(ursell=10.0, qb=1.0)\n        print(limiter.render())\n\n    \"\"\"\n\n    model_type: Literal[\"limiter\", \"LIMITER\"] = Field(\n        default=\"limiter\", description=\"Model type discriminator\"\n    )\n    ursell: Optional[float] = Field(\n        default=None,\n        description=(\"The upper threshold for Ursell number (SWAN default: 10.0)\"),\n    )\n    qb: Optional[float] = Field(\n        default=None,\n        description=\"The threshold for fraction of breaking waves (SWAN default: 1.0)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"LIMITER\"\n        if self.ursell is not None:\n            repr += f\" ursell={self.ursell}\"\n        if self.qb is not None:\n            repr += f\" qb={self.qb}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['limiter', 'LIMITER'] = Field(default='limiter', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.ursell","title":"ursell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ursell: Optional[float] = Field(default=None, description='The upper threshold for Ursell number (SWAN default: 10.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.qb","title":"qb  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qb: Optional[float] = Field(default=None, description='The threshold for fraction of breaking waves (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"LIMITER\"\n    if self.ursell is not None:\n        repr += f\" ursell={self.ursell}\"\n    if self.qb is not None:\n        repr += f\" qb={self.qb}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#obstacle","title":"Obstacle","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE","title":"OBSTACLE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Subgrid obstacle.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE -&gt;TRANSM|TRANS1D|TRANS2D|GODA|DANGREMOND REFL [reflc] -&gt;RSPEC|RDIFF &amp;\n    (FREEBOARD [hgt] [gammat] [gammar] QUAY) LINE &lt; [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user provides the characteristics of a (line of) sub-grid obstacle(s) through which waves are transmitted or against which waves are reflected (possibly both at the same time). The obstacle is sub-grid in the sense that it is narrow compared to the spatial meshes; its length should be at least one mesh length.</p> <p>The location of the obstacle is defined by a sequence of corner points of a line. The obstacles interrupt the propagation of the waves from one grid point to the next wherever this obstacle line is located between two neighbouring grid points (of the computational grid; the resolution of the obstacle is therefore equal to the computational grid spacing). This implies that an obstacle to be effective must be located such that it crosses at least one grid line. This is always the case when an obstacle is larger than one mesh length.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE--notes","title":"Notes","text":"<ul> <li>The advise is to define obstacles with the least amount of points possible.</li> <li>SWAN checks if the criterion <code>reflc^2 + trcoef^2 LE 1</code> is fulfilled.</li> </ul>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLE\nobs = OBSTACLE(\n    transmission=dict(model_type=\"transm\", trcoef=0.5),\n    reflection=dict(reflc=0.5),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class OBSTACLE(BaseComponent):\n    \"\"\"Subgrid obstacle.\n\n    .. code-block:: text\n\n        OBSTACLE -&gt;TRANSM|TRANS1D|TRANS2D|GODA|DANGREMOND REFL [reflc] -&gt;RSPEC|RDIFF &amp;\n            (FREEBOARD [hgt] [gammat] [gammar] QUAY) LINE &lt; [xp] [yp] &gt;\n\n    With this optional command the user provides the characteristics of a (line\n    of) sub-grid obstacle(s) through which waves are transmitted or against which\n    waves are reflected (possibly both at the same time). The obstacle is sub-grid\n    in the sense that it is narrow compared to the spatial meshes; its length should\n    be at least one mesh length.\n\n    The location of the obstacle is defined by a sequence of corner points of a line.\n    The obstacles interrupt the propagation of the waves from one grid point to the\n    next wherever this obstacle line is located between two neighbouring grid points\n    (of the computational grid; the resolution of the obstacle is therefore equal to\n    the computational grid spacing). This implies that an obstacle to be effective must\n    be located such that it crosses at least one grid line. This is always the case\n    when an obstacle is larger than one mesh length.\n\n    Notes\n    -----\n\n    * The advise is to define obstacles with the least amount of points possible.\n    * SWAN checks if the criterion `reflc^2 + trcoef^2 LE 1` is fulfilled.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLE\n        obs = OBSTACLE(\n            transmission=dict(model_type=\"transm\", trcoef=0.5),\n            reflection=dict(reflc=0.5),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"obstacle\", \"OBSTACLE\"] = Field(\n        default=\"obstacle\", description=\"Model type discriminator\"\n    )\n    transmission: Optional[TRANSMISSION_TYPE] = Field(default=None)\n    reflection: Optional[REFL] = Field(default=None, description=\"Wave reflection\")\n    reflection_type: Optional[REFLECTION_TYPE] = Field(default=None)\n    freeboard: Optional[FREEBOARD] = Field(default=None, description=\"Freeboard\")\n    line: LINE = Field(default=None, description=\"Line of obstacle\")\n\n    @model_validator(mode=\"after\")\n    def hgt_consistent(self) -&gt; \"OBSTACLE\":\n        \"\"\"Warns if `hgt` has different values in DAM and FREEBOARD specifications.\"\"\"\n        if self.transmission is not None and self.freeboard is not None:\n            is_dam = self.transmission.model_type.upper() in [\"GODA\", \"DANGREMOND\"]\n            if is_dam and self.freeboard.hgt != self.transmission.hgt:\n                logger.warning(\"hgt in FREEBOARD and DAM specifications are not equal\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"OBSTACLE\"\n        if self.transmission is not None:\n            repr += f\" {self.transmission.render()}\"\n        if self.reflection:\n            repr += f\" {self.reflection.render()}\"\n        if self.reflection_type is not None:\n            repr += f\" {self.reflection_type.render()}\"\n        if self.freeboard is not None:\n            repr += f\" {self.freeboard.render()}\"\n        repr += f\" {self.line.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['obstacle', 'OBSTACLE'] = Field(default='obstacle', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.transmission","title":"transmission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transmission: Optional[TRANSMISSION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: Optional[REFL] = Field(default=None, description='Wave reflection')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.reflection_type","title":"reflection_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection_type: Optional[REFLECTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.freeboard","title":"freeboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freeboard: Optional[FREEBOARD] = Field(default=None, description='Freeboard')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.line","title":"line  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line: LINE = Field(default=None, description='Line of obstacle')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.hgt_consistent","title":"hgt_consistent","text":"<pre><code>hgt_consistent() -&gt; OBSTACLE\n</code></pre> <p>Warns if <code>hgt</code> has different values in DAM and FREEBOARD specifications.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef hgt_consistent(self) -&gt; \"OBSTACLE\":\n    \"\"\"Warns if `hgt` has different values in DAM and FREEBOARD specifications.\"\"\"\n    if self.transmission is not None and self.freeboard is not None:\n        is_dam = self.transmission.model_type.upper() in [\"GODA\", \"DANGREMOND\"]\n        if is_dam and self.freeboard.hgt != self.transmission.hgt:\n            logger.warning(\"hgt in FREEBOARD and DAM specifications are not equal\")\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"OBSTACLE\"\n    if self.transmission is not None:\n        repr += f\" {self.transmission.render()}\"\n    if self.reflection:\n        repr += f\" {self.reflection.render()}\"\n    if self.reflection_type is not None:\n        repr += f\" {self.reflection_type.render()}\"\n    if self.freeboard is not None:\n        repr += f\" {self.freeboard.render()}\"\n    repr += f\" {self.line.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG","title":"OBSTACLE_FIG","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Obstacle for free infragravity radiation.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE FIG [alpha1] [hss] [tss] (REFL [reflc]) LINE &lt;[xp] [yp]&gt;\n</code></pre> <p>With this optional command the user specifies the obstacles along which the free infra-gravity (FIG) energy is radiated. By placing the obstacles close to the shorelines SWAN will include the FIG source term along the coastlines according to the parametrization of Ardhuin et al. (2014).</p> <p>The location of the obstacle is defined by a sequence of corner points of a line. For an obstacle line to be effective its length is at least one mesh size large. It is recommended to place the obstacles at the inner area of the computational grid, not at or through the boundaries. In particular, each obstacle line must be bordered by wet points on both sides.</p> <p>In addition, the orientation of the obstacle line determines from which side of the obstacle the FIG wave energy is radiated away. If the begin point of the line is below or left of the end point, that is, pointing upwards/to the right, then FIG energy is radiated from the west/north side of the line. If the begin point is above or right of the end point (pointing downwards/to the left), then FIG energy is radiated away from the east/south side of the obstacle line.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--references","title":"References","text":"<p>Ardhuin, F., Rawat, A. and Aucan, J., 2014. A numerical model for free infragravity waves: Definition and validation at regional and global scales. Ocean Modelling, 77, pp.20-32.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--notes","title":"Notes","text":"<p>Either <code>hss</code> or <code>tss</code> or both are allowed to vary over the computational domain. In that case use the commands <code>INPGRID HSS</code> and <code>READINP HSS</code> and/or the commands <code>INPGRID TSS</code> and <code>READINP TSS</code> to define and read the sea-swell wave height/period It is permissible to have constant sea-swell height and non-constant sea-swell period, or vice versa. The command <code>OBST FIG</code> is still required to define the obstacles. The values of <code>hss</code> and/or <code>tss</code> in this command are then not required (they will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLE_FIG\nobs = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\nobs = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    reflection=dict(reflc=0.5),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class OBSTACLE_FIG(BaseComponent):\n    \"\"\"Obstacle for free infragravity radiation.\n\n    .. code-block:: text\n\n        OBSTACLE FIG [alpha1] [hss] [tss] (REFL [reflc]) LINE &lt;[xp] [yp]&gt;\n\n    With this optional command the user specifies the obstacles along which the\n    free infra-gravity (FIG) energy is radiated. By placing the obstacles close to\n    the shorelines SWAN will include the FIG source term along the coastlines\n    according to the parametrization of Ardhuin et al. (2014).\n\n    The location of the obstacle is defined by a sequence of corner points of a line.\n    For an obstacle line to be effective its length is at least one mesh size large. It\n    is recommended to place the obstacles at the inner area of the computational grid,\n    not at or through the boundaries. In particular, each obstacle line must be\n    bordered by wet points on both sides.\n\n    In addition, the orientation of the obstacle line determines from which side of the\n    obstacle the FIG wave energy is radiated away. If the begin point of the line is\n    below or left of the end point, that is, pointing upwards/to the right, then FIG\n    energy is radiated from the west/north side of the line. If the begin point is\n    above or right of the end point (pointing downwards/to the left), then FIG energy\n    is radiated away from the east/south side of the obstacle line.\n\n    References\n    ----------\n    Ardhuin, F., Rawat, A. and Aucan, J., 2014. A numerical model for free\n    infragravity waves: Definition and validation at regional and global scales.\n    Ocean Modelling, 77, pp.20-32.\n\n    Notes\n    -----\n    Either `hss` or `tss` or both are allowed to vary over the computational domain.\n    In that case use the commands `INPGRID HSS` and `READINP HSS` and/or the commands\n    `INPGRID TSS` and `READINP TSS` to define and read the sea-swell wave height/period\n    It is permissible to have constant sea-swell height and non-constant sea-swell\n    period, or vice versa. The command `OBST FIG` is still required to define the\n    obstacles. The values of `hss` and/or `tss` in this command are then not required\n    (they will be ignored).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLE_FIG\n        obs = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n        obs = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            reflection=dict(reflc=0.5),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"fig\", \"FIG\"] = Field(\n        default=\"fig\", description=\"Model type discriminator\"\n    )\n    alpha1: float = Field(\n        description=(\n            \"Calibration parameter (in 1/s) for determining the rate of radiating FIG \"\n            \"energy from the shorelines, values in Table 1 of Ardhuin et al. (2014) \"\n            \"are between 4e-4 and 8.1e-4\"\n        ),\n    )\n    hss: float = Field(\n        description=\"The sea-swell significant wave height (in m)\",\n        ge=0.0,\n    )\n    tss: float = Field(\n        description=\"The sea-swell mean wave period (in s)\",\n        ge=0.0,\n    )\n    reflection: Optional[REFL] = Field(default=None, description=\"Wave reflection\")\n    line: LINE = Field(description=\"Line of obstacle\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"OBSTACLE FIG alpha1={self.alpha1} hss={self.hss} tss={self.tss}\"\n        if self.reflection:\n            repr += f\" {self.reflection.render()}\"\n        repr += f\" {self.line.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['fig', 'FIG'] = Field(default='fig', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.alpha1","title":"alpha1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha1: float = Field(description='Calibration parameter (in 1/s) for determining the rate of radiating FIG energy from the shorelines, values in Table 1 of Ardhuin et al. (2014) are between 4e-4 and 8.1e-4')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.hss","title":"hss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hss: float = Field(description='The sea-swell significant wave height (in m)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.tss","title":"tss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tss: float = Field(description='The sea-swell mean wave period (in s)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: Optional[REFL] = Field(default=None, description='Wave reflection')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.line","title":"line  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line: LINE = Field(description='Line of obstacle')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"OBSTACLE FIG alpha1={self.alpha1} hss={self.hss} tss={self.tss}\"\n    if self.reflection:\n        repr += f\" {self.reflection.render()}\"\n    repr += f\" {self.line.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES","title":"OBSTACLES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>List of swan obstacles.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE ... LINE &lt; [xp] [yp] &gt;\nOBSTACLE ... LINE &lt; [xp] [yp] &gt;\n.\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of obstacle components.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLES, OBSTACLE, OBSTACLE_FIG\nobst1 = dict(\n    model_type=\"obstacle\",\n    reflection=dict(reflc=1.0),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nobst2 = OBSTACLE(\n    transmission=dict(model_type=\"transm\"),\n    line=dict(xp=[174.3, 174.3], yp=[-39.1, -39.2]),\n)\nobst3 = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nobstacles = OBSTACLES(obstacles=[obst1, obst2, obst3])\nfor obst in obstacles.render():\n    print(obst)\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class OBSTACLES(BaseComponent):\n    \"\"\"List of swan obstacles.\n\n    .. code-block:: text\n\n        OBSTACLE ... LINE &lt; [xp] [yp] &gt;\n        OBSTACLE ... LINE &lt; [xp] [yp] &gt;\n        .\n\n    This group component is a convenience to allow defining and rendering\n    a list of obstacle components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLES, OBSTACLE, OBSTACLE_FIG\n        obst1 = dict(\n            model_type=\"obstacle\",\n            reflection=dict(reflc=1.0),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        obst2 = OBSTACLE(\n            transmission=dict(model_type=\"transm\"),\n            line=dict(xp=[174.3, 174.3], yp=[-39.1, -39.2]),\n        )\n        obst3 = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        obstacles = OBSTACLES(obstacles=[obst1, obst2, obst3])\n        for obst in obstacles.render():\n            print(obst)\n\n    \"\"\"\n\n    model_type: Literal[\"obstacles\", \"OBSTACLES\"] = Field(\n        default=\"obstacles\", description=\"Model type discriminator\"\n    )\n    obstacles: list[OBSTACLES_TYPE] = Field(description=\"List of obstacles\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        repr = []\n        for obstacle in self.obstacles:\n            repr += [obstacle.cmd()]\n        return repr\n\n    def render(self) -&gt; str:\n        \"\"\"Override base class to allow rendering list of components.\"\"\"\n        cmds = []\n        for cmd in self.cmd():\n            cmds.append(super().render(cmd))\n        return cmds\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['obstacles', 'OBSTACLES'] = Field(default='obstacles', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.obstacles","title":"obstacles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacles: list[OBSTACLES_TYPE] = Field(description='List of obstacles')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    repr = []\n    for obstacle in self.obstacles:\n        repr += [obstacle.cmd()]\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Override base class to allow rendering list of components.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Override base class to allow rendering list of components.\"\"\"\n    cmds = []\n    for cmd in self.cmd():\n        cmds.append(super().render(cmd))\n    return cmds\n</code></pre>"},{"location":"components/physics/#wave-setup","title":"Wave setup","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP","title":"SETUP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave setup.</p> <p>.. code-block:: text</p> <pre><code>SETUP [supcor]\n</code></pre> <p>If this command is given, the wave-induced set-up is computed and accounted for in the wave computations (during the computation it is added to the depth that is obtained from the <code>READ BOTTOM</code> and <code>READ WLEVEL</code> commands). This approximation in SWAN can only be applied to open coast (unlimited supply of water from outside the domain, e.g. nearshore coasts) in contrast to closed basin, e.g. lakes and estuaries, where this option should not be used. Note that set-up is not computed correctly with spherical coordinates.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP--notes","title":"Notes","text":"<ul> <li>The SETUP command cannot be used in case of unstructured grids.</li> <li>Set-up is not supported in case of parallel runs using either MPI or OpenMP.</li> </ul>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SETUP\nsetup = SETUP()\nprint(setup.render())\nsetup = SETUP(supcor=0.5)\nprint(setup.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SETUP(BaseComponent):\n    \"\"\"Wave setup.\n\n    .. code-block:: text\n\n        SETUP [supcor]\n\n    If this command is given, the wave-induced set-up is computed and accounted for in\n    the wave computations (during the computation it is added to the depth that is\n    obtained from the `READ BOTTOM` and `READ WLEVEL` commands). This approximation in\n    SWAN can only be applied to open coast (unlimited supply of water from outside the\n    domain, e.g. nearshore coasts) in contrast to closed basin, e.g. lakes and\n    estuaries, where this option should not be used. Note that set-up is not computed\n    correctly with spherical coordinates.\n\n    Notes\n    -----\n\n    * The SETUP command cannot be used in case of unstructured grids.\n    * Set-up is not supported in case of parallel runs using either MPI or OpenMP.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SETUP\n        setup = SETUP()\n        print(setup.render())\n        setup = SETUP(supcor=0.5)\n        print(setup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"setup\", \"SETUP\"] = Field(\n        default=\"setup\", description=\"Model type discriminator\"\n    )\n    supcor: Optional[float] = Field(\n        default=None,\n        description=(\n            \"By default the wave-induced set-up is computed with a constant added \"\n            \"such that the set-up is zero in the deepest point in the computational \"\n            \"grid. The user can modify this constant by the value of `supcor`. The \"\n            \"user can thus impose a set-up in any one point (and only one) in the \"\n            \"computational grid by first running SWAN, then reading the set-up in \"\n            \"that point and adding or subtracting the required value of `supcor` \"\n            \"(in m; positive if the set-up has to rise) (SWAN default: 0.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SETUP\"\n        if self.supcor is not None:\n            repr += f\" supcor={self.supcor}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['setup', 'SETUP'] = Field(default='setup', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP.supcor","title":"supcor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supcor: Optional[float] = Field(default=None, description='By default the wave-induced set-up is computed with a constant added such that the set-up is zero in the deepest point in the computational grid. The user can modify this constant by the value of `supcor`. The user can thus impose a set-up in any one point (and only one) in the computational grid by first running SWAN, then reading the set-up in that point and adding or subtracting the required value of `supcor` (in m; positive if the set-up has to rise) (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SETUP\"\n    if self.supcor is not None:\n        repr += f\" supcor={self.supcor}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-diffraction","title":"Wave diffraction","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION","title":"DIFFRACTION","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave diffraction.</p> <p>.. code-block:: text</p> <pre><code>DIFFRACTION [idiffr] [smpar] [smnum] [cgmod]\n</code></pre> <p>If this optional command is given, the diffraction is included in the wave computation. But the diffraction approximation in SWAN does not properly handle diffraction in harbours or in front of reflecting obstacles (see Scientific/Technical documentation). Behind breakwaters with a down-wave beach, the SWAN results seem reasonable. The spatial resolution near (the tip of) the diffraction obstacle should be 1/5 to 1/10 of the dominant wave length.</p>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION--notes","title":"Notes","text":"<p>Without extra measures, the diffraction computations with SWAN often converge poorly or not at all. Two measures can be taken:</p> <ol> <li> <p>(RECOMMENDED) The user can request under-relaxation. See command <code>NUMERIC</code> parameter <code>alpha</code> and Scientific/Technical documentation (Eq. (3.31)). Very limited experience suggests <code>alpha = 0.01</code>.</p> </li> <li> <p>Alternatively, the user can request smoothing of the wave field for the computation of the diffraction parameter (the wave field remains intact for all other computations and output). This is done with a repeated convolution filtering.</p> </li> </ol>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION--examples","title":"Examples","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import DIFFRACTION\ndiffraction = DIFFRACTION()\nprint(diffraction.render())\ndiffraction = DIFFRACTION(idiffr=True, smpar=0.0, smnum=1.0)\nprint(diffraction.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class DIFFRACTION(BaseComponent):\n    \"\"\"Wave diffraction.\n\n    .. code-block:: text\n\n        DIFFRACTION [idiffr] [smpar] [smnum] [cgmod]\n\n    If this optional command is given, the diffraction is included in the wave\n    computation. But the diffraction approximation in SWAN does not properly handle\n    diffraction in harbours or in front of reflecting obstacles (see\n    Scientific/Technical documentation). Behind breakwaters with a down-wave beach, the\n    SWAN results seem reasonable. The spatial resolution near (the tip of) the\n    diffraction obstacle should be 1/5 to 1/10 of the dominant wave length.\n\n    Notes\n    -----\n    Without extra measures, the diffraction computations with SWAN often converge\n    poorly or not at all. Two measures can be taken:\n\n    1. (RECOMMENDED) The user can request under-relaxation. See command `NUMERIC`\n    parameter `alpha` and Scientific/Technical documentation (Eq. (3.31)). Very limited\n    experience suggests `alpha = 0.01`.\n\n    2. Alternatively, the user can request smoothing of the wave field for the\n    computation of the diffraction parameter (the wave field remains intact for all\n    other computations and output). This is done with a repeated convolution filtering.\n\n    Examples\n    --------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import DIFFRACTION\n        diffraction = DIFFRACTION()\n        print(diffraction.render())\n        diffraction = DIFFRACTION(idiffr=True, smpar=0.0, smnum=1.0)\n        print(diffraction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"diffraction\", \"DIFFRACTION\"] = Field(\n        default=\"diffraction\", description=\"Model type discriminator\"\n    )\n    idiffr: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Indicates the use of diffraction. If `idiffr=0` then no diffraction is \"\n            \"taken into account (SWAN default: 1)\"\n        ),\n    )\n    smpar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Smoothing parameter for the calculation of \u2207 \u00b7 \u221aEtot. During every \"\n            \"smoothing step all grid points exchange `smpar` times the energy with \"\n            \"their neighbours. Note that `smpar` is parameter a in the above text \"\n            \"(SWAN default: 0.0)\"\n        ),\n    )\n    smnum: Optional[int] = Field(\n        default=None,\n        description=\"Number of smoothing steps relative to `smpar` (SWAN default: 0)\",\n    )\n    cgmod: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Adaption of propagation velocities in geographic space due to \"\n            \"diffraction. If `cgmod=0` then no adaption (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"DIFFRACTION\"\n        if self.idiffr is not None:\n            repr += f\" idiffr={int(self.idiffr)}\"\n        if self.smpar is not None:\n            repr += f\" smpar={self.smpar}\"\n        if self.smnum is not None:\n            repr += f\" smnum={self.smnum}\"\n        if self.cgmod is not None:\n            repr += f\" cgmod={self.cgmod}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['diffraction', 'DIFFRACTION'] = Field(default='diffraction', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.idiffr","title":"idiffr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idiffr: Optional[bool] = Field(default=None, description='Indicates the use of diffraction. If `idiffr=0` then no diffraction is taken into account (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.smpar","title":"smpar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smpar: Optional[float] = Field(default=None, description='Smoothing parameter for the calculation of \u2207 \u00b7 \u221aEtot. During every smoothing step all grid points exchange `smpar` times the energy with their neighbours. Note that `smpar` is parameter a in the above text (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.smnum","title":"smnum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smnum: Optional[int] = Field(default=None, description='Number of smoothing steps relative to `smpar` (SWAN default: 0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.cgmod","title":"cgmod  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cgmod: Optional[float] = Field(default=None, description='Adaption of propagation velocities in geographic space due to diffraction. If `cgmod=0` then no adaption (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"DIFFRACTION\"\n    if self.idiffr is not None:\n        repr += f\" idiffr={int(self.idiffr)}\"\n    if self.smpar is not None:\n        repr += f\" smpar={self.smpar}\"\n    if self.smnum is not None:\n        repr += f\" smnum={self.smnum}\"\n    if self.cgmod is not None:\n        repr += f\" cgmod={self.cgmod}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#surfbeat","title":"Surfbeat","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT","title":"SURFBEAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Surfbeat.</p> <p>.. code-block:: text</p> <pre><code>SURFBEAT [df] [nmax] [emin] UNIFORM/LOGARITHMIC\n</code></pre> <p>Using this optional command, the user activates the Infragravity Energy Module (IEM) of Reniers and Zijlema (2022). Besides the energy balance equation for a sea-swell wave field, another energy balance is included to account for the transfer of sea-swell energy to the bound infragravity (BIG) wave. This infragravity energy balance also involves a nonlinear transfer, expressed by the biphase, through the phase coupling between the radiation stress forcing and the BIG wave. For the prediction of the biphase for obliquely incident waves, an evolution equation is provided under the assumption that the bottom slopes are mild and alongshore uniform.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT--references","title":"References","text":"<p>Reniers, A. and Zijlema, M., 2022. Swan surfbeat-1d. Coastal Engineering, 172, p.104068.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import SURFBEAT\nsurfbeat = SURFBEAT()\nprint(surfbeat.render())\nsurfbeat = SURFBEAT(df=0.01, nmax=50000, emin=0.05, spacing=\"logarithmic\")\nprint(surfbeat.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SURFBEAT(BaseComponent):\n    \"\"\"Surfbeat.\n\n    .. code-block:: text\n\n        SURFBEAT [df] [nmax] [emin] UNIFORM/LOGARITHMIC\n\n    Using this optional command, the user activates the Infragravity Energy Module\n    (IEM) of Reniers and Zijlema (2022). Besides the energy balance equation for a\n    sea-swell wave field, another energy balance is included to account for the\n    transfer of sea-swell energy to the bound infragravity (BIG) wave. This\n    infragravity energy balance also involves a nonlinear transfer, expressed by the\n    biphase, through the phase coupling between the radiation stress forcing and the\n    BIG wave. For the prediction of the biphase for obliquely incident waves, an\n    evolution equation is provided under the assumption that the bottom slopes are mild\n    and alongshore uniform.\n\n    References\n    ----------\n    Reniers, A. and Zijlema, M., 2022. Swan surfbeat-1d. Coastal Engineering, 172,\n    p.104068.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import SURFBEAT\n        surfbeat = SURFBEAT()\n        print(surfbeat.render())\n        surfbeat = SURFBEAT(df=0.01, nmax=50000, emin=0.05, spacing=\"logarithmic\")\n        print(surfbeat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"surfbeat\", \"SURFBEAT\"] = Field(\n        default=\"surfbeat\", description=\"Model type discriminator\"\n    )\n    df: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The constant size of BIG frequency bin (in Hz) (SWAN default: 0.01)\"\n        ),\n        ge=0.0,\n    )\n    nmax: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of short-wave pairs for creating bichromatic wave \"\n            \"groups (SWAN default: 50000)\"\n        ),\n        ge=0,\n    )\n    emin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The energy threshold in fraction of energy spectrum peak. With this \"\n            \"threshold one takes into account those short wave components to create \"\n            \"bichromatic wave groups while their energy levels are larger than \"\n            \"`emin x E_max` with `E_max` the peak of the spectrum (SWAN default: 0.05)\"\n        ),\n    )\n    spacing: Optional[Literal[\"uniform\", \"logarithmic\"]] = Field(\n        default=None,\n        description=(\n            \"Define if frequencies for reflected ig waves are uniformly or \"\n            \"logarithmically distributed\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SURFBEAT\"\n        if self.df is not None:\n            repr += f\" df={self.df}\"\n        if self.nmax is not None:\n            repr += f\" nmax={self.nmax}\"\n        if self.emin is not None:\n            repr += f\" emin={self.emin}\"\n        if self.spacing is not None:\n            repr += f\" {self.spacing.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['surfbeat', 'SURFBEAT'] = Field(default='surfbeat', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.df","title":"df  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>df: Optional[float] = Field(default=None, description='The constant size of BIG frequency bin (in Hz) (SWAN default: 0.01)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.nmax","title":"nmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nmax: Optional[int] = Field(default=None, description='The maximum number of short-wave pairs for creating bichromatic wave groups (SWAN default: 50000)', ge=0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.emin","title":"emin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>emin: Optional[float] = Field(default=None, description='The energy threshold in fraction of energy spectrum peak. With this threshold one takes into account those short wave components to create bichromatic wave groups while their energy levels are larger than `emin x E_max` with `E_max` the peak of the spectrum (SWAN default: 0.05)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spacing: Optional[Literal['uniform', 'logarithmic']] = Field(default=None, description='Define if frequencies for reflected ig waves are uniformly or logarithmically distributed')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SURFBEAT\"\n    if self.df is not None:\n        repr += f\" df={self.df}\"\n    if self.nmax is not None:\n        repr += f\" nmax={self.nmax}\"\n    if self.emin is not None:\n        repr += f\" emin={self.emin}\"\n    if self.spacing is not None:\n        repr += f\" {self.spacing.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#scattering","title":"Scattering","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT","title":"SCAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Scattering.</p> <p>.. code-block:: text</p> <pre><code>SCAT [iqcm] (GRID [rfac]) (TRUNC [alpha] [qmax])\n</code></pre> <p>Using this optional command, the user activates a source term that allows for the generation and propagation of cross correlations between scattered waves due to variations in the bathymetry and mean currents. Such variations are rapid compared to the distancebetween the crossing waves (at the scale of 100-1000 m) and is particularly relevant for cases involving narrowband waves (swells) in coastal regions with shallow water and ambient currents. In turn, the immediate spatial effects of coherent scattering, interference, refraction and diffraction can cause large-scale changes in the wave parameters.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--references","title":"References","text":"<p>Smit, P.B. and Janssen, T.T., 2013. The evolution of inhomogeneous wave statistics through a variable medium. Journal of Physical Oceanography, 43(8), pp.1741-1758.</p> <p>Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of inhomogeneous ocean waves. Ocean Modelling, 96, pp.26-35.</p> <p>Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of coherent wave fields over variable depth. Journal of Physical Oceanography, 45(4), pp.1139-1154.</p> <p>Akrish, G., Smit, P., Zijlema, M. and Reniers, A., 2020. Modelling statistical wave interferences over shear currents. Journal of Fluid Mechanics, 891, p.A2.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--notes","title":"Notes","text":"<p>Implemented in SWAN 41.41.</p> <p>If both <code>alpha</code> and <code>qmax</code> options are provided to truncate the infinite convolution sum their mimimum is considered as the final limit on the sum.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import SCAT\nscat = SCAT()\nprint(scat.render())\nscat = SCAT(iqcm=2, rfac=1.0, alpha=1.0)\nprint(scat.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class SCAT(BaseComponent):\n    \"\"\"Scattering.\n\n    .. code-block:: text\n\n        SCAT [iqcm] (GRID [rfac]) (TRUNC [alpha] [qmax])\n\n    Using this optional command, the user activates a source term that allows for the\n    generation and propagation of cross correlations between scattered waves due to\n    variations in the bathymetry and mean currents. Such variations are rapid compared\n    to the distancebetween the crossing waves (at the scale of 100-1000 m) and is\n    particularly relevant for cases involving narrowband waves (swells) in coastal\n    regions with shallow water and ambient currents. In turn, the immediate spatial\n    effects of coherent scattering, interference, refraction and diffraction can cause\n    large-scale changes in the wave parameters.\n\n    References\n    ----------\n    Smit, P.B. and Janssen, T.T., 2013. The evolution of inhomogeneous wave statistics\n    through a variable medium. Journal of Physical Oceanography, 43(8), pp.1741-1758.\n\n    Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of\n    inhomogeneous ocean waves. Ocean Modelling, 96, pp.26-35.\n\n    Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of\n    coherent wave fields over variable depth. Journal of Physical Oceanography, 45(4),\n    pp.1139-1154.\n\n    Akrish, G., Smit, P., Zijlema, M. and Reniers, A., 2020. Modelling statistical wave\n    interferences over shear currents. Journal of Fluid Mechanics, 891, p.A2.\n\n    Notes\n    -----\n    Implemented in SWAN 41.41.\n\n    If both `alpha` and `qmax` options are provided to truncate the infinite\n    convolution sum their mimimum is considered as the final limit on the sum.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import SCAT\n        scat = SCAT()\n        print(scat.render())\n        scat = SCAT(iqcm=2, rfac=1.0, alpha=1.0)\n        print(scat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"scat\", \"SCAT\"] = Field(\n        default=\"scat\", description=\"Model type discriminator\"\n    )\n    iqcm: Optional[Literal[0, 1, 2]] = Field(\n        default=None,\n        description=(\n            \"Indicates the modelling and computation of QC scattering:\\n\\n* 0: no \"\n            \"scattering\\n* 1: scattering due to non-uniform bathymetry and currents \"\n            \"(the latter only if applicable; see command `INPGRID CURRENT`)\\n* 2: \"\n            \"wave-current interaction under the assumption of a slowly varying \"\n            \"bathymetry\\n\\n(SWAN default: 1)\"\n        ),\n    )\n    rfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The resolution factor through which the incident spectral width is\"\n            \"multiplied (SWAN default: 1.0)\"\n        ),\n        ge=1.0,\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The coefficient by which the mean wave number is multiplied to set the\"\n            \"limit on the convolution sum (SWAN default: 1.0)\"\n        ),\n    )\n    qmax: Optional[float] = Field(\n        default=None, description=\"The maximum scattering wave number (in 1/m)\"\n    )\n\n    @model_validator(mode=\"after\")\n    def warn_if_qmax_and_alpha(self) -&gt; \"SCAT\":\n        if self.qmax is not None and self.alpha is not None:\n            logger.warning(\n                \"Both `alpha` and `qmax` options are provided to truncate the \"\n                \"infinite convolution sum. Their mimimum is considered in SWAN as the \"\n                \"final limit on the sum\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SCAT\"\n        if self.iqcm is not None:\n            repr += f\" iqcm={self.iqcm}\"\n        if self.rfac is not None:\n            repr += f\" GRID rfac={self.rfac}\"\n        if self.alpha is not None or self.qmax is not None:\n            repr += \" TRUNC\"\n            if self.alpha is not None:\n                repr += f\" alpha={self.alpha}\"\n            if self.qmax is not None:\n                repr += f\" qmax={self.qmax}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['scat', 'SCAT'] = Field(default='scat', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.iqcm","title":"iqcm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iqcm: Optional[Literal[0, 1, 2]] = Field(default=None, description='Indicates the modelling and computation of QC scattering:\\n\\n* 0: no scattering\\n* 1: scattering due to non-uniform bathymetry and currents (the latter only if applicable; see command `INPGRID CURRENT`)\\n* 2: wave-current interaction under the assumption of a slowly varying bathymetry\\n\\n(SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.rfac","title":"rfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rfac: Optional[float] = Field(default=None, description='The resolution factor through which the incident spectral width ismultiplied (SWAN default: 1.0)', ge=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='The coefficient by which the mean wave number is multiplied to set thelimit on the convolution sum (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.qmax","title":"qmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qmax: Optional[float] = Field(default=None, description='The maximum scattering wave number (in 1/m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT.warn_if_qmax_and_alpha","title":"warn_if_qmax_and_alpha","text":"<pre><code>warn_if_qmax_and_alpha() -&gt; SCAT\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef warn_if_qmax_and_alpha(self) -&gt; \"SCAT\":\n    if self.qmax is not None and self.alpha is not None:\n        logger.warning(\n            \"Both `alpha` and `qmax` options are provided to truncate the \"\n            \"infinite convolution sum. Their mimimum is considered in SWAN as the \"\n            \"final limit on the sum\"\n        )\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SCAT\"\n    if self.iqcm is not None:\n        repr += f\" iqcm={self.iqcm}\"\n    if self.rfac is not None:\n        repr += f\" GRID rfac={self.rfac}\"\n    if self.alpha is not None or self.qmax is not None:\n        repr += \" TRUNC\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.qmax is not None:\n            repr += f\" qmax={self.qmax}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#off","title":"Off","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF","title":"OFF","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Deactivate physics commands.</p> <p>.. code-block:: text</p> <pre><code>OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n</code></pre> <p>This command deactivates physics commands. The command can be used to switch off the computation of a certain physics component without having to remove the command from the input file. This is useful for testing purposes.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OFF--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import OFF\noff = OFF(physics=\"windgrowth\")\nprint(off.render())\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class OFF(BaseComponent):\n    \"\"\"Deactivate physics commands.\n\n    .. code-block:: text\n\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n\n    This command deactivates physics commands. The command can be used to switch off\n    the computation of a certain physics component without having to remove the command\n    from the input file. This is useful for testing purposes.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import OFF\n        off = OFF(physics=\"windgrowth\")\n        print(off.render())\n\n    \"\"\"\n\n    model_type: Literal[\"off\", \"OFF\"] = Field(\n        default=\"off\", description=\"Model type discriminator\"\n    )\n    physics: PhysicsOff = Field(description=\"Physics command to be switched off\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"OFF {self.physics.value.upper()}\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['off', 'OFF'] = Field(default='off', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF.physics","title":"physics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>physics: PhysicsOff = Field(description='Physics command to be switched off')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"OFF {self.physics.value.upper()}\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS","title":"OFFS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Deactivate multiple physics commands.</p> <p>.. code-block:: text</p> <pre><code>OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\nOFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n.\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of <code>OFF</code> components.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OFFS\noff1 = dict(physics=\"windgrowth\")\noff2 = dict(physics=\"wcapping\")\noffs = OFFS(offs=[off1, off2])\nfor off in offs.render():\n    print(off)\n</code></pre> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>class OFFS(BaseComponent):\n    \"\"\"Deactivate multiple physics commands.\n\n    .. code-block:: text\n\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n        .\n\n    This group component is a convenience to allow defining and rendering\n    a list of `OFF` components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OFFS\n        off1 = dict(physics=\"windgrowth\")\n        off2 = dict(physics=\"wcapping\")\n        offs = OFFS(offs=[off1, off2])\n        for off in offs.render():\n            print(off)\n\n    \"\"\"\n\n    model_type: Literal[\"offs\", \"OFFS\"] = Field(\n        default=\"offs\", description=\"Model type discriminator\"\n    )\n    offs: list[OFF] = Field(description=\"Physics commands to deactivate\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        repr = []\n        for off in self.offs:\n            repr += [off.cmd()]\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFFS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['offs', 'OFFS'] = Field(default='offs', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS.offs","title":"offs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offs: list[OFF] = Field(description='Physics commands to deactivate')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFFS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>src/rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    repr = []\n    for off in self.offs:\n        repr += [off.cmd()]\n    return repr\n</code></pre>"},{"location":"components/startup/","title":"Startup","text":"<p>Startup commands configure the basic model settings and must appear at the beginning of the SWAN input file.</p>"},{"location":"components/startup/#project","title":"PROJECT","text":"<p>Identifies the simulation with a name and run number.</p>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT","title":"PROJECT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Project.</p> <p>.. code-block:: text</p> <pre><code>PROJECT 'name' 'nr' 'title' 'title2 'title3'\n</code></pre> <p>With this required command the user defines a number of strings to identify the SWAN run (project name e.g., an engineering project) in the print and plot file.</p>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT\nproj = PROJECT(nr=\"01\")\nprint(proj.render())\nproj = PROJECT(\n    name=\"waus\",\n    nr=\"001\",\n    title1=\"Western Australia\",\n    title2=\"Perth Nest\"\n)\nprint(proj.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class PROJECT(BaseComponent):\n    \"\"\"SWAN Project.\n\n    .. code-block:: text\n\n        PROJECT 'name' 'nr' 'title' 'title2 'title3'\n\n    With this required command the user defines a number of strings to identify the\n    SWAN run (project name e.g., an engineering project) in the print and plot file.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT\n        proj = PROJECT(nr=\"01\")\n        print(proj.render())\n        proj = PROJECT(\n            name=\"waus\",\n            nr=\"001\",\n            title1=\"Western Australia\",\n            title2=\"Perth Nest\"\n        )\n        print(proj.render())\n\n    \"\"\"\n\n    model_type: Literal[\"project\", \"PROJECT\"] = Field(\n        default=\"project\",\n        description=\"Model type discriminator\",\n    )\n    name: Optional[str] = Field(\n        default=None,\n        description=\"Is the name of the project, at most 16 characters long\",\n        max_length=16,\n    )\n    nr: str = Field(\n        description=(\n            \"Is the run identification (to be provided as a character string; e.g. \"\n            \"the run number) to distinguish this run among other runs for the same \"\n            \"project; it is at most 4 characters long. It is the only required \"\n            \"information in this command.\"\n        ),\n        max_length=4,\n    )\n    title1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A string of at most 72 characters provided by the user to appear in the \"\n            \"output of the program for the user's convenience (SWAN default: blanks)\"\n        ),\n        max_length=72,\n    )\n    title2: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n    title3: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"PROJECT\"\n        if self.name is not None:\n            repr += f\" name='{self.name}'\"\n        repr += f\" nr='{self.nr}'\"\n        if self.title1 is not None:\n            repr += f\" title1='{self.title1}'\"\n        if self.title2 is not None:\n            repr += f\" title2='{self.title2}'\"\n        if self.title3 is not None:\n            repr += f\" title3='{self.title3}'\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['project', 'PROJECT'] = Field(default='project', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Is the name of the project, at most 16 characters long', max_length=16)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.nr","title":"nr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nr: str = Field(description='Is the run identification (to be provided as a character string; e.g. the run number) to distinguish this run among other runs for the same project; it is at most 4 characters long. It is the only required information in this command.', max_length=4)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title1","title":"title1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title1: Optional[str] = Field(default=None, description=\"A string of at most 72 characters provided by the user to appear in the output of the program for the user's convenience (SWAN default: blanks)\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title2","title":"title2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title2: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title3","title":"title3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title3: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"PROJECT\"\n    if self.name is not None:\n        repr += f\" name='{self.name}'\"\n    repr += f\" nr='{self.nr}'\"\n    if self.title1 is not None:\n        repr += f\" title1='{self.title1}'\"\n    if self.title2 is not None:\n        repr += f\" title2='{self.title2}'\"\n    if self.title3 is not None:\n        repr += f\" title3='{self.title3}'\"\n    return repr\n</code></pre>"},{"location":"components/startup/#set","title":"SET","text":"<p>Sets general model parameters like water level, nautical convention, and coordinate system options.</p>"},{"location":"components/startup/#rompy_swan.components.startup.SET","title":"SET","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN setting commands.</p> <p>.. code-block:: text</p> <pre><code>SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n    [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n</code></pre> <p>With this optional command the user assigns values to various general parameters.</p>"},{"location":"components/startup/#rompy_swan.components.startup.SET--notes","title":"Notes","text":"<p>The error level <code>maxerr</code> is coded as follows:</p> <ul> <li>1: warnings</li> <li>2: errors (possibly automatically repaired or repairable by SWAN)</li> <li>3: severe errors</li> </ul> <p>Default values for <code>pwtail</code> depend on formulations of physics:</p> <ul> <li>command GEN1: <code>pwtail = 5</code></li> <li>command GEN2: <code>pwtail = 5</code></li> <li>command GEN3 KOMEN: <code>pwtail = 4</code></li> <li>command GEN3 WESTH: <code>pwtail = 4</code></li> <li>command GEN3 JANSSEN: <code>pwtail = 5</code></li> </ul>"},{"location":"components/startup/#rompy_swan.components.startup.SET--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SET\nset = SET(level=0.5, direction_convention=\"nautical\")\nprint(set.render())\nset = SET(\n    level=-1.0,\n    nor=90,\n    depmin=0.01,\n    maxerr=3,\n    grav=9.81,\n    rho=1025,\n    cdcap=2.5e-3,\n    inrhog=0,\n    hsrerr=0.1,\n    direction_convention=\"nautical\",\n)\nprint(set.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class SET(BaseComponent):\n    \"\"\"SWAN setting commands.\n\n    .. code-block:: text\n\n        SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n            [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n\n    With this optional command the user assigns values to various general parameters.\n\n    Notes\n    -----\n    The error level `maxerr` is coded as follows:\n\n    * 1: warnings\n    * 2: errors (possibly automatically repaired or repairable by SWAN)\n    * 3: severe errors\n\n    Default values for `pwtail` depend on formulations of physics:\n\n    * command GEN1: `pwtail = 5`\n    * command GEN2: `pwtail = 5`\n    * command GEN3 KOMEN: `pwtail = 4`\n    * command GEN3 WESTH: `pwtail = 4`\n    * command GEN3 JANSSEN: `pwtail = 5`\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SET\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        print(set.render())\n        set = SET(\n            level=-1.0,\n            nor=90,\n            depmin=0.01,\n            maxerr=3,\n            grav=9.81,\n            rho=1025,\n            cdcap=2.5e-3,\n            inrhog=0,\n            hsrerr=0.1,\n            direction_convention=\"nautical\",\n        )\n        print(set.render())\n\n    \"\"\"\n\n    model_type: Literal[\"set\", \"SET\"] = Field(\n        default=\"set\", description=\"Model type discriminator\"\n    )\n    level: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Increase in water level that is constant in space and time can be given \"\n            \"with this option, `level` is the value of this increase (in m). For a \"\n            \"variable water level reference is made to the commands \"\n            \"INPGRID and READINP (SWAN default: 0)\"\n        ),\n        examples=[0],\n    )\n    nor: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Direction of North with respect to the x-axis (measured \"\n            \"counterclockwise); default `nor = 90`, i.e. x-axis of the problem \"\n            \"coordinate system points East. When spherical coordinates are used \"\n            \"(see command COORD) the value of `nor` may not be modified\"\n        ),\n        ge=-360.0,\n        le=360.0,\n    )\n    depmin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Threshold depth (in m). In the computation any positive depth smaller \"\n            \"than `depmin` is made equal to `depmin` (SWAN default: 0.05)\"\n        ),\n        ge=0.0,\n    )\n    maxmes: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of error messages during the computation at which the \"\n            \"computation is terminated. During the computational process messages are \"\n            \"written to the print file (SWAN default: 200)\"\n        ),\n        ge=0,\n    )\n    maxerr: Optional[Literal[1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"During pre-processing SWAN checks input data. Depending on the severity \"\n            \"of the errors encountered during this pre-processing, SWAN does not \"\n            \"start computations. The user can influence the error level above which \"\n            \"SWAN will  not start computations (at the level indicated the \"\n            \"computations will continue) (SWAN default: 1)\"\n        ),\n    )\n    grav: Optional[float] = Field(\n        default=None,\n        description=\"The gravitational acceleration (in m/s2) (SWAN default: 9.81)\",\n        ge=0.0,\n    )\n    rho: Optional[float] = Field(\n        default=None,\n        description=\"The water density (in kg/m3) (SWAN default: 1025)\",\n        ge=0.0,\n    )\n    cdcap: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The maximum value for the wind drag coefficient. A value of 99999 means\"\n            \"no cutting off the drag coefficient. A suggestion for this parameter is \"\n            \"`cdcap = 2.5x 10-3` (SWAN default: 99999) \"\n        ),\n        ge=0.0,\n    )\n    inrhog: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"To indicate whether the user requires output based on variance or based \"\n            \"on true energy (see Section 2.5). `inrhog` = 0: output based on variance, \"\n            \"`inrhog` = 1: output based on true energy (SWAN default: 0)\"\n        ),\n    )\n    hsrerr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The relative difference between the user imposed significant wave height \"\n            \"and the significant wave height computed by SWAN (anywhere along the \"\n            \"computational grid boundary) above which a warning will be given. This \"\n            \"relative difference is the difference normalized with the user provided \"\n            \"significant wave height. This warning will be given for each boundary \"\n            \"grid point where the problem occurs (with its x- and y-index number of \"\n            \"the computational grid). The cause of the difference is explained in \"\n            \"Section 2.6.3. To suppress these warnings (in particular for \"\n            \"nonstationary computations), set `hsrerr` at a very high value or use \"\n            \"command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)\"\n        ),\n        ge=0.0,\n    )\n    direction_convention: Literal[\"nautical\", \"cartesian\"] = Field(\n        description=(\n            \"Direction convention: `nautical` indicates that the Nautical convention \"\n            \"for wind and wave direction (SWAN input and output) will be used, \"\n            \"`cartesian` indicates that the Cartesian convention for wind and wave \"\n            \"direction will be used. For definition, see Section 2.5 or Appendix A \"\n            \"(SWAN default: `cartesian`)\"\n        ),\n    )\n    pwtail: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Power of high frequency tail; defines the shape of the spectral tail \"\n            \"above the highest prognostic frequency `fhigh` (see command CGRID). \"\n            \"The energy density is assumed to be proportional to frequency to the \"\n            \"power `pwtail`. If the user wishes to use another value, then this SET \"\n            \"command should be located in the command file after GEN1, GEN2 or GEN3 \"\n            \"command (these will override the SET command with respect to `pwtail`)\"\n        ),\n        ge=0,\n    )\n    froudmax: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the \"\n            \"water depth). The currents taken from a circulation model may mismatch \"\n            \"with given water depth `d` in the sense that the Froude number becomes \"\n            \"larger than 1. For this, the current velocities will be maximized by \"\n            \"Froude number times `sqrt(gh)` (SWAN default: 0.8)\"\n        ),\n        ge=0.0,\n    )\n    icewind: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of wind input by open water fraction. Default value \"\n            \"of zero corresponds to the case where wind input is scaled by the open \"\n            \"water fraction. If `icewind = 1` then sea ice does not affect wind input \"\n            \"directly. (Though there is still indirect effect via the sea ice sink \"\n            \"term; see command SICE) (SWAN default: 0)\"\n        ),\n    )\n\n    @field_validator(\"pwtail\")\n    @classmethod\n    def pwtail_after_gen(cls, v):\n        if v is not None:\n            logger.warning(\"pwtail only has effect if set after GEN command\")\n        return v\n\n    def cmd(self) -&gt; str:\n        repr = \"SET\"\n        if self.level is not None:\n            repr += f\" level={self.level}\"\n        if self.nor is not None:\n            repr += f\" nor={self.nor}\"\n        if self.depmin is not None:\n            repr += f\" depmin={self.depmin}\"\n        if self.maxmes is not None:\n            repr += f\" maxmes={self.maxmes}\"\n        if self.maxerr is not None:\n            repr += f\" maxerr={self.maxerr}\"\n        if self.grav is not None:\n            repr += f\" grav={self.grav}\"\n        if self.rho is not None:\n            repr += f\" rho={self.rho}\"\n        if self.cdcap is not None:\n            repr += f\" cdcap={self.cdcap}\"\n        if self.inrhog is not None:\n            repr += f\" inrhog={self.inrhog}\"\n        if self.hsrerr is not None:\n            repr += f\" hsrerr={self.hsrerr}\"\n        if self.direction_convention is not None:\n            repr += f\" {self.direction_convention.upper()}\"\n        if self.pwtail is not None:\n            repr += f\" pwtail={self.pwtail}\"\n        if self.froudmax is not None:\n            repr += f\" froudmax={self.froudmax}\"\n        if self.icewind is not None:\n            repr += f\" icewind={self.icewind}\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.SET.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['set', 'SET'] = Field(default='set', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: Optional[float] = Field(default=None, description='Increase in water level that is constant in space and time can be given with this option, `level` is the value of this increase (in m). For a variable water level reference is made to the commands INPGRID and READINP (SWAN default: 0)', examples=[0])\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.nor","title":"nor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nor: Optional[float] = Field(default=None, description='Direction of North with respect to the x-axis (measured counterclockwise); default `nor = 90`, i.e. x-axis of the problem coordinate system points East. When spherical coordinates are used (see command COORD) the value of `nor` may not be modified', ge=-360.0, le=360.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.depmin","title":"depmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depmin: Optional[float] = Field(default=None, description='Threshold depth (in m). In the computation any positive depth smaller than `depmin` is made equal to `depmin` (SWAN default: 0.05)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.maxmes","title":"maxmes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxmes: Optional[int] = Field(default=None, description='Maximum number of error messages during the computation at which the computation is terminated. During the computational process messages are written to the print file (SWAN default: 200)', ge=0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.maxerr","title":"maxerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxerr: Optional[Literal[1, 2, 3]] = Field(default=None, description='During pre-processing SWAN checks input data. Depending on the severity of the errors encountered during this pre-processing, SWAN does not start computations. The user can influence the error level above which SWAN will  not start computations (at the level indicated the computations will continue) (SWAN default: 1)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.grav","title":"grav  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grav: Optional[float] = Field(default=None, description='The gravitational acceleration (in m/s2) (SWAN default: 9.81)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.rho","title":"rho  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rho: Optional[float] = Field(default=None, description='The water density (in kg/m3) (SWAN default: 1025)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.cdcap","title":"cdcap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdcap: Optional[float] = Field(default=None, description='The maximum value for the wind drag coefficient. A value of 99999 meansno cutting off the drag coefficient. A suggestion for this parameter is `cdcap = 2.5x 10-3` (SWAN default: 99999) ', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.inrhog","title":"inrhog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inrhog: Optional[Literal[0, 1]] = Field(default=None, description='To indicate whether the user requires output based on variance or based on true energy (see Section 2.5). `inrhog` = 0: output based on variance, `inrhog` = 1: output based on true energy (SWAN default: 0)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.hsrerr","title":"hsrerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hsrerr: Optional[float] = Field(default=None, description='The relative difference between the user imposed significant wave height and the significant wave height computed by SWAN (anywhere along the computational grid boundary) above which a warning will be given. This relative difference is the difference normalized with the user provided significant wave height. This warning will be given for each boundary grid point where the problem occurs (with its x- and y-index number of the computational grid). The cause of the difference is explained in Section 2.6.3. To suppress these warnings (in particular for nonstationary computations), set `hsrerr` at a very high value or use command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.direction_convention","title":"direction_convention  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction_convention: Literal['nautical', 'cartesian'] = Field(description='Direction convention: `nautical` indicates that the Nautical convention for wind and wave direction (SWAN input and output) will be used, `cartesian` indicates that the Cartesian convention for wind and wave direction will be used. For definition, see Section 2.5 or Appendix A (SWAN default: `cartesian`)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.pwtail","title":"pwtail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pwtail: Optional[int] = Field(default=None, description='Power of high frequency tail; defines the shape of the spectral tail above the highest prognostic frequency `fhigh` (see command CGRID). The energy density is assumed to be proportional to frequency to the power `pwtail`. If the user wishes to use another value, then this SET command should be located in the command file after GEN1, GEN2 or GEN3 command (these will override the SET command with respect to `pwtail`)', ge=0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.froudmax","title":"froudmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>froudmax: Optional[float] = Field(default=None, description='Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the water depth). The currents taken from a circulation model may mismatch with given water depth `d` in the sense that the Froude number becomes larger than 1. For this, the current velocities will be maximized by Froude number times `sqrt(gh)` (SWAN default: 0.8)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.icewind","title":"icewind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icewind: Optional[Literal[0, 1]] = Field(default=None, description='Controls the scaling of wind input by open water fraction. Default value of zero corresponds to the case where wind input is scaled by the open water fraction. If `icewind = 1` then sea ice does not affect wind input directly. (Though there is still indirect effect via the sea ice sink term; see command SICE) (SWAN default: 0)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.SET.pwtail_after_gen","title":"pwtail_after_gen  <code>classmethod</code>","text":"<pre><code>pwtail_after_gen(v)\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>@field_validator(\"pwtail\")\n@classmethod\ndef pwtail_after_gen(cls, v):\n    if v is not None:\n        logger.warning(\"pwtail only has effect if set after GEN command\")\n    return v\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"SET\"\n    if self.level is not None:\n        repr += f\" level={self.level}\"\n    if self.nor is not None:\n        repr += f\" nor={self.nor}\"\n    if self.depmin is not None:\n        repr += f\" depmin={self.depmin}\"\n    if self.maxmes is not None:\n        repr += f\" maxmes={self.maxmes}\"\n    if self.maxerr is not None:\n        repr += f\" maxerr={self.maxerr}\"\n    if self.grav is not None:\n        repr += f\" grav={self.grav}\"\n    if self.rho is not None:\n        repr += f\" rho={self.rho}\"\n    if self.cdcap is not None:\n        repr += f\" cdcap={self.cdcap}\"\n    if self.inrhog is not None:\n        repr += f\" inrhog={self.inrhog}\"\n    if self.hsrerr is not None:\n        repr += f\" hsrerr={self.hsrerr}\"\n    if self.direction_convention is not None:\n        repr += f\" {self.direction_convention.upper()}\"\n    if self.pwtail is not None:\n        repr += f\" pwtail={self.pwtail}\"\n    if self.froudmax is not None:\n        repr += f\" froudmax={self.froudmax}\"\n    if self.icewind is not None:\n        repr += f\" icewind={self.icewind}\"\n    return repr\n</code></pre>"},{"location":"components/startup/#mode","title":"MODE","text":"<p>Specifies whether the simulation is stationary or non-stationary, and 1D or 2D.</p>"},{"location":"components/startup/#rompy_swan.components.startup.MODE","title":"MODE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Mode.</p> <p>.. code-block:: text</p> <pre><code>MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n</code></pre> <p>With this optional command the user indicates that the run will be either stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional (2D-mode). Nonstationary means either (see command COMPUTE):</p> <ul> <li>(a) one nonstationary computations or</li> <li>(b) a sequence of stationary computations or</li> <li>(c) a mix of (a) and (b)</li> </ul>"},{"location":"components/startup/#rompy_swan.components.startup.MODE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import MODE\nmode = MODE()\nprint(mode.render())\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\nprint(mode.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class MODE(BaseComponent):\n    \"\"\"SWAN Mode.\n\n    .. code-block:: text\n\n        MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n\n    With this optional command the user indicates that the run will be either\n    stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional\n    (2D-mode). Nonstationary means either (see command COMPUTE):\n\n    * (a) one nonstationary computations or\n    * (b) a sequence of stationary computations or\n    * (c) a mix of (a) and (b)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import MODE\n        mode = MODE()\n        print(mode.render())\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        print(mode.render())\n\n    \"\"\"\n\n    model_type: Literal[\"mode\", \"MODE\"] = Field(\n        default=\"mode\", description=\"Model type discriminator.\"\n    )\n    kind: Literal[\"stationary\", \"nonstationary\"] = Field(\n        default=\"stationary\",\n        description=\"Indicates if run will be stationary or nonstationary\",\n    )\n    dim: Literal[\"onedimensional\", \"twodimensional\"] = Field(\n        default=\"twodimensional\",\n        description=(\n            \"Indicates that the run will be either one-dimensional (1D-mode) or \"\n            \"two-dimensional (2D-mode)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.MODE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['mode', 'MODE'] = Field(default='mode', description='Model type discriminator.')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Literal['stationary', 'nonstationary'] = Field(default='stationary', description='Indicates if run will be stationary or nonstationary')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Literal['onedimensional', 'twodimensional'] = Field(default='twodimensional', description='Indicates that the run will be either one-dimensional (1D-mode) or two-dimensional (2D-mode)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.MODE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"components/startup/#coordinates","title":"COORDINATES","text":"<p>Defines the coordinate system (Cartesian or spherical).</p>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES","title":"COORDINATES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Coordinates.</p> <p>.. code-block:: text</p> <pre><code>COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n</code></pre> <p>Command to choose between Cartesian and spherical coordinates (see Section 2.5). A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.</p>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import COORDINATES\ncoords = COORDINATES()\nprint(coords.render())\ncoords = COORDINATES(\n    kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n    reapeating=True,\n)\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>class COORDINATES(BaseComponent):\n    \"\"\"SWAN Coordinates.\n\n    .. code-block:: text\n\n        COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n\n    Command to choose between Cartesian and spherical coordinates (see Section 2.5).\n    A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import COORDINATES\n        coords = COORDINATES()\n        print(coords.render())\n        coords = COORDINATES(\n            kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n            reapeating=True,\n        )\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"coordinates\", \"COORDINATES\"] = Field(\n        default=\"coordinates\",\n        description=\"Model type discriminator\",\n    )\n    kind: CARTESIAN | SPHERICAL = Field(\n        default_factory=CARTESIAN,\n        description=\"Coordinates kind\",\n    )\n    reapeating: bool = Field(\n        default=False,\n        description=(\n            \"This option is only for academic cases. It means that wave energy \"\n            \"leaving at one end of the domain (in computational x-direction) enter at \"\n            \"the other side; it is as if the wave field repeats itself in x-direction \"\n            \"with the length of the domain in x-direction. This option cannot be used \"\n            \"in combination with computation of set-up (see command SETUP). This \"\n            \"option is available only with regular grids\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"COORDINATES {self.kind.render()}\"\n        if self.reapeating:\n            repr += \" REPEATING\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['coordinates', 'COORDINATES'] = Field(default='coordinates', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: CARTESIAN | SPHERICAL = Field(default_factory=CARTESIAN, description='Coordinates kind')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.reapeating","title":"reapeating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reapeating: bool = Field(default=False, description='This option is only for academic cases. It means that wave energy leaving at one end of the domain (in computational x-direction) enter at the other side; it is as if the wave field repeats itself in x-direction with the length of the domain in x-direction. This option cannot be used in combination with computation of set-up (see command SETUP). This option is available only with regular grids')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"COORDINATES {self.kind.render()}\"\n    if self.reapeating:\n        repr += \" REPEATING\"\n    return repr\n</code></pre>"},{"location":"data-interfaces/","title":"Data Interfaces Overview","text":"<p>Rompy-swan provides data interfaces to connect external data sources with SWAN model inputs. These interfaces handle:</p> <ul> <li>Data loading \u2014 Read from NetCDF, THREDDS, local files</li> <li>Interpolation \u2014 Regrid data to SWAN computational grids</li> <li>File generation \u2014 Write SWAN-compatible input files</li> <li>Time handling \u2014 Extract data for simulation periods</li> </ul>"},{"location":"data-interfaces/#interface-types","title":"Interface Types","text":"Interface Purpose Use Case DataInterface Input grids Bathymetry, wind, currents from data sources BoundaryInterface Boundary conditions Spectral wave data at boundaries OutputInterface Output configuration Configure output based on time range LockupInterface Execution control Configure compute commands"},{"location":"data-interfaces/#datainterface","title":"DataInterface","text":"<p>The <code>DataInterface</code> connects external data sources to SWAN input grids (INPGRID commands).</p>"},{"location":"data-interfaces/#basic-usage","title":"Basic Usage","text":"<pre><code>from rompy_swan.interface import DataInterface\n\ndata = DataInterface(\n    bottom=dict(\n        model_type=\"swan_data_grid\",\n        source=dict(uri=\"bathymetry.nc\"),\n        var=\"elevation\",\n    ),\n    wind=dict(\n        model_type=\"swan_data_grid\",\n        source=dict(uri=\"wind.nc\"),\n        var=[\"u10\", \"v10\"],\n    ),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    inpgrid=data,  # Use DataInterface instead of INPGRIDS\n    ...\n)\n</code></pre>"},{"location":"data-interfaces/#supported-input-types","title":"Supported Input Types","text":"<ul> <li>bottom \u2014 Bathymetry</li> <li>wind \u2014 Wind forcing (u, v components)</li> <li>current \u2014 Current forcing (u, v components)</li> <li>wlevel \u2014 Water level</li> <li>ice \u2014 Ice coverage</li> <li>friction \u2014 Spatially varying friction</li> <li>mud \u2014 Mud properties</li> <li>vegetation \u2014 Vegetation properties</li> </ul>"},{"location":"data-interfaces/#data-sources","title":"Data Sources","text":"<p>DataInterface supports various data sources:</p> <pre><code># Local NetCDF file\nsource=dict(uri=\"data.nc\")\n\n# Remote THREDDS/OPeNDAP\nsource=dict(uri=\"https://thredds.server.com/data.nc\")\n\n# With specific reader\nsource=dict(\n    model_type=\"intake\",\n    catalog=\"catalog.yml\",\n    dataset=\"bathymetry\",\n)\n</code></pre>"},{"location":"data-interfaces/#boundaryinterface","title":"BoundaryInterface","text":"<p>The <code>BoundaryInterface</code> connects spectral wave data to SWAN boundary conditions.</p>"},{"location":"data-interfaces/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from rompy_swan.interface import BoundaryInterface\n\nboundary = BoundaryInterface(\n    source=dict(uri=\"spectra.nc\"),\n    sel=dict(method=\"nearest\"),\n    location=dict(model_type=\"side\", side=\"west\"),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    boundary=boundary,\n    ...\n)\n</code></pre>"},{"location":"data-interfaces/#spectral-data","title":"Spectral Data","text":"<p>BoundaryInterface expects spectral data with:</p> <ul> <li>freq \u2014 Frequency dimension</li> <li>dir \u2014 Direction dimension</li> <li>efth \u2014 Energy density spectrum</li> </ul>"},{"location":"data-interfaces/#location-options","title":"Location Options","text":"<pre><code># Entire side\nlocation=dict(model_type=\"side\", side=\"west\")\n\n# Segment\nlocation=dict(model_type=\"segment\", ...)\n\n# Points\nlocation=dict(model_type=\"points\", xp=[...], yp=[...])\n</code></pre>"},{"location":"data-interfaces/#outputinterface","title":"OutputInterface","text":"<p>The <code>OutputInterface</code> configures output based on the simulation time range.</p>"},{"location":"data-interfaces/#basic-usage_2","title":"Basic Usage","text":"<pre><code>from rompy_swan.interface import OutputInterface\n\noutput = OutputInterface(\n    block=dict(\n        fname=\"output.nc\",\n        output=[\"hsign\", \"tps\", \"dir\"],\n    ),\n    table=dict(\n        fname=\"output.tab\",\n        output=[\"hsign\", \"tps\"],\n    ),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    output=output,\n    ...\n)\n</code></pre>"},{"location":"data-interfaces/#lockupinterface","title":"LockupInterface","text":"<p>The <code>LockupInterface</code> configures compute commands based on the simulation period.</p>"},{"location":"data-interfaces/#basic-usage_3","title":"Basic Usage","text":"<pre><code>from rompy_swan.interface import LockupInterface\n\nlockup = LockupInterface(\n    compute=dict(model_type=\"nonstat\"),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    lockup=lockup,\n    ...\n)\n</code></pre>"},{"location":"data-interfaces/#swandatagrid","title":"SwanDataGrid","text":"<p>The <code>SwanDataGrid</code> class handles data loading and interpolation for input grids.</p> <pre><code>from rompy_swan.data import SwanDataGrid\n\ndata = SwanDataGrid(\n    source=dict(uri=\"bathymetry.nc\"),\n    var=\"elevation\",\n    coords=dict(x=\"longitude\", y=\"latitude\"),\n)\n\n# Get data for a specific grid and time\nds = data.get(destdir=\"/path/to/run\", grid=grid, time=time_range)\n</code></pre>"},{"location":"data-interfaces/#variable-mapping","title":"Variable Mapping","text":"<p>Map source variable names to SWAN conventions:</p> <pre><code>data = SwanDataGrid(\n    source=dict(uri=\"wind.nc\"),\n    var=[\"u10\", \"v10\"],  # Source variable names\n    coords=dict(\n        x=\"longitude\",\n        y=\"latitude\",\n        time=\"time\",\n    ),\n)\n</code></pre>"},{"location":"data-interfaces/#interpolation","title":"Interpolation","text":"<p>Data is automatically interpolated to the SWAN grid:</p> <pre><code>data = SwanDataGrid(\n    source=dict(uri=\"bathymetry.nc\"),\n    var=\"elevation\",\n    interpolator=dict(\n        model_type=\"regular_grid\",\n        method=\"linear\",\n    ),\n)\n</code></pre>"},{"location":"data-interfaces/#yaml-configuration","title":"YAML Configuration","text":"<p>Data interfaces can be configured in YAML:</p> <pre><code>inpgrid:\n  model_type: data_interface\n  bottom:\n    model_type: swan_data_grid\n    source:\n      uri: bathymetry.nc\n    var: elevation\n  wind:\n    model_type: swan_data_grid\n    source:\n      uri: wind.nc\n    var:\n      - u10\n      - v10\n\nboundary:\n  model_type: boundary_interface\n  source:\n    uri: spectra.nc\n  location:\n    model_type: side\n    side: west\n</code></pre>"},{"location":"data-interfaces/#next-steps","title":"Next Steps","text":"<ul> <li>DataInterface \u2014 Detailed data interface reference</li> <li>BoundaryInterface \u2014 Boundary condition interface</li> <li>Grid \u2014 SWAN grid configuration</li> <li>Sources \u2014 Data source types</li> </ul>"},{"location":"developer/contributing/","title":"Contributing","text":"<p>Contributions to rompy-swan are welcome! This guide covers how to set up a development environment and contribute to the project.</p>"},{"location":"developer/contributing/#development-setup","title":"Development Setup","text":""},{"location":"developer/contributing/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/rom-py/rompy-swan.git\ncd rompy-swan\n</code></pre>"},{"location":"developer/contributing/#create-a-virtual-environment","title":"Create a Virtual Environment","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # Linux/macOS\n# or\nvenv\\Scripts\\activate  # Windows\n</code></pre>"},{"location":"developer/contributing/#install-in-development-mode","title":"Install in Development Mode","text":"<pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"developer/contributing/#install-pre-commit-hooks","title":"Install Pre-commit Hooks","text":"<pre><code>pre-commit install\n</code></pre>"},{"location":"developer/contributing/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/\n</code></pre> <p>With coverage:</p> <pre><code>pytest tests/ --cov=rompy_swan --cov-report=html\n</code></pre>"},{"location":"developer/contributing/#code-style","title":"Code Style","text":"<p>Rompy-swan uses:</p> <ul> <li>Black for code formatting</li> <li>isort for import sorting</li> <li>flake8 for linting</li> <li>mypy for type checking</li> </ul> <p>Run all checks:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"developer/contributing/#documentation","title":"Documentation","text":""},{"location":"developer/contributing/#build-docs-locally","title":"Build Docs Locally","text":"<pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> <p>Then open http://localhost:8000 in your browser.</p>"},{"location":"developer/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use Markdown for all documentation</li> <li>Follow the existing structure in <code>docs/</code></li> <li>Add docstrings to all public classes and functions</li> <li>Include examples in docstrings</li> </ul>"},{"location":"developer/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/my-feature</code>)</li> <li>Make your changes</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass</li> <li>Update documentation as needed</li> <li>Submit a pull request</li> </ol>"},{"location":"developer/contributing/#adding-new-components","title":"Adding New Components","text":"<p>When adding new SWAN components:</p> <ol> <li>Create the component class in the appropriate module under <code>rompy_swan/components/</code></li> <li>Inherit from <code>BaseComponent</code></li> <li>Implement the <code>cmd()</code> method</li> <li>Add the <code>model_type</code> field as a <code>Literal</code></li> <li>Add tests in <code>tests/</code></li> <li>Add documentation in <code>docs/components/</code></li> </ol> <p>Example:</p> <pre><code>from typing import Literal\nfrom pydantic import Field\nfrom rompy_swan.components.base import BaseComponent\n\nclass MY_COMMAND(BaseComponent):\n    \"\"\"My new SWAN command.\n\n    This command does something useful.\n\n    Examples\n    --------\n    &gt;&gt;&gt; cmd = MY_COMMAND(param=1.0)\n    &gt;&gt;&gt; print(cmd.render())\n    MY_COMMAND param=1.0\n\n    \"\"\"\n\n    model_type: Literal[\"my_command\"] = Field(\n        default=\"my_command\",\n        description=\"Model type discriminator\",\n    )\n    param: float = Field(\n        default=1.0,\n        description=\"Parameter description\",\n        ge=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"MY_COMMAND param={self.param}\"\n</code></pre>"},{"location":"developer/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Please report issues on the GitHub issue tracker.</p> <p>Include:</p> <ul> <li>Python version</li> <li>rompy-swan version</li> <li>Minimal reproducible example</li> <li>Expected vs actual behavior</li> </ul>"},{"location":"developer/contributing/#questions","title":"Questions","text":"<p>For questions, please use GitHub Discussions.</p>"},{"location":"examples/","title":"Examples","text":"<p>These notebooks demonstrate common rompy-swan workflows.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li> <p> Declarative Configuration</p> <p>Configure SWAN simulations using YAML files for reproducible workflows.</p> <p> View notebook</p> </li> <li> <p> Procedural Configuration</p> <p>Build SWAN configurations programmatically using Python for dynamic setups.</p> <p> View notebook</p> </li> <li> <p> Sensitivity Analysis</p> <p>Run parameter sensitivity studies by varying configuration values.</p> <p> View notebook</p> </li> </ul>"},{"location":"examples/#boundary-conditions","title":"Boundary Conditions","text":"<ul> <li> <p> BOUNDSPEC Side</p> <p>Apply boundary conditions to entire domain sides.</p> <p> View notebook</p> </li> <li> <p> BOUNDSPEC Segment</p> <p>Apply boundary conditions to specific segments.</p> <p> View notebook</p> </li> <li> <p> BOUNDNEST1</p> <p>Nested boundary conditions from coarser SWAN runs.</p> <p> View notebook</p> </li> </ul>"},{"location":"examples/#components","title":"Components","text":"<ul> <li> <p> Output</p> <p>Configure SWAN output options (BLOCK, TABLE, SPECOUT).</p> <p> View notebook</p> </li> <li> <p> CGRID</p> <p>Define computational grids (REGULAR, CURVILINEAR, UNSTRUCTURED).</p> <p> View notebook</p> </li> <li> <p> Startup</p> <p>Initialize SWAN runs (PROJECT, SET, MODE, COORDINATES).</p> <p> View notebook</p> </li> <li> <p> Physics</p> <p>Configure physical processes (generation, breaking, friction).</p> <p> View notebook</p> </li> <li> <p> Numerics</p> <p>Set numerical schemes and iteration settings (PROP, NUMERIC).</p> <p> View notebook</p> </li> <li> <p> INPGRID</p> <p>Define input grids for forcing data (bathymetry, wind, currents).</p> <p> View notebook</p> </li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>To run these notebooks locally:</p> <pre><code># Clone the notebooks repository\ngit clone https://github.com/rom-py/rompy-notebooks.git\n\n# Install dependencies\npip install rompy-swan jupyter\n\n# Navigate to SWAN examples\ncd rompy-notebooks/notebooks/swan\n\n# Start Jupyter\njupyter notebook\n</code></pre> <p>SWAN Executable Required</p> <p>These examples require a working SWAN installation. See the installation guide for setup instructions.</p>"},{"location":"examples/example_declarative/","title":"SWAN declarative example","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nfrom pathlib import Path\nimport yaml\n\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> %load_ext autoreload %autoreload 2  from pathlib import Path import yaml  import warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre># Uncoment below to view the contents of the yaml file\n\n# !cat example_declarative.yml\n</pre> # Uncoment below to view the contents of the yaml file  # !cat example_declarative.yml In\u00a0[3]: Copied! <pre>from rompy.model import ModelRun\n\nconf = yaml.load(open(\"example_declarative.yml\"), Loader=yaml.Loader)\nrun = ModelRun(**conf)\nrun\n</pre> from rompy.model import ModelRun  conf = yaml.load(open(\"example_declarative.yml\"), Loader=yaml.Loader) run = ModelRun(**conf) run Out[3]: <pre>ModelRun(model_type='modelrun', run_id='run1', period=TimeRange(start=datetime.datetime(2023, 1, 1, 0, 0), end=datetime.datetime(2023, 1, 2, 0, 0), duration=datetime.timedelta(days=1), interval=datetime.timedelta(seconds=3600), include_end=True), output_dir=PosixPath('example_declarative'), config=SwanConfig(model_type='swan', template='/source/csiro/rompy-swan/src/rompy_swan/templates/swan', checkout='main', cgrid=REGULAR(model_type='regular', spectrum=SPECTRUM(model_type='spectrum', mdc=36, flow=0.04, fhigh=1.0, msc=None, dir1=None, dir2=None), grid=GRIDREGULAR(model_type='gridregular', xp=110.0, yp=-35.2, alp=4.0, xlen=7.5, ylen=12.5, mx=14, my=24, suffix='c')), startup=STARTUP(model_type='startup', project=PROJECT(model_type='project', name='Test declarative', nr='run1', title1='Declarative definition of a Swan config with rompy', title2=None, title3=None), set=SET(model_type='set', level=0.0, nor=None, depmin=0.05, maxmes=None, maxerr=None, grav=None, rho=None, cdcap=None, inrhog=None, hsrerr=None, direction_convention='nautical', pwtail=None, froudmax=None, icewind=None), mode=MODE(model_type='mode', kind='nonstationary', dim='twodimensional'), coordinates=COORDINATES(model_type='coordinates', kind=SPHERICAL(model_type='spherical', projection='ccm'), reapeating=False)), inpgrid=DataInterface(model_type='data_interface', bottom=SwanDataGrid(model_type='grid', id='data', source=SourceIntake(model_type='intake', dataset_id='gebco', catalog_uri='../../../rompy-swan/tests/data/catalog.yaml', catalog_yaml=None, kwargs={}), filter=Filter(sort={}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['elevation'], coords=DatasetCoords(t='time', x='lon', y='lat', z=None, s=None), crop_data=True, buffer=1.0, time_buffer=[0, 0], z1='elevation', z2=None, var=&lt;GridOptions.BOTTOM: 'bottom'&gt;, fac=-1.0), input=[SwanDataGrid(model_type='grid', id='data', source=SourceIntake(model_type='intake', dataset_id='era5', catalog_uri='../../../rompy-swan/tests/data/catalog.yaml', catalog_yaml=None, kwargs={}), filter=Filter(sort={'coords': ['latitude']}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['u10', 'v10'], coords=DatasetCoords(t='time', x='longitude', y='latitude', z=None, s=None), crop_data=True, buffer=2.0, time_buffer=[0, 0], z1='u10', z2='v10', var=&lt;GridOptions.WIND: 'wind'&gt;, fac=1.0)]), boundary=None, initial=INITIAL(model_type='initial', kind=DEFAULT(model_type='default')), physics=PHYSICS(model_type='physics', gen=GEN3(model_type='gen3', source_terms=WESTHUYSEN(model_type='westhuysen', wind_drag='wu', agrow=False, a=None, cds2=None, br=None)), sswell=None, negatinp=None, wcapping=None, quadrupl=QUADRUPL(model_type='quadrupl', iquad=2, lambd=None, cnl4=None, csh1=None, csh2=None, csh3=None), breaking=BREAKING_CONSTANT(model_type='constant', alpha=None, gamma=0.73), friction=FRICTION_MADSEN(model_type='madsen', kn=0.05), triad=TRIAD(model_type='triad', itriad=None, trfac=None, cutfr=None, a=None, b=None, ucrit=None, urslim=None), vegetation=None, mud=None, sice=None, turbulence=None, bragg=None, limiter=None, obstacle=None, setup=None, diffraction=None, surfbeat=None, scat=None, deactivate=None), prop=PROP(model_type='prop', scheme=BSBT(model_type='bsbt')), numeric=NUMERIC(model_type='numeric', stop=STOPC(model_type='stopc', dabs=0.05, drel=0.05, curvat=0.05, npnts=95.0, mode=NONSTAT(model_type='nonstat', mxitns=3), limiter=None), dirimpl=None, sigimpl=None, ctheta=None, csigma=None, setup=None), output=OUTPUT(model_type='output', frame=None, group=None, curve=None, ray=None, isoline=None, points=POINTS(model_type='points', sname='pts', xp=[114.0, 112.5, 115.0], yp=[-34.0, -26.0, -30.0]), ngrid=None, quantity=QUANTITIES(model_type='quantities', quantities=[QUANTITY(model_type='quantity', output=[&lt;BlockOptions.DEPTH: 'depth'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;, &lt;BlockOptions.TM01: 'tm01'&gt;], short=None, long=None, lexp=None, hexp=None, excv=-9.0, power=None, ref=None, fswell=None, noswll=None, fmin=None, fmax=None, coord=None), QUANTITY(model_type='quantity', output=[&lt;BlockOptions.HSWELL: 'hswell'&gt;], short=None, long=None, lexp=None, hexp=None, excv=None, power=None, ref=None, fswell=0.125, noswll=None, fmin=None, fmax=None, coord=None)]), output_options=None, block=BLOCK(model_type='block', sname='COMPGRID', fname='swangrid.nc', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='blk'), header=None, idla=None, output=[&lt;BlockOptions.DEPTH: 'depth'&gt;, &lt;BlockOptions.WIND: 'wind'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;], unit=None), table=TABLE(model_type='table', sname='pts', fname='swantable.txt', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='tbl'), format='header', output=[&lt;BlockOptions.TIME: 'time'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.HSWELL: 'hswell'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.TM01: 'tm01'&gt;]), specout=SPECOUT(model_type='specout', sname='pts', fname='swanspec.nc', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='spc'), dim=SPEC2D(model_type='spec2d'), freq=ABS(model_type='abs')), nestout=None, test=None), lockup=LOCKUP(model_type='lockup', compute=COMPUTE_NONSTAT(model_type='nonstat', times=NONSTATIONARY(model_type='nonstationary', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='c', tend=datetime.datetime(1970, 1, 2, 0, 0)), hotfile=HOTFILE(model_type='hotfile', fname=PosixPath('hotfile.txt'), format='free'), hottimes=[-1], suffix='_%Y%m%dT%H%M%S', initstat=True))), delete_existing=False, run_id_subdir=True)</pre> In\u00a0[4]: Copied! <pre># Model grid\n\nfig, ax = run.config.grid.plot(fscale=6)\n</pre> # Model grid  fig, ax = run.config.grid.plot(fscale=6) In\u00a0[5]: Copied! <pre># Model bathy\n\nbottom = run.config.inpgrid.bottom\nbottom._filter_grid(run.config.grid) # This isn't necessary since cropping is done by the SwanConfig, it is just for plotting\nfig, ax = bottom.plot(param=\"elevation\", vmin=-5000, vmax=0, cmap=\"turbo_r\", figsize=(5, 6))\nfig, ax = run.config.grid.plot(ax=ax)\n</pre> # Model bathy  bottom = run.config.inpgrid.bottom bottom._filter_grid(run.config.grid) # This isn't necessary since cropping is done by the SwanConfig, it is just for plotting fig, ax = bottom.plot(param=\"elevation\", vmin=-5000, vmax=0, cmap=\"turbo_r\", figsize=(5, 6)) fig, ax = run.config.grid.plot(ax=ax) In\u00a0[6]: Copied! <pre># Model winds\n\nwind = run.config.inpgrid.input[0]\nwind._filter_grid(run.config.grid) # This isn't necessary since cropping is done by the SwanConfig, it is just for plotting\nfig, ax = wind.plot(param=\"u10\", isel={\"time\": 0}, vmin=-5, vmax=5, cmap=\"RdBu_r\", figsize=(5, 6))\nfig, ax = run.config.grid.plot(ax=ax)\n</pre> # Model winds  wind = run.config.inpgrid.input[0] wind._filter_grid(run.config.grid) # This isn't necessary since cropping is done by the SwanConfig, it is just for plotting fig, ax = wind.plot(param=\"u10\", isel={\"time\": 0}, vmin=-5, vmax=5, cmap=\"RdBu_r\", figsize=(5, 6)) fig, ax = run.config.grid.plot(ax=ax) In\u00a0[7]: Copied! <pre>run()\n</pre> run() <pre>2025-09-18 21:23:08 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:23:08 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] rompy.model         :             Run ID : run1\n2025-09-18 21:23:08 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:23:08 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:23:08 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:23:08 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:23:08 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:23:08 [INFO] rompy.model         :   Output Directory : example_declarative\n2025-09-18 21:23:08 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] rompy.model         : \n2025-09-18 21:23:08 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:23:08 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] root                : \n2025-09-18 21:23:08 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:23:08 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:23:08 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:23:08 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:23:08 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:23:08 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:23:08 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:23:08 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:23:08 [INFO] rompy.model         :         Breaking: BREAKING_CONSTANT\n2025-09-18 21:23:08 [INFO] rompy.model         :         Friction: FRICTION_MADSEN\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:23:08 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:23:08 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:23:08 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:23:08 [INFO] rompy.model         :   \n2025-09-18 21:23:08 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:23:08 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] rompy.model         : \n2025-09-18 21:23:08 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:23:08 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] rompy.model         : Preparing input files in example_declarative\n2025-09-18 21:23:08 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:23:08 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:23:08 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:08 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:23:08 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:08 [INFO] rompy_swan.config   : \n2025-09-18 21:23:08 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:23:08 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :     \n2025-09-18 21:23:09 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:23:09 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:23:09 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Output file: example_declarative/run1/bottom.grd\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Completed in 0.04 seconds\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:23:09 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Output file: example_declarative/run1/wind.grd\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 Completed in 0.06 seconds\n2025-09-18 21:23:09 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:23:09 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:23:09 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy_swan.config   : \n2025-09-18 21:23:09 [INFO] rompy.model         : Rendering model templates to example_declarative/run1...\n2025-09-18 21:23:09 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:23:09 [INFO] rompy.core.render   : Output directory: example_declarative\n2025-09-18 21:23:09 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:23:09 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.04 seconds\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Total process time:  0.04 seconds\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Files created:       10\n2025-09-18 21:23:09 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_declarative/run1\n2025-09-18 21:23:09 [INFO] rompy.model         : \n2025-09-18 21:23:09 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:23:09 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:23:09 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:23:09 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_declarative/run1\n</pre> Out[7]: <pre>'/source/csiro/rompy-notebooks/notebooks/swan/example_declarative/run1'</pre> In\u00a0[8]: Copied! <pre>modeldir = Path(run.output_dir) / run.run_id\n\nsorted(modeldir.glob(\"*\"))\n</pre> modeldir = Path(run.output_dir) / run.run_id  sorted(modeldir.glob(\"*\")) Out[8]: <pre>[PosixPath('example_declarative/run1/INPUT'),\n PosixPath('example_declarative/run1/PRINT'),\n PosixPath('example_declarative/run1/bottom.grd'),\n PosixPath('example_declarative/run1/hotfile_20230102T000000.txt'),\n PosixPath('example_declarative/run1/norm_end'),\n PosixPath('example_declarative/run1/swangrid.nc'),\n PosixPath('example_declarative/run1/swaninit'),\n PosixPath('example_declarative/run1/swanspec.nc'),\n PosixPath('example_declarative/run1/swantable.txt'),\n PosixPath('example_declarative/run1/wind.grd')]</pre> In\u00a0[9]: Copied! <pre>input = modeldir / \"INPUT\"\nprint(input.read_text())\n</pre> input = modeldir / \"INPUT\" print(input.read_text()) <pre>! Rompy SwanConfig\n! Template: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n! Generated: 2025-09-18 09:23:08.993335 on rguedes-XPS-13-9350 by rguedes\n\n\n! Startup -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROJECT name='Test declarative' nr='run1' title1='Declarative definition of a Swan config with rompy'\n\nSET level=0.0 depmin=0.05 NAUTICAL\n\nMODE NONSTATIONARY TWODIMENSIONAL\n\nCOORDINATES SPHERICAL CCM\n\n! Computational Grid --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nCGRID REGULAR xpc=110.0 ypc=-35.2 alpc=4.0 xlenc=7.5 ylenc=12.5 mxc=14 myc=24 CIRCLE mdc=36 flow=0.04 fhigh=1.0\n\n! Input Grids ---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nINPGRID BOTTOM REG 109.0 -36.0 0.0 9 14 1.0 1.0 EXC -99.0\nREADINP BOTTOM -1.0 'bottom.grd' 3 FREE\n\nINPGRID WIND REG 110.0 -35.0 0.0 1 2 5.0 5.0 EXC -99.0 NONSTATION 20230101.000000 6.00 HR\nREADINP WIND 1.0 'wind.grd' 3 0 1 0 FREE\n\n\n\n! Boundary and Initial conditions -------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\nINITIAL DEFAULT\n\n\n! Physics -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGEN3 WESTHUYSEN DRAG WU\n\nQUADRUPL iquad=2\n\nBREAKING CONSTANT gamma=0.73\n\nFRICTION MADSEN kn=0.05\n\nTRIAD\n\n\n! Numerics ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROP BSBT\n\nNUMERIC STOPC dabs=0.05 drel=0.05 curvat=0.05 npnts=95.0 NONSTATIONARY mxitns=3\n\n\n! Output --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPOINTS sname='pts' &amp;\n    xp=114.0 yp=-34.0 &amp;\n    xp=112.5 yp=-26.0 &amp;\n    xp=115.0 yp=-30.0\n\nQUANTITY DEPTH HSIGN TPS DIR TM01 excv=-9.0\n\nQUANTITY HSWELL fswell=0.125\n\nBLOCK sname='COMPGRID' fname='swangrid.nc' &amp;\n    DEPTH &amp;\n    WIND &amp;\n    HSIGN &amp;\n    TPS &amp;\n    DIR &amp;\n    OUTPUT tbegblk=20230101.000000 deltblk=1.0 HR\n\nTABLE sname='pts' HEADER fname='swantable.txt' &amp;\n    TIME &amp;\n    HSIGN &amp;\n    HSWELL &amp;\n    DIR &amp;\n    TPS &amp;\n    TM01 &amp;\n    OUTPUT tbegtbl=20230101.000000 delttbl=1.0 HR\n\nSPECOUT sname='pts' SPEC2D ABS fname='swanspec.nc' OUTPUT tbegspc=20230101.000000 deltspc=1.0 HR\n\n\n! Lockup --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nCOMPUTE STATIONARY time=20230101.000000\nCOMPUTE NONSTATIONARY tbegc=20230101.000000 deltc=1.0 HR tendc=20230102.000000\nHOTFILE fname='hotfile_20230102T000000.txt' FREE\nSTOP\n</pre> In\u00a0[10]: Copied! <pre>!docker run  -v ./example_declarative/run1:/home oceanum/swan:4141 swan.exe\n</pre> !docker run  -v ./example_declarative/run1:/home oceanum/swan:4141 swan.exe <pre>\n SWAN is preparing computation\n\n iteration    1; sweep 1\n+iteration    1; sweep 2\n+iteration    1; sweep 3\n+iteration    1; sweep 4\n not possible to compute, first iteration\n\n iteration    2; sweep 1\n+iteration    2; sweep 2\n+iteration    2; sweep 3\n+iteration    2; sweep 4\n accuracy OK in  45.28 % of wet grid points ( 95.00 % required)\n\n iteration    3; sweep 1\n+iteration    3; sweep 2\n+iteration    3; sweep 3\n+iteration    3; sweep 4\n accuracy OK in   0.79 % of wet grid points ( 95.00 % required)\n\n iteration    4; sweep 1\n+iteration    4; sweep 2\n+iteration    4; sweep 3\n+iteration    4; sweep 4\n accuracy OK in  56.70 % of wet grid points ( 95.00 % required)\n\n iteration    5; sweep 1\n+iteration    5; sweep 2\n+iteration    5; sweep 3\n+iteration    5; sweep 4\n accuracy OK in  20.87 % of wet grid points ( 95.00 % required)\n\n iteration    6; sweep 1\n+iteration    6; sweep 2\n+iteration    6; sweep 3\n+iteration    6; sweep 4\n accuracy OK in  85.83 % of wet grid points ( 95.00 % required)\n\n iteration    7; sweep 1\n+iteration    7; sweep 2\n+iteration    7; sweep 3\n+iteration    7; sweep 4\n accuracy OK in  96.86 % of wet grid points ( 95.00 % required)\n\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.010000   , step      1; iteration    1; sweep 1\n+time 20230101.010000   , step      1; iteration    1; sweep 2\n+time 20230101.010000   , step      1; iteration    1; sweep 3\n+time 20230101.010000   , step      1; iteration    1; sweep 4\n+time 20230101.010000   , step      1; iteration    2; sweep 1\n+time 20230101.010000   , step      1; iteration    2; sweep 2\n+time 20230101.010000   , step      1; iteration    2; sweep 3\n+time 20230101.010000   , step      1; iteration    2; sweep 4\n+time 20230101.010000   , step      1; iteration    3; sweep 1\n+time 20230101.010000   , step      1; iteration    3; sweep 2\n+time 20230101.010000   , step      1; iteration    3; sweep 3\n+time 20230101.010000   , step      1; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.020000   , step      2; iteration    1; sweep 1\n+time 20230101.020000   , step      2; iteration    1; sweep 2\n+time 20230101.020000   , step      2; iteration    1; sweep 3\n+time 20230101.020000   , step      2; iteration    1; sweep 4\n+time 20230101.020000   , step      2; iteration    2; sweep 1\n+time 20230101.020000   , step      2; iteration    2; sweep 2\n+time 20230101.020000   , step      2; iteration    2; sweep 3\n+time 20230101.020000   , step      2; iteration    2; sweep 4\n+time 20230101.020000   , step      2; iteration    3; sweep 1\n+time 20230101.020000   , step      2; iteration    3; sweep 2\n+time 20230101.020000   , step      2; iteration    3; sweep 3\n+time 20230101.020000   , step      2; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.030000   , step      3; iteration    1; sweep 1\n+time 20230101.030000   , step      3; iteration    1; sweep 2\n+time 20230101.030000   , step      3; iteration    1; sweep 3\n+time 20230101.030000   , step      3; iteration    1; sweep 4\n+time 20230101.030000   , step      3; iteration    2; sweep 1\n+time 20230101.030000   , step      3; iteration    2; sweep 2\n+time 20230101.030000   , step      3; iteration    2; sweep 3\n+time 20230101.030000   , step      3; iteration    2; sweep 4\n+time 20230101.030000   , step      3; iteration    3; sweep 1\n+time 20230101.030000   , step      3; iteration    3; sweep 2\n+time 20230101.030000   , step      3; iteration    3; sweep 3\n+time 20230101.030000   , step      3; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.040000   , step      4; iteration    1; sweep 1\n+time 20230101.040000   , step      4; iteration    1; sweep 2\n+time 20230101.040000   , step      4; iteration    1; sweep 3\n+time 20230101.040000   , step      4; iteration    1; sweep 4\n+time 20230101.040000   , step      4; iteration    2; sweep 1\n+time 20230101.040000   , step      4; iteration    2; sweep 2\n+time 20230101.040000   , step      4; iteration    2; sweep 3\n+time 20230101.040000   , step      4; iteration    2; sweep 4\n+time 20230101.040000   , step      4; iteration    3; sweep 1\n+time 20230101.040000   , step      4; iteration    3; sweep 2\n+time 20230101.040000   , step      4; iteration    3; sweep 3\n+time 20230101.040000   , step      4; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.050000   , step      5; iteration    1; sweep 1\n+time 20230101.050000   , step      5; iteration    1; sweep 2\n+time 20230101.050000   , step      5; iteration    1; sweep 3\n+time 20230101.050000   , step      5; iteration    1; sweep 4\n+time 20230101.050000   , step      5; iteration    2; sweep 1\n+time 20230101.050000   , step      5; iteration    2; sweep 2\n+time 20230101.050000   , step      5; iteration    2; sweep 3\n+time 20230101.050000   , step      5; iteration    2; sweep 4\n+time 20230101.050000   , step      5; iteration    3; sweep 1\n+time 20230101.050000   , step      5; iteration    3; sweep 2\n+time 20230101.050000   , step      5; iteration    3; sweep 3\n+time 20230101.050000   , step      5; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.060000   , step      6; iteration    1; sweep 1\n+time 20230101.060000   , step      6; iteration    1; sweep 2\n+time 20230101.060000   , step      6; iteration    1; sweep 3\n+time 20230101.060000   , step      6; iteration    1; sweep 4\n+time 20230101.060000   , step      6; iteration    2; sweep 1\n+time 20230101.060000   , step      6; iteration    2; sweep 2\n+time 20230101.060000   , step      6; iteration    2; sweep 3\n+time 20230101.060000   , step      6; iteration    2; sweep 4\n+time 20230101.060000   , step      6; iteration    3; sweep 1\n+time 20230101.060000   , step      6; iteration    3; sweep 2\n+time 20230101.060000   , step      6; iteration    3; sweep 3\n+time 20230101.060000   , step      6; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.070000   , step      7; iteration    1; sweep 1\n+time 20230101.070000   , step      7; iteration    1; sweep 2\n+time 20230101.070000   , step      7; iteration    1; sweep 3\n+time 20230101.070000   , step      7; iteration    1; sweep 4\n+time 20230101.070000   , step      7; iteration    2; sweep 1\n+time 20230101.070000   , step      7; iteration    2; sweep 2\n+time 20230101.070000   , step      7; iteration    2; sweep 3\n+time 20230101.070000   , step      7; iteration    2; sweep 4\n+time 20230101.070000   , step      7; iteration    3; sweep 1\n+time 20230101.070000   , step      7; iteration    3; sweep 2\n+time 20230101.070000   , step      7; iteration    3; sweep 3\n+time 20230101.070000   , step      7; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.080000   , step      8; iteration    1; sweep 1\n+time 20230101.080000   , step      8; iteration    1; sweep 2\n+time 20230101.080000   , step      8; iteration    1; sweep 3\n+time 20230101.080000   , step      8; iteration    1; sweep 4\n+time 20230101.080000   , step      8; iteration    2; sweep 1\n+time 20230101.080000   , step      8; iteration    2; sweep 2\n+time 20230101.080000   , step      8; iteration    2; sweep 3\n+time 20230101.080000   , step      8; iteration    2; sweep 4\n+time 20230101.080000   , step      8; iteration    3; sweep 1\n+time 20230101.080000   , step      8; iteration    3; sweep 2\n+time 20230101.080000   , step      8; iteration    3; sweep 3\n+time 20230101.080000   , step      8; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.090000   , step      9; iteration    1; sweep 1\n+time 20230101.090000   , step      9; iteration    1; sweep 2\n+time 20230101.090000   , step      9; iteration    1; sweep 3\n+time 20230101.090000   , step      9; iteration    1; sweep 4\n+time 20230101.090000   , step      9; iteration    2; sweep 1\n+time 20230101.090000   , step      9; iteration    2; sweep 2\n+time 20230101.090000   , step      9; iteration    2; sweep 3\n+time 20230101.090000   , step      9; iteration    2; sweep 4\n+time 20230101.090000   , step      9; iteration    3; sweep 1\n+time 20230101.090000   , step      9; iteration    3; sweep 2\n+time 20230101.090000   , step      9; iteration    3; sweep 3\n+time 20230101.090000   , step      9; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.100000   , step     10; iteration    1; sweep 1\n+time 20230101.100000   , step     10; iteration    1; sweep 2\n+time 20230101.100000   , step     10; iteration    1; sweep 3\n+time 20230101.100000   , step     10; iteration    1; sweep 4\n+time 20230101.100000   , step     10; iteration    2; sweep 1\n+time 20230101.100000   , step     10; iteration    2; sweep 2\n+time 20230101.100000   , step     10; iteration    2; sweep 3\n+time 20230101.100000   , step     10; iteration    2; sweep 4\n+time 20230101.100000   , step     10; iteration    3; sweep 1\n+time 20230101.100000   , step     10; iteration    3; sweep 2\n+time 20230101.100000   , step     10; iteration    3; sweep 3\n+time 20230101.100000   , step     10; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.110000   , step     11; iteration    1; sweep 1\n+time 20230101.110000   , step     11; iteration    1; sweep 2\n+time 20230101.110000   , step     11; iteration    1; sweep 3\n+time 20230101.110000   , step     11; iteration    1; sweep 4\n+time 20230101.110000   , step     11; iteration    2; sweep 1\n+time 20230101.110000   , step     11; iteration    2; sweep 2\n+time 20230101.110000   , step     11; iteration    2; sweep 3\n+time 20230101.110000   , step     11; iteration    2; sweep 4\n+time 20230101.110000   , step     11; iteration    3; sweep 1\n+time 20230101.110000   , step     11; iteration    3; sweep 2\n+time 20230101.110000   , step     11; iteration    3; sweep 3\n+time 20230101.110000   , step     11; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.120000   , step     12; iteration    1; sweep 1\n+time 20230101.120000   , step     12; iteration    1; sweep 2\n+time 20230101.120000   , step     12; iteration    1; sweep 3\n+time 20230101.120000   , step     12; iteration    1; sweep 4\n+time 20230101.120000   , step     12; iteration    2; sweep 1\n+time 20230101.120000   , step     12; iteration    2; sweep 2\n+time 20230101.120000   , step     12; iteration    2; sweep 3\n+time 20230101.120000   , step     12; iteration    2; sweep 4\n+time 20230101.120000   , step     12; iteration    3; sweep 1\n+time 20230101.120000   , step     12; iteration    3; sweep 2\n+time 20230101.120000   , step     12; iteration    3; sweep 3\n+time 20230101.120000   , step     12; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.130000   , step     13; iteration    1; sweep 1\n+time 20230101.130000   , step     13; iteration    1; sweep 2\n+time 20230101.130000   , step     13; iteration    1; sweep 3\n+time 20230101.130000   , step     13; iteration    1; sweep 4\n+time 20230101.130000   , step     13; iteration    2; sweep 1\n+time 20230101.130000   , step     13; iteration    2; sweep 2\n+time 20230101.130000   , step     13; iteration    2; sweep 3\n+time 20230101.130000   , step     13; iteration    2; sweep 4\n+time 20230101.130000   , step     13; iteration    3; sweep 1\n+time 20230101.130000   , step     13; iteration    3; sweep 2\n+time 20230101.130000   , step     13; iteration    3; sweep 3\n+time 20230101.130000   , step     13; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.140000   , step     14; iteration    1; sweep 1\n+time 20230101.140000   , step     14; iteration    1; sweep 2\n+time 20230101.140000   , step     14; iteration    1; sweep 3\n+time 20230101.140000   , step     14; iteration    1; sweep 4\n+time 20230101.140000   , step     14; iteration    2; sweep 1\n+time 20230101.140000   , step     14; iteration    2; sweep 2\n+time 20230101.140000   , step     14; iteration    2; sweep 3\n+time 20230101.140000   , step     14; iteration    2; sweep 4\n+time 20230101.140000   , step     14; iteration    3; sweep 1\n+time 20230101.140000   , step     14; iteration    3; sweep 2\n+time 20230101.140000   , step     14; iteration    3; sweep 3\n+time 20230101.140000   , step     14; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.150000   , step     15; iteration    1; sweep 1\n+time 20230101.150000   , step     15; iteration    1; sweep 2\n+time 20230101.150000   , step     15; iteration    1; sweep 3\n+time 20230101.150000   , step     15; iteration    1; sweep 4\n+time 20230101.150000   , step     15; iteration    2; sweep 1\n+time 20230101.150000   , step     15; iteration    2; sweep 2\n+time 20230101.150000   , step     15; iteration    2; sweep 3\n+time 20230101.150000   , step     15; iteration    2; sweep 4\n+time 20230101.150000   , step     15; iteration    3; sweep 1\n+time 20230101.150000   , step     15; iteration    3; sweep 2\n+time 20230101.150000   , step     15; iteration    3; sweep 3\n+time 20230101.150000   , step     15; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.160000   , step     16; iteration    1; sweep 1\n+time 20230101.160000   , step     16; iteration    1; sweep 2\n+time 20230101.160000   , step     16; iteration    1; sweep 3\n+time 20230101.160000   , step     16; iteration    1; sweep 4\n+time 20230101.160000   , step     16; iteration    2; sweep 1\n+time 20230101.160000   , step     16; iteration    2; sweep 2\n+time 20230101.160000   , step     16; iteration    2; sweep 3\n+time 20230101.160000   , step     16; iteration    2; sweep 4\n+time 20230101.160000   , step     16; iteration    3; sweep 1\n+time 20230101.160000   , step     16; iteration    3; sweep 2\n+time 20230101.160000   , step     16; iteration    3; sweep 3\n+time 20230101.160000   , step     16; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.170000   , step     17; iteration    1; sweep 1\n+time 20230101.170000   , step     17; iteration    1; sweep 2\n+time 20230101.170000   , step     17; iteration    1; sweep 3\n+time 20230101.170000   , step     17; iteration    1; sweep 4\n+time 20230101.170000   , step     17; iteration    2; sweep 1\n+time 20230101.170000   , step     17; iteration    2; sweep 2\n+time 20230101.170000   , step     17; iteration    2; sweep 3\n+time 20230101.170000   , step     17; iteration    2; sweep 4\n+time 20230101.170000   , step     17; iteration    3; sweep 1\n+time 20230101.170000   , step     17; iteration    3; sweep 2\n+time 20230101.170000   , step     17; iteration    3; sweep 3\n+time 20230101.170000   , step     17; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.180000   , step     18; iteration    1; sweep 1\n+time 20230101.180000   , step     18; iteration    1; sweep 2\n+time 20230101.180000   , step     18; iteration    1; sweep 3\n+time 20230101.180000   , step     18; iteration    1; sweep 4\n+time 20230101.180000   , step     18; iteration    2; sweep 1\n+time 20230101.180000   , step     18; iteration    2; sweep 2\n+time 20230101.180000   , step     18; iteration    2; sweep 3\n+time 20230101.180000   , step     18; iteration    2; sweep 4\n+time 20230101.180000   , step     18; iteration    3; sweep 1\n+time 20230101.180000   , step     18; iteration    3; sweep 2\n+time 20230101.180000   , step     18; iteration    3; sweep 3\n+time 20230101.180000   , step     18; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.190000   , step     19; iteration    1; sweep 1\n+time 20230101.190000   , step     19; iteration    1; sweep 2\n+time 20230101.190000   , step     19; iteration    1; sweep 3\n+time 20230101.190000   , step     19; iteration    1; sweep 4\n+time 20230101.190000   , step     19; iteration    2; sweep 1\n+time 20230101.190000   , step     19; iteration    2; sweep 2\n+time 20230101.190000   , step     19; iteration    2; sweep 3\n+time 20230101.190000   , step     19; iteration    2; sweep 4\n+time 20230101.190000   , step     19; iteration    3; sweep 1\n+time 20230101.190000   , step     19; iteration    3; sweep 2\n+time 20230101.190000   , step     19; iteration    3; sweep 3\n+time 20230101.190000   , step     19; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.200000   , step     20; iteration    1; sweep 1\n+time 20230101.200000   , step     20; iteration    1; sweep 2\n+time 20230101.200000   , step     20; iteration    1; sweep 3\n+time 20230101.200000   , step     20; iteration    1; sweep 4\n+time 20230101.200000   , step     20; iteration    2; sweep 1\n+time 20230101.200000   , step     20; iteration    2; sweep 2\n+time 20230101.200000   , step     20; iteration    2; sweep 3\n+time 20230101.200000   , step     20; iteration    2; sweep 4\n+time 20230101.200000   , step     20; iteration    3; sweep 1\n+time 20230101.200000   , step     20; iteration    3; sweep 2\n+time 20230101.200000   , step     20; iteration    3; sweep 3\n+time 20230101.200000   , step     20; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.210000   , step     21; iteration    1; sweep 1\n+time 20230101.210000   , step     21; iteration    1; sweep 2\n+time 20230101.210000   , step     21; iteration    1; sweep 3\n+time 20230101.210000   , step     21; iteration    1; sweep 4\n+time 20230101.210000   , step     21; iteration    2; sweep 1\n+time 20230101.210000   , step     21; iteration    2; sweep 2\n+time 20230101.210000   , step     21; iteration    2; sweep 3\n+time 20230101.210000   , step     21; iteration    2; sweep 4\n+time 20230101.210000   , step     21; iteration    3; sweep 1\n+time 20230101.210000   , step     21; iteration    3; sweep 2\n+time 20230101.210000   , step     21; iteration    3; sweep 3\n+time 20230101.210000   , step     21; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.220000   , step     22; iteration    1; sweep 1\n+time 20230101.220000   , step     22; iteration    1; sweep 2\n+time 20230101.220000   , step     22; iteration    1; sweep 3\n+time 20230101.220000   , step     22; iteration    1; sweep 4\n+time 20230101.220000   , step     22; iteration    2; sweep 1\n+time 20230101.220000   , step     22; iteration    2; sweep 2\n+time 20230101.220000   , step     22; iteration    2; sweep 3\n+time 20230101.220000   , step     22; iteration    2; sweep 4\n+time 20230101.220000   , step     22; iteration    3; sweep 1\n+time 20230101.220000   , step     22; iteration    3; sweep 2\n+time 20230101.220000   , step     22; iteration    3; sweep 3\n+time 20230101.220000   , step     22; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230101.230000   , step     23; iteration    1; sweep 1\n+time 20230101.230000   , step     23; iteration    1; sweep 2\n+time 20230101.230000   , step     23; iteration    1; sweep 3\n+time 20230101.230000   , step     23; iteration    1; sweep 4\n+time 20230101.230000   , step     23; iteration    2; sweep 1\n+time 20230101.230000   , step     23; iteration    2; sweep 2\n+time 20230101.230000   , step     23; iteration    2; sweep 3\n+time 20230101.230000   , step     23; iteration    2; sweep 4\n+time 20230101.230000   , step     23; iteration    3; sweep 1\n+time 20230101.230000   , step     23; iteration    3; sweep 2\n+time 20230101.230000   , step     23; iteration    3; sweep 3\n+time 20230101.230000   , step     23; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n+time 20230102.000000   , step     24; iteration    1; sweep 1\n+time 20230102.000000   , step     24; iteration    1; sweep 2\n+time 20230102.000000   , step     24; iteration    1; sweep 3\n+time 20230102.000000   , step     24; iteration    1; sweep 4\n+time 20230102.000000   , step     24; iteration    2; sweep 1\n+time 20230102.000000   , step     24; iteration    2; sweep 2\n+time 20230102.000000   , step     24; iteration    2; sweep 3\n+time 20230102.000000   , step     24; iteration    2; sweep 4\n+time 20230102.000000   , step     24; iteration    3; sweep 1\n+time 20230102.000000   , step     24; iteration    3; sweep 2\n+time 20230102.000000   , step     24; iteration    3; sweep 3\n+time 20230102.000000   , step     24; iteration    3; sweep 4\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n</pre> In\u00a0[11]: Copied! <pre>import os\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom wavespectra import read_ncswan\nfrom wavespectra.core.swan import read_tab\n\npd.set_option(\"display.notebook_repr_html\", False)\n</pre> import os import numpy as np import pandas as pd import xarray as xr import matplotlib.pyplot as plt import cartopy.crs as ccrs from wavespectra import read_ncswan from wavespectra.core.swan import read_tab  pd.set_option(\"display.notebook_repr_html\", False) In\u00a0[12]: Copied! <pre>modeldir = Path(run.output_dir) / run.run_id\n\nsorted(modeldir.glob(\"*\"))\n</pre> modeldir = Path(run.output_dir) / run.run_id  sorted(modeldir.glob(\"*\")) Out[12]: <pre>[PosixPath('example_declarative/run1/INPUT'),\n PosixPath('example_declarative/run1/PRINT'),\n PosixPath('example_declarative/run1/bottom.grd'),\n PosixPath('example_declarative/run1/hotfile_20230102T000000.txt'),\n PosixPath('example_declarative/run1/norm_end'),\n PosixPath('example_declarative/run1/swangrid.nc'),\n PosixPath('example_declarative/run1/swaninit'),\n PosixPath('example_declarative/run1/swanspec.nc'),\n PosixPath('example_declarative/run1/swantable.txt'),\n PosixPath('example_declarative/run1/wind.grd')]</pre> In\u00a0[13]: Copied! <pre># Gridded output\n\ndsgrid = xr.open_dataset(modeldir / run.config.output.block.fname)\ndsgrid\n</pre> # Gridded output  dsgrid = xr.open_dataset(modeldir / run.config.output.block.fname) dsgrid Out[13]: <pre>&lt;xarray.Dataset&gt; Size: 228kB\nDimensions:    (time: 25, yc: 25, xc: 15)\nCoordinates:\n  * time       (time) datetime64[ns] 200B 2023-01-01 ... 2023-01-02\n    longitude  (yc, xc) float32 2kB ...\n    latitude   (yc, xc) float32 2kB ...\nDimensions without coordinates: yc, xc\nData variables:\n    depth      (time, yc, xc) float32 38kB ...\n    xwnd       (time, yc, xc) float32 38kB ...\n    ywnd       (time, yc, xc) float32 38kB ...\n    hs         (time, yc, xc) float32 38kB ...\n    tps        (time, yc, xc) float32 38kB ...\n    theta0     (time, yc, xc) float32 38kB ...\nAttributes:\n    Conventions:             CF-1.5\n    History:                 Created with agioncmd version 1.5\n    Directional_convention:  nautical\n    project:                 Test declarative\n    run:                     run1</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 25</li><li>yc: 25</li><li>xc: 15</li></ul></li><li>Coordinates: (3)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :timelong_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T01:00:00.000000000',\n       '2023-01-01T02:00:00.000000000', '2023-01-01T03:00:00.000000000',\n       '2023-01-01T04:00:00.000000000', '2023-01-01T05:00:00.000000000',\n       '2023-01-01T06:00:00.000000000', '2023-01-01T07:00:00.000000000',\n       '2023-01-01T08:00:00.000000000', '2023-01-01T09:00:00.000000000',\n       '2023-01-01T10:00:00.000000000', '2023-01-01T11:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T13:00:00.000000000',\n       '2023-01-01T14:00:00.000000000', '2023-01-01T15:00:00.000000000',\n       '2023-01-01T16:00:00.000000000', '2023-01-01T17:00:00.000000000',\n       '2023-01-01T18:00:00.000000000', '2023-01-01T19:00:00.000000000',\n       '2023-01-01T20:00:00.000000000', '2023-01-01T21:00:00.000000000',\n       '2023-01-01T22:00:00.000000000', '2023-01-01T23:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>longitude(yc, xc)float32...units :degrees_eastlong_name :longitudestandard_name :longitude<pre>[375 values with dtype=float32]</pre></li><li>latitude(yc, xc)float32...units :degrees_northlong_name :latitudestandard_name :latitude<pre>[375 values with dtype=float32]</pre></li></ul></li><li>Data variables: (6)<ul><li>depth(time, yc, xc)float32...units :mstandard_name :sea_floor_depth_below_sea_levellong_name :depth below mean sea level<pre>[9375 values with dtype=float32]</pre></li><li>xwnd(time, yc, xc)float32...units :m s-1standard_name :eastward_windlong_name :U-Component of Wind<pre>[9375 values with dtype=float32]</pre></li><li>ywnd(time, yc, xc)float32...units :m s-1standard_name :northward_windlong_name :V-Component of Wind<pre>[9375 values with dtype=float32]</pre></li><li>hs(time, yc, xc)float32...units :mstandard_name :sea_surface_wave_significant_heightlong_name :hs<pre>[9375 values with dtype=float32]</pre></li><li>tps(time, yc, xc)float32...units :slong_name :tps<pre>[9375 values with dtype=float32]</pre></li><li>theta0(time, yc, xc)float32...units :degreesstandard_name :sea_surface_wave_from_directionlong_name :theta0<pre>[9375 values with dtype=float32]</pre></li></ul></li><li>Indexes: (1)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00',\n               '2023-01-01 02:00:00', '2023-01-01 03:00:00',\n               '2023-01-01 04:00:00', '2023-01-01 05:00:00',\n               '2023-01-01 06:00:00', '2023-01-01 07:00:00',\n               '2023-01-01 08:00:00', '2023-01-01 09:00:00',\n               '2023-01-01 10:00:00', '2023-01-01 11:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 13:00:00',\n               '2023-01-01 14:00:00', '2023-01-01 15:00:00',\n               '2023-01-01 16:00:00', '2023-01-01 17:00:00',\n               '2023-01-01 18:00:00', '2023-01-01 19:00:00',\n               '2023-01-01 20:00:00', '2023-01-01 21:00:00',\n               '2023-01-01 22:00:00', '2023-01-01 23:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (5)Conventions :CF-1.5History :Created with agioncmd version 1.5Directional_convention :nauticalproject :Test declarativerun :run1</li></ul> In\u00a0[14]: Copied! <pre># Spectra output\n\ndspec = read_ncswan(modeldir / run.config.output.specout.fname)\ndspec\n</pre> # Spectra output  dspec = read_ncswan(modeldir / run.config.output.specout.fname) dspec Out[14]: <pre>&lt;xarray.Dataset&gt; Size: 379kB\nDimensions:  (site: 3, time: 25, freq: 35, dir: 36)\nCoordinates:\n  * time     (time) datetime64[ns] 200B 2023-01-01 ... 2023-01-02\n  * freq     (freq) float32 140B 0.04 0.04397 0.04834 ... 0.8275 0.9097 1.0\n  * dir      (dir) float32 144B 261.0 251.0 241.0 231.0 ... 291.0 281.0 271.0\n  * site     (site) int64 24B 1 2 3\nData variables:\n    lon      (site) float32 12B dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;\n    lat      (site) float32 12B dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;\n    efth     (time, site, freq, dir) float32 378kB dask.array&lt;chunksize=(25, 3, 35, 36), meta=np.ndarray&gt;\n    dpt      (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\n    wspd     (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\n    wdir     (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\nAttributes:\n    Conventions:             CF-1.5\n    History:                 Created with agioncmd version 1.5\n    Directional_convention:  nautical\n    project:                 Test declarative\n    model:                   41.41\n    run:                     run1</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 3</li><li>time: 25</li><li>freq: 35</li><li>dir: 36</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :timelong_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T01:00:00.000000000',\n       '2023-01-01T02:00:00.000000000', '2023-01-01T03:00:00.000000000',\n       '2023-01-01T04:00:00.000000000', '2023-01-01T05:00:00.000000000',\n       '2023-01-01T06:00:00.000000000', '2023-01-01T07:00:00.000000000',\n       '2023-01-01T08:00:00.000000000', '2023-01-01T09:00:00.000000000',\n       '2023-01-01T10:00:00.000000000', '2023-01-01T11:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T13:00:00.000000000',\n       '2023-01-01T14:00:00.000000000', '2023-01-01T15:00:00.000000000',\n       '2023-01-01T16:00:00.000000000', '2023-01-01T17:00:00.000000000',\n       '2023-01-01T18:00:00.000000000', '2023-01-01T19:00:00.000000000',\n       '2023-01-01T20:00:00.000000000', '2023-01-01T21:00:00.000000000',\n       '2023-01-01T22:00:00.000000000', '2023-01-01T23:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>freq(freq)float320.04 0.04397 0.04834 ... 0.9097 1.0units :s-1standard_name :wave_frequencyflow :0.04fhigh :0.9999985msc :34<pre>array([0.04    , 0.043972, 0.048338, 0.053138, 0.058415, 0.064215, 0.070592,\n       0.077602, 0.085307, 0.093778, 0.103091, 0.113327, 0.124581, 0.136951,\n       0.15055 , 0.1655  , 0.181934, 0.2     , 0.21986 , 0.241692, 0.265691,\n       0.292074, 0.321077, 0.35296 , 0.388008, 0.426537, 0.468892, 0.515452,\n       0.566636, 0.622902, 0.684756, 0.752752, 0.827499, 0.909669, 0.999999],\n      dtype=float32)</pre></li><li>dir(dir)float32261.0 251.0 241.0 ... 281.0 271.0<pre>array([261.      , 251.      , 241.      , 231.      , 221.      , 211.      ,\n       201.      , 191.      , 181.      , 171.      , 160.99998 , 151.      ,\n       141.      , 131.      , 120.999985, 110.999985, 100.99999 ,  90.99999 ,\n        80.99999 ,  70.999985,  60.999985,  50.999985,  40.99999 ,  30.999989,\n        20.99999 ,  10.999992,   0.999994, 350.99997 , 340.99997 , 330.99997 ,\n       320.99997 , 310.99997 , 300.99997 , 290.99997 , 281.      , 271.      ],\n      dtype=float32)</pre></li><li>site(site)int641 2 3<pre>array([1, 2, 3])</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;standard_name :longitudeunits :degrees_east  Array   Chunk   Bytes   12 B   12 B   Shape   (3,)   (3,)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 1 </li><li>lat(site)float32dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;standard_name :latitudeunits :degrees_north  Array   Chunk   Bytes   12 B   12 B   Shape   (3,)   (3,)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 1 </li><li>efth(time, site, freq, dir)float32dask.array&lt;chunksize=(25, 3, 35, 36), meta=np.ndarray&gt;standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1  Array   Chunk   Bytes   369.14 kiB   369.14 kiB   Shape   (25, 3, 35, 36)   (25, 3, 35, 36)   Dask graph   1 chunks in 3 graph layers   Data type   float32 numpy.ndarray  25 1 36 35 3 </li><li>dpt(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :sea_floor_depth_below_sea_surfaceunits :m  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 25 </li><li>wspd(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 8 graph layers   Data type   float32 numpy.ndarray  3 25 </li><li>wdir(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 8 graph layers   Data type   float32 numpy.ndarray  3 25 </li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00',\n               '2023-01-01 02:00:00', '2023-01-01 03:00:00',\n               '2023-01-01 04:00:00', '2023-01-01 05:00:00',\n               '2023-01-01 06:00:00', '2023-01-01 07:00:00',\n               '2023-01-01 08:00:00', '2023-01-01 09:00:00',\n               '2023-01-01 10:00:00', '2023-01-01 11:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 13:00:00',\n               '2023-01-01 14:00:00', '2023-01-01 15:00:00',\n               '2023-01-01 16:00:00', '2023-01-01 17:00:00',\n               '2023-01-01 18:00:00', '2023-01-01 19:00:00',\n               '2023-01-01 20:00:00', '2023-01-01 21:00:00',\n               '2023-01-01 22:00:00', '2023-01-01 23:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([ 0.03999999910593033,   0.0439719632267952,  0.04833833873271942,\n        0.05313829332590103, 0.058414872735738754,  0.06421541422605515,\n        0.07059194892644882,  0.07760166376829147,  0.08530744165182114,\n        0.09377838671207428,  0.10309050232172012,  0.11332729458808899,\n        0.12458059191703796,  0.13695132732391357,   0.1505504697561264,\n         0.1655000001192093,  0.18193399906158447,   0.1999998688697815,\n        0.21985965967178345,  0.24169152975082397,  0.26569128036499023,\n        0.29207417368888855,   0.3210768699645996,   0.3529595136642456,\n         0.3880080580711365,     0.42653688788414,  0.46889159083366394,\n         0.5154520869255066,   0.5666360259056091,   0.6229023933410645,\n         0.6847560405731201,   0.7527517080307007,    0.827499270439148,\n         0.9096691608428955,   0.9999985098838806],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([             261.0,              251.0,              241.0,\n                    231.0,              221.0,              211.0,\n                    201.0,              191.0,              181.0,\n                    171.0, 160.99998474121094,              151.0,\n                    141.0,              131.0, 120.99998474121094,\n       110.99998474121094, 100.99999237060547,  90.99999237060547,\n        80.99999237060547,  70.99998474121094,  60.99998474121094,\n        50.99998474121094,   40.9999885559082, 30.999988555908203,\n       20.999990463256836, 10.999992370605469, 0.9999943375587463,\n        350.9999694824219,  340.9999694824219,  330.9999694824219,\n        320.9999694824219,  310.9999694824219,  300.9999694824219,\n        290.9999694824219,              281.0,              271.0],\n      dtype='float32', name='dir'))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([1, 2, 3], dtype='int64', name='site'))</pre></li></ul></li><li>Attributes: (6)Conventions :CF-1.5History :Created with agioncmd version 1.5Directional_convention :nauticalproject :Test declarativemodel :41.41run :run1</li></ul> In\u00a0[15]: Copied! <pre>os.system(f\"head -n 15 {modeldir / run.config.output.table.fname}\")\n</pre> os.system(f\"head -n 15 {modeldir / run.config.output.table.fname}\") <pre>%\n%\n% Run:run1  Table:pts               SWAN version:41.41\n%\n%       Time               Hsig          Hswell        Dir           TPsmoo        Tm01     \n%       [ ]                [m]           [m]           [degr]        [sec]         [sec]    \n%\n20230101.000000          0.61126       0.00002       183.186        3.6992        2.7202 \n20230101.000000          1.07937       0.03900       176.467        4.9832        3.7063 \n20230101.000000         -9.00000      -9.00000        -9.000       -9.0000       -9.0000 \n20230101.010000          0.61275       0.00002       182.850        3.7210        2.7083 \n20230101.010000          1.07086       0.03935       176.350        5.0704        3.6928 \n20230101.010000         -9.00000      -9.00000        -9.000       -9.0000       -9.0000 \n20230101.020000          0.61664       0.00002       182.787        3.7145        2.7083 \n20230101.020000          1.06328       0.03973       176.565        5.0631        3.6886 \n</pre> Out[15]: <pre>0</pre> In\u00a0[16]: Copied! <pre># Timeseries output (keep 1st site only)\n\ndf = read_tab(modeldir / run.config.output.table.fname)\n\ndf[\"time\"] = df.index\ndf = df.drop_duplicates(\"time\", keep=\"first\").drop(\"time\", axis=1)\ndf.head()\n</pre> # Timeseries output (keep 1st site only)  df = read_tab(modeldir / run.config.output.table.fname)  df[\"time\"] = df.index df = df.drop_duplicates(\"time\", keep=\"first\").drop(\"time\", axis=1) df.head() Out[16]: <pre>                        Hsig   Hswell      Dir  TPsmoo    Tm01\ntime                                                          \n2023-01-01 00:00:00  0.61126  0.00002  183.186  3.6992  2.7202\n2023-01-01 01:00:00  0.61275  0.00002  182.850  3.7210  2.7083\n2023-01-01 02:00:00  0.61664  0.00002  182.787  3.7145  2.7083\n2023-01-01 03:00:00  0.61837  0.00001  182.792  3.7198  2.7177\n2023-01-01 04:00:00  0.62287  0.00001  182.762  3.7230  2.7247</pre> In\u00a0[17]: Copied! <pre>fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()))\np = dsgrid.depth.isel(time=0, drop=True).plot(ax=ax, x=\"longitude\", y=\"latitude\")\nax.coastlines();\n</pre> fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree())) p = dsgrid.depth.isel(time=0, drop=True).plot(ax=ax, x=\"longitude\", y=\"latitude\") ax.coastlines(); In\u00a0[18]: Copied! <pre>f = dsgrid.hs.isel(time=slice(0, -1, 3)).plot(\n    x=\"longitude\",\n    y=\"latitude\",\n    col=\"time\",\n    col_wrap=4,\n    vmin=0,\n    vmax=2,\n    cmap=\"turbo\",\n    subplot_kws=dict(projection=ccrs.PlateCarree()),\n)\nf.map(lambda: plt.gca().coastlines());\n</pre> f = dsgrid.hs.isel(time=slice(0, -1, 3)).plot(     x=\"longitude\",     y=\"latitude\",     col=\"time\",     col_wrap=4,     vmin=0,     vmax=2,     cmap=\"turbo\",     subplot_kws=dict(projection=ccrs.PlateCarree()), ) f.map(lambda: plt.gca().coastlines()); In\u00a0[19]: Copied! <pre>u = dsgrid.xwnd.isel(time=slice(0, -1, 3))\nv = dsgrid.ywnd.isel(time=slice(0, -1, 3))\nf = np.sqrt(u ** 2 + v ** 2).plot(\n    x=\"longitude\",\n    y=\"latitude\",\n    col=\"time\",\n    col_wrap=4,\n    vmin=2,\n    vmax=12,\n    cmap=\"jet\",\n    cbar_kwargs={\"label\": \"Wind speed (m/s)\"},\n    subplot_kws=dict(projection=ccrs.PlateCarree()),\n)\nfor ax, time in zip(f.axs.flat, u.time):\n    ax.coastlines()\n    ax.quiver(u.longitude, u.latitude, u.sel(time=time), v.sel(time=time), scale=150)\n    ax.plot(dspec.isel(site=0).lon, dspec.isel(site=0).lat, \"ok\")\n</pre> u = dsgrid.xwnd.isel(time=slice(0, -1, 3)) v = dsgrid.ywnd.isel(time=slice(0, -1, 3)) f = np.sqrt(u ** 2 + v ** 2).plot(     x=\"longitude\",     y=\"latitude\",     col=\"time\",     col_wrap=4,     vmin=2,     vmax=12,     cmap=\"jet\",     cbar_kwargs={\"label\": \"Wind speed (m/s)\"},     subplot_kws=dict(projection=ccrs.PlateCarree()), ) for ax, time in zip(f.axs.flat, u.time):     ax.coastlines()     ax.quiver(u.longitude, u.latitude, u.sel(time=time), v.sel(time=time), scale=150)     ax.plot(dspec.isel(site=0).lon, dspec.isel(site=0).lat, \"ok\") In\u00a0[20]: Copied! <pre>p = dspec.isel(site=0, time=slice(0, -1, 3)).spec.plot(col=\"time\", col_wrap=4)\n</pre> p = dspec.isel(site=0, time=slice(0, -1, 3)).spec.plot(col=\"time\", col_wrap=4) In\u00a0[21]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n\ndf.Hsig.plot(ax=ax1, label=\"From table\", linewidth=5)\ndspec.isel(site=0).spec.hs().to_pandas().plot(ax=ax1, label=\"From spectra\")\nax1.set_ylabel(\"Hs (m)\")\nl = ax1.legend()\n\ndf.TPsmoo.plot(ax=ax2, label=\"From table\", linewidth=5)\ndspec.isel(site=0).spec.tp(smooth=True).to_pandas().plot(ax=ax2, label=\"From spectra\")\nax2.set_ylabel(\"Tp (s)\")\nl = ax2.legend()\n</pre> fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))  df.Hsig.plot(ax=ax1, label=\"From table\", linewidth=5) dspec.isel(site=0).spec.hs().to_pandas().plot(ax=ax1, label=\"From spectra\") ax1.set_ylabel(\"Hs (m)\") l = ax1.legend()  df.TPsmoo.plot(ax=ax2, label=\"From table\", linewidth=5) dspec.isel(site=0).spec.tp(smooth=True).to_pandas().plot(ax=ax2, label=\"From spectra\") ax2.set_ylabel(\"Tp (s)\") l = ax2.legend()"},{"location":"examples/example_declarative/#swan-declarative-example","title":"SWAN declarative example\u00b6","text":"<p>In this notebook we will run SWAN entirely from a model runtime and config entirely declared in a yaml file. We only plot some model settings to visualise before creating the model workspace</p>"},{"location":"examples/example_declarative/#instantiate-model","title":"Instantiate model\u00b6","text":"<p>Use a fully-defined config from yaml to instantiate ModelRun with the runtime parameters and the config definition</p>"},{"location":"examples/example_declarative/#qc-config","title":"QC config\u00b6","text":"<p>Plot model grid and data to QC before generating the workspace</p>"},{"location":"examples/example_declarative/#run-the-model","title":"Run the model\u00b6","text":""},{"location":"examples/example_declarative/#check-the-workspace","title":"Check the workspace\u00b6","text":""},{"location":"examples/example_declarative/#run-the-model","title":"Run the model\u00b6","text":""},{"location":"examples/example_declarative/#plot-outputs","title":"Plot outputs\u00b6","text":""},{"location":"examples/example_declarative/#plot-model-depth","title":"Plot model depth\u00b6","text":""},{"location":"examples/example_declarative/#plot-gridded-hs","title":"Plot gridded Hs\u00b6","text":""},{"location":"examples/example_declarative/#plot-gridded-wind","title":"Plot gridded wind\u00b6","text":""},{"location":"examples/example_declarative/#plot-spectra","title":"Plot spectra\u00b6","text":""},{"location":"examples/example_declarative/#plot-timeseries","title":"Plot timeseries\u00b6","text":""},{"location":"examples/example_procedural/","title":"SWAN procedural example","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport shutil\nfrom pathlib import Path\nimport numpy as np\nimport xarray as xr\nimport matplotlib.pyplot as plt\nfrom cartopy import crs as ccrs\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</pre> %load_ext autoreload %autoreload 2  import shutil from pathlib import Path import numpy as np import xarray as xr import matplotlib.pyplot as plt from cartopy import crs as ccrs  import warnings warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>workdir = Path(\"example_procedural\")\nshutil.rmtree(workdir, ignore_errors=True)\nworkdir.mkdir()\n</pre> workdir = Path(\"example_procedural\") shutil.rmtree(workdir, ignore_errors=True) workdir.mkdir() In\u00a0[3]: Copied! <pre>from rompy_swan.grid import SwanGrid\n\ngrid = SwanGrid(\n    x0=110.0,\n    y0=-35.2,\n    rot=4.0,\n    dx=0.5,\n    dy=0.5,\n    nx=15,\n    ny=25,\n)\n\nfig, ax = grid.plot(fscale=6)\n</pre> from rompy_swan.grid import SwanGrid  grid = SwanGrid(     x0=110.0,     y0=-35.2,     rot=4.0,     dx=0.5,     dy=0.5,     nx=15,     ny=25, )  fig, ax = grid.plot(fscale=6) In\u00a0[4]: Copied! <pre>from rompy.core.time import TimeRange\nfrom rompy.core.types import DatasetCoords\nfrom rompy_binary_datasources.source import SourceDataset\nfrom rompy_swan.data import SwanDataGrid\nfrom rompy_swan.boundary import Boundnest1\n\nprojection = ccrs.PlateCarree()\n</pre> from rompy.core.time import TimeRange from rompy.core.types import DatasetCoords from rompy_binary_datasources.source import SourceDataset from rompy_swan.data import SwanDataGrid from rompy_swan.boundary import Boundnest1  projection = ccrs.PlateCarree() In\u00a0[5]: Copied! <pre>def my_fancy_interpolation(\n    dset: xr.Dataset,\n    grid: SwanGrid,\n    coords: DatasetCoords,\n    buffer: float = 0.0,\n) -&gt; xr.Dataset:\n    \"\"\"Dummy interpolation function.\"\"\"\n    x0, y0, x1, y1 = grid.bbox(buffer)\n    xarr = np.arange(x0, x1+grid.dx, grid.dx)\n    yarr = np.arange(y0, y1+grid.dy, grid.dy)\n    return dset.interp(**{coords.x: xarr, coords.y: yarr})\n</pre> def my_fancy_interpolation(     dset: xr.Dataset,     grid: SwanGrid,     coords: DatasetCoords,     buffer: float = 0.0, ) -&gt; xr.Dataset:     \"\"\"Dummy interpolation function.\"\"\"     x0, y0, x1, y1 = grid.bbox(buffer)     xarr = np.arange(x0, x1+grid.dx, grid.dx)     yarr = np.arange(y0, y1+grid.dy, grid.dy)     return dset.interp(**{coords.x: xarr, coords.y: yarr}) In\u00a0[6]: Copied! <pre>DATADIR = Path(\"../../../rompy-swan/tests/data\")\ndisplay(sorted(DATADIR.glob(\"*\")))\n\ngebco = xr.open_dataset(DATADIR / \"gebco-1deg.nc\")\nera5 = xr.open_dataset(DATADIR / \"era5-20230101.nc\")\noceanum = xr.open_dataset(DATADIR / \"aus-20230101.nc\")\n</pre> DATADIR = Path(\"../../../rompy-swan/tests/data\") display(sorted(DATADIR.glob(\"*\")))  gebco = xr.open_dataset(DATADIR / \"gebco-1deg.nc\") era5 = xr.open_dataset(DATADIR / \"era5-20230101.nc\") oceanum = xr.open_dataset(DATADIR / \"aus-20230101.nc\") <pre>[PosixPath('../../../rompy-swan/tests/data/aus-20230101.nc'),\n PosixPath('../../../rompy-swan/tests/data/catalog.yaml'),\n PosixPath('../../../rompy-swan/tests/data/era5-20230101.nc'),\n PosixPath('../../../rompy-swan/tests/data/gebco-1deg.nc'),\n PosixPath('../../../rompy-swan/tests/data/schism'),\n PosixPath('../../../rompy-swan/tests/data/wind.csv')]</pre> In\u00a0[7]: Copied! <pre># Define a time object to run the model using the time range from ERA5 dataset\n\nstart, end = era5.time.to_index()[[0, -1]]\ntimes = TimeRange(start=start, end=end, interval=\"1h\")\nprint(times)\n</pre> # Define a time object to run the model using the time range from ERA5 dataset  start, end = era5.time.to_index()[[0, -1]] times = TimeRange(start=start, end=end, interval=\"1h\") print(times) <pre>\n\tStart: 2023-01-01 00:00:00\n\tEnd: 2023-01-02 00:00:00\n\tDuration: 1 day\n\tInterval: 1:00:00\n\tInclude End: True\n\n</pre> In\u00a0[8]: Copied! <pre># Display the GEBCO dataset\n\ndisplay(gebco)\np = gebco.elevation.plot(figsize=(10, 5), cmap=\"terrain\")\n</pre> # Display the GEBCO dataset  display(gebco) p = gebco.elevation.plot(figsize=(10, 5), cmap=\"terrain\") <pre>&lt;xarray.Dataset&gt; Size: 526kB\nDimensions:    (lat: 181, lon: 360)\nCoordinates:\n  * lon        (lon) int64 3kB 0 1 2 3 4 5 6 7 ... 353 354 355 356 357 358 359\n  * lat        (lat) int64 1kB -90 -89 -88 -87 -86 -85 -84 ... 85 86 87 88 89 90\nData variables:\n    elevation  (lat, lon) float64 521kB ...\nAttributes:\n    title:    Subset of the GEBCO 2020 grid for testing purposes</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lat: 181</li><li>lon: 360</li></ul></li><li>Coordinates: (2)<ul><li>lon(lon)int640 1 2 3 4 5 ... 355 356 357 358 359standard_name :longitudelong_name :longitudeunits :degrees_eastaxis :Xsdn_parameter_urn :SDN:P01::ALONZZ01sdn_parameter_name :Longitude eastsdn_uom_urn :SDN:P06::DEGEsdn_uom_name :Degrees east<pre>array([  0,   1,   2, ..., 357, 358, 359], shape=(360,))</pre></li><li>lat(lat)int64-90 -89 -88 -87 -86 ... 87 88 89 90standard_name :latitudelong_name :latitudeunits :degrees_northaxis :Ysdn_parameter_urn :SDN:P01::ALATZZ01sdn_parameter_name :Latitude northsdn_uom_urn :SDN:P06::DEGNsdn_uom_name :Degrees north<pre>array([-90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77,\n       -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63,\n       -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49,\n       -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35,\n       -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21,\n       -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10,  -9,  -8,  -7,\n        -6,  -5,  -4,  -3,  -2,  -1,   0,   1,   2,   3,   4,   5,   6,   7,\n         8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,\n        22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,\n        36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,\n        50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n        64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,\n        78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90])</pre></li></ul></li><li>Data variables: (1)<ul><li>elevation(lat, lon)float64...standard_name :height_above_reference_ellipsoidlong_name :Elevation relative to sea levelunits :msdn_parameter_urn :SDN:P01::BATHHGHTsdn_parameter_name :Sea floor height (above mean sea level) {bathymetric height}sdn_uom_urn :SDN:P06::ULAAsdn_uom_name :Metres<pre>[65160 values with dtype=float64]</pre></li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       350, 351, 352, 353, 354, 355, 356, 357, 358, 359],\n      dtype='int64', name='lon', length=360))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([-90, -89, -88, -87, -86, -85, -84, -83, -82, -81,\n       ...\n        81,  82,  83,  84,  85,  86,  87,  88,  89,  90],\n      dtype='int64', name='lat', length=181))</pre></li></ul></li><li>Attributes: (1)title :Subset of the GEBCO 2020 grid for testing purposes</li></ul> In\u00a0[9]: Copied! <pre># Process gebco into the model bathy\n\ndset = my_fancy_interpolation(gebco, grid, DatasetCoords(x=\"lon\", y=\"lat\"), buffer=1.0)\ndset\n</pre> # Process gebco into the model bathy  dset = my_fancy_interpolation(gebco, grid, DatasetCoords(x=\"lon\", y=\"lat\"), buffer=1.0) dset Out[9]: <pre>&lt;xarray.Dataset&gt; Size: 5kB\nDimensions:    (lat: 30, lon: 21)\nCoordinates:\n  * lon        (lon) float64 168B 108.2 108.7 109.2 109.7 ... 117.2 117.7 118.2\n  * lat        (lat) float64 240B -36.2 -35.7 -35.2 -34.7 ... -22.7 -22.2 -21.7\nData variables:\n    elevation  (lat, lon) float64 5kB -5.443e+03 -5.552e+03 ... 333.9 346.7\nAttributes:\n    title:    Subset of the GEBCO 2020 grid for testing purposes</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lat: 30</li><li>lon: 21</li></ul></li><li>Coordinates: (2)<ul><li>lon(lon)float64108.2 108.7 109.2 ... 117.7 118.2standard_name :longitudelong_name :longitudeunits :degrees_eastaxis :Xsdn_parameter_urn :SDN:P01::ALONZZ01sdn_parameter_name :Longitude eastsdn_uom_urn :SDN:P06::DEGEsdn_uom_name :Degrees east<pre>array([108.162922, 108.662922, 109.162922, 109.662922, 110.162922, 110.662922,\n       111.162922, 111.662922, 112.162922, 112.662922, 113.162922, 113.662922,\n       114.162922, 114.662922, 115.162922, 115.662922, 116.162922, 116.662922,\n       117.162922, 117.662922, 118.162922])</pre></li><li>lat(lat)float64-36.2 -35.7 -35.2 ... -22.2 -21.7standard_name :latitudelong_name :latitudeunits :degrees_northaxis :Ysdn_parameter_urn :SDN:P01::ALATZZ01sdn_parameter_name :Latitude northsdn_uom_urn :SDN:P06::DEGNsdn_uom_name :Degrees north<pre>array([-36.2, -35.7, -35.2, -34.7, -34.2, -33.7, -33.2, -32.7, -32.2, -31.7,\n       -31.2, -30.7, -30.2, -29.7, -29.2, -28.7, -28.2, -27.7, -27.2, -26.7,\n       -26.2, -25.7, -25.2, -24.7, -24.2, -23.7, -23.2, -22.7, -22.2, -21.7])</pre></li></ul></li><li>Data variables: (1)<ul><li>elevation(lat, lon)float64-5.443e+03 -5.552e+03 ... 346.7standard_name :height_above_reference_ellipsoidlong_name :Elevation relative to sea levelunits :msdn_parameter_urn :SDN:P01::BATHHGHTsdn_parameter_name :Sea floor height (above mean sea level) {bathymetric height}sdn_uom_urn :SDN:P06::ULAAsdn_uom_name :Metres<pre>array([[-5.44333690e+03, -5.55203010e+03, -5.51244369e+03,\n        -5.16607459e+03, -4.98063565e+03, -5.12815275e+03,\n        -5.26401315e+03, -5.37575645e+03, -5.46007918e+03,\n        -5.48767018e+03, -5.48030864e+03, -5.40063214e+03,\n        -5.33507511e+03, -5.29873051e+03, -5.15867064e+03,\n        -4.80402934e+03, -4.53275451e+03, -4.43396051e+03,\n        -4.36858181e+03, -4.37233761e+03, -4.43275069e+03],\n       [-5.48174021e+03, -5.56709226e+03, -5.53045000e+03,\n        -5.24140795e+03, -4.98359843e+03, -4.79040738e+03,\n        -4.67873520e+03, -4.73572125e+03, -4.80830313e+03,\n        -4.91315198e+03, -4.91768694e+03, -4.71467774e+03,\n        -4.46867165e+03, -4.13370725e+03, -3.79005251e+03,\n        -3.42841791e+03, -3.13898421e+03, -2.99893036e+03,\n        -2.91206937e+03, -2.93526162e+03, -3.03258501e+03],\n       [-5.36776536e+03, -5.45166166e+03, -5.39673752e+03,\n        -5.05460122e+03, -4.63601884e+03, -4.05927354e+03,\n        -3.66337384e+03, -3.64163414e+03, -3.70276106e+03,\n        -3.93533466e+03, -3.93694232e+03, -3.46069362e+03,\n        -2.88378672e+03, -2.09862332e+03, -1.46811240e+03,\n        -1.15756930e+03, -9.23004043e+02, -8.45632943e+02,\n...\n        -4.34846244e+03, -4.68482305e+03, -4.77194110e+03,\n        -4.62750527e+03, -4.00399667e+03, -3.23228993e+03,\n        -2.15396903e+03, -1.21748125e+03, -5.74438754e+02,\n        -1.05447174e+02,  3.44222627e+00,  1.00844153e+02,\n         1.74479103e+02,  2.53412629e+02,  3.43308629e+02,\n         4.21966997e+02,  4.77375297e+02,  5.17342488e+02],\n       [-3.73903434e+03, -4.00741114e+03, -4.27036950e+03,\n        -4.52211740e+03, -4.73636365e+03, -4.87302095e+03,\n        -4.84350990e+03, -4.47020530e+03, -3.85659019e+03,\n        -2.74578529e+03, -1.71157177e+03, -8.35821765e+02,\n        -2.00260509e+02, -6.16371095e+01,  5.55717162e+01,\n         1.28474916e+02,  2.13744018e+02,  3.24597518e+02,\n         4.11605805e+02,  4.49279605e+02,  4.68767626e+02],\n       [-4.16772633e+03, -4.39071798e+03, -4.58527702e+03,\n        -4.72101047e+03, -4.82205572e+03, -4.85133292e+03,\n        -4.69269580e+03, -4.14527385e+03, -3.48418546e+03,\n        -2.58792721e+03, -1.73280097e+03, -9.62774665e+02,\n        -3.73438369e+02, -1.57940169e+02,  8.27680065e+00,\n         7.25335006e+01,  1.46090556e+02,  2.38889556e+02,\n         3.09416554e+02,  3.33863954e+02,  3.46746509e+02]])</pre></li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([108.1629223150705, 108.6629223150705, 109.1629223150705,\n       109.6629223150705, 110.1629223150705, 110.6629223150705,\n       111.1629223150705, 111.6629223150705, 112.1629223150705,\n       112.6629223150705, 113.1629223150705, 113.6629223150705,\n       114.1629223150705, 114.6629223150705, 115.1629223150705,\n       115.6629223150705, 116.1629223150705, 116.6629223150705,\n       117.1629223150705, 117.6629223150705, 118.1629223150705],\n      dtype='float64', name='lon'))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([              -36.2,               -35.7,               -35.2,\n                     -34.7,               -34.2,               -33.7,\n                     -33.2,               -32.7,               -32.2,\n       -31.700000000000003, -31.200000000000003, -30.700000000000003,\n       -30.200000000000003, -29.700000000000003, -29.200000000000003,\n       -28.700000000000003, -28.200000000000003, -27.700000000000003,\n       -27.200000000000003, -26.700000000000003, -26.200000000000003,\n       -25.700000000000003, -25.200000000000003, -24.700000000000003,\n       -24.200000000000003, -23.700000000000003, -23.200000000000003,\n       -22.700000000000003, -22.200000000000003, -21.700000000000003],\n      dtype='float64', name='lat'))</pre></li></ul></li><li>Attributes: (1)title :Subset of the GEBCO 2020 grid for testing purposes</li></ul> In\u00a0[10]: Copied! <pre># Create and plot the data instance. This object will be provided to the SWAN Config through the DataInterface\n\nbottom = SwanDataGrid(\n    var=\"bottom\",\n    source=SourceDataset(obj=dset),\n    z1=\"elevation\",\n    fac=-1,\n    coords={\"x\": \"lon\", \"y\": \"lat\"},\n    crop_data=False, # So data isn't cropped to model grid inside SwanConfig\n)\n\nfig, ax = bottom.plot(param=\"elevation\", vmin=-5000, vmax=0, cmap=\"turbo_r\", figsize=(5, 6))\ngrid.plot(ax=ax);\n</pre> # Create and plot the data instance. This object will be provided to the SWAN Config through the DataInterface  bottom = SwanDataGrid(     var=\"bottom\",     source=SourceDataset(obj=dset),     z1=\"elevation\",     fac=-1,     coords={\"x\": \"lon\", \"y\": \"lat\"},     crop_data=False, # So data isn't cropped to model grid inside SwanConfig )  fig, ax = bottom.plot(param=\"elevation\", vmin=-5000, vmax=0, cmap=\"turbo_r\", figsize=(5, 6)) grid.plot(ax=ax); In\u00a0[11]: Copied! <pre># Display the ERA dataset\n\ndisplay(era5)\n\nfu = era5.u10.plot(col=\"time\", figsize=(15, 1.5), subplot_kws={\"projection\": projection}, cbar_kwargs={\"label\": \"u (m/s)\"})\nfv = era5.v10.plot(col=\"time\", figsize=(15, 1.5), subplot_kws={\"projection\": projection}, cbar_kwargs={\"label\": \"v (m/s)\"})\nfor f in [fu, fv]:\n    f.map(lambda: plt.gca().coastlines())\n</pre> # Display the ERA dataset  display(era5)  fu = era5.u10.plot(col=\"time\", figsize=(15, 1.5), subplot_kws={\"projection\": projection}, cbar_kwargs={\"label\": \"u (m/s)\"}) fv = era5.v10.plot(col=\"time\", figsize=(15, 1.5), subplot_kws={\"projection\": projection}, cbar_kwargs={\"label\": \"v (m/s)\"}) for f in [fu, fv]:     f.map(lambda: plt.gca().coastlines()) <pre>&lt;xarray.Dataset&gt; Size: 214kB\nDimensions:    (time: 5, latitude: 37, longitude: 72)\nCoordinates:\n  * latitude   (latitude) float32 148B 90.0 85.0 80.0 75.0 ... -80.0 -85.0 -90.0\n  * longitude  (longitude) float32 288B 0.0 5.0 10.0 15.0 ... 345.0 350.0 355.0\n  * time       (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\nData variables:\n    u10        (time, latitude, longitude) float64 107kB ...\n    v10        (time, latitude, longitude) float64 107kB ...\nAttributes:\n    Conventions:  CF-1.6\n    history:      2023-06-10 00:03:38 GMT by grib_to_netcdf-2.25.1: /opt/ecmw...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>latitude: 37</li><li>longitude: 72</li></ul></li><li>Coordinates: (3)<ul><li>latitude(latitude)float3290.0 85.0 80.0 ... -85.0 -90.0<pre>array([ 90.,  85.,  80.,  75.,  70.,  65.,  60.,  55.,  50.,  45.,  40.,  35.,\n        30.,  25.,  20.,  15.,  10.,   5.,   0.,  -5., -10., -15., -20., -25.,\n       -30., -35., -40., -45., -50., -55., -60., -65., -70., -75., -80., -85.,\n       -90.], dtype=float32)</pre></li><li>longitude(longitude)float320.0 5.0 10.0 ... 345.0 350.0 355.0<pre>array([  0.,   5.,  10.,  15.,  20.,  25.,  30.,  35.,  40.,  45.,  50.,  55.,\n        60.,  65.,  70.,  75.,  80.,  85.,  90.,  95., 100., 105., 110., 115.,\n       120., 125., 130., 135., 140., 145., 150., 155., 160., 165., 170., 175.,\n       180., 185., 190., 195., 200., 205., 210., 215., 220., 225., 230., 235.,\n       240., 245., 250., 255., 260., 265., 270., 275., 280., 285., 290., 295.,\n       300., 305., 310., 315., 320., 325., 330., 335., 340., 345., 350., 355.],\n      dtype=float32)</pre></li><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (2)<ul><li>u10(time, latitude, longitude)float64...long_name :10 metre U wind componentunits :m s**-1valid_max :300.0valid_min :-300.0<pre>[13320 values with dtype=float64]</pre></li><li>v10(time, latitude, longitude)float64...long_name :10 metre V wind componentunits :m s**-1valid_max :300.0valid_min :-300.0<pre>[13320 values with dtype=float64]</pre></li></ul></li><li>Indexes: (3)<ul><li>latitudePandasIndex<pre>PandasIndex(Index([ 90.0,  85.0,  80.0,  75.0,  70.0,  65.0,  60.0,  55.0,  50.0,  45.0,\n        40.0,  35.0,  30.0,  25.0,  20.0,  15.0,  10.0,   5.0,   0.0,  -5.0,\n       -10.0, -15.0, -20.0, -25.0, -30.0, -35.0, -40.0, -45.0, -50.0, -55.0,\n       -60.0, -65.0, -70.0, -75.0, -80.0, -85.0, -90.0],\n      dtype='float32', name='latitude'))</pre></li><li>longitudePandasIndex<pre>PandasIndex(Index([  0.0,   5.0,  10.0,  15.0,  20.0,  25.0,  30.0,  35.0,  40.0,  45.0,\n        50.0,  55.0,  60.0,  65.0,  70.0,  75.0,  80.0,  85.0,  90.0,  95.0,\n       100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0, 145.0,\n       150.0, 155.0, 160.0, 165.0, 170.0, 175.0, 180.0, 185.0, 190.0, 195.0,\n       200.0, 205.0, 210.0, 215.0, 220.0, 225.0, 230.0, 235.0, 240.0, 245.0,\n       250.0, 255.0, 260.0, 265.0, 270.0, 275.0, 280.0, 285.0, 290.0, 295.0,\n       300.0, 305.0, 310.0, 315.0, 320.0, 325.0, 330.0, 335.0, 340.0, 345.0,\n       350.0, 355.0],\n      dtype='float32', name='longitude'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (2)Conventions :CF-1.6history :2023-06-10 00:03:38 GMT by grib_to_netcdf-2.25.1: /opt/ecmwf/mars-client/bin/grib_to_netcdf.bin -S param -o /cache/data1/adaptor.mars.internal-1686355363.059632-31231-4-716aba91-9c1f-4cb0-85d0-16ceb0c26b80.nc /cache/tmp/716aba91-9c1f-4cb0-85d0-16ceb0c26b80-adaptor.mars.internal-1686355351.013629-31231-7-tmp.grib</li></ul> In\u00a0[12]: Copied! <pre># Process it into the model forcing\n\ndset = my_fancy_interpolation(era5, grid, DatasetCoords(x=\"longitude\", y=\"latitude\"), buffer=1.0)\ndset\n</pre> # Process it into the model forcing  dset = my_fancy_interpolation(era5, grid, DatasetCoords(x=\"longitude\", y=\"latitude\"), buffer=1.0) dset Out[12]: <pre>&lt;xarray.Dataset&gt; Size: 51kB\nDimensions:    (time: 5, latitude: 30, longitude: 21)\nCoordinates:\n  * time       (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * longitude  (longitude) float64 168B 108.2 108.7 109.2 ... 117.2 117.7 118.2\n  * latitude   (latitude) float64 240B -36.2 -35.7 -35.2 ... -22.7 -22.2 -21.7\nData variables:\n    u10        (time, latitude, longitude) float64 25kB 3.054 3.084 ... 1.339\n    v10        (time, latitude, longitude) float64 25kB 4.884 4.951 ... 0.9003\nAttributes:\n    Conventions:  CF-1.6\n    history:      2023-06-10 00:03:38 GMT by grib_to_netcdf-2.25.1: /opt/ecmw...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>latitude: 30</li><li>longitude: 21</li></ul></li><li>Coordinates: (3)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>longitude(longitude)float64108.2 108.7 109.2 ... 117.7 118.2<pre>array([108.162922, 108.662922, 109.162922, 109.662922, 110.162922, 110.662922,\n       111.162922, 111.662922, 112.162922, 112.662922, 113.162922, 113.662922,\n       114.162922, 114.662922, 115.162922, 115.662922, 116.162922, 116.662922,\n       117.162922, 117.662922, 118.162922])</pre></li><li>latitude(latitude)float64-36.2 -35.7 -35.2 ... -22.2 -21.7<pre>array([-36.2, -35.7, -35.2, -34.7, -34.2, -33.7, -33.2, -32.7, -32.2, -31.7,\n       -31.2, -30.7, -30.2, -29.7, -29.2, -28.7, -28.2, -27.7, -27.2, -26.7,\n       -26.2, -25.7, -25.2, -24.7, -24.2, -23.7, -23.2, -22.7, -22.2, -21.7])</pre></li></ul></li><li>Data variables: (2)<ul><li>u10(time, latitude, longitude)float643.054 3.084 3.115 ... 2.082 1.339long_name :10 metre U wind componentunits :m s**-1valid_max :300.0valid_min :-300.0<pre>array([[[ 3.05406734,  3.08442334,  3.11477934, ...,  3.42997523,\n          3.40515123,  3.38032723],\n        [ 2.02745922,  2.04287522,  2.05829122, ...,  2.44683484,\n          2.44877084,  2.45070684],\n        [ 1.0008511 ,  1.0013271 ,  1.0018031 , ...,  1.46369444,\n          1.49239044,  1.52108644],\n        ...,\n        [-3.39869218, -3.22623018, -3.05376818, ..., -0.4115609 ,\n         -0.8750729 , -1.3385849 ],\n        [-3.21607748, -3.05314548, -2.89021348, ..., -0.30344738,\n         -0.74917938, -1.19491138],\n        [-3.03346278, -2.88006078, -2.72665878, ..., -0.19533386,\n         -0.62328586, -1.05123786]],\n\n       [[ 3.56696104,  3.54759304,  3.52822504, ...,  3.86722608,\n          4.10837808,  4.34953008],\n        [ 2.74384988,  2.70505188,  2.66625388, ...,  2.78601324,\n          3.06493524,  3.34385724],\n        [ 1.92073872,  1.86251072,  1.80428272, ...,  1.70480039,\n          2.02149239,  2.33818439],\n...\n        [-2.19217152, -1.93024152, -1.66831152, ...,  2.80878855,\n          1.94261055,  1.07643255],\n        [-1.76190573, -1.47092573, -1.17994573, ...,  3.40180597,\n          2.53819797,  1.67458997],\n        [-1.33163994, -1.01160994, -0.69157994, ...,  3.99482339,\n          3.13378539,  2.27274739]],\n\n       [[-1.24672642, -1.42658642, -1.60644642, ..., -1.26073352,\n         -1.04990152, -0.83906952],\n        [-1.90700676, -2.09171676, -2.27642676, ..., -1.97772168,\n         -1.74131968, -1.50491768],\n        [-2.56728711, -2.75684711, -2.94640711, ..., -2.69470983,\n         -2.43273783, -2.17076583],\n        ...,\n        [-1.33056564, -1.00461164, -0.67865764, ...,  1.2409733 ,\n          0.3903633 , -0.4602467 ],\n        [-0.92305018, -0.56310618, -0.20316218, ...,  2.03251779,\n          1.23605779,  0.43959779],\n        [-0.51553472, -0.12160072,  0.27233328, ...,  2.82406227,\n          2.08175227,  1.33944227]]], shape=(5, 30, 21))</pre></li><li>v10(time, latitude, longitude)float644.884 4.951 5.019 ... 1.778 0.9003long_name :10 metre V wind componentunits :m s**-1valid_max :300.0valid_min :-300.0<pre>array([[[4.88356179, 4.95115779, 5.01875379, ..., 4.90943125,\n         4.79985525, 4.69027925],\n        [5.0786504 , 5.1807064 , 5.2827624 , ..., 5.49437785,\n         5.37279185, 5.25120585],\n        [5.27373901, 5.41025501, 5.54677101, ..., 6.07932446,\n         5.94572846, 5.81213246],\n        ...,\n        [9.39734418, 9.62032218, 9.84330018, ..., 4.53337248,\n         3.72631448, 2.91925648],\n        [9.38104521, 9.61145321, 9.84186121, ..., 4.55956504,\n         3.67827704, 2.79698904],\n        [9.36474624, 9.60258424, 9.84042224, ..., 4.58575759,\n         3.63023959, 2.67472159]],\n\n       [[5.48801128, 5.53226328, 5.57651528, ..., 5.11887975,\n         4.98858375, 4.85828775],\n        [5.69499962, 5.75327162, 5.81154362, ..., 5.46036237,\n         5.34885637, 5.23735037],\n        [5.90198796, 5.97427996, 6.04657196, ..., 5.80184499,\n         5.70912899, 5.61641299],\n...\n        [9.03196617, 9.38474217, 9.73751817, ..., 2.7115134 ,\n         2.0856734 , 1.4598334 ],\n        [8.9127322 , 9.2495682 , 9.5864042 , ..., 2.88410324,\n         2.23736324, 1.59062324],\n        [8.79349824, 9.11439424, 9.43529024, ..., 3.05669309,\n         2.38905309, 1.72141309]],\n\n       [[5.98526781, 6.02446381, 6.06365981, ..., 4.77517889,\n         4.66387089, 4.55256289],\n        [6.22551532, 6.25792132, 6.29032732, ..., 4.82699794,\n         4.68910994, 4.55122194],\n        [6.46576284, 6.49137884, 6.51699484, ..., 4.87881699,\n         4.71434899, 4.54988099],\n        ...,\n        [9.38537356, 9.65775356, 9.93013356, ..., 3.12724953,\n         2.47717753, 1.82710553],\n        [9.23130611, 9.48598611, 9.74066611, ..., 2.89148189,\n         2.12758989, 1.36369789],\n        [9.07723866, 9.31421866, 9.55119866, ..., 2.65571426,\n         1.77800226, 0.90029026]]], shape=(5, 30, 21))</pre></li></ul></li><li>Indexes: (3)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>longitudePandasIndex<pre>PandasIndex(Index([108.1629223150705, 108.6629223150705, 109.1629223150705,\n       109.6629223150705, 110.1629223150705, 110.6629223150705,\n       111.1629223150705, 111.6629223150705, 112.1629223150705,\n       112.6629223150705, 113.1629223150705, 113.6629223150705,\n       114.1629223150705, 114.6629223150705, 115.1629223150705,\n       115.6629223150705, 116.1629223150705, 116.6629223150705,\n       117.1629223150705, 117.6629223150705, 118.1629223150705],\n      dtype='float64', name='longitude'))</pre></li><li>latitudePandasIndex<pre>PandasIndex(Index([              -36.2,               -35.7,               -35.2,\n                     -34.7,               -34.2,               -33.7,\n                     -33.2,               -32.7,               -32.2,\n       -31.700000000000003, -31.200000000000003, -30.700000000000003,\n       -30.200000000000003, -29.700000000000003, -29.200000000000003,\n       -28.700000000000003, -28.200000000000003, -27.700000000000003,\n       -27.200000000000003, -26.700000000000003, -26.200000000000003,\n       -25.700000000000003, -25.200000000000003, -24.700000000000003,\n       -24.200000000000003, -23.700000000000003, -23.200000000000003,\n       -22.700000000000003, -22.200000000000003, -21.700000000000003],\n      dtype='float64', name='latitude'))</pre></li></ul></li><li>Attributes: (2)Conventions :CF-1.6history :2023-06-10 00:03:38 GMT by grib_to_netcdf-2.25.1: /opt/ecmwf/mars-client/bin/grib_to_netcdf.bin -S param -o /cache/data1/adaptor.mars.internal-1686355363.059632-31231-4-716aba91-9c1f-4cb0-85d0-16ceb0c26b80.nc /cache/tmp/716aba91-9c1f-4cb0-85d0-16ceb0c26b80-adaptor.mars.internal-1686355351.013629-31231-7-tmp.grib</li></ul> In\u00a0[13]: Copied! <pre># ERA5 has Latitude in reverse order, use filter to reverse it\n\nfrom rompy.core.filters import Filter\n</pre> # ERA5 has Latitude in reverse order, use filter to reverse it  from rompy.core.filters import Filter In\u00a0[14]: Copied! <pre># Create and plot the data instance. This object will be provided to the SWAN Config through the DataInterface\n\nwind = SwanDataGrid(\n    var=\"wind\",\n    source=SourceDataset(obj=dset),\n    z1=\"u10\",\n    z2=\"v10\",\n    coords={\"x\": \"longitude\", \"y\": \"latitude\"},\n    crop_data=False, # So data isn't cropped to model grid inside SwanConfig\n    filter=Filter(sort=dict(coords=[\"latitude\"]))\n)\n\nfig, ax = wind.plot(param=\"u10\", isel={\"time\": 0}, vmin=-5, vmax=5, cmap=\"RdBu_r\", figsize=(5, 6))\ngrid.plot(ax=ax);\n</pre> # Create and plot the data instance. This object will be provided to the SWAN Config through the DataInterface  wind = SwanDataGrid(     var=\"wind\",     source=SourceDataset(obj=dset),     z1=\"u10\",     z2=\"v10\",     coords={\"x\": \"longitude\", \"y\": \"latitude\"},     crop_data=False, # So data isn't cropped to model grid inside SwanConfig     filter=Filter(sort=dict(coords=[\"latitude\"])) )  fig, ax = wind.plot(param=\"u10\", isel={\"time\": 0}, vmin=-5, vmax=5, cmap=\"RdBu_r\", figsize=(5, 6)) grid.plot(ax=ax); In\u00a0[15]: Copied! <pre># Open and check the test spectra dataset\n\ndisplay(oceanum)\n\nfig, ax = plt.subplots(figsize=(10, 5), subplot_kw={\"projection\": projection})\nc = oceanum.isel(time=[0]).spec.hs()\np = ax.scatter(oceanum.lon, oceanum.lat, s=6, c=c, cmap=\"turbo\", vmin=0, vmax=4)\nax.set_title(c.time.to_index().to_pydatetime()[0])\nplt.colorbar(p, label=f\"Hs (m)\")\nax.coastlines()\ngrid.plot(ax=ax);\n</pre> # Open and check the test spectra dataset  display(oceanum)  fig, ax = plt.subplots(figsize=(10, 5), subplot_kw={\"projection\": projection}) c = oceanum.isel(time=[0]).spec.hs() p = ax.scatter(oceanum.lon, oceanum.lat, s=6, c=c, cmap=\"turbo\", vmin=0, vmax=4) ax.set_title(c.time.to_index().to_pydatetime()[0]) plt.colorbar(p, label=f\"Hs (m)\") ax.coastlines() grid.plot(ax=ax); <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (site: 412, time: 5, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 3kB 0 4 8 12 16 20 ... 1624 1628 1632 1636 1640 1644\n  * freq     (freq) float32 44B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float32 32B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    lon      (site) float32 2kB ...\n    lat      (site) float32 2kB ...\n    efth     (time, site, freq, dir) float64 1MB ...\n    dpt      (time, site) float32 8kB ...\n    wspd     (time, site) float32 8kB ...\n    wdir     (time, site) float32 8kB ...\nAttributes: (12/16)\n    product_name:           ww3.all_spec.nc\n    area:                   Global 0.5 x 0.5 degree\n    data_type:              OCO spectra 2D\n    format_version:         1.1\n    southernmost_latitude:  n/a\n    northernmost_latitude:  n/a\n    ...                     ...\n    minimum_altitude:       n/a\n    maximum_altitude:       n/a\n    altitude_resolution:    n/a\n    start_date:             2023-01-01 00:00:00\n    stop_date:              2023-02-01 00:00:00\n    field_type:             3-hourly</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 412</li><li>time: 5</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int640 4 8 12 16 ... 1632 1636 1640 1644<pre>array([   0,    4,    8, ..., 1636, 1640, 1644], shape=(412,))</pre></li><li>freq(freq)float320.05417 0.05959 ... 0.1277 0.1405standard_name :sea_surface_wave_frequencyunits :Hz<pre>array([0.054172, 0.059589, 0.065548, 0.072103, 0.079313, 0.087244, 0.095968,\n       0.105565, 0.116122, 0.127734, 0.140507], dtype=float32)</pre></li><li>dir(dir)float320.0 45.0 90.0 ... 225.0 270.0 315.0standard_name :sea_surface_wave_from_directionunits :degree<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.], dtype=float32)</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32...standard_name :longitudeunits :degrees_east<pre>[412 values with dtype=float32]</pre></li><li>lat(site)float32...standard_name :latitudeunits :degrees_north<pre>[412 values with dtype=float32]</pre></li><li>efth(time, site, freq, dir)float64...standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1<pre>[181280 values with dtype=float64]</pre></li><li>dpt(time, site)float32...standard_name :sea_floor_depth_below_sea_surfaceunits :m<pre>[2060 values with dtype=float32]</pre></li><li>wspd(time, site)float32...standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1<pre>[2060 values with dtype=float32]</pre></li><li>wdir(time, site)float32...standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree<pre>[2060 values with dtype=float32]</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([   0,    4,    8,   12,   16,   20,   24,   28,   32,   36,\n       ...\n       1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644],\n      dtype='int64', name='site', length=412))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417170003056526, 0.05958886817097664, 0.06554775685071945,\n       0.07210253179073334, 0.07931278645992279, 0.08724407106637955,\n       0.09596847742795944, 0.10556533187627792, 0.11612186580896378,\n       0.12773405015468597, 0.14050745964050293],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float32', name='dir'))</pre></li></ul></li><li>Attributes: (16)product_name :ww3.all_spec.ncarea :Global 0.5 x 0.5 degreedata_type :OCO spectra 2Dformat_version :1.1southernmost_latitude :n/anorthernmost_latitude :n/alatitude_resolution :n/awesternmost_longitude :n/aeasternmost_longitude :n/alongitude_resolution :n/aminimum_altitude :n/amaximum_altitude :n/aaltitude_resolution :n/astart_date :2023-01-01 00:00:00stop_date :2023-02-01 00:00:00field_type :3-hourly</li></ul> In\u00a0[16]: Copied! <pre># Create the boundary instance. This object will be provided to the SWAN Config through the BoundaryInterface\n\nboundary_from_data = Boundnest1(\n    id=\"westaus\",\n    source=SourceDataset(obj=oceanum),\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 4}, # points are sparse around the offshore boundary so make sure tolerance is appropriate\n)\n</pre> # Create the boundary instance. This object will be provided to the SWAN Config through the BoundaryInterface  boundary_from_data = Boundnest1(     id=\"westaus\",     source=SourceDataset(obj=oceanum),     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 4}, # points are sparse around the offshore boundary so make sure tolerance is appropriate ) In\u00a0[17]: Copied! <pre># Generate the boundary data and plot them to check.\n# This isn't necessary but it is useful for checking the generated boundary look okay\n\n# Generate the boundary data\noutfile, cmd = boundary_from_data.get(destdir=workdir, grid=grid, time=times)\n\n# Read the boundary data into an xarray dataset\nfrom wavespectra import read_swan\n\nds = read_swan(outfile)\ndisplay(ds)\n\n# Plot the boundary data alongside the source dataset and the model grid\nfig, ax = plt.subplots(figsize=(10, 5), subplot_kw={\"projection\": projection})\n\n# Source dataset\nc = oceanum.isel(time=[0]).spec.hs()\np = ax.scatter(oceanum.lon, oceanum.lat, s=20, c=c, marker=\"v\", cmap=\"turbo\", vmin=0, vmax=4)\n\n# Generated boundary dataset\nc = ds.isel(time=[0]).spec.hs()\np = ax.scatter(ds.lon, ds.lat, s=50, c=c, cmap=\"turbo\", edgecolors=\"0.5\", vmin=0, vmax=4)\n\n# Model grid\ngrid.plot(ax=ax)\n\n# Axis settings\nax.set_title(c.time.to_index().to_pydatetime()[0])\nplt.colorbar(p, label=f\"Hs (m)\")\nax.coastlines()\nax.set_extent([ds.lon.min()-3, ds.lon.max()+3, ds.lat.min()-3, ds.lat.max()+3])\n</pre> # Generate the boundary data and plot them to check. # This isn't necessary but it is useful for checking the generated boundary look okay  # Generate the boundary data outfile, cmd = boundary_from_data.get(destdir=workdir, grid=grid, time=times)  # Read the boundary data into an xarray dataset from wavespectra import read_swan  ds = read_swan(outfile) display(ds)  # Plot the boundary data alongside the source dataset and the model grid fig, ax = plt.subplots(figsize=(10, 5), subplot_kw={\"projection\": projection})  # Source dataset c = oceanum.isel(time=[0]).spec.hs() p = ax.scatter(oceanum.lon, oceanum.lat, s=20, c=c, marker=\"v\", cmap=\"turbo\", vmin=0, vmax=4)  # Generated boundary dataset c = ds.isel(time=[0]).spec.hs() p = ax.scatter(ds.lon, ds.lat, s=50, c=c, cmap=\"turbo\", edgecolors=\"0.5\", vmin=0, vmax=4)  # Model grid grid.plot(ax=ax)  # Axis settings ax.set_title(c.time.to_index().to_pydatetime()[0]) plt.colorbar(p, label=f\"Hs (m)\") ax.coastlines() ax.set_extent([ds.lon.min()-3, ds.lon.max()+3, ds.lat.min()-3, ds.lat.max()+3]) <pre>&lt;xarray.Dataset&gt; Size: 273kB\nDimensions:  (time: 5, site: 77, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 616B 1 2 3 4 5 6 7 8 9 ... 69 70 71 72 73 74 75 76 77\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 271kB 0.0 0.0 ... 5.238e-05\n    lat      (site) float64 616B -35.2 -35.17 -35.13 -35.1 ... -34.2 -34.7 -35.2\n    lon      (site) float64 616B 110.0 110.5 111.0 111.5 ... 109.9 110.0 110.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 77</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int641 2 3 4 5 6 7 ... 72 73 74 75 76 77<pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n       37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,\n       55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,\n       73, 74, 75, 76, 77])</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 ... 0.006496 5.238e-05standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.13879808e-02, 1.97839296e-03, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.95571909e-01, 3.16542874e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          6.72891015e-01, 3.16542874e-04, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 7.91357186e-05, ...,\n          4.59778525e-02, 8.46752189e-03, 6.33085749e-04],\n         [0.00000000e+00, 0.00000000e+00, 7.91357186e-05, ...,\n          2.84097230e-02, 8.30925045e-03, 7.91357186e-05],\n         [0.00000000e+00, 0.00000000e+00, 7.91357186e-05, ...,\n          1.71724509e-02, 7.28048611e-03, 7.91357186e-05]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.23931316e-02, 2.06022696e-03, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.98336711e-01, 3.16957993e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          6.75516723e-01, 3.16957993e-04, 0.00000000e+00],\n...\n          4.26566896e-02, 4.87801560e-03, 6.74619179e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.64658293e-03, ...,\n          2.65696169e-02, 6.01967883e-03, 1.03787566e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.43900780e-03, ...,\n          1.54643473e-02, 5.86399748e-03, 5.18937830e-05]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.78108924e-03, 1.30962444e-03, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.12738316e-02, 3.66694843e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.91729018e-01, 1.04769955e-04, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 8.38159642e-04, ...,\n          4.44224610e-02, 5.55280763e-03, 6.81004709e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.56686390e-03, ...,\n          2.77116532e-02, 6.75766211e-03, 1.04769955e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.35732399e-03, ...,\n          1.61345731e-02, 6.49573722e-03, 5.23849776e-05]]]],\n      shape=(5, 77, 11, 8))</pre></li><li>lat(site)float64-35.2 -35.17 -35.13 ... -34.7 -35.2standard_name :latitudeunits :degrees_north<pre>array([-35.2     , -35.165122, -35.130244, -35.095365, -35.060487,\n       -35.025609, -34.990731, -34.955852, -34.920974, -34.886096,\n       -34.851218, -34.816339, -34.781461, -34.746583, -34.711705,\n       -34.212923, -33.714141, -33.215359, -32.716577, -32.217795,\n       -31.719013, -31.220231, -30.721448, -30.222666, -29.723884,\n       -29.225102, -28.72632 , -28.227538, -27.728756, -27.229974,\n       -26.731192, -26.23241 , -25.733628, -25.234846, -24.736064,\n       -24.237282, -23.7385  , -23.239718, -22.740936, -22.775814,\n       -22.810693, -22.845571, -22.880449, -22.915327, -22.950206,\n       -22.985084, -23.019962, -23.05484 , -23.089718, -23.124597,\n       -23.159475, -23.194353, -23.229231, -23.728013, -24.226795,\n       -24.725577, -25.224359, -25.723142, -26.221924, -26.720706,\n       -27.219488, -27.71827 , -28.217052, -28.715834, -29.214616,\n       -29.713398, -30.21218 , -30.710962, -31.209744, -31.708526,\n       -32.207308, -32.70609 , -33.204872, -33.703654, -34.202436,\n       -34.701218, -35.2     ])</pre></li><li>lon(site)float64110.0 110.5 111.0 ... 110.0 110.0standard_name :longitudeunits :degrees_east<pre>array([110.      , 110.498782, 110.997564, 111.496346, 111.995128,\n       112.49391 , 112.992692, 113.491474, 113.990256, 114.489038,\n       114.98782 , 115.486602, 115.985384, 116.484166, 116.982948,\n       116.94807 , 116.913192, 116.878314, 116.843435, 116.808557,\n       116.773679, 116.738801, 116.703922, 116.669044, 116.634166,\n       116.599288, 116.56441 , 116.529531, 116.494653, 116.459775,\n       116.424897, 116.390018, 116.35514 , 116.320262, 116.285384,\n       116.250505, 116.215627, 116.180749, 116.145871, 115.647089,\n       115.148307, 114.649525, 114.150743, 113.651961, 113.153179,\n       112.654396, 112.155614, 111.656832, 111.15805 , 110.659268,\n       110.160486, 109.661704, 109.162922, 109.197801, 109.232679,\n       109.267557, 109.302435, 109.337313, 109.372192, 109.40707 ,\n       109.441948, 109.476826, 109.511705, 109.546583, 109.581461,\n       109.616339, 109.651218, 109.686096, 109.720974, 109.755852,\n       109.790731, 109.825609, 109.860487, 109.895365, 109.930244,\n       109.965122, 110.      ])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n       37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,\n       55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,\n       73, 74, 75, 76, 77],\n      dtype='int64', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[18]: Copied! <pre>from rompy_swan.config import SwanConfig\n\nSwanConfig?\n</pre> from rompy_swan.config import SwanConfig  SwanConfig? <pre>Init signature:\nSwanConfig(\n    *,\n    model_type: Literal['swan', 'SWAN'] = 'swan',\n    template: str = '/source/csiro/rompy-swan/src/rompy_swan/templates/swan',\n    checkout: Optional[str] = 'main',\n    cgrid: Union[rompy_swan.components.cgrid.REGULAR, rompy_swan.components.cgrid.CURVILINEAR, rompy_swan.components.cgrid.UNSTRUCTURED],\n    startup: Optional[Annotated[rompy_swan.components.group.STARTUP, FieldInfo(annotation=NoneType, required=True, description='Startup components')]] = None,\n    inpgrid: Optional[Annotated[Union[rompy_swan.components.group.INPGRIDS, rompy_swan.interface.DataInterface], FieldInfo(annotation=NoneType, required=True, description='Input grid components', discriminator='model_type')]] = None,\n    boundary: Optional[Annotated[Union[rompy_swan.components.boundary.BOUNDSPEC, rompy_swan.components.boundary.BOUNDNEST1, rompy_swan.components.boundary.BOUNDNEST2, rompy_swan.components.boundary.BOUNDNEST3, rompy_swan.interface.BoundaryInterface], FieldInfo(annotation=NoneType, required=True, description='Boundary component', discriminator='model_type')]] = None,\n    initial: Optional[Annotated[rompy_swan.components.boundary.INITIAL, FieldInfo(annotation=NoneType, required=True, description='Initial component')]] = None,\n    physics: Optional[Annotated[rompy_swan.components.group.PHYSICS, FieldInfo(annotation=NoneType, required=True, description='Physics components')]] = None,\n    prop: Optional[Annotated[rompy_swan.components.numerics.PROP, FieldInfo(annotation=NoneType, required=True, description='Propagation components')]] = None,\n    numeric: Optional[Annotated[rompy_swan.components.numerics.NUMERIC, FieldInfo(annotation=NoneType, required=True, description='Numerics components')]] = None,\n    output: Optional[Annotated[rompy_swan.components.group.OUTPUT, FieldInfo(annotation=NoneType, required=True, description='Output components')]] = None,\n    lockup: Optional[Annotated[rompy_swan.components.group.LOCKUP, FieldInfo(annotation=NoneType, required=True, description='Output components')]] = None,\n    **data: Any,\n) -&gt; None\nDocstring:     \nSWAN config class.\n\nTODO: Combine boundary and inpgrid into a single input type.\n\nNote\n----\nThe `cgrid` is the only required field since it is used to define the swan grid\nobject which is passed to other components.\nInit docstring:\nCreate a new model by parsing and validating input data from keyword arguments.\n\nRaises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.\nFile:           /source/csiro/rompy-swan/src/rompy_swan/config.py\nType:           ModelMetaclass\nSubclasses:     SwanConfigComponents</pre> In\u00a0[19]: Copied! <pre>from rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.subcomponents.readgrid import GRIDREGULAR\nfrom rompy_swan.subcomponents.spectrum import SPECTRUM\n\ncgrid = REGULAR(\n    grid=GRIDREGULAR(\n        xp=grid.x0,\n        yp=grid.y0,\n        alp=grid.rot,\n        xlen=grid.xlen,\n        ylen=grid.ylen,\n        mx=grid.nx -1,\n        my=grid.ny -1,\n    ),\n    spectrum=SPECTRUM(\n        mdc=36,\n        flow=0.04,\n        fhigh=1.0,\n    ),\n)\n\nprint(cgrid.render())\n</pre> from rompy_swan.components.cgrid import REGULAR from rompy_swan.subcomponents.readgrid import GRIDREGULAR from rompy_swan.subcomponents.spectrum import SPECTRUM  cgrid = REGULAR(     grid=GRIDREGULAR(         xp=grid.x0,         yp=grid.y0,         alp=grid.rot,         xlen=grid.xlen,         ylen=grid.ylen,         mx=grid.nx -1,         my=grid.ny -1,     ),     spectrum=SPECTRUM(         mdc=36,         flow=0.04,         fhigh=1.0,     ), )  print(cgrid.render()) <pre>CGRID REGULAR xpc=110.0 ypc=-35.2 alpc=4.0 xlenc=7.0 ylenc=12.0 mxc=14 myc=24 CIRCLE mdc=36 flow=0.04 fhigh=1.0\n</pre> In\u00a0[20]: Copied! <pre>from rompy_swan.components.group import STARTUP\nfrom rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.subcomponents.startup import SPHERICAL\n\nproject = PROJECT(\n    name=\"Test procedural\",\n    nr=\"run1\",\n    title1=\"Procedural definition of a Swan config with rompy\",\n)\n\nset = SET(level=0.0, depmin=0.05, direction_convention=\"nautical\")\n\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n\ncoordinates = COORDINATES(kind=SPHERICAL())\n\nstartup = STARTUP(\n    project=project,\n    set=set,\n    mode=mode,\n    coordinates=coordinates,\n)\n\nprint(startup.render())\n</pre> from rompy_swan.components.group import STARTUP from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES from rompy_swan.subcomponents.startup import SPHERICAL  project = PROJECT(     name=\"Test procedural\",     nr=\"run1\",     title1=\"Procedural definition of a Swan config with rompy\", )  set = SET(level=0.0, depmin=0.05, direction_convention=\"nautical\")  mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")  coordinates = COORDINATES(kind=SPHERICAL())  startup = STARTUP(     project=project,     set=set,     mode=mode,     coordinates=coordinates, )  print(startup.render()) <pre>PROJECT name='Test procedural' nr='run1' title1='Procedural definition of a Swan config with rompy'\n\nSET level=0.0 depmin=0.05 NAUTICAL\n\nMODE NONSTATIONARY TWODIMENSIONAL\n\nCOORDINATES SPHERICAL CCM\n</pre> In\u00a0[21]: Copied! <pre>from rompy_swan.interface import DataInterface\n\ninpgrid = DataInterface(\n    bottom=bottom,\n    input=[wind],\n)\n\ninpgrid\n</pre> from rompy_swan.interface import DataInterface  inpgrid = DataInterface(     bottom=bottom,     input=[wind], )  inpgrid Out[21]: <pre>DataInterface(model_type='data_interface', bottom=SwanDataGrid(model_type='grid', id='data', source=SourceDataset(model_type='dataset', obj=&lt;xarray.Dataset&gt; Size: 5kB\nDimensions:    (lat: 30, lon: 21)\nCoordinates:\n  * lon        (lon) float64 168B 108.2 108.7 109.2 109.7 ... 117.2 117.7 118.2\n  * lat        (lat) float64 240B -36.2 -35.7 -35.2 -34.7 ... -22.7 -22.2 -21.7\nData variables:\n    elevation  (lat, lon) float64 5kB -5.443e+03 -5.552e+03 ... 333.9 346.7\nAttributes:\n    title:    Subset of the GEBCO 2020 grid for testing purposes), filter=Filter(sort={}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['elevation'], coords=DatasetCoords(t='time', x='lon', y='lat', z=None, s=None), crop_data=False, buffer=0.0, time_buffer=[0, 0], z1='elevation', z2=None, var=&lt;GridOptions.BOTTOM: 'bottom'&gt;, fac=-1.0), input=[SwanDataGrid(model_type='grid', id='data', source=SourceDataset(model_type='dataset', obj=&lt;xarray.Dataset&gt; Size: 51kB\nDimensions:    (time: 5, latitude: 30, longitude: 21)\nCoordinates:\n  * time       (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * longitude  (longitude) float64 168B 108.2 108.7 109.2 ... 117.2 117.7 118.2\n  * latitude   (latitude) float64 240B -36.2 -35.7 -35.2 ... -22.7 -22.2 -21.7\nData variables:\n    u10        (time, latitude, longitude) float64 25kB 3.054 3.084 ... 1.339\n    v10        (time, latitude, longitude) float64 25kB 4.884 4.951 ... 0.9003\nAttributes:\n    Conventions:  CF-1.6\n    history:      2023-06-10 00:03:38 GMT by grib_to_netcdf-2.25.1: /opt/ecmw...), filter=Filter(sort={'coords': ['latitude']}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['u10', 'v10'], coords=DatasetCoords(t='time', x='longitude', y='latitude', z=None, s=None), crop_data=False, buffer=0.0, time_buffer=[0, 0], z1='u10', z2='v10', var=&lt;GridOptions.WIND: 'wind'&gt;, fac=1.0)])</pre> In\u00a0[22]: Copied! <pre>from rompy_swan.components.boundary import  BOUNDSPEC\nfrom rompy_swan.subcomponents.boundary import SIDE, CONSTANTPAR\nfrom rompy_swan.subcomponents.spectrum import SHAPESPEC, JONSWAP\n\nshape = JONSWAP(gamma=3.3)\n\nshapespec = SHAPESPEC(shape=shape, per_type=\"peak\", dspr_type=\"degrees\")\n\nlocation = SIDE(side=\"west\", direction=\"ccw\")\n\ndata = CONSTANTPAR(hs=2.0, per=12.0, dir=255.0, dd=25.0)\n\nboundary_parametric = BOUNDSPEC(shapespec=shapespec, location=location, data=data)\n\nprint(boundary_parametric.render())\n</pre> from rompy_swan.components.boundary import  BOUNDSPEC from rompy_swan.subcomponents.boundary import SIDE, CONSTANTPAR from rompy_swan.subcomponents.spectrum import SHAPESPEC, JONSWAP  shape = JONSWAP(gamma=3.3)  shapespec = SHAPESPEC(shape=shape, per_type=\"peak\", dspr_type=\"degrees\")  location = SIDE(side=\"west\", direction=\"ccw\")  data = CONSTANTPAR(hs=2.0, per=12.0, dir=255.0, dd=25.0)  boundary_parametric = BOUNDSPEC(shapespec=shapespec, location=location, data=data)  print(boundary_parametric.render()) <pre>BOUND SHAPESPEC JONSWAP gamma=3.3 PEAK DSPR DEGREES\nBOUNDSPEC SIDE WEST CCW CONSTANT PAR hs=2.0 per=12.0 dir=255.0 dd=25.0\n</pre> <p>And here we define boundary from the data using the <code>BoundaryInterface</code> object which interfaces that with the time and grid objects within <code>SwanConfig</code>:</p> In\u00a0[23]: Copied! <pre>from rompy_swan.interface import BoundaryInterface\n\nboundary_interface = BoundaryInterface(\n    kind=boundary_from_data\n)\n\nboundary_interface\n</pre> from rompy_swan.interface import BoundaryInterface  boundary_interface = BoundaryInterface(     kind=boundary_from_data )  boundary_interface Out[23]: <pre>BoundaryInterface(model_type='boundary_interface', kind=Boundnest1(model_type='boundnest1', id='westaus', source=SourceDataset(model_type='dataset', obj=&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (site: 412, time: 5, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 3kB 0 4 8 12 16 20 ... 1624 1628 1632 1636 1640 1644\n  * freq     (freq) float32 44B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float32 32B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    lon      (site) float32 2kB 108.0 108.0 108.0 108.0 ... 157.0 157.0 157.0\n    lat      (site) float32 2kB -42.0 -34.0 -26.0 -18.0 ... -19.0 -12.0 -9.0\n    efth     (time, site, freq, dir) float64 1MB ...\n    dpt      (time, site) float32 8kB ...\n    wspd     (time, site) float32 8kB ...\n    wdir     (time, site) float32 8kB ...\nAttributes: (12/16)\n    product_name:           ww3.all_spec.nc\n    area:                   Global 0.5 x 0.5 degree\n    data_type:              OCO spectra 2D\n    format_version:         1.1\n    southernmost_latitude:  n/a\n    northernmost_latitude:  n/a\n    ...                     ...\n    minimum_altitude:       n/a\n    maximum_altitude:       n/a\n    altitude_resolution:    n/a\n    start_date:             2023-01-01 00:00:00\n    stop_date:              2023-02-01 00:00:00\n    field_type:             3-hourly), filter=Filter(sort={}, subset={}, crop={'time': Slice(start=Timestamp('2023-01-01 00:00:00'), stop=Timestamp('2023-01-02 00:00:00')), 'longitude': Slice(start=107.1629223150705, stop=118.98294835181876), 'latitude': Slice(start=-37.2, stop=-20.740936080673237)}, timenorm={}, rename={}, derived={}), variables=['efth', 'lon', 'lat'], coords=DatasetCoords(t='time', x='longitude', y='latitude', z=None, s=None), crop_data=True, buffer=2.0, time_buffer=[0, 0], spacing=None, sel_method='idw', sel_method_kwargs={'tolerance': 4}, grid_type='boundary_wave_station', rectangle='closed'))</pre> In\u00a0[24]: Copied! <pre>from rompy_swan.components.boundary import INITIAL\nfrom rompy_swan.subcomponents.boundary import DEFAULT\n\ninitial = INITIAL(kind=DEFAULT())\n\nprint(initial.render())\n</pre> from rompy_swan.components.boundary import INITIAL from rompy_swan.subcomponents.boundary import DEFAULT  initial = INITIAL(kind=DEFAULT())  print(initial.render()) <pre>INITIAL DEFAULT\n</pre> In\u00a0[25]: Copied! <pre>from rompy_swan.components.group import PHYSICS\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_RIPPLES, QUADRUPL, TRIAD\nfrom rompy_swan.subcomponents.physics import WESTHUYSEN\n\ngen = GEN3(source_terms=WESTHUYSEN(wind_drag=\"wu\", cds2=5.0e-5, br=1.75e-3))\n\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\n\nfriction = FRICTION_RIPPLES(s=2.65, d=0.0001)\n\ntriad = TRIAD(itriad=1)\n\nquad = QUADRUPL(iquad=2, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833, csh3=-1.25)\n\nphysics = PHYSICS(\n    gen=gen,\n    breaking=breaking,\n    friction=friction,\n    triad=triad,\n    quadrupl=quad,\n)\n\nprint(physics.render())\n</pre> from rompy_swan.components.group import PHYSICS from rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_RIPPLES, QUADRUPL, TRIAD from rompy_swan.subcomponents.physics import WESTHUYSEN  gen = GEN3(source_terms=WESTHUYSEN(wind_drag=\"wu\", cds2=5.0e-5, br=1.75e-3))  breaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)  friction = FRICTION_RIPPLES(s=2.65, d=0.0001)  triad = TRIAD(itriad=1)  quad = QUADRUPL(iquad=2, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833, csh3=-1.25)  physics = PHYSICS(     gen=gen,     breaking=breaking,     friction=friction,     triad=triad,     quadrupl=quad, )  print(physics.render()) <pre>GEN3 WESTHUYSEN cds2=5e-05 br=0.00175 DRAG WU\n\nQUADRUPL iquad=2 lambda=0.25 cnl4=30000000.0 csh1=5.5 csh2=0.833 csh3=-1.25\n\nBREAKING CONSTANT alpha=1.0 gamma=0.73\n\nFRICTION RIPPLES S=2.65 D=0.0001\n\nTRIAD itriad=1\n</pre> In\u00a0[26]: Copied! <pre>from rompy_swan.components.numerics import PROP\nfrom rompy_swan.subcomponents.numerics import BSBT\n\nprop = PROP(scheme=BSBT())\n\nprint(prop.render())\n</pre> from rompy_swan.components.numerics import PROP from rompy_swan.subcomponents.numerics import BSBT  prop = PROP(scheme=BSBT())  print(prop.render()) <pre>PROP BSBT\n</pre> In\u00a0[27]: Copied! <pre>from rompy_swan.components.numerics import NUMERIC\nfrom rompy_swan.subcomponents.numerics import STAT, STOPC, DIRIMPL\n\nstopc = STOPC(dabs=0.02, drel=0.02, curvat=0.02, npnts=98, mode=STAT(mxitst=50))\n\ndirimpl = DIRIMPL(cdd=0.5)\n\nnumeric = NUMERIC(stop=stopc, dirimpl=dirimpl)\n\nprint(numeric.render())\n</pre> from rompy_swan.components.numerics import NUMERIC from rompy_swan.subcomponents.numerics import STAT, STOPC, DIRIMPL  stopc = STOPC(dabs=0.02, drel=0.02, curvat=0.02, npnts=98, mode=STAT(mxitst=50))  dirimpl = DIRIMPL(cdd=0.5)  numeric = NUMERIC(stop=stopc, dirimpl=dirimpl)  print(numeric.render()) <pre>NUMERIC STOPC dabs=0.02 drel=0.02 curvat=0.02 npnts=98.0 STATIONARY mxitst=50 DIRIMPL cdd=0.5\n</pre> In\u00a0[28]: Copied! <pre>from rompy_swan.components.group import OUTPUT\nfrom rompy_swan.components.output import POINTS, QUANTITY, QUANTITIES, BLOCK, TABLE, SPECOUT\nfrom rompy_swan.subcomponents.output import SPEC2D, ABS\nfrom rompy_swan.subcomponents.time import TimeRangeOpen\n\npoints = POINTS(\n    sname=\"pts\",\n    xp=[114.0, 112.5, 115.0],\n    yp=[-34.0, -26.0, -30.0],\n)\n\nq1 = QUANTITY(output=[\"hsign\"], hexp=50.0)\nq2 = QUANTITY(output=[\"hsign\", \"tps\"], fmin=0.04, fmax=0.3)\nq3 = QUANTITY(output=[\"hswell\"], fswell=0.125)\nquantity = QUANTITIES(quantities=[q1, q2, q3])\n\nblock = BLOCK(\n    sname=\"COMPGRID\",\n    fname=\"outgrid.nc\",\n    output=[\"depth\", \"wind\", \"hsign\", \"hswell\", \"dir\", \"tps\"],\n    times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten\n    idla=3,\n)\n\ntable = TABLE(\n    sname=\"pts\",\n    fname=\"outpts.txt\",\n    output=[\"time\", \"hsign\", \"dir\", \"tps\", \"tm01\"],\n    times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten\n)\n\nspecout = SPECOUT(\n    sname=\"pts\",\n    fname=\"swanspec.nc\",\n    dim=SPEC2D(),\n    freq=ABS(),\n    times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten\n)\n\noutput = OUTPUT(\n    points=points,\n    quantity=quantity,\n    block=block,\n    table=table,\n    specout=specout,\n)\n\nprint(output.render())\n</pre> from rompy_swan.components.group import OUTPUT from rompy_swan.components.output import POINTS, QUANTITY, QUANTITIES, BLOCK, TABLE, SPECOUT from rompy_swan.subcomponents.output import SPEC2D, ABS from rompy_swan.subcomponents.time import TimeRangeOpen  points = POINTS(     sname=\"pts\",     xp=[114.0, 112.5, 115.0],     yp=[-34.0, -26.0, -30.0], )  q1 = QUANTITY(output=[\"hsign\"], hexp=50.0) q2 = QUANTITY(output=[\"hsign\", \"tps\"], fmin=0.04, fmax=0.3) q3 = QUANTITY(output=[\"hswell\"], fswell=0.125) quantity = QUANTITIES(quantities=[q1, q2, q3])  block = BLOCK(     sname=\"COMPGRID\",     fname=\"outgrid.nc\",     output=[\"depth\", \"wind\", \"hsign\", \"hswell\", \"dir\", \"tps\"],     times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten     idla=3, )  table = TABLE(     sname=\"pts\",     fname=\"outpts.txt\",     output=[\"time\", \"hsign\", \"dir\", \"tps\", \"tm01\"],     times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten )  specout = SPECOUT(     sname=\"pts\",     fname=\"swanspec.nc\",     dim=SPEC2D(),     freq=ABS(),     times=TimeRangeOpen(tfmt=1, dfmt=\"min\"), # Default times which will be overwritten )  output = OUTPUT(     points=points,     quantity=quantity,     block=block,     table=table,     specout=specout, )  print(output.render()) <pre>POINTS sname='pts' &amp;\n    xp=114.0 yp=-34.0 &amp;\n    xp=112.5 yp=-26.0 &amp;\n    xp=115.0 yp=-30.0\n\nQUANTITY HSIGN hexp=50.0\n\nQUANTITY HSIGN TPS fmin=0.04 fmax=0.3\n\nQUANTITY HSWELL fswell=0.125\n\nBLOCK sname='COMPGRID' fname='outgrid.nc' LAYOUT idla=3 &amp;\n    DEPTH &amp;\n    WIND &amp;\n    HSIGN &amp;\n    HSWELL &amp;\n    DIR &amp;\n    TPS &amp;\n    OUTPUT tbegblk=19700101.000000 deltblk=60.0 MIN\n\nTABLE sname='pts' fname='outpts.txt' &amp;\n    TIME &amp;\n    HSIGN &amp;\n    DIR &amp;\n    TPS &amp;\n    TM01 &amp;\n    OUTPUT tbegtbl=19700101.000000 delttbl=60.0 MIN\n\nSPECOUT sname='pts' SPEC2D ABS fname='swanspec.nc' OUTPUT tbegspc=19700101.000000 deltspc=60.0 MIN\n</pre> In\u00a0[29]: Copied! <pre>from rompy_swan.components.group import LOCKUP\nfrom rompy_swan.components.lockup import COMPUTE_STAT, HOTFILE\nfrom rompy_swan.subcomponents.time import NONSTATIONARY\n\nhotfile = HOTFILE(fname=\"hotfile.swn\", format=\"free\")\n\ncompute = COMPUTE_STAT(\n    times=NONSTATIONARY(tfmt=1, dfmt=\"hr\"), # We use nonstationary times here to prescribe multiple STAT commands\n    hotfile=hotfile,\n    hottimes=[1, -1], # Output hotfile after the 2nd and last time steps\n)\n\nlockup = LOCKUP(compute=compute)\n\nprint(lockup.render())\n</pre> from rompy_swan.components.group import LOCKUP from rompy_swan.components.lockup import COMPUTE_STAT, HOTFILE from rompy_swan.subcomponents.time import NONSTATIONARY  hotfile = HOTFILE(fname=\"hotfile.swn\", format=\"free\")  compute = COMPUTE_STAT(     times=NONSTATIONARY(tfmt=1, dfmt=\"hr\"), # We use nonstationary times here to prescribe multiple STAT commands     hotfile=hotfile,     hottimes=[1, -1], # Output hotfile after the 2nd and last time steps )  lockup = LOCKUP(compute=compute)  print(lockup.render()) <pre>COMPUTE STATIONARY time=19700101.000000\nCOMPUTE STATIONARY time=19700101.010000\nHOTFILE fname='hotfile_19700101T010000.swn' FREE\nCOMPUTE STATIONARY time=19700101.020000\nCOMPUTE STATIONARY time=19700101.030000\nCOMPUTE STATIONARY time=19700101.040000\nCOMPUTE STATIONARY time=19700101.050000\nCOMPUTE STATIONARY time=19700101.060000\nCOMPUTE STATIONARY time=19700101.070000\nCOMPUTE STATIONARY time=19700101.080000\nCOMPUTE STATIONARY time=19700101.090000\nCOMPUTE STATIONARY time=19700101.100000\nCOMPUTE STATIONARY time=19700101.110000\nCOMPUTE STATIONARY time=19700101.120000\nCOMPUTE STATIONARY time=19700101.130000\nCOMPUTE STATIONARY time=19700101.140000\nCOMPUTE STATIONARY time=19700101.150000\nCOMPUTE STATIONARY time=19700101.160000\nCOMPUTE STATIONARY time=19700101.170000\nCOMPUTE STATIONARY time=19700101.180000\nCOMPUTE STATIONARY time=19700101.190000\nCOMPUTE STATIONARY time=19700101.200000\nCOMPUTE STATIONARY time=19700101.210000\nCOMPUTE STATIONARY time=19700101.220000\nCOMPUTE STATIONARY time=19700101.230000\nCOMPUTE STATIONARY time=19700102.000000\nHOTFILE fname='hotfile_19700102T000000.swn' FREE\nSTOP\n</pre> In\u00a0[30]: Copied! <pre>config = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    inpgrid=inpgrid,\n    initial=initial,\n    boundary=boundary_interface,\n    physics=physics,\n    prop=prop,\n    numeric=numeric,\n    output=output,\n    lockup=lockup,\n)\n</pre> config = SwanConfig(     cgrid=cgrid,     startup=startup,     inpgrid=inpgrid,     initial=initial,     boundary=boundary_interface,     physics=physics,     prop=prop,     numeric=numeric,     output=output,     lockup=lockup, ) In\u00a0[31]: Copied! <pre>from rompy.model import ModelRun\nfrom rompy.core.time import TimeRange\n\nrun = ModelRun(\n    run_id=\"run1\",\n    period=times,\n    output_dir=str(workdir),\n    config=config,\n)\n\nrundir = run()\n</pre> from rompy.model import ModelRun from rompy.core.time import TimeRange  run = ModelRun(     run_id=\"run1\",     period=times,     output_dir=str(workdir),     config=config, )  rundir = run() <pre>2025-09-18 21:17:29 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:17:29 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy.model         :             Run ID : run1\n2025-09-18 21:17:29 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:17:29 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:17:29 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:17:29 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:17:29 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:17:29 [INFO] rompy.model         :   Output Directory : example_procedural\n2025-09-18 21:17:29 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy.model         : \n2025-09-18 21:17:29 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:17:29 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] root                : \n2025-09-18 21:17:29 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:17:29 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:17:29 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:17:29 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:17:29 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:17:29 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:17:29 [INFO] rompy.model         :         Size: 7.0x12.0\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Boundary: BoundaryInterface\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:17:29 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:17:29 [INFO] rompy.model         :         Breaking: BREAKING_CONSTANT\n2025-09-18 21:17:29 [INFO] rompy.model         :         Friction: FRICTION_RIPPLES\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:17:29 [INFO] rompy.model         :         Quantities: 3 output group(s)\n2025-09-18 21:17:29 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:17:29 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:17:29 [INFO] rompy.model         :   \n2025-09-18 21:17:29 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:17:29 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy.model         : \n2025-09-18 21:17:29 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:17:29 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy.model         : Preparing input files in example_procedural\n2025-09-18 21:17:29 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:17:29 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:17:29 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:17:29 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy_swan.config   : \n2025-09-18 21:17:29 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Size:       7.0x12.0\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :     \n2025-09-18 21:17:29 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - Boundary: BoundaryInterface\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:17:29 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:17:29 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Output file: example_procedural/run1/bottom.grd\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (30, 21)\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Completed in 0.01 seconds\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:17:29 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Output file: example_procedural/run1/wind.grd\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 30, 21)\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 30, 21)\n2025-09-18 21:17:29 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:17:30 [INFO] rompy_swan.data     :   \u2022 Completed in 0.02 seconds\n2025-09-18 21:17:30 [INFO] rompy_swan.data     :   \u2022 File size: 0.03 MB\n2025-09-18 21:17:30 [INFO] rompy_swan.interface: Generating boundary file: example_procedural/run1/westaus.bnd\n2025-09-18 21:17:30 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:30 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:17:30 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:30 [INFO] rompy_swan.config   : \n2025-09-18 21:17:30 [INFO] rompy.model         : Rendering model templates to example_procedural/run1...\n2025-09-18 21:17:30 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:17:30 [INFO] rompy.core.render   : Output directory: example_procedural\n2025-09-18 21:17:30 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:17:30 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.02 seconds\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Files created:       4\n2025-09-18 21:17:30 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_procedural/run1\n2025-09-18 21:17:30 [INFO] rompy.model         : \n2025-09-18 21:17:30 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:17:30 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:17:30 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:17:30 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_procedural/run1\n</pre> In\u00a0[32]: Copied! <pre>modeldir = Path(run.output_dir) / run.run_id\n\nsorted(modeldir.glob(\"*\"))\n</pre> modeldir = Path(run.output_dir) / run.run_id  sorted(modeldir.glob(\"*\")) Out[32]: <pre>[PosixPath('example_procedural/run1/INPUT'),\n PosixPath('example_procedural/run1/bottom.grd'),\n PosixPath('example_procedural/run1/westaus.bnd'),\n PosixPath('example_procedural/run1/wind.grd')]</pre> In\u00a0[33]: Copied! <pre>input = modeldir / \"INPUT\"\nprint(input.read_text())\n</pre> input = modeldir / \"INPUT\" print(input.read_text()) <pre>! Rompy SwanConfig\n! Template: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n! Generated: 2025-09-18 09:17:29.934680 on rguedes-XPS-13-9350 by rguedes\n\n\n! Startup -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROJECT name='Test procedural' nr='run1' title1='Procedural definition of a Swan config with rompy'\n\nSET level=0.0 depmin=0.05 NAUTICAL\n\nMODE NONSTATIONARY TWODIMENSIONAL\n\nCOORDINATES SPHERICAL CCM\n\n! Computational Grid --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nCGRID REGULAR xpc=110.0 ypc=-35.2 alpc=4.0 xlenc=7.0 ylenc=12.0 mxc=14 myc=24 CIRCLE mdc=36 flow=0.04 fhigh=1.0\n\n! Input Grids ---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nINPGRID BOTTOM REG 108.1629223150705 -36.2 0.0 20 29 0.5 0.5 EXC -99.0\nREADINP BOTTOM -1.0 'bottom.grd' 3 FREE\n\nINPGRID WIND REG 108.1629223150705 -36.2 0.0 20 29 0.5 0.5 EXC -99.0 NONSTATION 20230101.000000 6.00 HR\nREADINP WIND 1.0 'wind.grd' 3 0 1 0 FREE\n\n\n\n! Boundary and Initial conditions -------------------------------------------------------------------------------------------------------------------------------------------------\n\nBOUNDNEST1 NEST 'westaus.bnd' CLOSED\n\nINITIAL DEFAULT\n\n\n! Physics -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGEN3 WESTHUYSEN cds2=5e-05 br=0.00175 DRAG WU\n\nQUADRUPL iquad=2 lambda=0.25 cnl4=30000000.0 csh1=5.5 csh2=0.833 csh3=-1.25\n\nBREAKING CONSTANT alpha=1.0 gamma=0.73\n\nFRICTION RIPPLES S=2.65 D=0.0001\n\nTRIAD itriad=1\n\n\n! Numerics ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROP BSBT\n\nNUMERIC STOPC dabs=0.02 drel=0.02 curvat=0.02 npnts=98.0 STATIONARY mxitst=50 DIRIMPL cdd=0.5\n\n\n! Output --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPOINTS sname='pts' &amp;\n    xp=114.0 yp=-34.0 &amp;\n    xp=112.5 yp=-26.0 &amp;\n    xp=115.0 yp=-30.0\n\nQUANTITY HSIGN hexp=50.0\n\nQUANTITY HSIGN TPS fmin=0.04 fmax=0.3\n\nQUANTITY HSWELL fswell=0.125\n\nBLOCK sname='COMPGRID' fname='outgrid.nc' LAYOUT idla=3 &amp;\n    DEPTH &amp;\n    WIND &amp;\n    HSIGN &amp;\n    HSWELL &amp;\n    DIR &amp;\n    TPS &amp;\n    OUTPUT tbegblk=20230101.000000 deltblk=60.0 MIN\n\nTABLE sname='pts' fname='outpts.txt' &amp;\n    TIME &amp;\n    HSIGN &amp;\n    DIR &amp;\n    TPS &amp;\n    TM01 &amp;\n    OUTPUT tbegtbl=20230101.000000 delttbl=60.0 MIN\n\nSPECOUT sname='pts' SPEC2D ABS fname='swanspec.nc' OUTPUT tbegspc=20230101.000000 deltspc=60.0 MIN\n\n\n! Lockup --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nCOMPUTE STATIONARY time=20230101.000000\nCOMPUTE STATIONARY time=20230101.010000\nHOTFILE fname='hotfile_20230101T010000.swn' FREE\nCOMPUTE STATIONARY time=20230101.020000\nCOMPUTE STATIONARY time=20230101.030000\nCOMPUTE STATIONARY time=20230101.040000\nCOMPUTE STATIONARY time=20230101.050000\nCOMPUTE STATIONARY time=20230101.060000\nCOMPUTE STATIONARY time=20230101.070000\nCOMPUTE STATIONARY time=20230101.080000\nCOMPUTE STATIONARY time=20230101.090000\nCOMPUTE STATIONARY time=20230101.100000\nCOMPUTE STATIONARY time=20230101.110000\nCOMPUTE STATIONARY time=20230101.120000\nCOMPUTE STATIONARY time=20230101.130000\nCOMPUTE STATIONARY time=20230101.140000\nCOMPUTE STATIONARY time=20230101.150000\nCOMPUTE STATIONARY time=20230101.160000\nCOMPUTE STATIONARY time=20230101.170000\nCOMPUTE STATIONARY time=20230101.180000\nCOMPUTE STATIONARY time=20230101.190000\nCOMPUTE STATIONARY time=20230101.200000\nCOMPUTE STATIONARY time=20230101.210000\nCOMPUTE STATIONARY time=20230101.220000\nCOMPUTE STATIONARY time=20230101.230000\nCOMPUTE STATIONARY time=20230102.000000\nHOTFILE fname='hotfile_20230102T000000.swn' FREE\nSTOP\n</pre> In\u00a0[34]: Copied! <pre>!docker run  -v ./example_procedural/run1:/home oceanum/swan:4141 swan.exe &gt; example_procedural/swan.log\n!tail example_procedural/swan.log\n</pre> !docker run  -v ./example_procedural/run1:/home oceanum/swan:4141 swan.exe &gt; example_procedural/swan.log !tail example_procedural/swan.log <pre>\n iteration    4; sweep 1\n+iteration    4; sweep 2\n+iteration    4; sweep 3\n+iteration    4; sweep 4\n accuracy OK in  98.89 % of wet grid points ( 98.00 % required)\n\n+SWAN is processing output request    1\n+SWAN is processing output request    2\n+SWAN is processing output request    3\n</pre> In\u00a0[35]: Copied! <pre>import os\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom wavespectra import read_ncswan, read_swan\nfrom wavespectra.core.swan import read_tab\n\npd.set_option(\"display.notebook_repr_html\", False)\n</pre> import os import numpy as np import pandas as pd import xarray as xr import matplotlib.pyplot as plt import cartopy.crs as ccrs from wavespectra import read_ncswan, read_swan from wavespectra.core.swan import read_tab  pd.set_option(\"display.notebook_repr_html\", False) In\u00a0[36]: Copied! <pre>sorted(modeldir.glob(\"*\"))\n</pre> sorted(modeldir.glob(\"*\")) Out[36]: <pre>[PosixPath('example_procedural/run1/INPUT'),\n PosixPath('example_procedural/run1/PRINT'),\n PosixPath('example_procedural/run1/bottom.grd'),\n PosixPath('example_procedural/run1/hotfile_20230101T010000.swn'),\n PosixPath('example_procedural/run1/hotfile_20230102T000000.swn'),\n PosixPath('example_procedural/run1/norm_end'),\n PosixPath('example_procedural/run1/outgrid.nc'),\n PosixPath('example_procedural/run1/outpts.txt'),\n PosixPath('example_procedural/run1/swaninit'),\n PosixPath('example_procedural/run1/swanspec.nc'),\n PosixPath('example_procedural/run1/westaus.bnd'),\n PosixPath('example_procedural/run1/wind.grd')]</pre> In\u00a0[37]: Copied! <pre># Gridded output\n\ndsgrid = xr.open_dataset(modeldir / run.config.output.block.fname)\ndsgrid\n</pre> # Gridded output  dsgrid = xr.open_dataset(modeldir / run.config.output.block.fname) dsgrid Out[37]: <pre>&lt;xarray.Dataset&gt; Size: 266kB\nDimensions:    (time: 25, yc: 25, xc: 15)\nCoordinates:\n  * time       (time) datetime64[ns] 200B 2023-01-01 ... 2023-01-02\n    longitude  (yc, xc) float32 2kB ...\n    latitude   (yc, xc) float32 2kB ...\nDimensions without coordinates: yc, xc\nData variables:\n    depth      (time, yc, xc) float32 38kB ...\n    xwnd       (time, yc, xc) float32 38kB ...\n    ywnd       (time, yc, xc) float32 38kB ...\n    hs         (time, yc, xc) float32 38kB ...\n    hswe       (time, yc, xc) float32 38kB ...\n    theta0     (time, yc, xc) float32 38kB ...\n    tps        (time, yc, xc) float32 38kB ...\nAttributes:\n    Conventions:             CF-1.5\n    History:                 Created with agioncmd version 1.5\n    Directional_convention:  nautical\n    project:                 Test procedural\n    run:                     run1</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 25</li><li>yc: 25</li><li>xc: 15</li></ul></li><li>Coordinates: (3)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :timelong_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T01:00:00.000000000',\n       '2023-01-01T02:00:00.000000000', '2023-01-01T03:00:00.000000000',\n       '2023-01-01T04:00:00.000000000', '2023-01-01T05:00:00.000000000',\n       '2023-01-01T06:00:00.000000000', '2023-01-01T07:00:00.000000000',\n       '2023-01-01T08:00:00.000000000', '2023-01-01T09:00:00.000000000',\n       '2023-01-01T10:00:00.000000000', '2023-01-01T11:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T13:00:00.000000000',\n       '2023-01-01T14:00:00.000000000', '2023-01-01T15:00:00.000000000',\n       '2023-01-01T16:00:00.000000000', '2023-01-01T17:00:00.000000000',\n       '2023-01-01T18:00:00.000000000', '2023-01-01T19:00:00.000000000',\n       '2023-01-01T20:00:00.000000000', '2023-01-01T21:00:00.000000000',\n       '2023-01-01T22:00:00.000000000', '2023-01-01T23:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>longitude(yc, xc)float32...units :degrees_eastlong_name :longitudestandard_name :longitude<pre>[375 values with dtype=float32]</pre></li><li>latitude(yc, xc)float32...units :degrees_northlong_name :latitudestandard_name :latitude<pre>[375 values with dtype=float32]</pre></li></ul></li><li>Data variables: (7)<ul><li>depth(time, yc, xc)float32...units :mstandard_name :sea_floor_depth_below_sea_levellong_name :depth below mean sea level<pre>[9375 values with dtype=float32]</pre></li><li>xwnd(time, yc, xc)float32...units :m s-1standard_name :eastward_windlong_name :U-Component of Wind<pre>[9375 values with dtype=float32]</pre></li><li>ywnd(time, yc, xc)float32...units :m s-1standard_name :northward_windlong_name :V-Component of Wind<pre>[9375 values with dtype=float32]</pre></li><li>hs(time, yc, xc)float32...units :mstandard_name :sea_surface_wave_significant_heightlong_name :hs<pre>[9375 values with dtype=float32]</pre></li><li>hswe(time, yc, xc)float32...units :mstandard_name :sea_surface_swell_wave_significant_heightlong_name :wave height of swell part<pre>[9375 values with dtype=float32]</pre></li><li>theta0(time, yc, xc)float32...units :degreesstandard_name :sea_surface_wave_from_directionlong_name :theta0<pre>[9375 values with dtype=float32]</pre></li><li>tps(time, yc, xc)float32...units :slong_name :tps<pre>[9375 values with dtype=float32]</pre></li></ul></li><li>Indexes: (1)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00',\n               '2023-01-01 02:00:00', '2023-01-01 03:00:00',\n               '2023-01-01 04:00:00', '2023-01-01 05:00:00',\n               '2023-01-01 06:00:00', '2023-01-01 07:00:00',\n               '2023-01-01 08:00:00', '2023-01-01 09:00:00',\n               '2023-01-01 10:00:00', '2023-01-01 11:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 13:00:00',\n               '2023-01-01 14:00:00', '2023-01-01 15:00:00',\n               '2023-01-01 16:00:00', '2023-01-01 17:00:00',\n               '2023-01-01 18:00:00', '2023-01-01 19:00:00',\n               '2023-01-01 20:00:00', '2023-01-01 21:00:00',\n               '2023-01-01 22:00:00', '2023-01-01 23:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (5)Conventions :CF-1.5History :Created with agioncmd version 1.5Directional_convention :nauticalproject :Test proceduralrun :run1</li></ul> In\u00a0[38]: Copied! <pre># Spectra output\n\ndspec = read_ncswan(modeldir / run.config.output.specout.fname)\ndspec\n</pre> # Spectra output  dspec = read_ncswan(modeldir / run.config.output.specout.fname) dspec Out[38]: <pre>&lt;xarray.Dataset&gt; Size: 379kB\nDimensions:  (site: 3, time: 25, freq: 35, dir: 36)\nCoordinates:\n  * time     (time) datetime64[ns] 200B 2023-01-01 ... 2023-01-02\n  * freq     (freq) float32 140B 0.04 0.04397 0.04834 ... 0.8275 0.9097 1.0\n  * dir      (dir) float32 144B 261.0 251.0 241.0 231.0 ... 291.0 281.0 271.0\n  * site     (site) int64 24B 1 2 3\nData variables:\n    lon      (site) float32 12B dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;\n    lat      (site) float32 12B dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;\n    efth     (time, site, freq, dir) float32 378kB dask.array&lt;chunksize=(25, 3, 35, 36), meta=np.ndarray&gt;\n    dpt      (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\n    wspd     (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\n    wdir     (time, site) float32 300B dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;\nAttributes:\n    Conventions:             CF-1.5\n    History:                 Created with agioncmd version 1.5\n    Directional_convention:  nautical\n    project:                 Test procedural\n    model:                   41.41\n    run:                     run1</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 3</li><li>time: 25</li><li>freq: 35</li><li>dir: 36</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :timelong_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T01:00:00.000000000',\n       '2023-01-01T02:00:00.000000000', '2023-01-01T03:00:00.000000000',\n       '2023-01-01T04:00:00.000000000', '2023-01-01T05:00:00.000000000',\n       '2023-01-01T06:00:00.000000000', '2023-01-01T07:00:00.000000000',\n       '2023-01-01T08:00:00.000000000', '2023-01-01T09:00:00.000000000',\n       '2023-01-01T10:00:00.000000000', '2023-01-01T11:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T13:00:00.000000000',\n       '2023-01-01T14:00:00.000000000', '2023-01-01T15:00:00.000000000',\n       '2023-01-01T16:00:00.000000000', '2023-01-01T17:00:00.000000000',\n       '2023-01-01T18:00:00.000000000', '2023-01-01T19:00:00.000000000',\n       '2023-01-01T20:00:00.000000000', '2023-01-01T21:00:00.000000000',\n       '2023-01-01T22:00:00.000000000', '2023-01-01T23:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>freq(freq)float320.04 0.04397 0.04834 ... 0.9097 1.0units :s-1standard_name :wave_frequencyflow :0.04fhigh :0.9999985msc :34<pre>array([0.04    , 0.043972, 0.048338, 0.053138, 0.058415, 0.064215, 0.070592,\n       0.077602, 0.085307, 0.093778, 0.103091, 0.113327, 0.124581, 0.136951,\n       0.15055 , 0.1655  , 0.181934, 0.2     , 0.21986 , 0.241692, 0.265691,\n       0.292074, 0.321077, 0.35296 , 0.388008, 0.426537, 0.468892, 0.515452,\n       0.566636, 0.622902, 0.684756, 0.752752, 0.827499, 0.909669, 0.999999],\n      dtype=float32)</pre></li><li>dir(dir)float32261.0 251.0 241.0 ... 281.0 271.0<pre>array([261.      , 251.      , 241.      , 231.      , 221.      , 211.      ,\n       201.      , 191.      , 181.      , 171.      , 160.99998 , 151.      ,\n       141.      , 131.      , 120.999985, 110.999985, 100.99999 ,  90.99999 ,\n        80.99999 ,  70.999985,  60.999985,  50.999985,  40.99999 ,  30.999989,\n        20.99999 ,  10.999992,   0.999994, 350.99997 , 340.99997 , 330.99997 ,\n       320.99997 , 310.99997 , 300.99997 , 290.99997 , 281.      , 271.      ],\n      dtype=float32)</pre></li><li>site(site)int641 2 3<pre>array([1, 2, 3])</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;standard_name :longitudeunits :degrees_east  Array   Chunk   Bytes   12 B   12 B   Shape   (3,)   (3,)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 1 </li><li>lat(site)float32dask.array&lt;chunksize=(3,), meta=np.ndarray&gt;standard_name :latitudeunits :degrees_north  Array   Chunk   Bytes   12 B   12 B   Shape   (3,)   (3,)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 1 </li><li>efth(time, site, freq, dir)float32dask.array&lt;chunksize=(25, 3, 35, 36), meta=np.ndarray&gt;standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1  Array   Chunk   Bytes   369.14 kiB   369.14 kiB   Shape   (25, 3, 35, 36)   (25, 3, 35, 36)   Dask graph   1 chunks in 3 graph layers   Data type   float32 numpy.ndarray  25 1 36 35 3 </li><li>dpt(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :sea_floor_depth_below_sea_surfaceunits :m  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 2 graph layers   Data type   float32 numpy.ndarray  3 25 </li><li>wspd(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 8 graph layers   Data type   float32 numpy.ndarray  3 25 </li><li>wdir(time, site)float32dask.array&lt;chunksize=(25, 3), meta=np.ndarray&gt;standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree  Array   Chunk   Bytes   300 B   300 B   Shape   (25, 3)   (25, 3)   Dask graph   1 chunks in 8 graph layers   Data type   float32 numpy.ndarray  3 25 </li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00',\n               '2023-01-01 02:00:00', '2023-01-01 03:00:00',\n               '2023-01-01 04:00:00', '2023-01-01 05:00:00',\n               '2023-01-01 06:00:00', '2023-01-01 07:00:00',\n               '2023-01-01 08:00:00', '2023-01-01 09:00:00',\n               '2023-01-01 10:00:00', '2023-01-01 11:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 13:00:00',\n               '2023-01-01 14:00:00', '2023-01-01 15:00:00',\n               '2023-01-01 16:00:00', '2023-01-01 17:00:00',\n               '2023-01-01 18:00:00', '2023-01-01 19:00:00',\n               '2023-01-01 20:00:00', '2023-01-01 21:00:00',\n               '2023-01-01 22:00:00', '2023-01-01 23:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([ 0.03999999910593033,   0.0439719632267952,  0.04833833873271942,\n        0.05313829332590103, 0.058414872735738754,  0.06421541422605515,\n        0.07059194892644882,  0.07760166376829147,  0.08530744165182114,\n        0.09377838671207428,  0.10309050232172012,  0.11332729458808899,\n        0.12458059191703796,  0.13695132732391357,   0.1505504697561264,\n         0.1655000001192093,  0.18193399906158447,   0.1999998688697815,\n        0.21985965967178345,  0.24169152975082397,  0.26569128036499023,\n        0.29207417368888855,   0.3210768699645996,   0.3529595136642456,\n         0.3880080580711365,     0.42653688788414,  0.46889159083366394,\n         0.5154520869255066,   0.5666360259056091,   0.6229023933410645,\n         0.6847560405731201,   0.7527517080307007,    0.827499270439148,\n         0.9096691608428955,   0.9999985098838806],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([             261.0,              251.0,              241.0,\n                    231.0,              221.0,              211.0,\n                    201.0,              191.0,              181.0,\n                    171.0, 160.99998474121094,              151.0,\n                    141.0,              131.0, 120.99998474121094,\n       110.99998474121094, 100.99999237060547,  90.99999237060547,\n        80.99999237060547,  70.99998474121094,  60.99998474121094,\n        50.99998474121094,   40.9999885559082, 30.999988555908203,\n       20.999990463256836, 10.999992370605469, 0.9999943375587463,\n        350.9999694824219,  340.9999694824219,  330.9999694824219,\n        320.9999694824219,  310.9999694824219,  300.9999694824219,\n        290.9999694824219,              281.0,              271.0],\n      dtype='float32', name='dir'))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([1, 2, 3], dtype='int64', name='site'))</pre></li></ul></li><li>Attributes: (6)Conventions :CF-1.5History :Created with agioncmd version 1.5Directional_convention :nauticalproject :Test proceduralmodel :41.41run :run1</li></ul> In\u00a0[39]: Copied! <pre>os.system(f\"head -n 15 {modeldir / run.config.output.table.fname}\")\n</pre> os.system(f\"head -n 15 {modeldir / run.config.output.table.fname}\") <pre>%\n%\n% Run:run1  Table:pts               SWAN version:41.41\n%\n%       Time               Hsig          Dir           TPsmoo        Tm01     \n%       [ ]                [m]           [degr]        [sec]         [sec]    \n%\n20230101.000000           4.0560       222.149       14.4021       10.9046 \n20230101.000000           2.9192       211.237       14.2411        8.8702 \n20230101.000000          -9.0000      -999.000       -9.0000       -9.0000 \n20230101.010000           4.0446       222.069       14.3827       10.8835 \n20230101.010000           2.9188       211.452       14.2370        8.9171 \n20230101.010000          -9.0000      -999.000       -9.0000       -9.0000 \n20230101.020000           4.0369       222.077       14.3634       10.8677 \n20230101.020000           2.9401       211.405       14.2326        8.9359 \n</pre> Out[39]: <pre>0</pre> In\u00a0[40]: Copied! <pre># Timeseries output (keep 1st site only)\n\ndf = read_tab(modeldir / run.config.output.table.fname)\n\ndf[\"time\"] = df.index\ndf = df.drop_duplicates(\"time\", keep=\"first\").drop(\"time\", axis=1)\ndf.head()\n</pre> # Timeseries output (keep 1st site only)  df = read_tab(modeldir / run.config.output.table.fname)  df[\"time\"] = df.index df = df.drop_duplicates(\"time\", keep=\"first\").drop(\"time\", axis=1) df.head() Out[40]: <pre>                       Hsig      Dir   TPsmoo     Tm01\ntime                                                  \n2023-01-01 00:00:00  4.0560  222.149  14.4021  10.9046\n2023-01-01 01:00:00  4.0446  222.069  14.3827  10.8835\n2023-01-01 02:00:00  4.0369  222.077  14.3634  10.8677\n2023-01-01 03:00:00  4.0299  222.086  14.3448  10.8482\n2023-01-01 04:00:00  4.0209  222.084  14.3272  10.8374</pre> In\u00a0[41]: Copied! <pre>fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()))\np = dsgrid.depth.isel(time=0, drop=True).plot(ax=ax, x=\"longitude\", y=\"latitude\")\nax.coastlines();\n</pre> fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree())) p = dsgrid.depth.isel(time=0, drop=True).plot(ax=ax, x=\"longitude\", y=\"latitude\") ax.coastlines(); In\u00a0[42]: Copied! <pre>f = dsgrid.hs.isel(time=slice(0, -1, 3)).plot(\n    x=\"longitude\",\n    y=\"latitude\",\n    col=\"time\",\n    col_wrap=4,\n    vmin=0,\n    vmax=4,\n    cmap=\"turbo\",\n    subplot_kws=dict(projection=ccrs.PlateCarree()),\n)\nf.map(lambda: plt.gca().coastlines());\n</pre> f = dsgrid.hs.isel(time=slice(0, -1, 3)).plot(     x=\"longitude\",     y=\"latitude\",     col=\"time\",     col_wrap=4,     vmin=0,     vmax=4,     cmap=\"turbo\",     subplot_kws=dict(projection=ccrs.PlateCarree()), ) f.map(lambda: plt.gca().coastlines()); In\u00a0[43]: Copied! <pre>u = dsgrid.xwnd.isel(time=slice(0, -1, 3))\nv = dsgrid.ywnd.isel(time=slice(0, -1, 3))\nf = np.sqrt(u ** 2 + v ** 2).plot(\n    x=\"longitude\",\n    y=\"latitude\",\n    col=\"time\",\n    col_wrap=4,\n    vmin=2,\n    vmax=12,\n    cmap=\"jet\",\n    cbar_kwargs={\"label\": \"Wind speed (m/s)\"},\n    subplot_kws=dict(projection=ccrs.PlateCarree()),\n)\nfor ax, time in zip(f.axs.flat, u.time):\n    ax.coastlines()\n    ax.quiver(u.longitude, u.latitude, u.sel(time=time), v.sel(time=time), scale=200)\n    ax.plot(dspec.isel(site=0).lon, dspec.isel(site=0).lat, \"ok\")\n</pre> u = dsgrid.xwnd.isel(time=slice(0, -1, 3)) v = dsgrid.ywnd.isel(time=slice(0, -1, 3)) f = np.sqrt(u ** 2 + v ** 2).plot(     x=\"longitude\",     y=\"latitude\",     col=\"time\",     col_wrap=4,     vmin=2,     vmax=12,     cmap=\"jet\",     cbar_kwargs={\"label\": \"Wind speed (m/s)\"},     subplot_kws=dict(projection=ccrs.PlateCarree()), ) for ax, time in zip(f.axs.flat, u.time):     ax.coastlines()     ax.quiver(u.longitude, u.latitude, u.sel(time=time), v.sel(time=time), scale=200)     ax.plot(dspec.isel(site=0).lon, dspec.isel(site=0).lat, \"ok\") In\u00a0[44]: Copied! <pre>p = dspec.isel(site=0, time=slice(0, -1, 3)).spec.plot(col=\"time\", col_wrap=4)\n</pre> p = dspec.isel(site=0, time=slice(0, -1, 3)).spec.plot(col=\"time\", col_wrap=4) In\u00a0[45]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n\ndf.Hsig.plot(ax=ax1, label=\"From table\", linewidth=5)\ndspec.isel(site=0).spec.hs().to_pandas().plot(ax=ax1, label=\"From spectra\")\nax1.set_ylabel(\"Hs (m)\")\nl = ax1.legend()\n\ndf.TPsmoo.plot(ax=ax2, label=\"From table\", linewidth=5)\ndspec.isel(site=0).spec.tp(smooth=True).to_pandas().plot(ax=ax2, label=\"From spectra\")\nax2.set_ylabel(\"Tp (s)\")\nl = ax2.legend()\n</pre> fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))  df.Hsig.plot(ax=ax1, label=\"From table\", linewidth=5) dspec.isel(site=0).spec.hs().to_pandas().plot(ax=ax1, label=\"From spectra\") ax1.set_ylabel(\"Hs (m)\") l = ax1.legend()  df.TPsmoo.plot(ax=ax2, label=\"From table\", linewidth=5) dspec.isel(site=0).spec.tp(smooth=True).to_pandas().plot(ax=ax2, label=\"From spectra\") ax2.set_ylabel(\"Tp (s)\") l = ax2.legend() In\u00a0[46]: Copied! <pre>hotfiles = sorted(modeldir.glob(f\"{run.config.lockup.compute.hotfile.fname.stem}*\"))\nhotfiles\n</pre> hotfiles = sorted(modeldir.glob(f\"{run.config.lockup.compute.hotfile.fname.stem}*\")) hotfiles Out[46]: <pre>[PosixPath('example_procedural/run1/hotfile_20230101T010000.swn'),\n PosixPath('example_procedural/run1/hotfile_20230102T000000.swn')]</pre> In\u00a0[47]: Copied! <pre># Investigate why the option to read as grid doesn't work\n\ndset = read_swan(str(hotfiles[-1]), as_site=False)\nstats = dset.spec.stats([\"hs\", \"tp\", \"dpm\"]).chunk()\n\nfig, [ax1, ax2, ax3] = plt.subplots(1, 3, figsize=(15, 5), subplot_kw=dict(projection=ccrs.PlateCarree()))\np = ax1.scatter(dset.lon, dset.lat, s=15, c=stats.hs, vmin=0, vmax=4, cmap=\"turbo\")\nplt.colorbar(p, label=\"Hs (m)\")\np = ax2.scatter(dset.lon, dset.lat, s=15, c=stats.tp, vmin=12, vmax=16, cmap=\"viridis\")\nplt.colorbar(p, label=\"Tp (s)\")\np = ax3.scatter(dset.lon, dset.lat, s=15, c=stats.dpm, vmin=0, vmax=360, cmap=\"hsv\")\nplt.colorbar(p, label=\"Dpm (deg)\")\nfor ax in [ax1, ax2, ax3]:\n    ax.coastlines();\n</pre> # Investigate why the option to read as grid doesn't work  dset = read_swan(str(hotfiles[-1]), as_site=False) stats = dset.spec.stats([\"hs\", \"tp\", \"dpm\"]).chunk()  fig, [ax1, ax2, ax3] = plt.subplots(1, 3, figsize=(15, 5), subplot_kw=dict(projection=ccrs.PlateCarree())) p = ax1.scatter(dset.lon, dset.lat, s=15, c=stats.hs, vmin=0, vmax=4, cmap=\"turbo\") plt.colorbar(p, label=\"Hs (m)\") p = ax2.scatter(dset.lon, dset.lat, s=15, c=stats.tp, vmin=12, vmax=16, cmap=\"viridis\") plt.colorbar(p, label=\"Tp (s)\") p = ax3.scatter(dset.lon, dset.lat, s=15, c=stats.dpm, vmin=0, vmax=360, cmap=\"hsv\") plt.colorbar(p, label=\"Dpm (deg)\") for ax in [ax1, ax2, ax3]:     ax.coastlines();"},{"location":"examples/example_procedural/#swan-procedural-example","title":"SWAN procedural example\u00b6","text":"<p>In this notebook we will use the SWAN Components and data objects to define a SWAN workspace</p>"},{"location":"examples/example_procedural/#workspace-basepath","title":"Workspace basepath\u00b6","text":""},{"location":"examples/example_procedural/#model-grid","title":"Model Grid\u00b6","text":""},{"location":"examples/example_procedural/#work-with-existing-data","title":"Work with existing data\u00b6","text":"<p>We will work with subsets of global bathymetry from Gebco, winds from ERA5 and spectral boundary from Oceanum available in Rompy. Some dummy interpolation routine is used to exemplify how existing xarray datasources could be processed and then provided to rompy to define the model config</p>"},{"location":"examples/example_procedural/#times","title":"Times\u00b6","text":""},{"location":"examples/example_procedural/#bathy","title":"Bathy\u00b6","text":""},{"location":"examples/example_procedural/#winds","title":"Winds\u00b6","text":""},{"location":"examples/example_procedural/#boundary","title":"Boundary\u00b6","text":""},{"location":"examples/example_procedural/#swan-components","title":"SWAN components\u00b6","text":"<p>SWAN commands can be fully prescribed using what we define as \"Components\". Components are pydantic objects that describe the different sets of command instruction in SWAN with fields that matching command options and a <code>render()</code> method that returns the string to render in the <code>INPUT</code> command file.</p> <p>The <code>SwanConfig</code> config class takes the components as fields organised as \"group\" components, a collection of individual components that are defined together and validated for consistency. These groups are structured similarly to the main groups of SWAN commands as defined by the subsections in Chapter 4 of the user manual.</p>"},{"location":"examples/example_procedural/#cgrid","title":"CGRID\u00b6","text":""},{"location":"examples/example_procedural/#startup","title":"Startup\u00b6","text":""},{"location":"examples/example_procedural/#input-grids","title":"Input grids\u00b6","text":"<p>We will prescribe input grids from our previously defined <code>SwanDataGrid</code> objects using the <code>DataInterface</code> object. This object is used by <code>SwanConfig</code> as an interface to pass around times and grids between model and data objects, create model input times and generate consistent CMD instructions.</p>"},{"location":"examples/example_procedural/#boundary","title":"Boundary\u00b6","text":"<p>Boundary can be defined either from a SWAN boundary component or using the <code>BoundaryInterface</code> class which works in an analogous way to <code>DataInterface</code>.</p> <p>Below we define a pure parametric boundary using the <code>BOUNDSPEC</code> component just to demonstrate it:</p>"},{"location":"examples/example_procedural/#initial-conditions","title":"Initial conditions\u00b6","text":"<p>Components are available to represent the different initial conditions options in SWAN including <code>DEFAULT</code>, <code>ZERO</code>, <code>PAR</code> and <code>HOTSTART</code></p> <p>TODO: define an interface to define initial conditions.</p>"},{"location":"examples/example_procedural/#physics","title":"Physics\u00b6","text":"<p>The Components support every SWAN physics command option. They are prescribed in the <code>SwanConfig</code> using the PHYSICS group component.</p>"},{"location":"examples/example_procedural/#propagation-scheme","title":"Propagation scheme\u00b6","text":""},{"location":"examples/example_procedural/#numerics","title":"Numerics\u00b6","text":""},{"location":"examples/example_procedural/#output","title":"Output\u00b6","text":"<p>Output commands are defined in <code>SwanConfig</code> with the <code>OUTPUT</code> group component. Many validations are defined to ensure location and write components are prescribed correctly.</p> <p>The output write components (and the lockup ones) require times, however we can skip defining times here as <code>SwanConfig</code> will ensure consistent times are defined for all time-dependant components.</p>"},{"location":"examples/example_procedural/#lockup","title":"Lockup\u00b6","text":"<p>The lockup components are prescribed to the <code>SwanConfig</code> class from the <code>LOCKUP</code> group component. similar to the output components, time-based fields do not need to be prescribed as they will be reset in the config class, however some time parameters such as <code>tfmt</code> and <code>dfmt</code> are maintained if defined so they could be defined here.</p>"},{"location":"examples/example_procedural/#instantiate-config","title":"Instantiate config\u00b6","text":"<p>Note each field is optional so it is possible to skip defining a certain group component such as <code>prop</code> to allow using default options in SWAN.</p>"},{"location":"examples/example_procedural/#generate-workspace","title":"Generate workspace\u00b6","text":""},{"location":"examples/example_procedural/#check-the-workspace","title":"Check the workspace\u00b6","text":""},{"location":"examples/example_procedural/#run-the-model","title":"Run the model\u00b6","text":"<p>Redirect to avoid large output</p>"},{"location":"examples/example_procedural/#plot-outputs","title":"Plot outputs\u00b6","text":""},{"location":"examples/example_procedural/#plot-model-depth","title":"Plot model depth\u00b6","text":""},{"location":"examples/example_procedural/#plot-gridded-hs","title":"Plot gridded Hs\u00b6","text":""},{"location":"examples/example_procedural/#plot-gridded-wind","title":"Plot gridded wind\u00b6","text":""},{"location":"examples/example_procedural/#plot-spectra","title":"Plot spectra\u00b6","text":""},{"location":"examples/example_procedural/#plot-timeseries","title":"Plot timeseries\u00b6","text":""},{"location":"examples/example_procedural/#plot-hotfile","title":"Plot hotfile\u00b6","text":""},{"location":"examples/example_sensitivity/","title":"SWAN sensitivity example","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\nfrom copy import deepcopy\nfrom pathlib import Path\nimport yaml\nimport shutil\n\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> %load_ext autoreload %autoreload 2  import os from copy import deepcopy from pathlib import Path import yaml import shutil  import warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre>workdir = Path(\"example_sensitivity\")\nshutil.rmtree(workdir, ignore_errors=True)\nworkdir.mkdir()\n</pre> workdir = Path(\"example_sensitivity\") shutil.rmtree(workdir, ignore_errors=True) workdir.mkdir() In\u00a0[3]: Copied! <pre># Uncoment below to view the contents of the yaml file\n\n# !cat example_sensitivity.yml\n</pre> # Uncoment below to view the contents of the yaml file  # !cat example_sensitivity.yml In\u00a0[4]: Copied! <pre>from rompy_swan.config import SwanConfig\n\nconf_dict = yaml.load(open(\"example_sensitivity.yml\"), Loader=yaml.Loader)\nconfig = SwanConfig(**conf_dict)\nconfig\n</pre> from rompy_swan.config import SwanConfig  conf_dict = yaml.load(open(\"example_sensitivity.yml\"), Loader=yaml.Loader) config = SwanConfig(**conf_dict) config Out[4]: <pre>SwanConfig(model_type='swan', template='/source/csiro/rompy-swan/src/rompy_swan/templates/swan', checkout='main', cgrid=REGULAR(model_type='regular', spectrum=SPECTRUM(model_type='spectrum', mdc=36, flow=0.04, fhigh=1.0, msc=None, dir1=None, dir2=None), grid=GRIDREGULAR(model_type='gridregular', xp=110.0, yp=-35.2, alp=4.0, xlen=7.5, ylen=12.5, mx=14, my=24, suffix='c')), startup=STARTUP(model_type='startup', project=PROJECT(model_type='project', name='Test sensitivity', nr='run1', title1='Source terms sensitivity testing', title2=None, title3=None), set=SET(model_type='set', level=0.0, nor=None, depmin=0.05, maxmes=None, maxerr=None, grav=None, rho=None, cdcap=None, inrhog=None, hsrerr=None, direction_convention='nautical', pwtail=None, froudmax=None, icewind=None), mode=MODE(model_type='mode', kind='nonstationary', dim='twodimensional'), coordinates=COORDINATES(model_type='coordinates', kind=SPHERICAL(model_type='spherical', projection='ccm'), reapeating=False)), inpgrid=DataInterface(model_type='data_interface', bottom=SwanDataGrid(model_type='grid', id='data', source=SourceIntake(model_type='intake', dataset_id='gebco', catalog_uri='../../../rompy-swan/tests/data/catalog.yaml', catalog_yaml=None, kwargs={}), filter=Filter(sort={}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['elevation'], coords=DatasetCoords(t='time', x='lon', y='lat', z=None, s=None), crop_data=True, buffer=1.0, time_buffer=[0, 0], z1='elevation', z2=None, var=&lt;GridOptions.BOTTOM: 'bottom'&gt;, fac=-1.0), input=[SwanDataGrid(model_type='grid', id='data', source=SourceIntake(model_type='intake', dataset_id='era5', catalog_uri='../../../rompy-swan/tests/data/catalog.yaml', catalog_yaml=None, kwargs={}), filter=Filter(sort={'coords': ['latitude']}, subset={}, crop={}, timenorm={}, rename={}, derived={}), variables=['u10', 'v10'], coords=DatasetCoords(t='time', x='longitude', y='latitude', z=None, s=None), crop_data=True, buffer=2.0, time_buffer=[0, 0], z1='u10', z2='v10', var=&lt;GridOptions.WIND: 'wind'&gt;, fac=1.0)]), boundary=BOUNDSPEC(model_type='boundspec', shapespec=SHAPESPEC(model_type='shapespec', shape=TMA(model_type='tma', gamma=3.3, d=12.0), per_type='peak', dspr_type='degrees'), location=SIDE(model_type='side', side='west', direction='ccw'), data=CONSTANTPAR(model_type='constantpar', hs=2.0, per=12.0, dir=255.0, dd=25.0)), initial=INITIAL(model_type='initial', kind=DEFAULT(model_type='default')), physics=PHYSICS(model_type='physics', gen=GEN3(model_type='gen3', source_terms=KOMEN(model_type='komen', wind_drag='wu', agrow=False, a=None, cds2=2.3e-05, stpm=0.00302)), sswell=None, negatinp=None, wcapping=None, quadrupl=None, breaking=None, friction=FRICTION_JONSWAP(model_type='jonswap', cfjon=0.038), triad=None, vegetation=None, mud=None, sice=None, turbulence=None, bragg=None, limiter=None, obstacle=None, setup=None, diffraction=None, surfbeat=None, scat=None, deactivate=None), prop=PROP(model_type='prop', scheme=BSBT(model_type='bsbt')), numeric=NUMERIC(model_type='numeric', stop=STOPC(model_type='stopc', dabs=0.02, drel=0.02, curvat=0.02, npnts=98.0, mode=STAT(model_type='stat', mxitst=3, alfa=None), limiter=None), dirimpl=None, sigimpl=None, ctheta=None, csigma=None, setup=None), output=OUTPUT(model_type='output', frame=None, group=None, curve=None, ray=None, isoline=None, points=POINTS(model_type='points', sname='pts', xp=[114.0, 112.5, 115.0], yp=[-34.0, -26.0, -30.0]), ngrid=None, quantity=QUANTITIES(model_type='quantities', quantities=[QUANTITY(model_type='quantity', output=[&lt;BlockOptions.DEPTH: 'depth'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;, &lt;BlockOptions.TM01: 'tm01'&gt;], short=None, long=None, lexp=None, hexp=None, excv=-9.0, power=None, ref=None, fswell=None, noswll=None, fmin=None, fmax=None, coord=None), QUANTITY(model_type='quantity', output=[&lt;BlockOptions.HSWELL: 'hswell'&gt;], short=None, long=None, lexp=None, hexp=None, excv=None, power=None, ref=None, fswell=0.125, noswll=None, fmin=None, fmax=None, coord=None)]), output_options=None, block=BLOCK(model_type='block', sname='COMPGRID', fname='swangrid.nc', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='blk'), header=None, idla=None, output=[&lt;BlockOptions.DEPTH: 'depth'&gt;, &lt;BlockOptions.WIND: 'wind'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;], unit=None), table=TABLE(model_type='table', sname='pts', fname='swantable.txt', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='tbl'), format='header', output=[&lt;BlockOptions.TIME: 'time'&gt;, &lt;BlockOptions.HSIGN: 'hsign'&gt;, &lt;BlockOptions.HSWELL: 'hswell'&gt;, &lt;BlockOptions.DIR: 'dir'&gt;, &lt;BlockOptions.TPS: 'tps'&gt;, &lt;BlockOptions.TM01: 'tm01'&gt;]), specout=SPECOUT(model_type='specout', sname='pts', fname='swanspec.nc', times=TimeRangeOpen(model_type='open', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='hr', suffix='spc'), dim=SPEC2D(model_type='spec2d'), freq=ABS(model_type='abs')), nestout=None, test=None), lockup=LOCKUP(model_type='lockup', compute=COMPUTE_STAT(model_type='stat', times=NONSTATIONARY(model_type='nonstationary', tbeg=datetime.datetime(1970, 1, 1, 0, 0), delt=datetime.timedelta(seconds=3600), tfmt=1, dfmt='sec', suffix='', tend=datetime.datetime(1970, 1, 2, 0, 0)), hotfile=HOTFILE(model_type='hotfile', fname=PosixPath('hotfile.txt'), format='free'), hottimes=[1, -1], suffix='_%Y%m%dT%H%M%S')))</pre> In\u00a0[5]: Copied! <pre># Project\n\nprint(config.startup.project.render())\n</pre> # Project  print(config.startup.project.render()) <pre>PROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing'\n</pre> In\u00a0[6]: Copied! <pre># Source terms\n\nprint(config.physics.gen.render())\n</pre> # Source terms  print(config.physics.gen.render()) <pre>GEN3 KOMEN cds2=2.3e-05 stpm=0.00302 DRAG WU\n</pre> In\u00a0[7]: Copied! <pre>def set_experiment(config, source_terms):\n    \"\"\"Return a new config object for a given experiment\"\"\"\n    new_config = deepcopy(config)\n    new_config.startup.project.title2 = f\"Experiment {source_terms.model_type.upper()}\"\n    new_config.physics.gen.source_terms = source_terms\n    return new_config\n</pre> def set_experiment(config, source_terms):     \"\"\"Return a new config object for a given experiment\"\"\"     new_config = deepcopy(config)     new_config.startup.project.title2 = f\"Experiment {source_terms.model_type.upper()}\"     new_config.physics.gen.source_terms = source_terms     return new_config In\u00a0[8]: Copied! <pre>from rompy.core.time import TimeRange\n\nperiod = TimeRange(\n    start=\"2023-01-01T00:00:00\",\n    end=\"2023-01-02T00:00:00\",\n    interval=\"1h\"\n)\n\nprint(period)\n</pre> from rompy.core.time import TimeRange  period = TimeRange(     start=\"2023-01-01T00:00:00\",     end=\"2023-01-02T00:00:00\",     interval=\"1h\" )  print(period) <pre>\n\tStart: 2023-01-01 00:00:00\n\tEnd: 2023-01-02 00:00:00\n\tDuration: 1 day\n\tInterval: 1:00:00\n\tInclude End: True\n\n</pre> In\u00a0[9]: Copied! <pre>from rompy.model import ModelRun\nfrom rompy_swan.subcomponents.physics import KOMEN, JANSSEN, WESTHUYSEN, ST6C1, ST6C2, ST6C3, ST6C4, ST6C5\nruns = []\nfor component in [KOMEN, JANSSEN, WESTHUYSEN, ST6C1, ST6C2, ST6C3, ST6C4, ST6C5]:\n    source_terms = component()\n    run_id = f\"{source_terms.model_type.lower()}\"\n    new_config = set_experiment(config, source_terms=source_terms)\n\n    print(f\"\\n{new_config.startup.project.render()}\")\n    print(f\"{new_config.physics.gen.source_terms.render()}\")\n\n    runs.append(ModelRun(\n        run_id=run_id,\n        config=new_config,\n        period=period,\n        output_dir=str(workdir)),\n    )\n</pre> from rompy.model import ModelRun from rompy_swan.subcomponents.physics import KOMEN, JANSSEN, WESTHUYSEN, ST6C1, ST6C2, ST6C3, ST6C4, ST6C5 runs = [] for component in [KOMEN, JANSSEN, WESTHUYSEN, ST6C1, ST6C2, ST6C3, ST6C4, ST6C5]:     source_terms = component()     run_id = f\"{source_terms.model_type.lower()}\"     new_config = set_experiment(config, source_terms=source_terms)      print(f\"\\n{new_config.startup.project.render()}\")     print(f\"{new_config.physics.gen.source_terms.render()}\")      runs.append(ModelRun(         run_id=run_id,         config=new_config,         period=period,         output_dir=str(workdir)),     ) <pre>\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment KOMEN'\nKOMEN DRAG WU\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment JANSSEN'\nJANSSEN DRAG WU\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment WESTHUYSEN'\nWESTHUYSEN DRAG WU\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment ST6C1'\nST6 a1sds=4.7e-07 a2sds=6.6e-06 p1sds=4.0 p2sds=4.0 UP HWANG VECTAU U10PROXY windscaling=28.0 AGROW\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment ST6C2'\nST6 a1sds=4.7e-07 a2sds=6.6e-06 p1sds=4.0 p2sds=4.0 UP FAN VECTAU U10PROXY windscaling=28.0 AGROW\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment ST6C3'\nST6 a1sds=2.8e-06 a2sds=3.5e-05 p1sds=4.0 p2sds=4.0 UP HWANG VECTAU U10PROXY windscaling=32.0 AGROW\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment ST6C4'\nST6 a1sds=2.8e-06 a2sds=3.5e-05 p1sds=4.0 p2sds=4.0 UP HWANG VECTAU U10PROXY windscaling=32.0 DEBIAS cdfac=0.89 AGROW\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment ST6C5'\nST6 a1sds=6.5e-06 a2sds=8.5e-05 p1sds=4.0 p2sds=4.0 UP HWANG VECTAU U10PROXY windscaling=35.0 DEBIAS cdfac=0.89 AGROW\n</pre> In\u00a0[10]: Copied! <pre>for run in runs:\n    run()\n</pre> for run in runs:     run() <pre>2025-09-18 21:31:48 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:48 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy.model         :             Run ID : komen\n2025-09-18 21:31:48 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:48 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:48 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:48 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:48 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:48 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:48 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy.model         : \n2025-09-18 21:31:48 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:48 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] root                : \n2025-09-18 21:31:48 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:48 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:48 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:48 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:48 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:48 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:48 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:48 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:48 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:48 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:48 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:48 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:48 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:48 [INFO] rompy.model         :   \n2025-09-18 21:31:48 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:48 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy.model         : \n2025-09-18 21:31:48 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:48 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:48 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:48 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:48 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:48 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy_swan.config   : \n2025-09-18 21:31:48 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:48 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:48 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:48 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/komen/bottom.grd\n2025-09-18 21:31:48 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:48 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:48 [INFO] rompy_swan.data     : \n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.18 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/komen/wind.grd\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.06 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy.model         : Rendering model templates to example_sensitivity/komen...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.03 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Total process time:  0.03 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/komen\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/komen\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         :             Run ID : janssen\n2025-09-18 21:31:49 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:49 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:49 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:49 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] root                : \n2025-09-18 21:31:49 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:49 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:49 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:49 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:49 [INFO] rompy.model         :   \n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:49 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/janssen/bottom.grd\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.05 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/janssen/wind.grd\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.10 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy.model         : Rendering model templates to example_sensitivity/janssen...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/janssen\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/janssen\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         :             Run ID : westhuysen\n2025-09-18 21:31:49 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:49 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:49 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:49 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] root                : \n2025-09-18 21:31:49 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:49 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:49 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:49 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:49 [INFO] rompy.model         :   \n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:49 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/westhuysen/bottom.grd\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.02 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/westhuysen/wind.grd\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 Completed in 0.10 seconds\n2025-09-18 21:31:49 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy.model         : Rendering model templates to example_sensitivity/westhuysen...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:49 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Total process time:  0.01 seconds\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:49 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/westhuysen\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/westhuysen\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         :             Run ID : st6c1\n2025-09-18 21:31:49 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:49 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:49 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:49 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:49 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] root                : \n2025-09-18 21:31:49 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:49 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:49 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:49 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:49 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:49 [INFO] rompy.model         :   \n2025-09-18 21:31:49 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:49 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : \n2025-09-18 21:31:49 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:49 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:49 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:49 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : \n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:49 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:49 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:49 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:49 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c1/bottom.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Completed in 0.05 seconds\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c1/wind.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Completed in 0.10 seconds\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \n2025-09-18 21:31:50 [INFO] rompy.model         : Rendering model templates to example_sensitivity/st6c1...\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Total process time:  0.01 seconds\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c1\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c1\n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         :             Run ID : st6c2\n2025-09-18 21:31:50 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:50 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:50 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:50 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] root                : \n2025-09-18 21:31:50 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:50 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:50 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:50 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:50 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:50 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:50 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:50 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:50 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:50 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:50 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:50 [INFO] rompy.model         :   \n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:50 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \n2025-09-18 21:31:50 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c2/bottom.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Completed in 0.04 seconds\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c2/wind.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Completed in 0.10 seconds\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \n2025-09-18 21:31:50 [INFO] rompy.model         : Rendering model templates to example_sensitivity/st6c2...\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:50 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:50 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c2\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c2\n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         :             Run ID : st6c3\n2025-09-18 21:31:50 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:50 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:50 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:50 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:50 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] root                : \n2025-09-18 21:31:50 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:50 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:50 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:50 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:50 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:50 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:50 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:50 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:50 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:50 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:50 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:50 [INFO] rompy.model         :   \n2025-09-18 21:31:50 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:50 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : \n2025-09-18 21:31:50 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:50 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:50 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:50 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : \n2025-09-18 21:31:50 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:50 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:50 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:50 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c3/bottom.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Completed in 0.04 seconds\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:50 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c3/wind.grd\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:50 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Completed in 0.12 seconds\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \n2025-09-18 21:31:51 [INFO] rompy.model         : Rendering model templates to example_sensitivity/st6c3...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c3\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c3\n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         :             Run ID : st6c4\n2025-09-18 21:31:51 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:51 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:51 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:51 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] root                : \n2025-09-18 21:31:51 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:51 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:51 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:51 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:51 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:51 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:51 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:51 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:51 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:51 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:51 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:51 [INFO] rompy.model         :   \n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:51 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \n2025-09-18 21:31:51 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c4/bottom.grd\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Completed in 0.04 seconds\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c4/wind.grd\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Completed in 0.12 seconds\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \n2025-09-18 21:31:51 [INFO] rompy.model         : Rendering model templates to example_sensitivity/st6c4...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c4\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c4\n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                      MODEL RUN CONFIGURATION                       \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         :             Run ID : st6c5\n2025-09-18 21:31:51 [INFO] rompy.model         :         Model Type : SwanConfig\n2025-09-18 21:31:51 [INFO] rompy.model         :         Start Time : 2023-01-01T00:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :           End Time : 2023-01-02T00:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :           Duration : 1 day\n2025-09-18 21:31:51 [INFO] rompy.model         :      Time Interval : 1:00:00\n2025-09-18 21:31:51 [INFO] rompy.model         :   Output Directory : example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] root                : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] root                : \u2503                  MODEL CONFIGURATION (SwanConfig)                  \u2503\n2025-09-18 21:31:51 [INFO] root                : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] root                : \n2025-09-18 21:31:51 [INFO] rompy.model         : SwanConfig:\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2503                   SWAN COMPONENTS CONFIGURATION                    \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Computational Grid: REGULAR\n2025-09-18 21:31:51 [INFO] rompy.model         :         Resolution: 14x24 cells\n2025-09-18 21:31:51 [INFO] rompy.model         :         Origin: (110.0, -35.2)\n2025-09-18 21:31:51 [INFO] rompy.model         :         Rotation: 4.0\u00b0\n2025-09-18 21:31:51 [INFO] rompy.model         :         Size: 7.5x12.5\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Startup: STARTUP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Input Grid: DataInterface\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Boundary: BOUNDSPEC\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Initial: INITIAL\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Physics: PHYSICS\n2025-09-18 21:31:51 [INFO] rompy.model         :         Generation: GEN3\n2025-09-18 21:31:51 [INFO] rompy.model         :         Breaking: NoneType\n2025-09-18 21:31:51 [INFO] rompy.model         :         Friction: FRICTION_JONSWAP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Propagation: PROP\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Numerics: NUMERIC\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Output: OUTPUT\n2025-09-18 21:31:51 [INFO] rompy.model         :         Quantities: 2 output group(s)\n2025-09-18 21:31:51 [INFO] rompy.model         :         Block output: Yes\n2025-09-18 21:31:51 [INFO] rompy.model         :         Spectral output: Yes\n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Lock-up: LOCKUP\n2025-09-18 21:31:51 [INFO] rompy.model         :   \n2025-09-18 21:31:51 [INFO] rompy.model         :     \u2022 Template: .../csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.model         :   \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                     STARTING MODEL GENERATION                      \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : Preparing input files in example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.model         : Processing model configuration...\n2025-09-18 21:31:51 [INFO] rompy.model         : Running configuration callable...\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2503                   PROCESSING SWAN CONFIGURATION                    \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \n2025-09-18 21:31:51 [INFO] rompy_swan.config   : Configuration components:\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - CGRID: REGULAR\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2503                         GRID CONFIGURATION                         \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2520\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2528\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Type:       REG\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Resolution: 14x24 cells\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Origin:     (110.0, -35.2)\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Rotation:   4.0\u00b0\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Size:       7.5x12.5\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \n2025-09-18 21:31:51 [INFO] rompy_swan.config   :       \u2022 Spectrum:\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :           Direction bins: 36\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :           Frequency range: 0.04 - 1.0 Hz\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Startup: STARTUP\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Input Grid: DataInterface\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Boundary: BOUNDSPEC\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Physics: PHYSICS\n2025-09-18 21:31:51 [INFO] rompy_swan.config   :   - Output: OUTPUT\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : Rendering SWAN configuration components\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                      WRITING BOTTOM GRID DATA                      \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c5/bottom.grd\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: elevation with shape (15, 10)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Scaling factor: -1.0\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                      WRITING SWAN ASCII DATA                       \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Completed in 0.05 seconds\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2503                       WRITING WIND GRID DATA                       \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.data     : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Output file: example_sensitivity/st6c5/wind.grd\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: u10 with shape (5, 3, 2)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Variable: v10 with shape (5, 3, 2)\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Scaling factor: 1.0\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 Completed in 0.11 seconds\n2025-09-18 21:31:51 [INFO] rompy_swan.data     :   \u2022 File size: 0.00 MB\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2503               SWAN CONFIGURATION RENDERING COMPLETE                \u2503\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy_swan.config   : \n2025-09-18 21:31:51 [INFO] rompy.model         : Rendering model templates to example_sensitivity/st6c5...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template source: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Output directory: example_sensitivity\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Using template version: main\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Locating template repository...\n2025-09-18 21:31:51 [INFO] rompy.core.render   : Template repository located at: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Generating files from template...\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Rendering time:      0.01 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Total process time:  0.02 seconds\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Files created:       3\n2025-09-18 21:31:51 [INFO] rompy.core.render   :   \u2022 Output location:     /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c5\n2025-09-18 21:31:51 [INFO] rompy.model         : \n2025-09-18 21:31:51 [INFO] rompy.model         : \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2503                     MODEL GENERATION COMPLETE                      \u2503\n2025-09-18 21:31:51 [INFO] rompy.model         : \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n2025-09-18 21:31:51 [INFO] rompy.model         : Model files generated at: /source/csiro/rompy-notebooks/notebooks/swan/example_sensitivity/st6c5\n</pre> In\u00a0[11]: Copied! <pre>modeldirs = sorted(workdir.glob(\"*\"))\nmodeldirs\n</pre> modeldirs = sorted(workdir.glob(\"*\")) modeldirs Out[11]: <pre>[PosixPath('example_sensitivity/janssen'),\n PosixPath('example_sensitivity/komen'),\n PosixPath('example_sensitivity/st6c1'),\n PosixPath('example_sensitivity/st6c2'),\n PosixPath('example_sensitivity/st6c3'),\n PosixPath('example_sensitivity/st6c4'),\n PosixPath('example_sensitivity/st6c5'),\n PosixPath('example_sensitivity/westhuysen')]</pre> In\u00a0[12]: Copied! <pre>sorted(modeldirs[0].glob(\"*\"))\n</pre> sorted(modeldirs[0].glob(\"*\")) Out[12]: <pre>[PosixPath('example_sensitivity/janssen/INPUT'),\n PosixPath('example_sensitivity/janssen/bottom.grd'),\n PosixPath('example_sensitivity/janssen/wind.grd')]</pre> In\u00a0[13]: Copied! <pre>input = modeldirs[0] / \"INPUT\"\nprint(input.read_text())\n</pre> input = modeldirs[0] / \"INPUT\" print(input.read_text()) <pre>! Rompy SwanConfig\n! Template: /source/csiro/rompy-swan/src/rompy_swan/templates/swan\n! Generated: 2025-09-18 09:31:49.226225 on rguedes-XPS-13-9350 by rguedes\n\n\n! Startup -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROJECT name='Test sensitivity' nr='run1' title1='Source terms sensitivity testing' title2='Experiment JANSSEN'\n\nSET level=0.0 depmin=0.05 NAUTICAL\n\nMODE NONSTATIONARY TWODIMENSIONAL\n\nCOORDINATES SPHERICAL CCM\n\n! Computational Grid --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nCGRID REGULAR xpc=110.0 ypc=-35.2 alpc=4.0 xlenc=7.5 ylenc=12.5 mxc=14 myc=24 CIRCLE mdc=36 flow=0.04 fhigh=1.0\n\n! Input Grids ---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nINPGRID BOTTOM REG 109.0 -36.0 0.0 9 14 1.0 1.0 EXC -99.0\nREADINP BOTTOM -1.0 'bottom.grd' 3 FREE\n\nINPGRID WIND REG 110.0 -35.0 0.0 1 2 5.0 5.0 EXC -99.0 NONSTATION 20230101.000000 6.00 HR\nREADINP WIND 1.0 'wind.grd' 3 0 1 0 FREE\n\n\n\n! Boundary and Initial conditions -------------------------------------------------------------------------------------------------------------------------------------------------\n\nBOUND SHAPESPEC TMA gamma=3.3 d=12.0 PEAK DSPR DEGREES\nBOUNDSPEC SIDE WEST CCW CONSTANT PAR hs=2.0 per=12.0 dir=255.0 dd=25.0\n\nINITIAL DEFAULT\n\n\n! Physics -------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGEN3 JANSSEN DRAG WU\n\nFRICTION JONSWAP CONSTANT cfjon=0.038\n\n\n! Numerics ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPROP BSBT\n\nNUMERIC STOPC dabs=0.02 drel=0.02 curvat=0.02 npnts=98.0 STATIONARY mxitst=3\n\n\n! Output --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPOINTS sname='pts' &amp;\n    xp=114.0 yp=-34.0 &amp;\n    xp=112.5 yp=-26.0 &amp;\n    xp=115.0 yp=-30.0\n\nQUANTITY DEPTH HSIGN TPS DIR TM01 excv=-9.0\n\nQUANTITY HSWELL fswell=0.125\n\nBLOCK sname='COMPGRID' fname='swangrid.nc' &amp;\n    DEPTH &amp;\n    WIND &amp;\n    HSIGN &amp;\n    TPS &amp;\n    DIR &amp;\n    OUTPUT tbegblk=20230101.000000 deltblk=1.0 HR\n\nTABLE sname='pts' HEADER fname='swantable.txt' &amp;\n    TIME &amp;\n    HSIGN &amp;\n    HSWELL &amp;\n    DIR &amp;\n    TPS &amp;\n    TM01 &amp;\n    OUTPUT tbegtbl=20230101.000000 delttbl=1.0 HR\n\nSPECOUT sname='pts' SPEC2D ABS fname='swanspec.nc' OUTPUT tbegspc=20230101.000000 deltspc=1.0 HR\n\n\n! Lockup --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nCOMPUTE STATIONARY time=20230101.000000\nCOMPUTE STATIONARY time=20230101.010000\nHOTFILE fname='hotfile_20230101T010000.txt' FREE\nCOMPUTE STATIONARY time=20230101.020000\nCOMPUTE STATIONARY time=20230101.030000\nCOMPUTE STATIONARY time=20230101.040000\nCOMPUTE STATIONARY time=20230101.050000\nCOMPUTE STATIONARY time=20230101.060000\nCOMPUTE STATIONARY time=20230101.070000\nCOMPUTE STATIONARY time=20230101.080000\nCOMPUTE STATIONARY time=20230101.090000\nCOMPUTE STATIONARY time=20230101.100000\nCOMPUTE STATIONARY time=20230101.110000\nCOMPUTE STATIONARY time=20230101.120000\nCOMPUTE STATIONARY time=20230101.130000\nCOMPUTE STATIONARY time=20230101.140000\nCOMPUTE STATIONARY time=20230101.150000\nCOMPUTE STATIONARY time=20230101.160000\nCOMPUTE STATIONARY time=20230101.170000\nCOMPUTE STATIONARY time=20230101.180000\nCOMPUTE STATIONARY time=20230101.190000\nCOMPUTE STATIONARY time=20230101.200000\nCOMPUTE STATIONARY time=20230101.210000\nCOMPUTE STATIONARY time=20230101.220000\nCOMPUTE STATIONARY time=20230101.230000\nCOMPUTE STATIONARY time=20230102.000000\nHOTFILE fname='hotfile_20230102T000000.txt' FREE\nSTOP\n</pre> In\u00a0[14]: Copied! <pre>for modeldir in modeldirs:\n    cmd = [\"docker\", \"run\", \"-v\", f\"./{modeldir}:/home\", \"oceanum/swan:4141\", \"swan.exe\", \"&gt;\", f\"{modeldir}/swan.log\"]\n    print(\" \".join(cmd))\n    os.system(\" \".join(cmd))\n</pre> for modeldir in modeldirs:     cmd = [\"docker\", \"run\", \"-v\", f\"./{modeldir}:/home\", \"oceanum/swan:4141\", \"swan.exe\", \"&gt;\", f\"{modeldir}/swan.log\"]     print(\" \".join(cmd))     os.system(\" \".join(cmd)) <pre>docker run -v ./example_sensitivity/janssen:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/janssen/swan.log\ndocker run -v ./example_sensitivity/komen:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/komen/swan.log\ndocker run -v ./example_sensitivity/st6c1:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/st6c1/swan.log\ndocker run -v ./example_sensitivity/st6c2:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/st6c2/swan.log\ndocker run -v ./example_sensitivity/st6c3:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/st6c3/swan.log\ndocker run -v ./example_sensitivity/st6c4:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/st6c4/swan.log\ndocker run -v ./example_sensitivity/st6c5:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/st6c5/swan.log\ndocker run -v ./example_sensitivity/westhuysen:/home oceanum/swan:4141 swan.exe &gt; example_sensitivity/westhuysen/swan.log\n</pre> In\u00a0[15]: Copied! <pre># Check for output files\nfor modeldir in modeldirs:\n    print(sorted(modeldir.glob(\"*.nc\")))\n</pre> # Check for output files for modeldir in modeldirs:     print(sorted(modeldir.glob(\"*.nc\"))) <pre>[PosixPath('example_sensitivity/janssen/swangrid.nc'), PosixPath('example_sensitivity/janssen/swanspec.nc')]\n[PosixPath('example_sensitivity/komen/swangrid.nc'), PosixPath('example_sensitivity/komen/swanspec.nc')]\n[PosixPath('example_sensitivity/st6c1/swangrid.nc'), PosixPath('example_sensitivity/st6c1/swanspec.nc')]\n[PosixPath('example_sensitivity/st6c2/swangrid.nc'), PosixPath('example_sensitivity/st6c2/swanspec.nc')]\n[PosixPath('example_sensitivity/st6c3/swangrid.nc'), PosixPath('example_sensitivity/st6c3/swanspec.nc')]\n[PosixPath('example_sensitivity/st6c4/swangrid.nc'), PosixPath('example_sensitivity/st6c4/swanspec.nc')]\n[PosixPath('example_sensitivity/st6c5/swangrid.nc'), PosixPath('example_sensitivity/st6c5/swanspec.nc')]\n[PosixPath('example_sensitivity/westhuysen/swangrid.nc'), PosixPath('example_sensitivity/westhuysen/swanspec.nc')]\n</pre> In\u00a0[16]: Copied! <pre>import os\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom wavespectra import read_ncswan, read_swan\nfrom wavespectra.core.swan import read_tab\n\npd.set_option(\"display.notebook_repr_html\", False)\n</pre> import os import numpy as np import pandas as pd import xarray as xr import matplotlib.pyplot as plt import cartopy.crs as ccrs from wavespectra import read_ncswan, read_swan from wavespectra.core.swan import read_tab  pd.set_option(\"display.notebook_repr_html\", False) In\u00a0[17]: Copied! <pre>def read_gridded_output(run):\n    \"\"\"Read mean gridded output from a model run\"\"\"\n    modeldir = Path(run.output_dir) / run.run_id\n    dset = xr.open_dataset(modeldir / run.config.output.block.fname)\n    return dset.mean(\"time\")\n\n\ndef read_spectra_output(run):\n    \"\"\"Read mean spectra output from a model run\"\"\"\n    modeldir = Path(run.output_dir) / run.run_id\n    dset = read_ncswan(modeldir / run.config.output.specout.fname)\n    return dset.mean(\"time\")\n</pre> def read_gridded_output(run):     \"\"\"Read mean gridded output from a model run\"\"\"     modeldir = Path(run.output_dir) / run.run_id     dset = xr.open_dataset(modeldir / run.config.output.block.fname)     return dset.mean(\"time\")   def read_spectra_output(run):     \"\"\"Read mean spectra output from a model run\"\"\"     modeldir = Path(run.output_dir) / run.run_id     dset = read_ncswan(modeldir / run.config.output.specout.fname)     return dset.mean(\"time\") In\u00a0[18]: Copied! <pre># Gridded parameters\n\ndsgrid = xr.concat([read_gridded_output(run) for run in runs], dim=\"source_terms\")\ndsgrid[\"source_terms\"] = [run.run_id for run in runs]\ndsgrid\n</pre> # Gridded parameters  dsgrid = xr.concat([read_gridded_output(run) for run in runs], dim=\"source_terms\") dsgrid[\"source_terms\"] = [run.run_id for run in runs] dsgrid Out[18]: <pre>&lt;xarray.Dataset&gt; Size: 75kB\nDimensions:       (source_terms: 8, yc: 25, xc: 15)\nCoordinates:\n    longitude     (yc, xc) float32 2kB 110.0 110.5 111.1 ... 115.5 116.1 116.6\n    latitude      (yc, xc) float32 2kB -35.2 -35.16 -35.13 ... -22.24 -22.21\n  * source_terms  (source_terms) &lt;U10 320B 'komen' 'janssen' ... 'st6c4' 'st6c5'\nDimensions without coordinates: yc, xc\nData variables:\n    depth         (source_terms, yc, xc) float32 12kB 4.824e+03 4.16e+03 ... nan\n    xwnd          (source_terms, yc, xc) float32 12kB -0.8986 -1.029 ... nan nan\n    ywnd          (source_terms, yc, xc) float32 12kB 6.718 6.65 ... nan nan\n    hs            (source_terms, yc, xc) float32 12kB 1.019 0.6307 ... nan nan\n    tps           (source_terms, yc, xc) float32 12kB 11.66 11.66 ... nan nan\n    theta0        (source_terms, yc, xc) float32 12kB 255.5 291.2 ... nan nan</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>source_terms: 8</li><li>yc: 25</li><li>xc: 15</li></ul></li><li>Coordinates: (3)<ul><li>longitude(yc, xc)float32110.0 110.5 111.1 ... 116.1 116.6units :degrees_eastlong_name :longitudestandard_name :longitude<pre>array([[110.      , 110.53441 , 111.06882 , 111.603226, 112.137634,\n        112.67204 , 113.20646 , 113.74087 , 114.275276, 114.809685,\n        115.34409 , 115.8785  , 116.41291 , 116.94732 , 117.48173 ],\n       [109.96367 , 110.49808 , 111.032486, 111.566895, 112.1013  ,\n        112.63571 , 113.17013 , 113.70454 , 114.238945, 114.77335 ,\n        115.30776 , 115.84217 , 116.37658 , 116.91099 , 117.4454  ],\n       [109.92734 , 110.46175 , 110.996155, 111.53056 , 112.06497 ,\n        112.59938 , 113.13379 , 113.668205, 114.202614, 114.73702 ,\n        115.27143 , 115.80584 , 116.34025 , 116.87466 , 117.409065],\n       [109.89101 , 110.425415, 110.95982 , 111.49423 , 112.02864 ,\n        112.56305 , 113.09746 , 113.631874, 114.16628 , 114.70069 ,\n        115.2351  , 115.76951 , 116.30392 , 116.838326, 117.372734],\n       [109.854675, 110.389084, 110.92349 , 111.4579  , 111.99231 ,\n        112.52672 , 113.06113 , 113.59554 , 114.12995 , 114.66436 ,\n        115.19877 , 115.73318 , 116.267586, 116.801994, 117.3364  ],\n       [109.818344, 110.35275 , 110.88716 , 111.42157 , 111.95598 ,\n        112.49039 , 113.024796, 113.559204, 114.09362 , 114.62803 ,\n        115.16244 , 115.696846, 116.231255, 116.76566 , 117.30007 ],\n       [109.78201 , 110.31642 , 110.85083 , 111.38524 , 111.91965 ,\n        112.454056, 112.988464, 113.52287 , 114.05728 , 114.5917  ,\n...\n        114.690125, 115.22453 , 115.75894 , 116.29335 , 116.82777 ],\n       [109.3097  , 109.84411 , 110.37852 , 110.91293 , 111.44734 ,\n        111.98175 , 112.51616 , 113.05057 , 113.58498 , 114.119385,\n        114.65379 , 115.1882  , 115.72261 , 116.25702 , 116.791435],\n       [109.27337 , 109.80778 , 110.342186, 110.876595, 111.41101 ,\n        111.94542 , 112.47983 , 113.01424 , 113.548645, 114.08305 ,\n        114.61746 , 115.15187 , 115.68628 , 116.22069 , 116.755104],\n       [109.23704 , 109.77145 , 110.305855, 110.84026 , 111.37467 ,\n        111.90909 , 112.4435  , 112.977905, 113.512314, 114.04672 ,\n        114.58113 , 115.11554 , 115.64995 , 116.18436 , 116.718765],\n       [109.20071 , 109.735115, 110.26952 , 110.80393 , 111.33834 ,\n        111.87276 , 112.407166, 112.941574, 113.47598 , 114.01039 ,\n        114.5448  , 115.07921 , 115.61362 , 116.148026, 116.682434],\n       [109.164375, 109.698784, 110.23319 , 110.7676  , 111.30201 ,\n        111.836426, 112.370834, 112.90524 , 113.43965 , 113.97406 ,\n        114.50847 , 115.04288 , 115.577286, 116.111694, 116.6461  ],\n       [109.128044, 109.66245 , 110.19686 , 110.73127 , 111.26568 ,\n        111.80009 , 112.3345  , 112.86891 , 113.40332 , 113.93773 ,\n        114.47214 , 115.006546, 115.540955, 116.07536 , 116.60977 ]],\n      dtype=float32)</pre></li><li>latitude(yc, xc)float32-35.2 -35.16 ... -22.24 -22.21units :degrees_northlong_name :latitudestandard_name :latitude<pre>array([[-35.2     , -35.162632, -35.125263, -35.08789 , -35.05052 ,\n        -35.013153, -34.975784, -34.938416, -34.901043, -34.863674,\n        -34.826305, -34.788937, -34.751568, -34.714195, -34.676826],\n       [-34.680435, -34.643066, -34.605698, -34.56833 , -34.530956,\n        -34.493587, -34.45622 , -34.41885 , -34.38148 , -34.34411 ,\n        -34.30674 , -34.26937 , -34.232002, -34.194633, -34.15726 ],\n       [-34.160873, -34.1235  , -34.086132, -34.048763, -34.011395,\n        -33.974022, -33.936653, -33.899284, -33.861916, -33.824547,\n        -33.787178, -33.749805, -33.712437, -33.675068, -33.6377  ],\n       [-33.641308, -33.60394 , -33.566566, -33.529198, -33.49183 ,\n        -33.45446 , -33.41709 , -33.37972 , -33.34235 , -33.30498 ,\n        -33.267612, -33.230244, -33.19287 , -33.155502, -33.118134],\n       [-33.121742, -33.084373, -33.047005, -33.009632, -32.972263,\n        -32.934895, -32.897526, -32.860157, -32.822784, -32.785416,\n        -32.748047, -32.71068 , -32.67331 , -32.635937, -32.598568],\n       [-32.602177, -32.564808, -32.52744 , -32.49007 , -32.452698,\n        -32.41533 , -32.37796 , -32.34059 , -32.303223, -32.265854,\n        -32.22848 , -32.191113, -32.153744, -32.116375, -32.079002],\n       [-32.08261 , -32.045242, -32.007874, -31.970505, -31.933134,\n        -31.895765, -31.858397, -31.821026, -31.783657, -31.746286,\n...\n        -25.474142, -25.436771, -25.399403, -25.362034, -25.324665],\n       [-25.328274, -25.290903, -25.253532, -25.216164, -25.178795,\n        -25.141426, -25.104055, -25.066685, -25.029316, -24.991947,\n        -24.954578, -24.917208, -24.879837, -24.842468, -24.8051  ],\n       [-24.808708, -24.77134 , -24.73397 , -24.696602, -24.659231,\n        -24.62186 , -24.584492, -24.547123, -24.509754, -24.472383,\n        -24.435013, -24.397644, -24.360275, -24.322906, -24.285536],\n       [-24.289143, -24.251774, -24.214405, -24.177036, -24.139666,\n        -24.102295, -24.064926, -24.027557, -23.990189, -23.952818,\n        -23.915447, -23.878078, -23.84071 , -23.80334 , -23.76597 ],\n       [-23.769579, -23.732208, -23.69484 , -23.65747 , -23.620102,\n        -23.582731, -23.54536 , -23.507992, -23.470623, -23.433254,\n        -23.395884, -23.358513, -23.321144, -23.283775, -23.246407],\n       [-23.250015, -23.212646, -23.175276, -23.137907, -23.100536,\n        -23.063168, -23.025799, -22.988428, -22.95106 , -22.913689,\n        -22.87632 , -22.838951, -22.80158 , -22.764212, -22.726841],\n       [-22.73045 , -22.69308 , -22.65571 , -22.618341, -22.58097 ,\n        -22.543602, -22.506233, -22.468863, -22.431494, -22.394123,\n        -22.356754, -22.319386, -22.282015, -22.244646, -22.207275]],\n      dtype=float32)</pre></li><li>source_terms(source_terms)&lt;U10'komen' 'janssen' ... 'st6c5'<pre>array(['komen', 'janssen', 'westhuysen', 'st6c1', 'st6c2', 'st6c3', 'st6c4',\n       'st6c5'], dtype='&lt;U10')</pre></li></ul></li><li>Data variables: (6)<ul><li>depth(source_terms, yc, xc)float324.824e+03 4.16e+03 ... nan nan<pre>array([[[4823.951 , 4160.235 , 3517.904 , ...,       nan,       nan,\n               nan],\n        [4081.297 , 3441.2422, 2892.3357, ...,       nan,       nan,\n               nan],\n        [3056.671 , 2631.195 , 2384.4294, ...,       nan,       nan,\n               nan],\n        ...,\n        [3246.6487, 4145.945 , 4225.1567, ...,       nan,       nan,\n               nan],\n        [3510.1592, 4227.9146, 4563.9614, ...,       nan,       nan,\n               nan],\n        [3835.8284, 4350.438 , 4695.601 , ...,       nan,       nan,\n               nan]],\n\n       [[4823.951 , 4160.235 , 3517.904 , ...,       nan,       nan,\n               nan],\n        [4081.297 , 3441.2422, 2892.3357, ...,       nan,       nan,\n               nan],\n        [3056.671 , 2631.195 , 2384.4294, ...,       nan,       nan,\n               nan],\n...\n        [3246.6487, 4145.945 , 4225.1567, ...,       nan,       nan,\n               nan],\n        [3510.1592, 4227.9146, 4563.9614, ...,       nan,       nan,\n               nan],\n        [3835.8284, 4350.438 , 4695.601 , ...,       nan,       nan,\n               nan]],\n\n       [[4823.951 , 4160.235 , 3517.904 , ...,       nan,       nan,\n               nan],\n        [4081.297 , 3441.2422, 2892.3357, ...,       nan,       nan,\n               nan],\n        [3056.671 , 2631.195 , 2384.4294, ...,       nan,       nan,\n               nan],\n        ...,\n        [3246.6487, 4145.945 , 4225.1567, ...,       nan,       nan,\n               nan],\n        [3510.1592, 4227.9146, 4563.9614, ...,       nan,       nan,\n               nan],\n        [3835.8284, 4350.438 , 4695.601 , ...,       nan,       nan,\n               nan]]], shape=(8, 25, 15), dtype=float32)</pre></li><li>xwnd(source_terms, yc, xc)float32-0.8986 -1.029 -1.157 ... nan nan<pre>array([[[-0.8985871, -1.0285959, -1.157384 , ...,        nan,\n                nan,        nan],\n        [-1.1927854, -1.3132724, -1.432905 , ...,        nan,\n                nan,        nan],\n        [-1.6694846, -1.7384562, -1.8047427, ...,        nan,\n                nan,        nan],\n        ...,\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan]],\n\n       [[-0.8985871, -1.0285959, -1.157384 , ...,        nan,\n                nan,        nan],\n        [-1.1927854, -1.3132724, -1.432905 , ...,        nan,\n                nan,        nan],\n        [-1.6694846, -1.7384562, -1.8047427, ...,        nan,\n                nan,        nan],\n...\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan]],\n\n       [[-0.8985871, -1.0285959, -1.157384 , ...,        nan,\n                nan,        nan],\n        [-1.1927854, -1.3132724, -1.432905 , ...,        nan,\n                nan,        nan],\n        [-1.6694846, -1.7384562, -1.8047427, ...,        nan,\n                nan,        nan],\n        ...,\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan],\n        [       nan,        nan,        nan, ...,        nan,\n                nan,        nan]]], shape=(8, 25, 15), dtype=float32)</pre></li><li>ywnd(source_terms, yc, xc)float326.718 6.65 6.582 ... nan nan nan<pre>array([[[6.7184663, 6.650105 , 6.5822325, ...,       nan,       nan,\n               nan],\n        [6.903531 , 6.849573 , 6.785363 , ...,       nan,       nan,\n               nan],\n        [7.2056627, 7.13828  , 7.054905 , ...,       nan,       nan,\n               nan],\n        ...,\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan]],\n\n       [[6.7184663, 6.650105 , 6.5822325, ...,       nan,       nan,\n               nan],\n        [6.903531 , 6.849573 , 6.785363 , ...,       nan,       nan,\n               nan],\n        [7.2056627, 7.13828  , 7.054905 , ...,       nan,       nan,\n               nan],\n...\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan]],\n\n       [[6.7184663, 6.650105 , 6.5822325, ...,       nan,       nan,\n               nan],\n        [6.903531 , 6.849573 , 6.785363 , ...,       nan,       nan,\n               nan],\n        [7.2056627, 7.13828  , 7.054905 , ...,       nan,       nan,\n               nan],\n        ...,\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan],\n        [      nan,       nan,       nan, ...,       nan,       nan,\n               nan]]], shape=(8, 25, 15), dtype=float32)</pre></li><li>hs(source_terms, yc, xc)float321.019 0.6307 0.6288 ... nan nan nan<pre>array([[[1.0192268 , 0.63066536, 0.6288341 , ...,        nan,\n                nan,        nan],\n        [1.1814324 , 1.3336895 , 1.2929169 , ...,        nan,\n                nan,        nan],\n        [1.2695091 , 1.4816737 , 1.4532303 , ...,        nan,\n                nan,        nan],\n        ...,\n        [1.7042453 , 1.9786367 , 1.9581891 , ...,        nan,\n                nan,        nan],\n        [1.6415908 , 1.8393509 , 1.8341626 , ...,        nan,\n                nan,        nan],\n        [1.5887021 , 1.671926  , 1.694815  , ...,        nan,\n                nan,        nan]],\n\n       [[1.0107424 , 0.6126289 , 0.60542625, ...,        nan,\n                nan,        nan],\n        [1.1889399 , 1.32725   , 1.2820215 , ...,        nan,\n                nan,        nan],\n        [1.2861719 , 1.4874724 , 1.4557636 , ...,        nan,\n                nan,        nan],\n...\n        [1.6818448 , 1.9637436 , 1.9407938 , ...,        nan,\n                nan,        nan],\n        [1.6280103 , 1.8407547 , 1.8310803 , ...,        nan,\n                nan,        nan],\n        [1.574511  , 1.67745   , 1.6956695 , ...,        nan,\n                nan,        nan]],\n\n       [[1.0049133 , 0.5968502 , 0.5881523 , ...,        nan,\n                nan,        nan],\n        [1.1108131 , 1.1534166 , 1.10535   , ...,        nan,\n                nan,        nan],\n        [1.1872003 , 1.3097018 , 1.2791528 , ...,        nan,\n                nan,        nan],\n        ...,\n        [1.7535931 , 2.0571308 , 2.0438855 , ...,        nan,\n                nan,        nan],\n        [1.6953642 , 1.9304483 , 1.9248636 , ...,        nan,\n                nan,        nan],\n        [1.6400958 , 1.7745602 , 1.7801449 , ...,        nan,\n                nan,        nan]]], shape=(8, 25, 15), dtype=float32)</pre></li><li>tps(source_terms, yc, xc)float3211.66 11.66 11.66 ... nan nan nan<pre>array([[[11.661121 , 11.661121 , 11.661732 , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.661793 , 11.66222  , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.662037 , 11.662708 , ...,        nan,\n                nan,        nan],\n        ...,\n        [ 7.6884065,  7.8873553,  7.903043 , ...,        nan,\n                nan,        nan],\n        [ 7.7627187,  7.927702 ,  7.9547405, ...,        nan,\n                nan,        nan],\n        [ 7.8102965,  7.9473553,  7.978271 , ...,        nan,\n                nan,        nan]],\n\n       [[11.661121 , 11.66164  , 11.662373 , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.662556 , 11.663898 , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.663197 , 10.905086 , ...,        nan,\n                nan,        nan],\n...\n        [ 7.538561 ,  7.665639 ,  7.6623135, ...,        nan,\n                nan,        nan],\n        [ 8.1478   ,  7.7109585,  7.7162695, ...,        nan,\n                nan,        nan],\n        [ 8.539263 ,  7.7229834,  7.735404 , ...,        nan,\n                nan,        nan]],\n\n       [[11.661121 , 11.661884 , 11.662403 , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.661884 , 11.66222  , ...,        nan,\n                nan,        nan],\n        [11.661121 , 11.661945 , 11.6628   , ...,        nan,\n                nan,        nan],\n        ...,\n        [ 7.7295146,  7.864436 ,  7.868037 , ...,        nan,\n                nan,        nan],\n        [ 7.7735524,  7.9105506,  7.9117393, ...,        nan,\n                nan,        nan],\n        [ 7.8086786,  7.9306006,  7.932705 , ...,        nan,\n                nan,        nan]]], shape=(8, 25, 15), dtype=float32)</pre></li><li>theta0(source_terms, yc, xc)float32255.5 291.2 291.5 ... nan nan nan<pre>array([[[255.51137, 291.2079 , 291.5412 , ...,       nan,       nan,\n               nan],\n        [232.16513, 207.59586, 205.65694, ...,       nan,       nan,\n               nan],\n        [215.15535, 197.54132, 198.0902 , ...,       nan,       nan,\n               nan],\n        ...,\n        [178.59105, 182.74272, 189.30594, ...,       nan,       nan,\n               nan],\n        [183.33075, 184.87103, 189.97305, ...,       nan,       nan,\n               nan],\n        [187.59137, 180.92574, 186.74869, ...,       nan,       nan,\n               nan]],\n\n       [[255.24213, 287.9488 , 287.68384, ...,       nan,       nan,\n               nan],\n        [229.47887, 206.4798 , 204.27303, ...,       nan,       nan,\n               nan],\n        [212.41219, 196.26465, 195.89618, ...,       nan,       nan,\n               nan],\n...\n        [178.39902, 182.91827, 189.82843, ...,       nan,       nan,\n               nan],\n        [182.74205, 184.25159, 189.59729, ...,       nan,       nan,\n               nan],\n        [187.41913, 180.35092, 186.54213, ...,       nan,       nan,\n               nan]],\n\n       [[255.1523 , 286.08612, 285.77368, ...,       nan,       nan,\n               nan],\n        [242.54309, 226.48305, 225.45906, ...,       nan,       nan,\n               nan],\n        [229.49602, 212.3399 , 212.71413, ...,       nan,       nan,\n               nan],\n        ...,\n        [175.19928, 180.99101, 187.77765, ...,       nan,       nan,\n               nan],\n        [179.3098 , 182.44803, 187.57178, ...,       nan,       nan,\n               nan],\n        [183.65086, 178.93758, 185.23143, ...,       nan,       nan,\n               nan]]], shape=(8, 25, 15), dtype=float32)</pre></li></ul></li><li>Indexes: (1)<ul><li>source_termsPandasIndex<pre>PandasIndex(Index(['komen', 'janssen', 'westhuysen', 'st6c1', 'st6c2', 'st6c3', 'st6c4',\n       'st6c5'],\n      dtype='object', name='source_terms'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[19]: Copied! <pre># Wave spectra\n\ndspec = xr.concat([read_spectra_output(run) for run in runs], dim=\"source_terms\")\ndspec[\"source_terms\"] = [run.run_id for run in runs]\ndspec\n</pre> # Wave spectra  dspec = xr.concat([read_spectra_output(run) for run in runs], dim=\"source_terms\") dspec[\"source_terms\"] = [run.run_id for run in runs] dspec Out[19]: <pre>&lt;xarray.Dataset&gt; Size: 122kB\nDimensions:       (source_terms: 8, site: 3, freq: 35, dir: 36)\nCoordinates:\n  * freq          (freq) float32 140B 0.04 0.04397 0.04834 ... 0.8275 0.9097 1.0\n  * dir           (dir) float32 144B 261.0 251.0 241.0 ... 291.0 281.0 271.0\n  * site          (site) int64 24B 1 2 3\n  * source_terms  (source_terms) &lt;U10 320B 'komen' 'janssen' ... 'st6c4' 'st6c5'\nData variables:\n    lon           (source_terms, site) float32 96B dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;\n    lat           (source_terms, site) float32 96B dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;\n    efth          (source_terms, site, freq, dir) float32 121kB dask.array&lt;chunksize=(1, 3, 35, 36), meta=np.ndarray&gt;\n    dpt           (source_terms, site) float32 96B dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;\n    wspd          (source_terms, site) float32 96B dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;\n    wdir          (source_terms, site) float32 96B dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>source_terms: 8</li><li>site: 3</li><li>freq: 35</li><li>dir: 36</li></ul></li><li>Coordinates: (4)<ul><li>freq(freq)float320.04 0.04397 0.04834 ... 0.9097 1.0units :s-1standard_name :wave_frequencyflow :0.04fhigh :0.9999985msc :34<pre>array([0.04    , 0.043972, 0.048338, 0.053138, 0.058415, 0.064215, 0.070592,\n       0.077602, 0.085307, 0.093778, 0.103091, 0.113327, 0.124581, 0.136951,\n       0.15055 , 0.1655  , 0.181934, 0.2     , 0.21986 , 0.241692, 0.265691,\n       0.292074, 0.321077, 0.35296 , 0.388008, 0.426537, 0.468892, 0.515452,\n       0.566636, 0.622902, 0.684756, 0.752752, 0.827499, 0.909669, 0.999999],\n      dtype=float32)</pre></li><li>dir(dir)float32261.0 251.0 241.0 ... 281.0 271.0<pre>array([261.      , 251.      , 241.      , 231.      , 221.      , 211.      ,\n       201.      , 191.      , 181.      , 171.      , 160.99998 , 151.      ,\n       141.      , 131.      , 120.999985, 110.999985, 100.99999 ,  90.99999 ,\n        80.99999 ,  70.999985,  60.999985,  50.999985,  40.99999 ,  30.999989,\n        20.99999 ,  10.999992,   0.999994, 350.99997 , 340.99997 , 330.99997 ,\n       320.99997 , 310.99997 , 300.99997 , 290.99997 , 281.      , 271.      ],\n      dtype=float32)</pre></li><li>site(site)int641 2 3<pre>array([1, 2, 3])</pre></li><li>source_terms(source_terms)&lt;U10'komen' 'janssen' ... 'st6c5'<pre>array(['komen', 'janssen', 'westhuysen', 'st6c1', 'st6c2', 'st6c3', 'st6c4',\n       'st6c5'], dtype='&lt;U10')</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(source_terms, site)float32dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;  Array   Chunk   Bytes   96 B   12 B   Shape   (8, 3)   (1, 3)   Dask graph   8 chunks in 25 graph layers   Data type   float32 numpy.ndarray  3 8 </li><li>lat(source_terms, site)float32dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;  Array   Chunk   Bytes   96 B   12 B   Shape   (8, 3)   (1, 3)   Dask graph   8 chunks in 25 graph layers   Data type   float32 numpy.ndarray  3 8 </li><li>efth(source_terms, site, freq, dir)float32dask.array&lt;chunksize=(1, 3, 35, 36), meta=np.ndarray&gt;  Array   Chunk   Bytes   118.12 kiB   14.77 kiB   Shape   (8, 3, 35, 36)   (1, 3, 35, 36)   Dask graph   8 chunks in 49 graph layers   Data type   float32 numpy.ndarray  8 1 36 35 3 </li><li>dpt(source_terms, site)float32dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;  Array   Chunk   Bytes   96 B   12 B   Shape   (8, 3)   (1, 3)   Dask graph   8 chunks in 41 graph layers   Data type   float32 numpy.ndarray  3 8 </li><li>wspd(source_terms, site)float32dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;  Array   Chunk   Bytes   96 B   12 B   Shape   (8, 3)   (1, 3)   Dask graph   8 chunks in 89 graph layers   Data type   float32 numpy.ndarray  3 8 </li><li>wdir(source_terms, site)float32dask.array&lt;chunksize=(1, 3), meta=np.ndarray&gt;  Array   Chunk   Bytes   96 B   12 B   Shape   (8, 3)   (1, 3)   Dask graph   8 chunks in 89 graph layers   Data type   float32 numpy.ndarray  3 8 </li></ul></li><li>Indexes: (4)<ul><li>freqPandasIndex<pre>PandasIndex(Index([ 0.03999999910593033,   0.0439719632267952,  0.04833833873271942,\n        0.05313829332590103, 0.058414872735738754,  0.06421541422605515,\n        0.07059194892644882,  0.07760166376829147,  0.08530744165182114,\n        0.09377838671207428,  0.10309050232172012,  0.11332729458808899,\n        0.12458059191703796,  0.13695132732391357,   0.1505504697561264,\n         0.1655000001192093,  0.18193399906158447,   0.1999998688697815,\n        0.21985965967178345,  0.24169152975082397,  0.26569128036499023,\n        0.29207417368888855,   0.3210768699645996,   0.3529595136642456,\n         0.3880080580711365,     0.42653688788414,  0.46889159083366394,\n         0.5154520869255066,   0.5666360259056091,   0.6229023933410645,\n         0.6847560405731201,   0.7527517080307007,    0.827499270439148,\n         0.9096691608428955,   0.9999985098838806],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([             261.0,              251.0,              241.0,\n                    231.0,              221.0,              211.0,\n                    201.0,              191.0,              181.0,\n                    171.0, 160.99998474121094,              151.0,\n                    141.0,              131.0, 120.99998474121094,\n       110.99998474121094, 100.99999237060547,  90.99999237060547,\n        80.99999237060547,  70.99998474121094,  60.99998474121094,\n        50.99998474121094,   40.9999885559082, 30.999988555908203,\n       20.999990463256836, 10.999992370605469, 0.9999943375587463,\n        350.9999694824219,  340.9999694824219,  330.9999694824219,\n        320.9999694824219,  310.9999694824219,  300.9999694824219,\n        290.9999694824219,              281.0,              271.0],\n      dtype='float32', name='dir'))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([1, 2, 3], dtype='int64', name='site'))</pre></li><li>source_termsPandasIndex<pre>PandasIndex(Index(['komen', 'janssen', 'westhuysen', 'st6c1', 'st6c2', 'st6c3', 'st6c4',\n       'st6c5'],\n      dtype='object', name='source_terms'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[20]: Copied! <pre>f = dsgrid.hs.plot(\n    x=\"longitude\",\n    y=\"latitude\",\n    col=\"source_terms\",\n    col_wrap=4,\n    vmin=0.5,\n    vmax=3.0,\n    cmap=\"turbo\",\n    subplot_kws=dict(projection=ccrs.PlateCarree()),\n    cbar_kwargs=dict(label=\"Hs (m)\"),\n)\nf.map(lambda: plt.gca().coastlines());\n</pre> f = dsgrid.hs.plot(     x=\"longitude\",     y=\"latitude\",     col=\"source_terms\",     col_wrap=4,     vmin=0.5,     vmax=3.0,     cmap=\"turbo\",     subplot_kws=dict(projection=ccrs.PlateCarree()),     cbar_kwargs=dict(label=\"Hs (m)\"), ) f.map(lambda: plt.gca().coastlines()); In\u00a0[21]: Copied! <pre>p = dspec.isel(site=0).spec.plot(col=\"source_terms\", col_wrap=4, cbar_kwargs={\"label\": \"Ed (m2/Hz/deg)\"})\n</pre> p = dspec.isel(site=0).spec.plot(col=\"source_terms\", col_wrap=4, cbar_kwargs={\"label\": \"Ed (m2/Hz/deg)\"})"},{"location":"examples/example_sensitivity/#swan-sensitivity-example","title":"SWAN sensitivity example\u00b6","text":"<p>In this notebook we will load the base config options from yaml file and define different SWAN workspaces for different source terms to simulate sensitivity testing</p>"},{"location":"examples/example_sensitivity/#workspace-basepath","title":"Workspace basepath\u00b6","text":""},{"location":"examples/example_sensitivity/#instantiate-model","title":"Instantiate model\u00b6","text":"<p>Use a fully-defined config from yaml to instantiate ModelRun with the runtime parameters and the config definition</p>"},{"location":"examples/example_sensitivity/#examine-components","title":"Examine components\u00b6","text":""},{"location":"examples/example_sensitivity/#sensitivity-config","title":"Sensitivity config\u00b6","text":""},{"location":"examples/example_sensitivity/#generate-workspaces","title":"Generate workspaces\u00b6","text":""},{"location":"examples/example_sensitivity/#check-the-workspace","title":"Check the workspace\u00b6","text":""},{"location":"examples/example_sensitivity/#run-the-model","title":"Run the model\u00b6","text":""},{"location":"examples/example_sensitivity/#plot-outputs","title":"Plot outputs\u00b6","text":""},{"location":"examples/example_sensitivity/#gridded-parameters","title":"Gridded parameters\u00b6","text":""},{"location":"examples/example_sensitivity/#wave-spectra","title":"Wave spectra\u00b6","text":""},{"location":"examples/boundary/boundnest1/","title":"SWAN BOUNDNEST1","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\nfrom pathlib import Path\nfrom tempfile import mkdtemp\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport wavespectra\n\nfrom rompy.core.source import SourceFile\nfrom rompy.core.time import TimeRange\nfrom rompy_swan.grid import SwanGrid\nfrom rompy_swan.boundary import Boundnest1\n\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> %load_ext autoreload %autoreload 2  import os from pathlib import Path from tempfile import mkdtemp import matplotlib.pyplot as plt import cartopy.crs as ccrs import wavespectra  from rompy.core.source import SourceFile from rompy.core.time import TimeRange from rompy_swan.grid import SwanGrid from rompy_swan.boundary import Boundnest1  import warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre>def plot_boundary_side(dset, bnd, grid, time):\n    \"\"\"Plot side boundary stats.\n\n    This function plots a snapshot of wave statistics from the source spectra dataset\n    and the boundary wave stats generated for a grid from those spectra points.\n\n    Parameters\n    ----------\n    dset: xr.Dataset\n        Source spectra dataset used to define boundary from.\n    bnd: xr.Dataset\n        Boundary dataset read from the SWAN ASCII file.\n    grid: SwanGrid\n        Grid object defining the SWAN domain.\n    time: Datatime | str\n        Time to plot.\n\n    \"\"\"\n    # xb, yb = bnd._boundary_points(grid)\n    xb = grid.x[:, 0]\n    yb = grid.y[:, 0]\n\n    fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))\n\n    # Hs\n    ax = axs[0]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)\n    plt.colorbar(p, label=\"Hs (m)\")\n    ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.hs(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"turbo\", vmin=2.0, vmax=3.5)\n\n    # Tp\n    ax = axs[1]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)\n    plt.colorbar(p, label=\"Tp (s)\")\n    ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.tp(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"viridis\", vmin=13.8, vmax=14.5)\n\n    # Dpm\n    ax = axs[2]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)\n    plt.colorbar(p, label=\"Dpm (deg)\")\n    ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.dpm(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"hsv\", vmin=220, vmax=225)\n\n    for ax in axs:\n        grid.plot(ax=ax, fscale=5)\n        ax.set_extent([110.5, 115.5, -29.5, -23.5])\n        ax.set_title(time)\n        ax.coastlines()\n</pre> def plot_boundary_side(dset, bnd, grid, time):     \"\"\"Plot side boundary stats.      This function plots a snapshot of wave statistics from the source spectra dataset     and the boundary wave stats generated for a grid from those spectra points.      Parameters     ----------     dset: xr.Dataset         Source spectra dataset used to define boundary from.     bnd: xr.Dataset         Boundary dataset read from the SWAN ASCII file.     grid: SwanGrid         Grid object defining the SWAN domain.     time: Datatime | str         Time to plot.      \"\"\"     # xb, yb = bnd._boundary_points(grid)     xb = grid.x[:, 0]     yb = grid.y[:, 0]      fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))      # Hs     ax = axs[0]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)     plt.colorbar(p, label=\"Hs (m)\")     ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.hs(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"turbo\", vmin=2.0, vmax=3.5)      # Tp     ax = axs[1]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)     plt.colorbar(p, label=\"Tp (s)\")     ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.tp(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"viridis\", vmin=13.8, vmax=14.5)      # Dpm     ax = axs[2]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)     plt.colorbar(p, label=\"Dpm (deg)\")     ax.scatter(bnd.lon, bnd.lat, s=40, c=bnd.sel(time=time).spec.dpm(), marker=\"s\", edgecolor=\"k\", linewidth=0.5, cmap=\"hsv\", vmin=220, vmax=225)      for ax in axs:         grid.plot(ax=ax, fscale=5)         ax.set_extent([110.5, 115.5, -29.5, -23.5])         ax.set_title(time)         ax.coastlines() In\u00a0[3]: Copied! <pre>datadir = Path(\"../../../../rompy-swan/tests/data\")\nmodeldir = Path(\"model\")\nmodeldir.mkdir(exist_ok=True)\n</pre> datadir = Path(\"../../../../rompy-swan/tests/data\") modeldir = Path(\"model\") modeldir.mkdir(exist_ok=True) In\u00a0[4]: Copied! <pre># source defines the dataset to be used to create the model boundary\n\nsource = SourceFile(\n    uri=datadir / \"aus-20230101.nc\",\n    kwargs=dict(engine=\"netcdf4\"),\n)\ndset = source.open()\ndset\n</pre> # source defines the dataset to be used to create the model boundary  source = SourceFile(     uri=datadir / \"aus-20230101.nc\",     kwargs=dict(engine=\"netcdf4\"), ) dset = source.open() dset Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (site: 412, time: 5, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 3kB 0 4 8 12 16 20 ... 1624 1628 1632 1636 1640 1644\n  * freq     (freq) float32 44B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float32 32B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    lon      (site) float32 2kB ...\n    lat      (site) float32 2kB ...\n    efth     (time, site, freq, dir) float64 1MB ...\n    dpt      (time, site) float32 8kB ...\n    wspd     (time, site) float32 8kB ...\n    wdir     (time, site) float32 8kB ...\nAttributes: (12/16)\n    product_name:           ww3.all_spec.nc\n    area:                   Global 0.5 x 0.5 degree\n    data_type:              OCO spectra 2D\n    format_version:         1.1\n    southernmost_latitude:  n/a\n    northernmost_latitude:  n/a\n    ...                     ...\n    minimum_altitude:       n/a\n    maximum_altitude:       n/a\n    altitude_resolution:    n/a\n    start_date:             2023-01-01 00:00:00\n    stop_date:              2023-02-01 00:00:00\n    field_type:             3-hourly</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 412</li><li>time: 5</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int640 4 8 12 16 ... 1632 1636 1640 1644<pre>array([   0,    4,    8, ..., 1636, 1640, 1644], shape=(412,))</pre></li><li>freq(freq)float320.05417 0.05959 ... 0.1277 0.1405standard_name :sea_surface_wave_frequencyunits :Hz<pre>array([0.054172, 0.059589, 0.065548, 0.072103, 0.079313, 0.087244, 0.095968,\n       0.105565, 0.116122, 0.127734, 0.140507], dtype=float32)</pre></li><li>dir(dir)float320.0 45.0 90.0 ... 225.0 270.0 315.0standard_name :sea_surface_wave_from_directionunits :degree<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.], dtype=float32)</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32...standard_name :longitudeunits :degrees_east<pre>[412 values with dtype=float32]</pre></li><li>lat(site)float32...standard_name :latitudeunits :degrees_north<pre>[412 values with dtype=float32]</pre></li><li>efth(time, site, freq, dir)float64...standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1<pre>[181280 values with dtype=float64]</pre></li><li>dpt(time, site)float32...standard_name :sea_floor_depth_below_sea_surfaceunits :m<pre>[2060 values with dtype=float32]</pre></li><li>wspd(time, site)float32...standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1<pre>[2060 values with dtype=float32]</pre></li><li>wdir(time, site)float32...standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree<pre>[2060 values with dtype=float32]</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([   0,    4,    8,   12,   16,   20,   24,   28,   32,   36,\n       ...\n       1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644],\n      dtype='int64', name='site', length=412))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417170003056526, 0.05958886817097664, 0.06554775685071945,\n       0.07210253179073334, 0.07931278645992279, 0.08724407106637955,\n       0.09596847742795944, 0.10556533187627792, 0.11612186580896378,\n       0.12773405015468597, 0.14050745964050293],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float32', name='dir'))</pre></li></ul></li><li>Attributes: (16)product_name :ww3.all_spec.ncarea :Global 0.5 x 0.5 degreedata_type :OCO spectra 2Dformat_version :1.1southernmost_latitude :n/anorthernmost_latitude :n/alatitude_resolution :n/awesternmost_longitude :n/aeasternmost_longitude :n/alongitude_resolution :n/aminimum_altitude :n/amaximum_altitude :n/aaltitude_resolution :n/astart_date :2023-01-01 00:00:00stop_date :2023-02-01 00:00:00field_type :3-hourly</li></ul> In\u00a0[5]: Copied! <pre># times prescribe the times over which the model will run\n\ntimes = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\")\nprint(times)\n</pre> # times prescribe the times over which the model will run  times = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\") print(times) <pre>\n\tStart: 2023-01-01 00:00:00\n\tEnd: 2023-01-02 00:00:00\n\tDuration: 1 day\n\tInterval: 6:00:00\n\tInclude End: True\n\n</pre> In\u00a0[6]: Copied! <pre># grid defines the model grid\n\ngrid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20)\nprint(grid)\n</pre> # grid defines the model grid  grid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20) print(grid) <pre>SwanGrid: REG, 8x9\n</pre> In\u00a0[7]: Copied! <pre># Plot model grid and boundary points in the source spectra\n\nfig, ax = grid.plot(fscale=5)\nax.plot(dset.lon, dset.lat, \"ok\")\nax.set_extent([108, 120, -35.5, -19])\n</pre> # Plot model grid and boundary points in the source spectra  fig, ax = grid.plot(fscale=5) ax.plot(dset.lon, dset.lat, \"ok\") ax.set_extent([108, 120, -35.5, -19]) In\u00a0[8]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = Boundnest1(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    rectangle=\"closed\",\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"head -n 80 {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = Boundnest1(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     rectangle=\"closed\", )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"head -n 80 {filename}\"); <pre>\"BOUNDNEST1 NEST 'wa.bnd' CLOSED\"</pre> <pre>SWAN   1                                Swan standard spectral file\n$   Created by wavespectra\n$   \nTIME                                    time-dependent data\n     1                                  time coding option\nLONLAT                                  locations in spherical coordinates\n    31                                  number of locations\n  112.000000  -29.000000\n  112.469846  -28.828990\n  112.939693  -28.657980\n  113.409539  -28.486970\n  113.879385  -28.315960\n  114.349232  -28.144950\n  114.819078  -27.973940\n  115.288924  -27.802929\n  115.117914  -27.333083\n  114.946904  -26.863237\n  114.775894  -26.393391\n  114.604884  -25.923544\n  114.433874  -25.453698\n  114.262864  -24.983852\n  114.091854  -24.514005\n  113.920844  -24.044159\n  113.450997  -24.215169\n  112.981151  -24.386179\n  112.511305  -24.557189\n  112.041458  -24.728199\n  111.571612  -24.899209\n  111.101766  -25.070219\n  110.631919  -25.241230\n  110.802929  -25.711076\n  110.973940  -26.180922\n  111.144950  -26.650768\n  111.315960  -27.120615\n  111.486970  -27.590461\n  111.657980  -28.060307\n  111.828990  -28.530154\n  112.000000  -29.000000\nAFREQ                                   absolute frequencies in Hz\n    11                                  number of frequencies\n    0.05417\n    0.05959\n    0.06555\n    0.07210\n    0.07931\n    0.08724\n    0.09597\n    0.10557\n    0.11612\n    0.12773\n    0.14051\nNDIR                                    spectral nautical directions in degr\n     8                                  number of directions\n     0.0000\n    45.0000\n    90.0000\n   135.0000\n   180.0000\n   225.0000\n   270.0000\n   315.0000\nQUANT\n     1                                  number of quantities in table\nVaDens                                  variance densities in m2/Hz/degr\nm2/Hz/degr                              unit\n   -99                                  exception value\n20230101.000000                         date and time\nFACTOR\n    3.77111971E-05\n    0    0    0    0  324  732    4    0\n    0    0    0    0  306 2831    2    0\n    0    0    0    0  211 8155    0    0\n    0    0    0    0  150 9998    0    0\n    0    0    0    0  124 5261    2    0\n    0    0    0    1   86 2541    3    5\n    0    0    0   11  143 1321    5   12\n    0    0    2   71  351  919    3    9\n    0    0    9  188  966  735    1    9\n    0    0   21  350 1357  565    0    2\n    0    0   18  687 1325  363    1    0\n</pre> In\u00a0[9]: Copied! <pre># Load the boundary created as a dataset\nds = wavespectra.read_swan(filename, as_site=True)\ndisplay(ds)\n\n# Plot boundary stats calculated from ds\nfor time in ds.time.to_index()[::2]:\n    plot_boundary_side(dset, ds, grid, time)\n</pre> # Load the boundary created as a dataset ds = wavespectra.read_swan(filename, as_site=True) display(ds)  # Plot boundary stats calculated from ds for time in ds.time.to_index()[::2]:     plot_boundary_side(dset, ds, grid, time) <pre>&lt;xarray.Dataset&gt; Size: 110kB\nDimensions:  (time: 5, site: 31, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 248B 1 2 3 4 5 6 7 8 9 ... 23 24 25 26 27 28 29 30 31\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 109kB 0.0 0.0 0.0 ... 4.87e-05 0.0\n    lat      (site) float64 248B -29.0 -28.83 -28.66 ... -28.06 -28.53 -29.0\n    lon      (site) float64 248B 112.0 112.5 112.9 113.4 ... 111.7 111.8 112.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 31</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int641 2 3 4 5 6 7 ... 26 27 28 29 30 31<pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 ... 4.87e-05 0.0standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.76045963e-02, 1.50844788e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.06760399e-01, 7.54223942e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.07534812e-01, 0.00000000e+00, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 3.39400774e-04, ...,\n          2.77177299e-02, 3.77111971e-05, 3.39400774e-04],\n         [0.00000000e+00, 0.00000000e+00, 7.91935139e-04, ...,\n          2.13068264e-02, 0.00000000e+00, 7.54223942e-05],\n         [0.00000000e+00, 0.00000000e+00, 6.78801548e-04, ...,\n          1.36891645e-02, 3.77111971e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.72222233e-02, 1.47545926e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.03392807e-01, 3.68864814e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.04608563e-01, 0.00000000e+00, 0.00000000e+00],\n...\n          3.66117027e-02, 8.90795686e-05, 2.22698922e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.24711396e-03, ...,\n          1.91521072e-02, 4.45397843e-05, 8.90795686e-05],\n         [0.00000000e+00, 0.00000000e+00, 2.36060857e-03, ...,\n          1.07786278e-02, 4.45397843e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          7.15820444e-03, 4.86952683e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          8.71158350e-02, 4.86952683e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.15760201e-01, 9.73905366e-05, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 1.36346751e-03, ...,\n          4.05144632e-02, 9.73905366e-05, 1.94781073e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.21738171e-03, ...,\n          2.15233086e-02, 0.00000000e+00, 9.73905366e-05],\n         [0.00000000e+00, 0.00000000e+00, 2.14259181e-03, ...,\n          1.06155685e-02, 4.86952683e-05, 0.00000000e+00]]]],\n      shape=(5, 31, 11, 8))</pre></li><li>lat(site)float64-29.0 -28.83 ... -28.53 -29.0standard_name :latitudeunits :degrees_north<pre>array([-29.      , -28.82899 , -28.65798 , -28.48697 , -28.31596 ,\n       -28.14495 , -27.97394 , -27.802929, -27.333083, -26.863237,\n       -26.393391, -25.923544, -25.453698, -24.983852, -24.514005,\n       -24.044159, -24.215169, -24.386179, -24.557189, -24.728199,\n       -24.899209, -25.070219, -25.24123 , -25.711076, -26.180922,\n       -26.650768, -27.120615, -27.590461, -28.060307, -28.530154,\n       -29.      ])</pre></li><li>lon(site)float64112.0 112.5 112.9 ... 111.8 112.0standard_name :longitudeunits :degrees_east<pre>array([112.      , 112.469846, 112.939693, 113.409539, 113.879385,\n       114.349232, 114.819078, 115.288924, 115.117914, 114.946904,\n       114.775894, 114.604884, 114.433874, 114.262864, 114.091854,\n       113.920844, 113.450997, 112.981151, 112.511305, 112.041458,\n       111.571612, 111.101766, 110.631919, 110.802929, 110.97394 ,\n       111.14495 , 111.31596 , 111.48697 , 111.65798 , 111.82899 ,\n       112.      ])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],\n      dtype='int64', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[10]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = Boundnest1(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 2.5},\n    rectangle=\"closed\",\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"head -n 80 {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = Boundnest1(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 2.5},     rectangle=\"closed\", )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"head -n 80 {filename}\"); <pre>\"BOUNDNEST1 NEST 'wa.bnd' CLOSED\"</pre> <pre>SWAN   1                                Swan standard spectral file\n$   Created by wavespectra\n$   \nTIME                                    time-dependent data\n     1                                  time coding option\nLONLAT                                  locations in spherical coordinates\n    31                                  number of locations\n  112.000000  -29.000000\n  112.469846  -28.828990\n  112.939693  -28.657980\n  113.409539  -28.486970\n  113.879385  -28.315960\n  114.349232  -28.144950\n  114.819078  -27.973940\n  115.288924  -27.802929\n  115.117914  -27.333083\n  114.946904  -26.863237\n  114.775894  -26.393391\n  114.604884  -25.923544\n  114.433874  -25.453698\n  114.262864  -24.983852\n  114.091854  -24.514005\n  113.920844  -24.044159\n  113.450997  -24.215169\n  112.981151  -24.386179\n  112.511305  -24.557189\n  112.041458  -24.728199\n  111.571612  -24.899209\n  111.101766  -25.070219\n  110.631919  -25.241230\n  110.802929  -25.711076\n  110.973940  -26.180922\n  111.144950  -26.650768\n  111.315960  -27.120615\n  111.486970  -27.590461\n  111.657980  -28.060307\n  111.828990  -28.530154\n  112.000000  -29.000000\nAFREQ                                   absolute frequencies in Hz\n    11                                  number of frequencies\n    0.05417\n    0.05959\n    0.06555\n    0.07210\n    0.07931\n    0.08724\n    0.09597\n    0.10557\n    0.11612\n    0.12773\n    0.14051\nNDIR                                    spectral nautical directions in degr\n     8                                  number of directions\n     0.0000\n    45.0000\n    90.0000\n   135.0000\n   180.0000\n   225.0000\n   270.0000\n   315.0000\nQUANT\n     1                                  number of quantities in table\nVaDens                                  variance densities in m2/Hz/degr\nm2/Hz/degr                              unit\n   -99                                  exception value\n20230101.000000                         date and time\nFACTOR\n    4.32390256E-05\n    0    0    0    0  361  699    5    0\n    0    0    0    0  365 2990    2    0\n    0    0    0    0  289 7579    0    0\n    0    0    0    0  190 9998    0    0\n    0    0    0    0  137 5204    2    0\n    0    0    0    0   88 2514    2    5\n    0    0    0    2  113 1270    5   14\n    0    0    2   19  167  745    2   12\n    0    0   12  130  333  555    2   12\n    0    0   35  315  625  407    0    2\n    0    0   28  567  807  301    2    0\n</pre> In\u00a0[11]: Copied! <pre># Load the boundary created as a dataset\nds = wavespectra.read_swan(filename, as_site=True)\ndisplay(ds)\n\n# Plot boundary stats calculated from ds\nfor time in ds.time.to_index()[::2]:\n    plot_boundary_side(dset, ds, grid, time)\n</pre> # Load the boundary created as a dataset ds = wavespectra.read_swan(filename, as_site=True) display(ds)  # Plot boundary stats calculated from ds for time in ds.time.to_index()[::2]:     plot_boundary_side(dset, ds, grid, time) <pre>&lt;xarray.Dataset&gt; Size: 110kB\nDimensions:  (time: 5, site: 31, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 248B 1 2 3 4 5 6 7 8 9 ... 23 24 25 26 27 28 29 30 31\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 109kB 0.0 0.0 0.0 ... 0.0 0.0\n    lat      (site) float64 248B -29.0 -28.83 -28.66 ... -28.06 -28.53 -29.0\n    lon      (site) float64 248B 112.0 112.5 112.9 113.4 ... 111.7 111.8 112.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 31</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int641 2 3 4 5 6 7 ... 26 27 28 29 30 31<pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 0.0 ... 0.00881 0.0 0.0standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.02240789e-02, 2.16195128e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.29284687e-01, 8.64780512e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.27708575e-01, 0.00000000e+00, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 5.18868307e-04, ...,\n          2.39976592e-02, 8.64780512e-05, 5.18868307e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.51336590e-03, ...,\n          1.75982834e-02, 0.00000000e+00, 8.64780512e-05],\n         [0.00000000e+00, 0.00000000e+00, 1.21069272e-03, ...,\n          1.30149467e-02, 8.64780512e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.49135966e-02, 9.00491445e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          7.90031161e-02, 0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.66815615e-01, 0.00000000e+00, 0.00000000e+00],\n...\n          3.70043212e-02, 1.19755085e-04, 1.99591808e-04],\n         [0.00000000e+00, 0.00000000e+00, 7.98367232e-04, ...,\n          1.72048138e-02, 0.00000000e+00, 1.19755085e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.91608136e-03, ...,\n          1.06981209e-02, 1.19755085e-04, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          5.10350657e-03, 1.07442244e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          6.58083742e-02, 0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.24020814e-01, 1.07442244e-04, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 3.59931516e-03, ...,\n          3.37905856e-02, 1.07442244e-04, 3.22326731e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.68605609e-03, ...,\n          1.99305362e-02, 0.00000000e+00, 1.07442244e-04],\n         [0.00000000e+00, 0.00000000e+00, 4.40513199e-03, ...,\n          8.81026398e-03, 0.00000000e+00, 0.00000000e+00]]]],\n      shape=(5, 31, 11, 8))</pre></li><li>lat(site)float64-29.0 -28.83 ... -28.53 -29.0standard_name :latitudeunits :degrees_north<pre>array([-29.      , -28.82899 , -28.65798 , -28.48697 , -28.31596 ,\n       -28.14495 , -27.97394 , -27.802929, -27.333083, -26.863237,\n       -26.393391, -25.923544, -25.453698, -24.983852, -24.514005,\n       -24.044159, -24.215169, -24.386179, -24.557189, -24.728199,\n       -24.899209, -25.070219, -25.24123 , -25.711076, -26.180922,\n       -26.650768, -27.120615, -27.590461, -28.060307, -28.530154,\n       -29.      ])</pre></li><li>lon(site)float64112.0 112.5 112.9 ... 111.8 112.0standard_name :longitudeunits :degrees_east<pre>array([112.      , 112.469846, 112.939693, 113.409539, 113.879385,\n       114.349232, 114.819078, 115.288924, 115.117914, 114.946904,\n       114.775894, 114.604884, 114.433874, 114.262864, 114.091854,\n       113.920844, 113.450997, 112.981151, 112.511305, 112.041458,\n       111.571612, 111.101766, 110.631919, 110.802929, 110.97394 ,\n       111.14495 , 111.31596 , 111.48697 , 111.65798 , 111.82899 ,\n       112.      ])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],\n      dtype='int64', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[12]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = Boundnest1(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    rectangle=\"closed\",\n    spacing=\"parent\",\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"head -n 80 {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = Boundnest1(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     rectangle=\"closed\",     spacing=\"parent\", )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"head -n 80 {filename}\"); <pre>\"BOUNDNEST1 NEST 'wa.bnd' CLOSED\"</pre> <pre>SWAN   1                                Swan standard spectral file\n$   Created by wavespectra\n$   \nTIME                                    time-dependent data\n     1                                  time coding option\nLONLAT                                  locations in spherical coordinates\n    22                                  number of locations\n  112.000000  -29.000000\n  112.664463  -28.758155\n  113.328926  -28.516310\n  113.993389  -28.274466\n  114.657852  -28.032621\n  115.276771  -27.769539\n  115.034926  -27.105076\n  114.793081  -26.440612\n  114.551237  -25.776150\n  114.309392  -25.111687\n  114.067547  -24.447223\n  113.659445  -24.139300\n  112.994982  -24.381145\n  112.330519  -24.622990\n  111.666056  -24.864835\n  111.001593  -25.106679\n  110.739214  -25.536019\n  110.981059  -26.200482\n  111.222903  -26.864945\n  111.464748  -27.529408\n  111.706593  -28.193871\n  111.948438  -28.858334\nAFREQ                                   absolute frequencies in Hz\n    11                                  number of frequencies\n    0.05417\n    0.05959\n    0.06555\n    0.07210\n    0.07931\n    0.08724\n    0.09597\n    0.10557\n    0.11612\n    0.12773\n    0.14051\nNDIR                                    spectral nautical directions in degr\n     8                                  number of directions\n     0.0000\n    45.0000\n    90.0000\n   135.0000\n   180.0000\n   225.0000\n   270.0000\n   315.0000\nQUANT\n     1                                  number of quantities in table\nVaDens                                  variance densities in m2/Hz/degr\nm2/Hz/degr                              unit\n   -99                                  exception value\n20230101.000000                         date and time\nFACTOR\n    3.77111971E-05\n    0    0    0    0  324  732    4    0\n    0    0    0    0  306 2831    2    0\n    0    0    0    0  211 8155    0    0\n    0    0    0    0  150 9998    0    0\n    0    0    0    0  124 5261    2    0\n    0    0    0    1   86 2541    3    5\n    0    0    0   11  143 1321    5   12\n    0    0    2   71  351  919    3    9\n    0    0    9  188  966  735    1    9\n    0    0   21  350 1357  565    0    2\n    0    0   18  687 1325  363    1    0\nFACTOR\n    3.34683442E-05\n    0    0    0    0  305  762    4    0\n    0    0    0    0  275 2743    1    0\n    0    0    0    0  171 8603    0    0\n    0    0    0    0  135 9998    0    0\n    0    0    0    0  126 5349    2    0\n    0    0    0    2   93 2589    3    6\n    0    0    0   17  173 1393    5   12\n</pre> In\u00a0[13]: Copied! <pre># Load the boundary created as a dataset\nds = wavespectra.read_swan(filename, as_site=True)\ndisplay(ds)\n\n# Plot boundary stats calculated from ds\nfor time in ds.time.to_index()[::2]:\n    plot_boundary_side(dset, ds, grid, time)\n</pre> # Load the boundary created as a dataset ds = wavespectra.read_swan(filename, as_site=True) display(ds)  # Plot boundary stats calculated from ds for time in ds.time.to_index()[::2]:     plot_boundary_side(dset, ds, grid, time) <pre>&lt;xarray.Dataset&gt; Size: 78kB\nDimensions:  (time: 5, site: 22, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 176B 1 2 3 4 5 6 7 8 9 ... 14 15 16 17 18 19 20 21 22\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 77kB 0.0 0.0 0.0 ... 4.817e-05 0.0\n    lat      (site) float64 176B -29.0 -28.76 -28.52 ... -27.53 -28.19 -28.86\n    lon      (site) float64 176B 112.0 112.7 113.3 114.0 ... 111.5 111.7 111.9</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 22</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int641 2 3 4 5 6 7 ... 17 18 19 20 21 22<pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n       19, 20, 21, 22])</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 ... 4.817e-05 0.0standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.76045963e-02, 1.50844788e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.06760399e-01, 7.54223942e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.07534812e-01, 0.00000000e+00, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 3.39400774e-04, ...,\n          2.77177299e-02, 3.77111971e-05, 3.39400774e-04],\n         [0.00000000e+00, 0.00000000e+00, 7.91935139e-04, ...,\n          2.13068264e-02, 0.00000000e+00, 7.54223942e-05],\n         [0.00000000e+00, 0.00000000e+00, 6.78801548e-04, ...,\n          1.36891645e-02, 3.77111971e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.55028783e-02, 1.33873377e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          9.18036681e-02, 3.34683442e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.87928165e-01, 0.00000000e+00, 0.00000000e+00],\n...\n          3.30847446e-02, 7.18452652e-05, 2.15535796e-04],\n         [0.00000000e+00, 0.00000000e+00, 9.69911080e-04, ...,\n          1.64884884e-02, 3.59226326e-05, 1.07767898e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.11943532e-03, ...,\n          1.15311651e-02, 7.18452652e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          7.27322526e-03, 4.81670547e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          8.79048748e-02, 4.81670547e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.13128828e-01, 9.63341094e-05, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 1.30051048e-03, ...,\n          4.05566601e-02, 9.63341094e-05, 1.92668219e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.15600931e-03, ...,\n          2.13861723e-02, 0.00000000e+00, 9.63341094e-05],\n         [0.00000000e+00, 0.00000000e+00, 2.07118335e-03, ...,\n          1.06449191e-02, 4.81670547e-05, 0.00000000e+00]]]],\n      shape=(5, 22, 11, 8))</pre></li><li>lat(site)float64-29.0 -28.76 ... -28.19 -28.86standard_name :latitudeunits :degrees_north<pre>array([-29.      , -28.758155, -28.51631 , -28.274466, -28.032621,\n       -27.769539, -27.105076, -26.440612, -25.77615 , -25.111687,\n       -24.447223, -24.1393  , -24.381145, -24.62299 , -24.864835,\n       -25.106679, -25.536019, -26.200482, -26.864945, -27.529408,\n       -28.193871, -28.858334])</pre></li><li>lon(site)float64112.0 112.7 113.3 ... 111.7 111.9standard_name :longitudeunits :degrees_east<pre>array([112.      , 112.664463, 113.328926, 113.993389, 114.657852,\n       115.276771, 115.034926, 114.793081, 114.551237, 114.309392,\n       114.067547, 113.659445, 112.994982, 112.330519, 111.666056,\n       111.001593, 110.739214, 110.981059, 111.222903, 111.464748,\n       111.706593, 111.948438])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n       21, 22],\n      dtype='int64', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[14]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = Boundnest1(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    rectangle=\"closed\",\n    spacing=1.0,\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"head -n 80 {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = Boundnest1(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     rectangle=\"closed\",     spacing=1.0, )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"head -n 80 {filename}\"); <pre>\"BOUNDNEST1 NEST 'wa.bnd' CLOSED\"</pre> <pre>SWAN   1                                Swan standard spectral file\n$   Created by wavespectra\n$   \nTIME                                    time-dependent data\n     1                                  time coding option\nLONLAT                                  locations in spherical coordinates\n    16                                  number of locations\n  112.000000  -29.000000\n  112.939693  -28.657980\n  113.879385  -28.315960\n  114.819078  -27.973940\n  115.117914  -27.333083\n  114.775894  -26.393391\n  114.433874  -25.453698\n  114.091854  -24.514005\n  113.450997  -24.215169\n  112.511305  -24.557189\n  111.571612  -24.899209\n  110.631919  -25.241230\n  110.973940  -26.180922\n  111.315960  -27.120615\n  111.657980  -28.060307\n  112.000000  -29.000000\nAFREQ                                   absolute frequencies in Hz\n    11                                  number of frequencies\n    0.05417\n    0.05959\n    0.06555\n    0.07210\n    0.07931\n    0.08724\n    0.09597\n    0.10557\n    0.11612\n    0.12773\n    0.14051\nNDIR                                    spectral nautical directions in degr\n     8                                  number of directions\n     0.0000\n    45.0000\n    90.0000\n   135.0000\n   180.0000\n   225.0000\n   270.0000\n   315.0000\nQUANT\n     1                                  number of quantities in table\nVaDens                                  variance densities in m2/Hz/degr\nm2/Hz/degr                              unit\n   -99                                  exception value\n20230101.000000                         date and time\nFACTOR\n    3.77111971E-05\n    0    0    0    0  324  732    4    0\n    0    0    0    0  306 2831    2    0\n    0    0    0    0  211 8155    0    0\n    0    0    0    0  150 9998    0    0\n    0    0    0    0  124 5261    2    0\n    0    0    0    1   86 2541    3    5\n    0    0    0   11  143 1321    5   12\n    0    0    2   71  351  919    3    9\n    0    0    9  188  966  735    1    9\n    0    0   21  350 1357  565    0    2\n    0    0   18  687 1325  363    1    0\nFACTOR\n    2.99598167E-05\n    0    0    0    0  283  800    4    0\n    0    0    0    0  255 2828    1    0\n    0    0    0    0  157 8520    0    0\n    0    0    0    0  121 9998    0    0\n    0    0    0    0  112 5290    2    0\n    0    0    0    1   82 2559    3    6\n    0    0    0   14  153 1356    6   11\n    0    0    1   86  429 1042    5    6\n    0    0    6  183 1269  894    1    7\n    0    0   12  306 1714  735    1    1\n    0    0   10  633 1590  479    1    0\nFACTOR\n    1.74700485E-05\n</pre> In\u00a0[15]: Copied! <pre># Load the boundary created as a dataset\nds = wavespectra.read_swan(filename, as_site=True)\ndisplay(ds)\n\n# Plot boundary stats calculated from ds\nfor time in ds.time.to_index()[::2]:\n    plot_boundary_side(dset, ds, grid, time)\n</pre> # Load the boundary created as a dataset ds = wavespectra.read_swan(filename, as_site=True) display(ds)  # Plot boundary stats calculated from ds for time in ds.time.to_index()[::2]:     plot_boundary_side(dset, ds, grid, time) <pre>&lt;xarray.Dataset&gt; Size: 57kB\nDimensions:  (time: 5, site: 16, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 128B 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 56kB 0.0 0.0 0.0 ... 4.87e-05 0.0\n    lat      (site) float64 128B -29.0 -28.66 -28.32 ... -27.12 -28.06 -29.0\n    lon      (site) float64 128B 112.0 112.9 113.9 114.8 ... 111.3 111.7 112.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 16</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int641 2 3 4 5 6 7 ... 11 12 13 14 15 16<pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16])</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 ... 4.87e-05 0.0standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.76045963e-02, 1.50844788e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          1.06760399e-01, 7.54223942e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          3.07534812e-01, 0.00000000e+00, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 3.39400774e-04, ...,\n          2.77177299e-02, 3.77111971e-05, 3.39400774e-04],\n         [0.00000000e+00, 0.00000000e+00, 7.91935139e-04, ...,\n          2.13068264e-02, 0.00000000e+00, 7.54223942e-05],\n         [0.00000000e+00, 0.00000000e+00, 6.78801548e-04, ...,\n          1.36891645e-02, 3.77111971e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.39678534e-02, 1.19839267e-04, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          8.47263616e-02, 2.99598167e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          2.55257638e-01, 0.00000000e+00, 0.00000000e+00],\n...\n          3.27757932e-02, 7.15628672e-05, 2.14688602e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.00188014e-03, ...,\n          1.64236780e-02, 3.57814336e-05, 1.43125734e-04],\n         [0.00000000e+00, 0.00000000e+00, 2.18266745e-03, ...,\n          1.15216216e-02, 7.15628672e-05, 0.00000000e+00]],\n\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          7.15820444e-03, 4.86952683e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          8.71158350e-02, 4.86952683e-05, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n          4.15760201e-01, 9.73905366e-05, 0.00000000e+00],\n         ...,\n         [0.00000000e+00, 0.00000000e+00, 1.36346751e-03, ...,\n          4.05144632e-02, 9.73905366e-05, 1.94781073e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.21738171e-03, ...,\n          2.15233086e-02, 0.00000000e+00, 9.73905366e-05],\n         [0.00000000e+00, 0.00000000e+00, 2.14259181e-03, ...,\n          1.06155685e-02, 4.86952683e-05, 0.00000000e+00]]]],\n      shape=(5, 16, 11, 8))</pre></li><li>lat(site)float64-29.0 -28.66 ... -28.06 -29.0standard_name :latitudeunits :degrees_north<pre>array([-29.      , -28.65798 , -28.31596 , -27.97394 , -27.333083,\n       -26.393391, -25.453698, -24.514005, -24.215169, -24.557189,\n       -24.899209, -25.24123 , -26.180922, -27.120615, -28.060307,\n       -29.      ])</pre></li><li>lon(site)float64112.0 112.9 113.9 ... 111.7 112.0standard_name :longitudeunits :degrees_east<pre>array([112.      , 112.939693, 113.879385, 114.819078, 115.117914,\n       114.775894, 114.433874, 114.091854, 113.450997, 112.511305,\n       111.571612, 110.631919, 110.97394 , 111.31596 , 111.65798 ,\n       112.      ])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], dtype='int64', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul>"},{"location":"examples/boundary/boundnest1/#swan-boundnest1","title":"SWAN BOUNDNEST1\u00b6","text":"<p>This notebooks shows examples of how to prescribe BOUNDNEST1 spectral boundaries using rompy boundary data objects.</p> <p>Boundary of type <code>BOUNDNEST1</code> can be specified from existing spectral data using the <code>rompy_swan.boundary.Boundnest1</code> object. Spectra are interpolated or nearest-selected from a source spectra dataset along the model grid and saved as a single SWAN SPEC2D ASCII file.</p>"},{"location":"examples/boundary/boundnest1/#helper-functions","title":"Helper functions\u00b6","text":""},{"location":"examples/boundary/boundnest1/#define-rompy-objects","title":"Define rompy objects\u00b6","text":"<p>Create instances of source, time and grid objects to use with the boundary classes</p>"},{"location":"examples/boundary/boundnest1/#boundnest1-with-idw-interpolation-at-all-boundary-points","title":"Boundnest1 with IDW interpolation at all boundary points\u00b6","text":"<p>Create <code>BOUNDNEST1</code> type SWAN boundary by interpolating from the source spectra dataset along the model domain using the Inverse Distance Weighting (<code>idw</code>) sel method from wavespectra. Boundary data are defined at all points along the grid boundary given the <code>spacing</code> parameter isn't prescribed</p>  \u26a0\ufe0f When using IDW, missing values are returned for locations that do not have three or   more sites withing tolerance in the source dataset. This is okay for land locations   but will be problematic for locations expecting an open boundary. Use a larger   tolerance when encountering this problem."},{"location":"examples/boundary/boundnest1/#boundnest1-with-nearest-selection-at-all-boundary-points","title":"Boundnest1 with nearest selection at all boundary points\u00b6","text":"<p>Create <code>BOUNDNEST1</code> type SWAN boundary by nearest-selecting from the source spectra dataset along the model domain using the Nearest Neighbour (<code>nearest</code>) sel method from wavespectra. Boundary data are defined at all points along the grid boundary given the <code>spacing</code> parameter isn't prescribed</p>  \u26a0\ufe0f When using nearest, exceptions are raised for locations that do not have at least one   site placed withing tolerance in the source dataset. Use a larger tolerance when   encountering this problem."},{"location":"examples/boundary/boundnest1/#boundnest1-with-spacing-defined-from-the-parent-dataset","title":"Boundnest1 with spacing defined from the parent dataset\u00b6","text":"<p>Create <code>BOUNDNEST1</code> type SWAN boundary by interpolating from the source spectra dataset along the model domain at locations along the grid boundary defined acording to the minimum spacing between points in the source dataset.</p>  \u26a0\ufe0f When using any custom spacing, it is possible there won't be boundary points defined   at some of the grid vertices if the grid sides are not divisible by the spacing."},{"location":"examples/boundary/boundnest1/#boundnest1-with-custom-spacing","title":"Boundnest1 with custom spacing\u00b6","text":"<p>Create <code>BOUNDNEST1</code> type SWAN boundary by interpolating from the source spectra dataset along the model domain at locations along the grid boundary defined custom <code>spacing</code> parameter.</p>  \u26a0\ufe0f When using any custom spacing, it is possible there won't be boundary points defined   at some of the grid vertices if the grid sides are not divisible by the spacing."},{"location":"examples/boundary/boundspec_segment/","title":"SWAN BOUNDSPEC SEGMENT","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\nfrom pathlib import Path\nfrom tempfile import mkdtemp\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom matplotlib import colors\nimport cartopy.crs as ccrs\nimport pandas as pd\nimport wavespectra\n\nfrom rompy.core.source import SourceFile\nfrom rompy.core.time import TimeRange\nfrom rompy_swan.grid import SwanGrid\nfrom rompy_swan.boundary import BoundspecSegmentXY\nfrom rompy_swan.subcomponents.boundary import SIDE, SIDES, XY\n\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> %load_ext autoreload %autoreload 2  import os from pathlib import Path from tempfile import mkdtemp import matplotlib.pyplot as plt import matplotlib from matplotlib import colors import cartopy.crs as ccrs import pandas as pd import wavespectra  from rompy.core.source import SourceFile from rompy.core.time import TimeRange from rompy_swan.grid import SwanGrid from rompy_swan.boundary import BoundspecSegmentXY from rompy_swan.subcomponents.boundary import SIDE, SIDES, XY  import warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre>def read_tpar(tparfile):\n    \"\"\"Read SWAN TPAR files as a Dataframe.\"\"\"\n    df = pd.read_csv(\n        tparfile,\n        sep=\" \",\n        header=None,\n        skiprows=1,\n        parse_dates=[0],\n        date_format=\"%Y%m%d.%H%M%S\",\n        index_col=0,\n    )\n    df.columns = [\"hs\", \"tp\", \"dpm\", \"dspr\"]\n    return df\n\n\ndef get_color(cmap, value, vmin, vmax):\n    \"\"\"Return the HEX color for a value in a colormap.\"\"\"\n    cmap = matplotlib.cm.get_cmap(cmap)\n    norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)\n    return colors.rgb2hex(cmap(norm(value)))\n\n\ndef plot_boundary_side(dset, tpars, grid, time):\n    \"\"\"Plot side boundary stats.\n\n    This function plots a snapshot of wave statistics from the source spectra dataset\n    and the boundary wave stats generated for a grid from those spectra points.\n\n    Parameters\n    ----------\n    dset: xr.Dataset\n        Source spectra dataset used to define the boundary.\n    tpars: list[pd.DataFrame]\n        Boundary time series defined from TPAR or SWAN ASCII file for each segment.\n    grid: SwanGrid\n        Grid object defining the SWAN domain.\n    time: Datatime | str\n        Time to plot.\n\n    \"\"\"\n    # xb, yb = bnd._boundary_points(grid)\n    xb = grid.x[:, 0]\n    yb = grid.y[:, 0]\n\n    fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))\n\n    # Hs\n    ax = axs[0]\n    p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)\n    plt.colorbar(p, label=\"Hs (m)\")\n    for df in tpars:\n        xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]\n        yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]\n        color = get_color(\"turbo\", df.loc[time][\"hs\"], 2.0, 3.5)\n        ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n\n    # Tp\n    ax = axs[1]\n    p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)\n    plt.colorbar(p, label=\"Tp (s)\")\n    for df in tpars:\n        xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]\n        yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]\n        color = get_color(\"viridis\", df.loc[time][\"tp\"], 13.8, 14.5)\n        ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n\n    # Dpm\n    ax = axs[2]\n    p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)\n    plt.colorbar(p, label=\"Dpm (deg)\")\n    for df in tpars:\n        xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]\n        yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]\n        color = get_color(\"hsv\", df.loc[time][\"dpm\"], 220, 225)\n        ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n    # ax.scatter(xb, yb, s=200, c=df.loc[time][\"dpm\"], marker=\"&gt;\", edgecolor=\"k\", cmap=\"hsv\", vmin=220, vmax=225)\n\n    for ax in axs:\n        grid.plot(ax=ax, fscale=5)\n        ax.set_extent([110.5, 115.5, -29.5, -23.5])\n        ax.set_title(time)\n        ax.coastlines()\n</pre> def read_tpar(tparfile):     \"\"\"Read SWAN TPAR files as a Dataframe.\"\"\"     df = pd.read_csv(         tparfile,         sep=\" \",         header=None,         skiprows=1,         parse_dates=[0],         date_format=\"%Y%m%d.%H%M%S\",         index_col=0,     )     df.columns = [\"hs\", \"tp\", \"dpm\", \"dspr\"]     return df   def get_color(cmap, value, vmin, vmax):     \"\"\"Return the HEX color for a value in a colormap.\"\"\"     cmap = matplotlib.cm.get_cmap(cmap)     norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)     return colors.rgb2hex(cmap(norm(value)))   def plot_boundary_side(dset, tpars, grid, time):     \"\"\"Plot side boundary stats.      This function plots a snapshot of wave statistics from the source spectra dataset     and the boundary wave stats generated for a grid from those spectra points.      Parameters     ----------     dset: xr.Dataset         Source spectra dataset used to define the boundary.     tpars: list[pd.DataFrame]         Boundary time series defined from TPAR or SWAN ASCII file for each segment.     grid: SwanGrid         Grid object defining the SWAN domain.     time: Datatime | str         Time to plot.      \"\"\"     # xb, yb = bnd._boundary_points(grid)     xb = grid.x[:, 0]     yb = grid.y[:, 0]      fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))      # Hs     ax = axs[0]     p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)     plt.colorbar(p, label=\"Hs (m)\")     for df in tpars:         xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]         yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]         color = get_color(\"turbo\", df.loc[time][\"hs\"], 2.0, 3.5)         ax.plot(xb, yb, color=color, linewidth=4, zorder=10)      # Tp     ax = axs[1]     p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)     plt.colorbar(p, label=\"Tp (s)\")     for df in tpars:         xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]         yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]         color = get_color(\"viridis\", df.loc[time][\"tp\"], 13.8, 14.5)         ax.plot(xb, yb, color=color, linewidth=4, zorder=10)      # Dpm     ax = axs[2]     p = ax.scatter(dset.lon, dset.lat, s=65, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)     plt.colorbar(p, label=\"Dpm (deg)\")     for df in tpars:         xb = [df.loc[time][\"x0\"], df.loc[time][\"x1\"]]         yb = [df.loc[time][\"y0\"], df.loc[time][\"y1\"]]         color = get_color(\"hsv\", df.loc[time][\"dpm\"], 220, 225)         ax.plot(xb, yb, color=color, linewidth=4, zorder=10)     # ax.scatter(xb, yb, s=200, c=df.loc[time][\"dpm\"], marker=\"&gt;\", edgecolor=\"k\", cmap=\"hsv\", vmin=220, vmax=225)      for ax in axs:         grid.plot(ax=ax, fscale=5)         ax.set_extent([110.5, 115.5, -29.5, -23.5])         ax.set_title(time)         ax.coastlines() In\u00a0[3]: Copied! <pre>datadir = Path(\"../../../../rompy-swan/tests/data\")\nmodeldir = Path(\"model\")\nmodeldir.mkdir(exist_ok=True)\n</pre> datadir = Path(\"../../../../rompy-swan/tests/data\") modeldir = Path(\"model\") modeldir.mkdir(exist_ok=True) In\u00a0[4]: Copied! <pre># source defines the dataset to be used to create the model boundary\n\nsource = SourceFile(\n    uri=datadir / \"aus-20230101.nc\",\n    kwargs=dict(engine=\"netcdf4\"),\n)\ndset = source.open()\ndset\n</pre> # source defines the dataset to be used to create the model boundary  source = SourceFile(     uri=datadir / \"aus-20230101.nc\",     kwargs=dict(engine=\"netcdf4\"), ) dset = source.open() dset Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (site: 412, time: 5, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 3kB 0 4 8 12 16 20 ... 1624 1628 1632 1636 1640 1644\n  * freq     (freq) float32 44B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float32 32B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    lon      (site) float32 2kB ...\n    lat      (site) float32 2kB ...\n    efth     (time, site, freq, dir) float64 1MB ...\n    dpt      (time, site) float32 8kB ...\n    wspd     (time, site) float32 8kB ...\n    wdir     (time, site) float32 8kB ...\nAttributes: (12/16)\n    product_name:           ww3.all_spec.nc\n    area:                   Global 0.5 x 0.5 degree\n    data_type:              OCO spectra 2D\n    format_version:         1.1\n    southernmost_latitude:  n/a\n    northernmost_latitude:  n/a\n    ...                     ...\n    minimum_altitude:       n/a\n    maximum_altitude:       n/a\n    altitude_resolution:    n/a\n    start_date:             2023-01-01 00:00:00\n    stop_date:              2023-02-01 00:00:00\n    field_type:             3-hourly</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 412</li><li>time: 5</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int640 4 8 12 16 ... 1632 1636 1640 1644<pre>array([   0,    4,    8, ..., 1636, 1640, 1644], shape=(412,))</pre></li><li>freq(freq)float320.05417 0.05959 ... 0.1277 0.1405standard_name :sea_surface_wave_frequencyunits :Hz<pre>array([0.054172, 0.059589, 0.065548, 0.072103, 0.079313, 0.087244, 0.095968,\n       0.105565, 0.116122, 0.127734, 0.140507], dtype=float32)</pre></li><li>dir(dir)float320.0 45.0 90.0 ... 225.0 270.0 315.0standard_name :sea_surface_wave_from_directionunits :degree<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.], dtype=float32)</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32...standard_name :longitudeunits :degrees_east<pre>[412 values with dtype=float32]</pre></li><li>lat(site)float32...standard_name :latitudeunits :degrees_north<pre>[412 values with dtype=float32]</pre></li><li>efth(time, site, freq, dir)float64...standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1<pre>[181280 values with dtype=float64]</pre></li><li>dpt(time, site)float32...standard_name :sea_floor_depth_below_sea_surfaceunits :m<pre>[2060 values with dtype=float32]</pre></li><li>wspd(time, site)float32...standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1<pre>[2060 values with dtype=float32]</pre></li><li>wdir(time, site)float32...standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree<pre>[2060 values with dtype=float32]</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([   0,    4,    8,   12,   16,   20,   24,   28,   32,   36,\n       ...\n       1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644],\n      dtype='int64', name='site', length=412))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417170003056526, 0.05958886817097664, 0.06554775685071945,\n       0.07210253179073334, 0.07931278645992279, 0.08724407106637955,\n       0.09596847742795944, 0.10556533187627792, 0.11612186580896378,\n       0.12773405015468597, 0.14050745964050293],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float32', name='dir'))</pre></li></ul></li><li>Attributes: (16)product_name :ww3.all_spec.ncarea :Global 0.5 x 0.5 degreedata_type :OCO spectra 2Dformat_version :1.1southernmost_latitude :n/anorthernmost_latitude :n/alatitude_resolution :n/awesternmost_longitude :n/aeasternmost_longitude :n/alongitude_resolution :n/aminimum_altitude :n/amaximum_altitude :n/aaltitude_resolution :n/astart_date :2023-01-01 00:00:00stop_date :2023-02-01 00:00:00field_type :3-hourly</li></ul> In\u00a0[5]: Copied! <pre># times prescribe the times over which the model will run\n\ntimes = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\")\nprint(times)\n</pre> # times prescribe the times over which the model will run  times = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\") print(times) <pre>\n\tStart: 2023-01-01 00:00:00\n\tEnd: 2023-01-02 00:00:00\n\tDuration: 1 day\n\tInterval: 6:00:00\n\tInclude End: True\n\n</pre> In\u00a0[6]: Copied! <pre># grid defines the model grid\n\ngrid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20)\ngrid\n</pre> # grid defines the model grid  grid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20) grid Out[6]: <pre>SwanGrid: REG, 8x9</pre> In\u00a0[7]: Copied! <pre># Plot model grid and boundary points in the source spectra\n\nfig, ax = grid.plot(fscale=5)\nax.plot(dset.lon, dset.lat, \"ok\")\nax.set_extent([108, 120, -35.5, -19])\n</pre> # Plot model grid and boundary points in the source spectra  fig, ax = grid.plot(fscale=5) ax.plot(dset.lon, dset.lat, \"ok\") ax.set_extent([108, 120, -35.5, -19]) In\u00a0[8]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSegmentXY(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    location=SIDE(side=\"west\", direction=\"ccw\"),\n)\n\nfilenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"ls -l {workspace}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSegmentXY(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     location=SIDE(side=\"west\", direction=\"ccw\"), )  filenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"ls -l {workspace}\"); <pre>\"BOUNDSPEC SEGMENT XY 110.63191943 -25.24122952 110.80292950 -25.71107583 CONSTANT FILE fname='wa_tpar_000.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.80292950 -25.71107583 110.97393957 -26.18092214 CONSTANT FILE fname='wa_tpar_001.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.97393957 -26.18092214 111.14494964 -26.65076845 CONSTANT FILE fname='wa_tpar_002.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.14494964 -26.65076845 111.31595971 -27.12061476 CONSTANT FILE fname='wa_tpar_003.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.31595971 -27.12061476 111.48696979 -27.59046107 CONSTANT FILE fname='wa_tpar_004.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.48696979 -27.59046107 111.65797986 -28.06030738 CONSTANT FILE fname='wa_tpar_005.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.65797986 -28.06030738 111.82898993 -28.53015369 CONSTANT FILE fname='wa_tpar_006.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.82898993 -28.53015369 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_007.bnd' seq=1\"</pre> <pre>total 32\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_000.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_001.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_002.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_003.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_004.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_005.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_006.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_007.bnd\n</pre> In\u00a0[9]: Copied! <pre>tpars = []\nfor filename, cmdrow in zip(filenames, cmd.split(\"\\n\")):\n    parts = cmdrow.split()\n    df = read_tpar(filename)\n    df[\"x0\"] = float(parts[3].split(\"=\")[-1])\n    df[\"x1\"] = float(parts[5].split(\"=\")[-1])\n    df[\"y0\"] = float(parts[4].split(\"=\")[-1])\n    df[\"y1\"] = float(parts[6].split(\"=\")[-1])\n    tpars.append(df)\n\nwith pd.option_context(\"display.max_columns\", 999):\n    display(df)\n</pre> tpars = [] for filename, cmdrow in zip(filenames, cmd.split(\"\\n\")):     parts = cmdrow.split()     df = read_tpar(filename)     df[\"x0\"] = float(parts[3].split(\"=\")[-1])     df[\"x1\"] = float(parts[5].split(\"=\")[-1])     df[\"y0\"] = float(parts[4].split(\"=\")[-1])     df[\"y1\"] = float(parts[6].split(\"=\")[-1])     tpars.append(df)  with pd.option_context(\"display.max_columns\", 999):     display(df) hs tp dpm dspr x0 x1 y0 y1 0 2023-01-01 00:00:00 2.91 14.14 224.35 25.31 111.82899 112.0 -28.530154 -29.0 2023-01-01 06:00:00 2.99 14.11 224.08 26.31 111.82899 112.0 -28.530154 -29.0 2023-01-01 12:00:00 3.35 14.25 223.91 28.19 111.82899 112.0 -28.530154 -29.0 2023-01-01 18:00:00 3.62 14.31 224.13 29.76 111.82899 112.0 -28.530154 -29.0 2023-01-02 00:00:00 3.59 14.18 224.47 30.52 111.82899 112.0 -28.530154 -29.0 <p>Plot boundary stats, note the values weighted by the four nearest neighbours at each site along the <code>WEST</code> boundary</p> In\u00a0[10]: Copied! <pre>for time in df.index[::2]:\n    plot_boundary_side(dset, tpars, grid, time)\n</pre> for time in df.index[::2]:     plot_boundary_side(dset, tpars, grid, time) In\u00a0[11]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSegmentXY(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    location=SIDES(\n        sides=[\n            SIDE(side=\"south\", direction=\"clockwise\"),\n            SIDE(side=\"west\", direction=\"clockwise\"),\n            SIDE(side=\"north\", direction=\"clockwise\"),\n        ],\n    ),\n)\n\nfilenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"ls -l {workspace}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSegmentXY(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 2.0},     location=SIDES(         sides=[             SIDE(side=\"south\", direction=\"clockwise\"),             SIDE(side=\"west\", direction=\"clockwise\"),             SIDE(side=\"north\", direction=\"clockwise\"),         ],     ), )  filenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"ls -l {workspace}\"); <pre>\"BOUNDSPEC SEGMENT XY 115.28892417 -27.80292950 114.81907786 -27.97393957 CONSTANT FILE fname='wa_tpar_000.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.81907786 -27.97393957 114.34923155 -28.14494964 CONSTANT FILE fname='wa_tpar_001.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.34923155 -28.14494964 113.87938524 -28.31595971 CONSTANT FILE fname='wa_tpar_002.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.87938524 -28.31595971 113.40953893 -28.48696979 CONSTANT FILE fname='wa_tpar_003.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.40953893 -28.48696979 112.93969262 -28.65797986 CONSTANT FILE fname='wa_tpar_004.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.93969262 -28.65797986 112.46984631 -28.82898993 CONSTANT FILE fname='wa_tpar_005.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.46984631 -28.82898993 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_006.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.00000000 -29.00000000 111.82898993 -28.53015369 CONSTANT FILE fname='wa_tpar_007.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.82898993 -28.53015369 111.65797986 -28.06030738 CONSTANT FILE fname='wa_tpar_008.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.65797986 -28.06030738 111.48696979 -27.59046107 CONSTANT FILE fname='wa_tpar_009.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.48696979 -27.59046107 111.31595971 -27.12061476 CONSTANT FILE fname='wa_tpar_010.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.31595971 -27.12061476 111.14494964 -26.65076845 CONSTANT FILE fname='wa_tpar_011.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.14494964 -26.65076845 110.97393957 -26.18092214 CONSTANT FILE fname='wa_tpar_012.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.97393957 -26.18092214 110.80292950 -25.71107583 CONSTANT FILE fname='wa_tpar_013.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.80292950 -25.71107583 110.63191943 -25.24122952 CONSTANT FILE fname='wa_tpar_014.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.63191943 -25.24122952 111.10176574 -25.07021945 CONSTANT FILE fname='wa_tpar_015.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.10176574 -25.07021945 111.57161205 -24.89920937 CONSTANT FILE fname='wa_tpar_016.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.57161205 -24.89920937 112.04145836 -24.72819930 CONSTANT FILE fname='wa_tpar_017.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.04145836 -24.72819930 112.51130467 -24.55718923 CONSTANT FILE fname='wa_tpar_018.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.51130467 -24.55718923 112.98115098 -24.38617916 CONSTANT FILE fname='wa_tpar_019.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.98115098 -24.38617916 113.45099729 -24.21516909 CONSTANT FILE fname='wa_tpar_020.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.45099729 -24.21516909 113.92084360 -24.04415902 CONSTANT FILE fname='wa_tpar_021.bnd' seq=1\"</pre> <pre>total 88\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_000.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_001.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_002.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_003.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_004.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_005.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_006.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_007.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_008.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_009.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_010.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_011.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_012.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_013.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_014.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_015.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_016.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_017.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_018.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_019.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_020.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_021.bnd\n</pre> In\u00a0[12]: Copied! <pre># Load boundaries for each segment into dataframes\n\ntpars = []\nfor filename, row in zip(filenames, cmd.split(\"\\n\")):\n    parts = row.split()\n    df = read_tpar(filename)\n    df[\"x0\"] = float(parts[3].split(\"=\")[-1])\n    df[\"x1\"] = float(parts[5].split(\"=\")[-1])\n    df[\"y0\"] = float(parts[4].split(\"=\")[-1])\n    df[\"y1\"] = float(parts[6].split(\"=\")[-1])\n    tpars.append(df)\n\nwith pd.option_context(\"display.max_columns\", 999):\n    display(df)\n</pre> # Load boundaries for each segment into dataframes  tpars = [] for filename, row in zip(filenames, cmd.split(\"\\n\")):     parts = row.split()     df = read_tpar(filename)     df[\"x0\"] = float(parts[3].split(\"=\")[-1])     df[\"x1\"] = float(parts[5].split(\"=\")[-1])     df[\"y0\"] = float(parts[4].split(\"=\")[-1])     df[\"y1\"] = float(parts[6].split(\"=\")[-1])     tpars.append(df)  with pd.option_context(\"display.max_columns\", 999):     display(df) hs tp dpm dspr x0 x1 y0 y1 0 2023-01-01 00:00:00 1.31 14.08 241.64 20.66 113.450997 113.920844 -24.215169 -24.044159 2023-01-01 06:00:00 1.31 13.89 241.93 21.96 113.450997 113.920844 -24.215169 -24.044159 2023-01-01 12:00:00 1.37 13.93 242.71 22.38 113.450997 113.920844 -24.215169 -24.044159 2023-01-01 18:00:00 1.43 14.17 243.00 21.91 113.450997 113.920844 -24.215169 -24.044159 2023-01-02 00:00:00 1.56 14.33 243.23 21.32 113.450997 113.920844 -24.215169 -24.044159 In\u00a0[13]: Copied! <pre># Plot boundary stats\n\nfor time in df.index[::2]:\n    plot_boundary_side(dset, tpars, grid, time)\n</pre> # Plot boundary stats  for time in df.index[::2]:     plot_boundary_side(dset, tpars, grid, time) In\u00a0[14]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSegmentXY(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    spacing=1.0,\n    location=SIDES(\n        sides=[\n            SIDE(side=\"north\", direction=\"ccw\"),\n            SIDE(side=\"west\", direction=\"ccw\"),\n            SIDE(side=\"south\", direction=\"ccw\"),\n        ],\n    ),\n)\n\nfilenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"ls -l {workspace}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSegmentXY(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 2.0},     spacing=1.0,     location=SIDES(         sides=[             SIDE(side=\"north\", direction=\"ccw\"),             SIDE(side=\"west\", direction=\"ccw\"),             SIDE(side=\"south\", direction=\"ccw\"),         ],     ), )  filenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"ls -l {workspace}\"); <pre>\"BOUNDSPEC SEGMENT XY 113.92084360 -24.04415902 112.98115098 -24.38617916 CONSTANT FILE fname='wa_tpar_000.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.98115098 -24.38617916 112.04145836 -24.72819930 CONSTANT FILE fname='wa_tpar_001.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.04145836 -24.72819930 111.10176574 -25.07021945 CONSTANT FILE fname='wa_tpar_002.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.10176574 -25.07021945 110.63191943 -25.24122952 CONSTANT FILE fname='wa_tpar_003.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.63191943 -25.24122952 110.97393957 -26.18092214 CONSTANT FILE fname='wa_tpar_004.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.97393957 -26.18092214 111.31595971 -27.12061476 CONSTANT FILE fname='wa_tpar_005.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.31595971 -27.12061476 111.65797986 -28.06030738 CONSTANT FILE fname='wa_tpar_006.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.65797986 -28.06030738 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_007.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.00000000 -29.00000000 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_008.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.00000000 -29.00000000 112.93969262 -28.65797986 CONSTANT FILE fname='wa_tpar_009.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.93969262 -28.65797986 113.87938524 -28.31595971 CONSTANT FILE fname='wa_tpar_010.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.87938524 -28.31595971 114.81907786 -27.97393957 CONSTANT FILE fname='wa_tpar_011.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.81907786 -27.97393957 115.28892417 -27.80292950 CONSTANT FILE fname='wa_tpar_012.bnd' seq=1\"</pre> <pre>total 52\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_000.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_001.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_002.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_003.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_004.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_005.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_006.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_007.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_008.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_009.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_010.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_011.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_012.bnd\n</pre> In\u00a0[15]: Copied! <pre># Load boundaries for each segment and plot boundary stats\n\ntpars = []\nfor filename, row in zip(filenames, cmd.split(\"\\n\")):\n    parts = row.split()\n    df = read_tpar(filename)\n    df[\"x0\"] = float(parts[3].split(\"=\")[-1])\n    df[\"x1\"] = float(parts[5].split(\"=\")[-1])\n    df[\"y0\"] = float(parts[4].split(\"=\")[-1])\n    df[\"y1\"] = float(parts[6].split(\"=\")[-1])\n    tpars.append(df)\n\nwith pd.option_context(\"display.max_columns\", 999):\n    display(df)\n\nfor time in df.index[::2]:\n    plot_boundary_side(dset, tpars, grid, time)\n</pre> # Load boundaries for each segment and plot boundary stats  tpars = [] for filename, row in zip(filenames, cmd.split(\"\\n\")):     parts = row.split()     df = read_tpar(filename)     df[\"x0\"] = float(parts[3].split(\"=\")[-1])     df[\"x1\"] = float(parts[5].split(\"=\")[-1])     df[\"y0\"] = float(parts[4].split(\"=\")[-1])     df[\"y1\"] = float(parts[6].split(\"=\")[-1])     tpars.append(df)  with pd.option_context(\"display.max_columns\", 999):     display(df)  for time in df.index[::2]:     plot_boundary_side(dset, tpars, grid, time) hs tp dpm dspr x0 x1 y0 y1 0 2023-01-01 00:00:00 1.94 13.82 225.0 14.52 114.819078 115.288924 -27.97394 -27.80293 2023-01-01 06:00:00 1.95 14.09 225.0 14.38 114.819078 115.288924 -27.97394 -27.80293 2023-01-01 12:00:00 2.34 14.06 225.0 18.83 114.819078 115.288924 -27.97394 -27.80293 2023-01-01 18:00:00 2.22 13.91 225.0 16.48 114.819078 115.288924 -27.97394 -27.80293 2023-01-02 00:00:00 2.05 13.85 225.0 13.39 114.819078 115.288924 -27.97394 -27.80293 In\u00a0[16]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSegmentXY(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    spacing=\"parent\",\n    location=SIDES(\n        sides=[\n            SIDE(side=\"north\", direction=\"ccw\"),\n            SIDE(side=\"west\", direction=\"ccw\"),\n            SIDE(side=\"south\", direction=\"ccw\"),\n        ],\n    ),\n)\n\nfilenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"ls -l {workspace}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSegmentXY(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 2.0},     spacing=\"parent\",     location=SIDES(         sides=[             SIDE(side=\"north\", direction=\"ccw\"),             SIDE(side=\"west\", direction=\"ccw\"),             SIDE(side=\"south\", direction=\"ccw\"),         ],     ), )  filenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"ls -l {workspace}\"); <pre>\"BOUNDSPEC SEGMENT XY 113.92084360 -24.04415902 113.25638059 -24.28600377 CONSTANT FILE fname='wa_tpar_000.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.25638059 -24.28600377 112.59191757 -24.52784853 CONSTANT FILE fname='wa_tpar_001.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.59191757 -24.52784853 111.92745462 -24.76969327 CONSTANT FILE fname='wa_tpar_002.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.92745462 -24.76969327 111.26299155 -25.01153805 CONSTANT FILE fname='wa_tpar_003.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.26299155 -25.01153805 110.63191943 -25.24122952 CONSTANT FILE fname='wa_tpar_004.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.63191943 -25.24122952 110.87376419 -25.90569253 CONSTANT FILE fname='wa_tpar_005.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.87376419 -25.90569253 111.11560894 -26.57015554 CONSTANT FILE fname='wa_tpar_006.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.11560894 -26.57015554 111.35745368 -27.23461850 CONSTANT FILE fname='wa_tpar_007.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.35745368 -27.23461850 111.59929846 -27.89908157 CONSTANT FILE fname='wa_tpar_008.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.59929846 -27.89908157 111.84114324 -28.56354464 CONSTANT FILE fname='wa_tpar_009.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.84114324 -28.56354464 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_010.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.00000000 -29.00000000 112.66446301 -28.75815524 CONSTANT FILE fname='wa_tpar_011.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.66446301 -28.75815524 113.32892603 -28.51631048 CONSTANT FILE fname='wa_tpar_012.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.32892603 -28.51631048 113.99338898 -28.27446574 CONSTANT FILE fname='wa_tpar_013.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.99338898 -28.27446574 114.65785205 -28.03262097 CONSTANT FILE fname='wa_tpar_014.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.65785205 -28.03262097 115.28892417 -27.80292950 CONSTANT FILE fname='wa_tpar_015.bnd' seq=1\"</pre> <pre>total 64\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_000.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_001.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_002.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_003.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_004.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_005.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_006.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_007.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_008.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_009.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_010.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_011.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_012.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_013.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_014.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_015.bnd\n</pre> In\u00a0[17]: Copied! <pre># Load boundaries for each segment and plot boundary stats\n\ntpars = []\nfor filename, row in zip(filenames, cmd.split(\"\\n\")):\n    parts = row.split()\n    df = read_tpar(filename)\n    df[\"x0\"] = float(parts[3].split(\"=\")[-1])\n    df[\"x1\"] = float(parts[5].split(\"=\")[-1])\n    df[\"y0\"] = float(parts[4].split(\"=\")[-1])\n    df[\"y1\"] = float(parts[6].split(\"=\")[-1])\n    tpars.append(df)\n\nwith pd.option_context(\"display.max_columns\", 999):\n    display(df)\n\nfor time in df.index[::2]:\n    plot_boundary_side(dset, tpars, grid, time)\n</pre> # Load boundaries for each segment and plot boundary stats  tpars = [] for filename, row in zip(filenames, cmd.split(\"\\n\")):     parts = row.split()     df = read_tpar(filename)     df[\"x0\"] = float(parts[3].split(\"=\")[-1])     df[\"x1\"] = float(parts[5].split(\"=\")[-1])     df[\"y0\"] = float(parts[4].split(\"=\")[-1])     df[\"y1\"] = float(parts[6].split(\"=\")[-1])     tpars.append(df)  with pd.option_context(\"display.max_columns\", 999):     display(df)  for time in df.index[::2]:     plot_boundary_side(dset, tpars, grid, time) hs tp dpm dspr x0 x1 y0 y1 0 2023-01-01 00:00:00 1.94 13.82 225.0 14.52 114.657852 115.288924 -28.032621 -27.80293 2023-01-01 06:00:00 1.95 14.09 225.0 14.38 114.657852 115.288924 -28.032621 -27.80293 2023-01-01 12:00:00 2.34 14.06 225.0 18.83 114.657852 115.288924 -28.032621 -27.80293 2023-01-01 18:00:00 2.22 13.91 225.0 16.48 114.657852 115.288924 -28.032621 -27.80293 2023-01-02 00:00:00 2.05 13.85 225.0 13.39 114.657852 115.288924 -28.032621 -27.80293 In\u00a0[18]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\n# Define the grid vertices as boundary points\nxb, yb = grid.boundary_points()\nfor point in zip(xb, yb):\n    print(point)\n\nbnd = BoundspecSegmentXY(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    location=XY(x=xb, y=yb)\n)\n\nfilenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"ls -l {workspace}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  # Define the grid vertices as boundary points xb, yb = grid.boundary_points() for point in zip(xb, yb):     print(point)  bnd = BoundspecSegmentXY(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     location=XY(x=xb, y=yb) )  filenames, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"ls -l {workspace}\"); <pre>(np.float64(112.0), np.float64(-29.0))\n(np.float64(112.46984631039295), np.float64(-28.828989928337165))\n(np.float64(112.9396926207859), np.float64(-28.65797985667433))\n(np.float64(113.40953893117886), np.float64(-28.486969785011496))\n(np.float64(113.87938524157181), np.float64(-28.31595971334866))\n(np.float64(114.34923155196478), np.float64(-28.144949641685827))\n(np.float64(114.81907786235773), np.float64(-27.973939570022992))\n(np.float64(115.28892417275068), np.float64(-27.80292949836016))\n(np.float64(115.11791410108785), np.float64(-27.333083187967205))\n(np.float64(114.94690402942501), np.float64(-26.863236877574252))\n(np.float64(114.77589395776218), np.float64(-26.393390567181296))\n(np.float64(114.60488388609934), np.float64(-25.923544256788343))\n(np.float64(114.43387381443651), np.float64(-25.453697946395387))\n(np.float64(114.26286374277367), np.float64(-24.983851636002434))\n(np.float64(114.09185367111084), np.float64(-24.51400532560948))\n(np.float64(113.920843599448), np.float64(-24.044159015216525))\n(np.float64(113.45099728905505), np.float64(-24.21516908687936))\n(np.float64(112.9811509786621), np.float64(-24.386179158542195))\n(np.float64(112.51130466826915), np.float64(-24.55718923020503))\n(np.float64(112.0414583578762), np.float64(-24.728199301867864))\n(np.float64(111.57161204748323), np.float64(-24.8992093735307))\n(np.float64(111.10176573709028), np.float64(-25.070219445193533))\n(np.float64(110.63191942669732), np.float64(-25.241229516856365))\n(np.float64(110.80292949836016), np.float64(-25.71107582724932))\n(np.float64(110.97393957002299), np.float64(-26.180922137642273))\n(np.float64(111.14494964168583), np.float64(-26.65076844803523))\n(np.float64(111.31595971334866), np.float64(-27.120614758428182))\n(np.float64(111.4869697850115), np.float64(-27.59046106882114))\n(np.float64(111.65797985667433), np.float64(-28.06030737921409))\n(np.float64(111.82898992833717), np.float64(-28.530153689607047))\n(np.float64(112.0), np.float64(-29.0))\n</pre> <pre>\"BOUNDSPEC SEGMENT XY 112.00000000 -29.00000000 112.46984631 -28.82898993 CONSTANT FILE fname='wa_tpar_000.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.46984631 -28.82898993 112.93969262 -28.65797986 CONSTANT FILE fname='wa_tpar_001.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.93969262 -28.65797986 113.40953893 -28.48696979 CONSTANT FILE fname='wa_tpar_002.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.40953893 -28.48696979 113.87938524 -28.31595971 CONSTANT FILE fname='wa_tpar_003.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.87938524 -28.31595971 114.34923155 -28.14494964 CONSTANT FILE fname='wa_tpar_004.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.34923155 -28.14494964 114.81907786 -27.97393957 CONSTANT FILE fname='wa_tpar_005.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.81907786 -27.97393957 115.28892417 -27.80292950 CONSTANT FILE fname='wa_tpar_006.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 115.28892417 -27.80292950 115.11791410 -27.33308319 CONSTANT FILE fname='wa_tpar_007.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 115.11791410 -27.33308319 114.94690403 -26.86323688 CONSTANT FILE fname='wa_tpar_008.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.94690403 -26.86323688 114.77589396 -26.39339057 CONSTANT FILE fname='wa_tpar_009.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.77589396 -26.39339057 114.60488389 -25.92354426 CONSTANT FILE fname='wa_tpar_010.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.60488389 -25.92354426 114.43387381 -25.45369795 CONSTANT FILE fname='wa_tpar_011.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.43387381 -25.45369795 114.26286374 -24.98385164 CONSTANT FILE fname='wa_tpar_012.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.26286374 -24.98385164 114.09185367 -24.51400533 CONSTANT FILE fname='wa_tpar_013.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 114.09185367 -24.51400533 113.92084360 -24.04415902 CONSTANT FILE fname='wa_tpar_014.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.92084360 -24.04415902 113.45099729 -24.21516909 CONSTANT FILE fname='wa_tpar_015.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 113.45099729 -24.21516909 112.98115098 -24.38617916 CONSTANT FILE fname='wa_tpar_016.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.98115098 -24.38617916 112.51130467 -24.55718923 CONSTANT FILE fname='wa_tpar_017.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.51130467 -24.55718923 112.04145836 -24.72819930 CONSTANT FILE fname='wa_tpar_018.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 112.04145836 -24.72819930 111.57161205 -24.89920937 CONSTANT FILE fname='wa_tpar_019.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.57161205 -24.89920937 111.10176574 -25.07021945 CONSTANT FILE fname='wa_tpar_020.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.10176574 -25.07021945 110.63191943 -25.24122952 CONSTANT FILE fname='wa_tpar_021.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.63191943 -25.24122952 110.80292950 -25.71107583 CONSTANT FILE fname='wa_tpar_022.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.80292950 -25.71107583 110.97393957 -26.18092214 CONSTANT FILE fname='wa_tpar_023.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 110.97393957 -26.18092214 111.14494964 -26.65076845 CONSTANT FILE fname='wa_tpar_024.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.14494964 -26.65076845 111.31595971 -27.12061476 CONSTANT FILE fname='wa_tpar_025.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.31595971 -27.12061476 111.48696979 -27.59046107 CONSTANT FILE fname='wa_tpar_026.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.48696979 -27.59046107 111.65797986 -28.06030738 CONSTANT FILE fname='wa_tpar_027.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.65797986 -28.06030738 111.82898993 -28.53015369 CONSTANT FILE fname='wa_tpar_028.bnd' seq=1\\nBOUNDSPEC SEGMENT XY 111.82898993 -28.53015369 112.00000000 -29.00000000 CONSTANT FILE fname='wa_tpar_029.bnd' seq=1\"</pre> <pre>total 120\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_000.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_001.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_002.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_003.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_004.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_005.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_006.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_007.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_008.bnd\n-rw-rw-r-- 1 rguedes rguedes 170 Sep 18 21:43 wa_tpar_009.bnd\n-rw-rw-r-- 1 rguedes rguedes 170 Sep 18 21:43 wa_tpar_010.bnd\n-rw-rw-r-- 1 rguedes rguedes 170 Sep 18 21:43 wa_tpar_011.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_012.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_013.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_014.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_015.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_016.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_017.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_018.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_019.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_020.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_021.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_022.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_023.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_024.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_025.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_026.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_027.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_028.bnd\n-rw-rw-r-- 1 rguedes rguedes 205 Sep 18 21:43 wa_tpar_029.bnd\n</pre> In\u00a0[19]: Copied! <pre># Load boundaries for each segment and plot boundary stats\n\ntpars = []\nfor filename, row in zip(filenames, cmd.split(\"\\n\")):\n    parts = row.split()\n    df = read_tpar(filename)\n    df[\"x0\"] = float(parts[3].split(\"=\")[-1])\n    df[\"x1\"] = float(parts[5].split(\"=\")[-1])\n    df[\"y0\"] = float(parts[4].split(\"=\")[-1])\n    df[\"y1\"] = float(parts[6].split(\"=\")[-1])\n    tpars.append(df)\n\n# Display the contents of one of the TPAR files\nwith pd.option_context(\"display.max_columns\", 999):\n    display(df)\n\n# Plot source and boundary stats\nfor time in df.index[::2]:\n    plot_boundary_side(dset, tpars, grid, time)\n</pre> # Load boundaries for each segment and plot boundary stats  tpars = [] for filename, row in zip(filenames, cmd.split(\"\\n\")):     parts = row.split()     df = read_tpar(filename)     df[\"x0\"] = float(parts[3].split(\"=\")[-1])     df[\"x1\"] = float(parts[5].split(\"=\")[-1])     df[\"y0\"] = float(parts[4].split(\"=\")[-1])     df[\"y1\"] = float(parts[6].split(\"=\")[-1])     tpars.append(df)  # Display the contents of one of the TPAR files with pd.option_context(\"display.max_columns\", 999):     display(df)  # Plot source and boundary stats for time in df.index[::2]:     plot_boundary_side(dset, tpars, grid, time) hs tp dpm dspr x0 x1 y0 y1 0 2023-01-01 00:00:00 2.91 14.14 224.35 25.31 111.82899 112.0 -28.530154 -29.0 2023-01-01 06:00:00 2.99 14.11 224.08 26.31 111.82899 112.0 -28.530154 -29.0 2023-01-01 12:00:00 3.35 14.25 223.91 28.19 111.82899 112.0 -28.530154 -29.0 2023-01-01 18:00:00 3.62 14.31 224.13 29.76 111.82899 112.0 -28.530154 -29.0 2023-01-02 00:00:00 3.59 14.18 224.47 30.52 111.82899 112.0 -28.530154 -29.0"},{"location":"examples/boundary/boundspec_segment/#swan-boundspec-segment","title":"SWAN BOUNDSPEC SEGMENT\u00b6","text":"<p>This notebooks shows examples of how to prescribe BOUNDSPEC SEGMENT spectral boundaries using rompy boundary data objects.</p> <p>Boundary of type <code>BOUNDSPEC SEGMENT</code> can be specified from existing spectral data using the <code>rompy_swan.boundary.BoundspecSegmentXY</code> object. The boundary locations can be defined in three different ways:</p> Type Description SIDE Define boundary segment along one side of computational grid SIDES Define boundary segment along multiple, contiguous sides of computational grid XY Define boundary segment from a sequency of points explicitly provided <p>The boundary spectra are defined by interpolating or nearest-selecting from the source spectra data at the selected boundary locations.</p> <p>This class only supports <code>FILE</code> type boundary since the <code>PAR</code> type does not allow for nonstationary boundary specification (the user can prescribe <code>PAR</code> type boundary by using the SWAN components if required).</p> <p>We currently support <code>TPAR</code> and <code>SPEC2D</code> file types to write the boundary data.</p>"},{"location":"examples/boundary/boundspec_segment/#helper-functions","title":"Helper functions\u00b6","text":""},{"location":"examples/boundary/boundspec_segment/#define-rompy-objects","title":"Define rompy objects\u00b6","text":"<p>Create instances of source, time and grid objects to use with the boundary classes</p>"},{"location":"examples/boundary/boundspec_segment/#boundary-segment-along-one-side","title":"Boundary segment along one side\u00b6","text":"<p>Create <code>BOUNDSPEC SEGMENT</code> type SWAN boundary with the points defined along one side of the computational grid.</p> <p>The boundary is defined as <code>TPAR</code> files by interpolating from the source spectra dataset along the grid side. The Inverse Distance Weighting (<code>idw</code>) sel method from wavespectra will be used to interpolate from the source spectra at each boundary point.</p>"},{"location":"examples/boundary/boundspec_segment/#boundary-segment-along-multiple-sides","title":"Boundary segment along multiple sides\u00b6","text":"<p>Create <code>BOUNDSPEC SEGMENT</code> type SWAN boundary with the points defined along multiple, contiguous sides of the computational grid.</p> <p>The boundary is defined as <code>TPAR</code> files by selecting from the nearest points in the source spectra dataset along the sides at the resolution defined by the <code>spacing</code> parameter which by default corresponds to the grid spacing itself (use <code>\"parent\"</code> to define the spacing based on spacing of points in the source spectra dataset, or set a custom spacing if desired).</p>  \u26a0\ufe0f When using SIDES, the order at which each side is provided matters. Ensure the order   and direction of each side are such that segments defined by each pair of points will   all be contiguous."},{"location":"examples/boundary/boundspec_segment/#boundary-segment-along-multiple-sides-with-custom-spacing","title":"Boundary segment along multiple sides with custom spacing\u00b6","text":"<p>Use a custom spacing of 1.0 degree to set the segment sizes. Notice the last segment is adjsted to ensure the grid length is respected.</p>  \u26a0\ufe0f In this example, sides are specified in the opposite order north-west-south with an   appropriate direction `ccw` that ensures contiguous segments."},{"location":"examples/boundary/boundspec_segment/#boundary-segment-along-multiple-sides-with-parent-spacing","title":"Boundary segment along multiple sides with parent spacing\u00b6","text":"<p>Set spacing from the minimum distance between spectral points in the source dataset.</p>"},{"location":"examples/boundary/boundspec_segment/#user-specified-boundary-points","title":"User-specified boundary points\u00b6","text":"<p>Users are free to set segments explicitly using the XY type</p>"},{"location":"examples/boundary/boundspec_side/","title":"SWAN BOUNDSPEC SIDE","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\nfrom pathlib import Path\nfrom tempfile import mkdtemp\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom matplotlib import colors\nimport cartopy.crs as ccrs\nimport pandas as pd\nimport wavespectra\n\nfrom rompy.core.source import SourceFile\nfrom rompy.core.time import TimeRange\nfrom rompy_swan.grid import SwanGrid\nfrom rompy_swan.boundary import BoundspecSide\n\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> %load_ext autoreload %autoreload 2  import os from pathlib import Path from tempfile import mkdtemp import matplotlib.pyplot as plt import matplotlib from matplotlib import colors import cartopy.crs as ccrs import pandas as pd import wavespectra  from rompy.core.source import SourceFile from rompy.core.time import TimeRange from rompy_swan.grid import SwanGrid from rompy_swan.boundary import BoundspecSide  import warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre>def read_tpar(tparfile):\n    \"\"\"Read SWAN TPAR files as a Dataframe.\"\"\"\n    df = pd.read_csv(\n        tparfile,\n        sep=\" \",\n        header=None,\n        skiprows=1,\n        parse_dates=[0],\n        date_format=\"%Y%m%d.%H%M%S\",\n        index_col=0,\n    )\n    df.columns = [\"hs\", \"tp\", \"dpm\", \"dspr\"]\n    return df\n\n\ndef get_color(cmap, value, vmin, vmax):\n    \"\"\"Return the HEX color for a value in a colormap.\"\"\"\n    cmap = matplotlib.cm.get_cmap(cmap)\n    norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)\n    return colors.rgb2hex(cmap(norm(value)))\n\n\ndef plot_boundary_side(dset, df, grid, time):\n    \"\"\"Plot side boundary stats.\n\n    This function plots a snapshot of wave statistics from the source spectra dataset\n    and the boundary wave stats generated for a grid from those spectra points.\n\n    Parameters\n    ----------\n    dset: xr.Dataset\n        Source spectra dataset used to define boundary from.\n    df: pd.DataFrame\n        Boundary time series defined from TPAR or SWAN ASCII file.\n    grid: SwanGrid\n        Grid object defining the SWAN domain.\n    time: Datatime | str\n        Time to plot.\n\n    \"\"\"\n    # xb, yb = bnd._boundary_points(grid)\n    xb = grid.x[:, 0]\n    yb = grid.y[:, 0]\n\n    fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))\n\n    # Hs\n    ax = axs[0]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)\n    color = get_color(\"turbo\", df.loc[time][\"hs\"], 2.0, 3.5)\n    ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n    plt.colorbar(p, label=\"Hs (m)\")\n\n    # Tp\n    ax = axs[1]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)\n    color = get_color(\"viridis\", df.loc[time][\"tp\"], 13.8, 14.5)\n    ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n    plt.colorbar(p, label=\"Tp (s)\")\n\n    # Dpm\n    ax = axs[2]\n    p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)\n    color = get_color(\"hsv\", df.loc[time][\"dpm\"], 220, 225)\n    ax.plot(xb, yb, color=color, linewidth=4, zorder=10)\n    # ax.scatter(xb, yb, s=200, c=df.loc[time][\"dpm\"], marker=\"&gt;\", edgecolor=\"k\", cmap=\"hsv\", vmin=220, vmax=225)\n    plt.colorbar(p, label=\"Dpm (deg)\")\n\n    for ax in axs:\n        grid.plot(ax=ax, fscale=5)\n        ax.set_extent([110.5, 115.5, -29.5, -23.5])\n        ax.set_title(time)\n        ax.coastlines()\n</pre> def read_tpar(tparfile):     \"\"\"Read SWAN TPAR files as a Dataframe.\"\"\"     df = pd.read_csv(         tparfile,         sep=\" \",         header=None,         skiprows=1,         parse_dates=[0],         date_format=\"%Y%m%d.%H%M%S\",         index_col=0,     )     df.columns = [\"hs\", \"tp\", \"dpm\", \"dspr\"]     return df   def get_color(cmap, value, vmin, vmax):     \"\"\"Return the HEX color for a value in a colormap.\"\"\"     cmap = matplotlib.cm.get_cmap(cmap)     norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)     return colors.rgb2hex(cmap(norm(value)))   def plot_boundary_side(dset, df, grid, time):     \"\"\"Plot side boundary stats.      This function plots a snapshot of wave statistics from the source spectra dataset     and the boundary wave stats generated for a grid from those spectra points.      Parameters     ----------     dset: xr.Dataset         Source spectra dataset used to define boundary from.     df: pd.DataFrame         Boundary time series defined from TPAR or SWAN ASCII file.     grid: SwanGrid         Grid object defining the SWAN domain.     time: Datatime | str         Time to plot.      \"\"\"     # xb, yb = bnd._boundary_points(grid)     xb = grid.x[:, 0]     yb = grid.y[:, 0]      fig, axs = plt.subplots(1, 3, subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(15, 3.5))      # Hs     ax = axs[0]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.hs(), cmap=\"turbo\", vmin=2.0, vmax=3.5)     color = get_color(\"turbo\", df.loc[time][\"hs\"], 2.0, 3.5)     ax.plot(xb, yb, color=color, linewidth=4, zorder=10)     plt.colorbar(p, label=\"Hs (m)\")      # Tp     ax = axs[1]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.tp(), cmap=\"viridis\", vmin=13.8, vmax=14.5)     color = get_color(\"viridis\", df.loc[time][\"tp\"], 13.8, 14.5)     ax.plot(xb, yb, color=color, linewidth=4, zorder=10)     plt.colorbar(p, label=\"Tp (s)\")      # Dpm     ax = axs[2]     p = ax.scatter(dset.lon, dset.lat, s=50, c=dset.sel(time=time).spec.dpm(), cmap=\"hsv\", vmin=220, vmax=225)     color = get_color(\"hsv\", df.loc[time][\"dpm\"], 220, 225)     ax.plot(xb, yb, color=color, linewidth=4, zorder=10)     # ax.scatter(xb, yb, s=200, c=df.loc[time][\"dpm\"], marker=\"&gt;\", edgecolor=\"k\", cmap=\"hsv\", vmin=220, vmax=225)     plt.colorbar(p, label=\"Dpm (deg)\")      for ax in axs:         grid.plot(ax=ax, fscale=5)         ax.set_extent([110.5, 115.5, -29.5, -23.5])         ax.set_title(time)         ax.coastlines() In\u00a0[3]: Copied! <pre>datadir = Path(\"../../../../rompy-swan/tests/data\")\nmodeldir = Path(\"model\")\nmodeldir.mkdir(exist_ok=True)\n</pre> datadir = Path(\"../../../../rompy-swan/tests/data\") modeldir = Path(\"model\") modeldir.mkdir(exist_ok=True) In\u00a0[4]: Copied! <pre># source defines the dataset to be used to create the model boundary\n\nsource = SourceFile(\n    uri=datadir / \"aus-20230101.nc\",\n    kwargs=dict(engine=\"netcdf4\"),\n)\ndset = source.open()\ndset\n</pre> # source defines the dataset to be used to create the model boundary  source = SourceFile(     uri=datadir / \"aus-20230101.nc\",     kwargs=dict(engine=\"netcdf4\"), ) dset = source.open() dset Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (site: 412, time: 5, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) int64 3kB 0 4 8 12 16 20 ... 1624 1628 1632 1636 1640 1644\n  * freq     (freq) float32 44B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float32 32B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    lon      (site) float32 2kB ...\n    lat      (site) float32 2kB ...\n    efth     (time, site, freq, dir) float64 1MB ...\n    dpt      (time, site) float32 8kB ...\n    wspd     (time, site) float32 8kB ...\n    wdir     (time, site) float32 8kB ...\nAttributes: (12/16)\n    product_name:           ww3.all_spec.nc\n    area:                   Global 0.5 x 0.5 degree\n    data_type:              OCO spectra 2D\n    format_version:         1.1\n    southernmost_latitude:  n/a\n    northernmost_latitude:  n/a\n    ...                     ...\n    minimum_altitude:       n/a\n    maximum_altitude:       n/a\n    altitude_resolution:    n/a\n    start_date:             2023-01-01 00:00:00\n    stop_date:              2023-02-01 00:00:00\n    field_type:             3-hourly</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>site: 412</li><li>time: 5</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02standard_name :time<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)int640 4 8 12 16 ... 1632 1636 1640 1644<pre>array([   0,    4,    8, ..., 1636, 1640, 1644], shape=(412,))</pre></li><li>freq(freq)float320.05417 0.05959 ... 0.1277 0.1405standard_name :sea_surface_wave_frequencyunits :Hz<pre>array([0.054172, 0.059589, 0.065548, 0.072103, 0.079313, 0.087244, 0.095968,\n       0.105565, 0.116122, 0.127734, 0.140507], dtype=float32)</pre></li><li>dir(dir)float320.0 45.0 90.0 ... 225.0 270.0 315.0standard_name :sea_surface_wave_from_directionunits :degree<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.], dtype=float32)</pre></li></ul></li><li>Data variables: (6)<ul><li>lon(site)float32...standard_name :longitudeunits :degrees_east<pre>[412 values with dtype=float32]</pre></li><li>lat(site)float32...standard_name :latitudeunits :degrees_north<pre>[412 values with dtype=float32]</pre></li><li>efth(time, site, freq, dir)float64...standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1<pre>[181280 values with dtype=float64]</pre></li><li>dpt(time, site)float32...standard_name :sea_floor_depth_below_sea_surfaceunits :m<pre>[2060 values with dtype=float32]</pre></li><li>wspd(time, site)float32...standard_name :wind_speed_at_10m_above_ground_levelunits :m s-1<pre>[2060 values with dtype=float32]</pre></li><li>wdir(time, site)float32...standard_name :wind_from_direction_at_10m_above_ground_levelunits :degree<pre>[2060 values with dtype=float32]</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index([   0,    4,    8,   12,   16,   20,   24,   28,   32,   36,\n       ...\n       1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644],\n      dtype='int64', name='site', length=412))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417170003056526, 0.05958886817097664, 0.06554775685071945,\n       0.07210253179073334, 0.07931278645992279, 0.08724407106637955,\n       0.09596847742795944, 0.10556533187627792, 0.11612186580896378,\n       0.12773405015468597, 0.14050745964050293],\n      dtype='float32', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float32', name='dir'))</pre></li></ul></li><li>Attributes: (16)product_name :ww3.all_spec.ncarea :Global 0.5 x 0.5 degreedata_type :OCO spectra 2Dformat_version :1.1southernmost_latitude :n/anorthernmost_latitude :n/alatitude_resolution :n/awesternmost_longitude :n/aeasternmost_longitude :n/alongitude_resolution :n/aminimum_altitude :n/amaximum_altitude :n/aaltitude_resolution :n/astart_date :2023-01-01 00:00:00stop_date :2023-02-01 00:00:00field_type :3-hourly</li></ul> In\u00a0[5]: Copied! <pre># times prescribe the times over which the model will run\n\ntimes = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\")\nprint(times)\n</pre> # times prescribe the times over which the model will run  times = TimeRange(start=\"2023-01-01T00\", end=\"2023-01-02T00\", interval=\"6h\") print(times) <pre>\n\tStart: 2023-01-01 00:00:00\n\tEnd: 2023-01-02 00:00:00\n\tDuration: 1 day\n\tInterval: 6:00:00\n\tInclude End: True\n\n</pre> In\u00a0[6]: Copied! <pre># grid defines the model grid\n\ngrid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20)\ngrid\n</pre> # grid defines the model grid  grid = SwanGrid(x0=112, y0=-29, dx=0.5, dy=0.5, nx=8, ny=9, rot=20) grid Out[6]: <pre>SwanGrid: REG, 8x9</pre> In\u00a0[7]: Copied! <pre># Plot model grid and boundary points in the source spectra\n\nfig, ax = grid.plot(fscale=5)\nax.plot(dset.lon, dset.lat, \"ok\")\nax.set_extent([108, 120, -35.5, -19])\n</pre> # Plot model grid and boundary points in the source spectra  fig, ax = grid.plot(fscale=5) ax.plot(dset.lon, dset.lat, \"ok\") ax.set_extent([108, 120, -35.5, -19]) In\u00a0[8]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSide(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    location={\"side\": \"west\"},\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"cat {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSide(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 2.0},     location={\"side\": \"west\"}, )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"cat {filename}\"); <pre>\"BOUNDSPEC SIDE WEST CCW CONSTANT FILE fname='wa_tpar_west_000.bnd' seq=1\"</pre> <pre>TPAR\n20230101.000000 2.74 14.39 223.83 30.07\n20230101.060000 2.80 14.03 223.88 31.27\n20230101.120000 3.07 14.04 223.26 32.15\n20230101.180000 3.48 14.17 223.08 33.61\n20230102.000000 3.52 14.21 223.68 33.73\n</pre> In\u00a0[9]: Copied! <pre># Load the boundary created as a dataframe\n\ndf = read_tpar(filename)\ndf\n</pre> # Load the boundary created as a dataframe  df = read_tpar(filename) df Out[9]: hs tp dpm dspr 0 2023-01-01 00:00:00 2.74 14.39 223.83 30.07 2023-01-01 06:00:00 2.80 14.03 223.88 31.27 2023-01-01 12:00:00 3.07 14.04 223.26 32.15 2023-01-01 18:00:00 3.48 14.17 223.08 33.61 2023-01-02 00:00:00 3.52 14.21 223.68 33.73 <p>Plot boundary stats, note the values weighted by the four nearest neighbours at the centre of the WEST boundary</p> In\u00a0[10]: Copied! <pre>for time in df.index[::2]:\n    plot_boundary_side(dset, df, grid, time)\n</pre> for time in df.index[::2]:     plot_boundary_side(dset, df, grid, time) In\u00a0[11]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSide(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 2.0},\n    location={\"side\": \"west\"},\n    file_type=\"spec2d\",\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\ndisplay(cmd)\nos.system(f\"head -n 50 {filename}\");\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSide(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 2.0},     location={\"side\": \"west\"},     file_type=\"spec2d\", )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  display(cmd) os.system(f\"head -n 50 {filename}\"); <pre>\"BOUNDSPEC SIDE WEST CCW CONSTANT FILE fname='wa_spec2d_west_000.bnd' seq=1\"</pre> <pre>SWAN   1                                Swan standard spectral file\n$   Created by wavespectra\n$   \nTIME                                    time-dependent data\n     1                                  time coding option\nLONLAT                                  locations in spherical coordinates\n     1                                  number of locations\n  111.000000  -27.000000\nAFREQ                                   absolute frequencies in Hz\n    11                                  number of frequencies\n    0.05417\n    0.05959\n    0.06555\n    0.07210\n    0.07931\n    0.08724\n    0.09597\n    0.10557\n    0.11612\n    0.12773\n    0.14051\nNDIR                                    spectral nautical directions in degr\n     8                                  number of directions\n     0.0000\n    45.0000\n    90.0000\n   135.0000\n   180.0000\n   225.0000\n   270.0000\n   315.0000\nQUANT\n     1                                  number of quantities in table\nVaDens                                  variance densities in m2/Hz/degr\nm2/Hz/degr                              unit\n   -99                                  exception value\n20230101.000000                         date and time\nFACTOR\n    2.51854154E-05\n    0    0    0    0  560 1009    0    0\n    0    0    0    0  500 2847    0    0\n    0    0    0    0  310 9450    0    0\n    0    0    0    0  286 9998    0    0\n    0    0    0    0  298 5650    0    0\n    0    0    0    4  211 2795    4    8\n    4    0    4   48  354 1481    4   24\n    4    0   12  238  890 1056    4   16\n    0    0   36  596 1660  802    0   16\n    0    0   36 1302 2041  580    0    8\n    0    0   40 1882 1815  369    0    0\n</pre> In\u00a0[12]: Copied! <pre># Load the boundary created as a dataset\n\nds = wavespectra.read_swan(filename, as_site=True)\nds\n</pre> # Load the boundary created as a dataset  ds = wavespectra.read_swan(filename, as_site=True) ds Out[12]: <pre>&lt;xarray.Dataset&gt; Size: 4kB\nDimensions:  (time: 5, site: 1, freq: 11, dir: 8)\nCoordinates:\n  * time     (time) datetime64[ns] 40B 2023-01-01 ... 2023-01-02\n  * site     (site) &lt;U18 72B 'wa_spec2d_west_000'\n  * freq     (freq) float64 88B 0.05417 0.05959 0.06555 ... 0.1161 0.1277 0.1405\n  * dir      (dir) float64 64B 0.0 45.0 90.0 135.0 180.0 225.0 270.0 315.0\nData variables:\n    efth     (time, site, freq, dir) float64 4kB 0.0 0.0 0.0 ... 0.01061 0.0 0.0\n    lat      (site) float64 8B -27.0\n    lon      (site) float64 8B 111.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>site: 1</li><li>freq: 11</li><li>dir: 8</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2023-01-01 ... 2023-01-02<pre>array(['2023-01-01T00:00:00.000000000', '2023-01-01T06:00:00.000000000',\n       '2023-01-01T12:00:00.000000000', '2023-01-01T18:00:00.000000000',\n       '2023-01-02T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>site(site)&lt;U18'wa_spec2d_west_000'<pre>array(['wa_spec2d_west_000'], dtype='&lt;U18')</pre></li><li>freq(freq)float640.05417 0.05959 ... 0.1277 0.1405<pre>array([0.05417, 0.05959, 0.06555, 0.0721 , 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051])</pre></li><li>dir(dir)float640.0 45.0 90.0 ... 225.0 270.0 315.0<pre>array([  0.,  45.,  90., 135., 180., 225., 270., 315.])</pre></li></ul></li><li>Data variables: (3)<ul><li>efth(time, site, freq, dir)float640.0 0.0 0.0 0.0 ... 0.01061 0.0 0.0standard_name :sea_surface_wave_directional_variance_spectral_densityunits :m2 s degree-1_units :m^{2}.s.degree^{-1}_variable_name :VaDens<pre>array([[[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          0.00000000e+00, 1.41038326e-02, 2.54120841e-02,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          0.00000000e+00, 1.25927077e-02, 7.17028776e-02,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          0.00000000e+00, 7.80747877e-03, 2.38002176e-01,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          0.00000000e+00, 7.20302880e-03, 2.51803783e-01,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          0.00000000e+00, 7.50525379e-03, 1.42297597e-01,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n          1.00741662e-04, 5.31412265e-03, 7.03932360e-02,\n          1.00741662e-04, 2.01483323e-04],\n         [1.00741662e-04, 0.00000000e+00, 1.00741662e-04,\n          1.20889994e-03, 8.91563705e-03, 3.72996002e-02,\n...\n          8.97669742e-04, 1.20021769e-02, 1.75411317e-01,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 2.99223248e-04,\n          7.31434605e-03, 2.06131571e-02, 9.00994445e-02,\n          0.00000000e+00, 0.00000000e+00],\n         [0.00000000e+00, 0.00000000e+00, 1.09715191e-03,\n          2.58994344e-02, 7.55039995e-02, 5.09011991e-02,\n          9.97410825e-05, 1.99482165e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.39637516e-03,\n          5.26965386e-02, 1.12906905e-01, 3.62060129e-02,\n          9.97410825e-05, 2.99223248e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.09715191e-03,\n          9.82117192e-02, 1.09814932e-01, 2.48022825e-02,\n          0.00000000e+00, 2.99223248e-04],\n         [0.00000000e+00, 0.00000000e+00, 1.89508057e-03,\n          9.40890878e-02, 8.09897590e-02, 1.42962218e-02,\n          0.00000000e+00, 1.99482165e-04],\n         [0.00000000e+00, 0.00000000e+00, 4.08938438e-03,\n          4.89063775e-02, 5.28960208e-02, 1.06058018e-02,\n          0.00000000e+00, 0.00000000e+00]]]])</pre></li><li>lat(site)float64-27.0standard_name :latitudeunits :degrees_north<pre>array([-27.])</pre></li><li>lon(site)float64111.0standard_name :longitudeunits :degrees_east<pre>array([111.])</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 06:00:00',\n               '2023-01-01 12:00:00', '2023-01-01 18:00:00',\n               '2023-01-02 00:00:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>sitePandasIndex<pre>PandasIndex(Index(['wa_spec2d_west_000'], dtype='object', name='site'))</pre></li><li>freqPandasIndex<pre>PandasIndex(Index([0.05417, 0.05959, 0.06555,  0.0721, 0.07931, 0.08724, 0.09597, 0.10557,\n       0.11612, 0.12773, 0.14051],\n      dtype='float64', name='freq'))</pre></li><li>dirPandasIndex<pre>PandasIndex(Index([0.0, 45.0, 90.0, 135.0, 180.0, 225.0, 270.0, 315.0], dtype='float64', name='dir'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[13]: Copied! <pre># Calculate boundary stats from dataset for plotting\n\ndf = ds.isel(site=0, drop=True).spec.stats([\"hs\", \"tp\", \"dpm\", \"dspr\"]).to_pandas()\ndf\n</pre> # Calculate boundary stats from dataset for plotting  df = ds.isel(site=0, drop=True).spec.stats([\"hs\", \"tp\", \"dpm\", \"dspr\"]).to_pandas() df Out[13]: hs tp dpm dspr time 2023-01-01 00:00:00 2.709378 14.361055 223.864182 31.245212 2023-01-01 06:00:00 2.799166 13.995838 223.720566 32.982870 2023-01-01 12:00:00 3.009826 14.025472 223.009888 33.819244 2023-01-01 18:00:00 3.453083 14.141555 222.878220 35.180063 2023-01-02 00:00:00 3.510868 14.194441 223.638062 35.336880 <p>Plot boundary stats, note the values are identical to the nearest neighbour at the centre of the <code>WEST</code> boundary</p> In\u00a0[14]: Copied! <pre>for time in df.index[::2]:\n    plot_boundary_side(dset, df, grid, time)\n</pre> for time in df.index[::2]:     plot_boundary_side(dset, df, grid, time) In\u00a0[15]: Copied! <pre>workspace = Path(mkdtemp(dir=\"model\"))\n\nbnd = BoundspecSide(\n    id=\"wa\",\n    source=source,\n    sel_method=\"nearest\",\n    sel_method_kwargs={\"tolerance\": 0.1},\n    location={\"side\": \"west\"},\n)\n\ntry:\n    filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\nexcept AssertionError as e:\n    print(e)\n</pre> workspace = Path(mkdtemp(dir=\"model\"))  bnd = BoundspecSide(     id=\"wa\",     source=source,     sel_method=\"nearest\",     sel_method_kwargs={\"tolerance\": 0.1},     location={\"side\": \"west\"}, )  try:     filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times) except AssertionError as e:     print(e)  <pre>Nearest site in dataset from ((np.float64(111.31595971334866), np.float64(-27.120614758428182))) is 0.338199 deg away but tolerance is 0.1 deg\n</pre> <p>The <code>idw</code> sel method requires at least two neighbours within the radius defined by <code>tolerance</code> however it does not raise an exception if those are not found but return missing values instead</p> In\u00a0[16]: Copied! <pre>bnd = BoundspecSide(\n    id=\"wa\",\n    source=source,\n    sel_method=\"idw\",\n    sel_method_kwargs={\"tolerance\": 0.1},\n    location={\"side\": \"west\"},\n)\n\nfilename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)\n\nos.system(f\"cat {filename}\");\n</pre> bnd = BoundspecSide(     id=\"wa\",     source=source,     sel_method=\"idw\",     sel_method_kwargs={\"tolerance\": 0.1},     location={\"side\": \"west\"}, )  filename, cmd = bnd.get(destdir=workspace, grid=grid, time=times)  os.system(f\"cat {filename}\"); <pre>TPAR\n20230101.000000 0.00 0.0 0.0 0.0\n20230101.060000 0.00 0.0 0.0 0.0\n20230101.120000 0.00 0.0 0.0 0.0\n20230101.180000 0.00 0.0 0.0 0.0\n20230102.000000 0.00 0.0 0.0 0.0\n</pre>"},{"location":"examples/boundary/boundspec_side/#swan-boundspec-side","title":"SWAN BOUNDSPEC SIDE\u00b6","text":"<p>This notebooks shows examples of how to prescribe BOUNDSPEC SIDE spectral boundaries using rompy boundary data objects.</p> <p>Boundary of type <code>BOUNDSPEC SIDE</code> can be specified from existing spectral data using the <code>rompy_swan.boundary.BoundspecSide</code> object. The boundary location is defined as the middle point of a side of a specified grid object. The boundary spectra are defined by interpolating or nearest-selecting from the source spectra data at the selected boundary location.</p> <p>This class only supports <code>FILE</code> type boundary since the <code>PAR</code> type does not allow for nonstationary boundary specification (the user can prescribe <code>PAR</code> type boundary by using the SWAN components if required).</p> <p>We currently support <code>TPAR</code> and <code>SPEC2D</code> file types to write the boundary data.</p>"},{"location":"examples/boundary/boundspec_side/#helper-functions","title":"Helper functions\u00b6","text":""},{"location":"examples/boundary/boundspec_side/#define-rompy-objects","title":"Define rompy objects\u00b6","text":"<p>Create instances of source, time and grid objects to use with the boundary classes</p>"},{"location":"examples/boundary/boundspec_side/#boundary-side-with-idw-and-tpar-files","title":"Boundary side with IDW and TPAR files\u00b6","text":"<p>Create <code>BOUNDSPEC SIDE</code> type SWAN boundary by interpolating from the source spectra dataset at the centre of the <code>WEST</code> side of the grid.</p> <p>The boundary is defined as <code>TPAR</code> files by interpolating at the middle point of the side using the Inverse Distance Weighting (<code>IDW</code>) sel method from wavespectra with a tolerance of 2 degrees within which at least three sites in the source spectra must exist (otherwise missing values are returned).</p>  \u26a0\ufe0f When using IDW, missing values are returned for locations that do not have three or   more sites withing tolerance in the source dataset. This is okay for land locations   but will be problematic for locations expecting an open boundary. Use a larger   tolerance when encountering this problem."},{"location":"examples/boundary/boundspec_side/#boundary-side-with-nearest-and-spec2d-files","title":"Boundary side with nearest and SPEC2D files\u00b6","text":"<p>Create <code>BOUNDSPEC SIDE</code> type SWAN boundary by nearest-selecting from the source spectra dataset at the centre of the <code>WEST</code> side of the grid.</p> <p>The boundary is defined as <code>SPEC2D</code> files by nearest-selecting at the middle point of the side using the Nearest neighbour (<code>nearest</code>) sel method from wavespectra with a tolerance of 2 degrees within which at least one site in the source spectra must exist (otherwise an exception is raised).</p>  \u26a0\ufe0f When using nearest, exceptions are raised for locations that do not have at least one   site placed withing tolerance in the source dataset. Use a larger tolerance when   encountering this problem."},{"location":"examples/boundary/boundspec_side/#no-nearest-neighbours","title":"No nearest neighbours\u00b6","text":"<p>When the <code>nearest</code> neighbour sel method is choosen there must be at least one site in the source spectra within the radius defined by <code>tolerance</code> otherwise an exception is raised</p>"},{"location":"examples/components/output/","title":"SWAN Output Components","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</pre> %load_ext autoreload %autoreload 2  import warnings warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>from rompy_swan.components.group import OUTPUT\nfrom rompy_swan.subcomponents.time import TimeRangeOpen\nfrom rompy_swan.components.output import (\n    SPECIAL_NAMES,\n    BaseLocation,\n    FRAME,\n    GROUP,\n    CURVE,\n    CURVES,\n    RAY,\n    ISOLINE,\n    POINTS,\n    POINTS_FILE,\n    NGRID,\n    NGRID_UNSTRUCTURED,\n    QUANTITY,\n    QUANTITIES,\n    OUTPUT_OPTIONS,\n    BLOCK,\n    BLOCKS,\n    TABLE,\n    SPECOUT,\n    NESTOUT,\n    TEST,\n)\n</pre> from rompy_swan.components.group import OUTPUT from rompy_swan.subcomponents.time import TimeRangeOpen from rompy_swan.components.output import (     SPECIAL_NAMES,     BaseLocation,     FRAME,     GROUP,     CURVE,     CURVES,     RAY,     ISOLINE,     POINTS,     POINTS_FILE,     NGRID,     NGRID_UNSTRUCTURED,     QUANTITY,     QUANTITIES,     OUTPUT_OPTIONS,     BLOCK,     BLOCKS,     TABLE,     SPECOUT,     NESTOUT,     TEST, ) In\u00a0[3]: Copied! <pre>OUTPUT?\n</pre> OUTPUT? <pre>Init signature:\nOUTPUT(\n    *,\n    model_type: Literal['output', 'OUTPUT'] = 'output',\n    frame: Optional[Annotated[rompy_swan.components.output.FRAME, FieldInfo(annotation=NoneType, required=True, description='Frame locations component')]] = None,\n    group: Optional[Annotated[rompy_swan.components.output.GROUP, FieldInfo(annotation=NoneType, required=True, description='Group locations component')]] = None,\n    curve: Optional[Annotated[rompy_swan.components.output.CURVES, FieldInfo(annotation=NoneType, required=True, description='Curve locations component')]] = None,\n    ray: Optional[Annotated[rompy_swan.components.output.RAY, FieldInfo(annotation=NoneType, required=True, description='Ray locations component')]] = None,\n    isoline: Optional[Annotated[rompy_swan.components.output.ISOLINE, FieldInfo(annotation=NoneType, required=True, description='Isoline locations component')]] = None,\n    points: Optional[Annotated[Union[rompy_swan.components.output.POINTS, rompy_swan.components.output.POINTS_FILE], FieldInfo(annotation=NoneType, required=True, description='Points locations component', discriminator='model_type')]] = None,\n    ngrid: Optional[Annotated[Union[rompy_swan.components.output.NGRID, rompy_swan.components.output.NGRID_UNSTRUCTURED], FieldInfo(annotation=NoneType, required=True, description='Ngrid locations component', discriminator='model_type')]] = None,\n    quantity: Optional[Annotated[rompy_swan.components.output.QUANTITIES, FieldInfo(annotation=NoneType, required=True, description='Quantity component')]] = None,\n    output_options: Optional[Annotated[rompy_swan.components.output.OUTPUT_OPTIONS, FieldInfo(annotation=NoneType, required=True, description='Output options component')]] = None,\n    block: Optional[Annotated[Union[rompy_swan.components.output.BLOCK, rompy_swan.components.output.BLOCKS], FieldInfo(annotation=NoneType, required=True, description='Block write component', discriminator='model_type')]] = None,\n    table: Optional[Annotated[rompy_swan.components.output.TABLE, FieldInfo(annotation=NoneType, required=True, description='Table write component')]] = None,\n    specout: Optional[Annotated[rompy_swan.components.output.SPECOUT, FieldInfo(annotation=NoneType, required=True, description='Spectra write component')]] = None,\n    nestout: Optional[Annotated[rompy_swan.components.output.NESTOUT, FieldInfo(annotation=NoneType, required=True, description='Nest write component')]] = None,\n    test: Optional[Annotated[rompy_swan.components.output.TEST, FieldInfo(annotation=NoneType, required=True, description='Intermediate write component')]] = None,\n) -&gt; None\nDocstring:     \nOutput group component.\n\n.. code-block:: text\n\n    FRAME 'sname' ...\n    GROUP 'sname' ...\n    CURVE 'sname' ...\n    RAY 'rname' ...\n    ISOLINE 'sname' 'rname' ...\n    POINTS 'sname ...\n    NGRID 'sname' ...\n    QUANTITY ...\n    OUTPUT OPTIONS ...\n    BLOCK 'sname' ...\n    TABLE 'sname' ...\n    SPECOUT 'sname' ...\n    NESTOUT 'sname ...\n\nThis group component is used to define multiple types of output locations and\nwrite components in a single model. Only fields that are explicitly prescribed are\nrendered by this group component.\n\nNote\n----\nThe components prescribed are validated according to some constraints as defined\nin the SWAN manual:\n\n- The name `'sname'` of each Locations component must be unique.\n- The Locations `'sname'` assigned to each write component must be defined.\n- The BLOCK component must be associated with either a `FRAME` or `GROUP`.\n- The ISOLINE write component must be associated with a `RAY` component.\n- The NGRID and NESTOUT components must be defined together.\n\nExamples\n--------\n\n.. ipython:: python\n    :okwarning:\n\n    from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\n    from rompy_swan.components.group import OUTPUT\n    points = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n    quantity = QUANTITIES(\n        quantities=[\n            dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n        ]\n    )\n    times = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\n    block = BLOCK(\n        model_type=\"block\",\n        sname=\"COMPGRID\",\n        fname=\"./swangrid.nc\",\n        output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n        times=times,\n    )\n    table = TABLE(\n        sname=\"outpts\",\n        format=\"noheader\",\n        fname=\"./swantable.nc\",\n        output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n        times=times,\n    )\n    out = OUTPUT(\n        points=points,\n        quantity=quantity,\n        block=block,\n        table=table,\n    )\n    print(out.render())\nInit docstring:\nCreate a new model by parsing and validating input data from keyword arguments.\n\nRaises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.\nFile:           /source/csiro/rompy-swan/src/rompy_swan/components/group.py\nType:           ModelMetaclass\nSubclasses:     </pre> In\u00a0[4]: Copied! <pre># Specifying a single block component\n\nblock = BLOCK(\n    sname=\"COMPGRID\",\n    fname=\"outgrid.nc\",\n    output=[\"depth\", \"wind\", \"hsign\", \"hswell\", \"dir\", \"tps\"],\n    times=TimeRangeOpen(tfmt=1, dfmt=\"min\"),\n    idla=3,\n)\nprint(block.render())\n\n# Note\n# ----\n# The times field is overriden in the SwanConfig class using the general TimeRange\n# but it can be used here to specify the time format and the time delta formats\n</pre> # Specifying a single block component  block = BLOCK(     sname=\"COMPGRID\",     fname=\"outgrid.nc\",     output=[\"depth\", \"wind\", \"hsign\", \"hswell\", \"dir\", \"tps\"],     times=TimeRangeOpen(tfmt=1, dfmt=\"min\"),     idla=3, ) print(block.render())  # Note # ---- # The times field is overriden in the SwanConfig class using the general TimeRange # but it can be used here to specify the time format and the time delta formats <pre>BLOCK sname='COMPGRID' fname='outgrid.nc' LAYOUT idla=3 &amp;\n    DEPTH &amp;\n    WIND &amp;\n    HSIGN &amp;\n    HSWELL &amp;\n    DIR &amp;\n    TPS &amp;\n    OUTPUT tbegblk=19700101.000000 deltblk=60.0 MIN\n</pre> In\u00a0[5]: Copied! <pre># Specifying multiple block components\n\nblock1 = BLOCK(sname=\"COMPGRID\", fname=\"depth.txt\", output=[\"depth\"])\nblock2 = BLOCK(sname=\"COMPGRID\", fname=\"hsign.txt\", output=[\"hsign\"])\nblock3 = BLOCK(sname=\"COMPGRID\", fname=\"tps.txt\", output=[\"tps\"])\nblock4 = BLOCK(sname=\"COMPGRID\", fname=\"dir.txt\", output=[\"dir\"])\n\nblocks = BLOCKS(components=[block1, block2, block3, block4])\nprint(blocks.render())\n</pre> # Specifying multiple block components  block1 = BLOCK(sname=\"COMPGRID\", fname=\"depth.txt\", output=[\"depth\"]) block2 = BLOCK(sname=\"COMPGRID\", fname=\"hsign.txt\", output=[\"hsign\"]) block3 = BLOCK(sname=\"COMPGRID\", fname=\"tps.txt\", output=[\"tps\"]) block4 = BLOCK(sname=\"COMPGRID\", fname=\"dir.txt\", output=[\"dir\"])  blocks = BLOCKS(components=[block1, block2, block3, block4]) print(blocks.render()) <pre>BLOCK sname='COMPGRID' fname='depth.txt' DEPTH\nBLOCK sname='COMPGRID' fname='hsign.txt' HSIGN\nBLOCK sname='COMPGRID' fname='tps.txt' TPS\nBLOCK sname='COMPGRID' fname='dir.txt' DIR\n</pre> In\u00a0[6]: Copied! <pre>output = OUTPUT(block=blocks)\nprint(output.render())\n</pre> output = OUTPUT(block=blocks) print(output.render()) <pre>BLOCK sname='COMPGRID' fname='depth.txt' DEPTH\n\nBLOCK sname='COMPGRID' fname='hsign.txt' HSIGN\n\nBLOCK sname='COMPGRID' fname='tps.txt' TPS\n\nBLOCK sname='COMPGRID' fname='dir.txt' DIR\n</pre>"},{"location":"examples/components/output/#swan-output-components","title":"SWAN Output Components\u00b6","text":"<p>This notebook shows examples of using the SWAN components to define model output commands</p>"},{"location":"examples/components/output/#output-group-component","title":"OUTPUT group component\u00b6","text":"<p>The OUTPUT group component provides an interface for the different types of SWAN output commands</p>"},{"location":"examples/components/output/#block","title":"BLOCK\u00b6","text":""},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>SWAN executable (for running simulations)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install rompy-swan\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/rom-py/rompy-swan.git\ncd rompy-swan\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>from rompy_swan import SwanConfig\nprint(\"rompy-swan installed successfully!\")\n</code></pre>"},{"location":"getting-started/installation/#swan-executable","title":"SWAN Executable","text":"<p>Rompy-swan generates SWAN input files but requires the SWAN executable to run simulations. Download SWAN from the official website.</p> <p>After installation, ensure the <code>swan</code> executable is in your PATH:</p> <pre><code>swan --version\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>Rompy-swan automatically installs:</p> <ul> <li>rompy \u2014 Core rompy framework</li> <li>pydantic \u2014 Data validation</li> <li>numpy \u2014 Numerical operations</li> <li>xarray \u2014 NetCDF data handling</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart \u2014 Run your first SWAN simulation</li> <li>Architecture \u2014 Understand the component structure</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This guide walks you through creating a basic SWAN simulation with rompy-swan.</p>"},{"location":"getting-started/quickstart/#basic-workflow","title":"Basic Workflow","text":"<ol> <li>Define the computational grid (CGRID)</li> <li>Configure startup parameters (project, mode, coordinates)</li> <li>Set up input grids for bathymetry, wind, etc.</li> <li>Configure physics (wave generation, breaking, friction)</li> <li>Define boundary conditions</li> <li>Configure output</li> <li>Generate the model and run</li> </ol>"},{"location":"getting-started/quickstart/#minimal-example","title":"Minimal Example","text":"<pre><code>from datetime import datetime\nfrom rompy.model import ModelRun\nfrom rompy.core.time import TimeRange\nfrom rompy_swan.config import SwanConfig\nfrom rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_JONSWAP\nfrom rompy_swan.components.numerics import NUMERIC\nfrom rompy_swan.components.group import STARTUP, PHYSICS\n\n# 1. Define the computational grid\ncgrid = REGULAR(\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n    grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n)\n\n# 2. Configure startup\nstartup = STARTUP(\n    project=PROJECT(name=\"MySimulation\", nr=\"001\"),\n    set=SET(level=0.0),\n    mode=MODE(),\n    coordinates=COORDINATES(),\n)\n\n# 3. Configure physics\nphysics = PHYSICS(\n    gen=GEN3(),\n    breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    friction=FRICTION_JONSWAP(cfjon=0.067),\n)\n\n# 4. Create the config\nconfig = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    physics=physics,\n)\n\n# 5. Create and run the model\nmodel = ModelRun(\n    run_id=\"my_swan_run\",\n    period=TimeRange(\n        start=datetime(2024, 1, 1),\n        end=datetime(2024, 1, 2),\n    ),\n    config=config,\n)\n\n# Generate input files\nmodel.generate()\n\n# Run SWAN (requires swan executable)\n# model.run()\n</code></pre>"},{"location":"getting-started/quickstart/#using-yaml-configuration","title":"Using YAML Configuration","text":"<p>For reproducibility, define your configuration in YAML:</p> <pre><code># config.yml\nmodel_type: swan\n\ncgrid:\n  model_type: regular\n  spectrum:\n    mdc: 36\n    flow: 0.04\n    fhigh: 1.0\n  grid:\n    xp: 0\n    yp: 0\n    alp: 0\n    xlen: 100000\n    ylen: 50000\n    mx: 100\n    my: 50\n\nstartup:\n  project:\n    name: MySimulation\n    nr: \"001\"\n  set:\n    level: 0.0\n  mode:\n    kind: nonstationary\n    dim: twodimensional\n  coordinates:\n    kind: cartesian\n\nphysics:\n  gen:\n    model_type: gen3\n  breaking:\n    model_type: constant\n    alpha: 1.0\n    gamma: 0.73\n  friction:\n    model_type: jonswap\n    cfjon: 0.067\n</code></pre> <p>Load and use:</p> <pre><code>import yaml\nfrom rompy_swan.config import SwanConfig\n\nwith open(\"config.yml\") as f:\n    config_dict = yaml.safe_load(f)\n\nconfig = SwanConfig(**config_dict)\n</code></pre>"},{"location":"getting-started/quickstart/#adding-input-grids","title":"Adding Input Grids","text":"<p>SWAN requires input grids for bathymetry and optionally for wind, currents, and other forcing:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR as INPGRID_REGULAR\nfrom rompy_swan.components.group import INPGRIDS\n\ninpgrid = INPGRIDS(\n    bottom=INPGRID_REGULAR(\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n        readinp=dict(fname=\"bottom.txt\"),\n    ),\n    wind=INPGRID_REGULAR(\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=10, my=5),\n        readinp=dict(fname=\"wind.txt\"),\n    ),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    inpgrid=inpgrid,\n    physics=physics,\n)\n</code></pre>"},{"location":"getting-started/quickstart/#adding-boundary-conditions","title":"Adding Boundary Conditions","text":"<p>For wave boundary conditions from spectral data:</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nfrom rompy_swan.subcomponents.boundary import SIDE, CONSTANTPAR\n\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"jonswap\", gamma=3.3),\n    location=SIDE(side=\"west\"),\n    data=CONSTANTPAR(hs=2.0, per=10.0, dir=270.0, dd=30.0),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    boundary=boundary,\n    physics=physics,\n)\n</code></pre>"},{"location":"getting-started/quickstart/#configuring-output","title":"Configuring Output","text":"<pre><code>from rompy_swan.components.output import BLOCK, QUANTITY\nfrom rompy_swan.components.group import OUTPUT\n\noutput = OUTPUT(\n    block=BLOCK(\n        model_type=\"block\",\n        sname=\"COMPGRID\",\n        fname=\"output.nc\",\n        output=[\"hsign\", \"tps\", \"dir\", \"depth\"],\n    ),\n    quantity=[\n        QUANTITY(output=[\"hsign\"], hexp=100.0),\n    ],\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    physics=physics,\n    output=output,\n)\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example-with-data-interface","title":"Complete Example with Data Interface","text":"<p>For connecting to external data sources:</p> <pre><code>from rompy_swan.interface import DataInterface, BoundaryInterface\n\n# Use DataInterface for automatic data handling\ndata = DataInterface(\n    bottom=dict(\n        model_type=\"swan_data_grid\",\n        source=dict(uri=\"bathymetry.nc\"),\n        var=\"elevation\",\n    ),\n    wind=dict(\n        model_type=\"swan_data_grid\",\n        source=dict(uri=\"wind.nc\"),\n        var=[\"u10\", \"v10\"],\n    ),\n)\n\nconfig = SwanConfig(\n    cgrid=cgrid,\n    startup=startup,\n    inpgrid=data,\n    physics=physics,\n)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture \u2014 Understand the component structure</li> <li>Configuration \u2014 Detailed configuration options</li> <li>Components \u2014 Reference for all components</li> <li>Data Interfaces \u2014 Connect external data sources</li> </ul>"},{"location":"subcomponents/base/","title":"Base","text":"<p>Sub-commands to support the output components</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY","title":"XY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Points in problem coordinates.</p> <p>.. code-block:: text</p> <pre><code>&lt; [x] [y] &gt;\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY--note","title":"Note","text":"<p>Coordinates should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.base import XY\npoints = XY(\n    x=[172, 172, 172, 172.5, 173],\n    y=[-41, -40.5, -40, -40, -40],\n    fmt=\"0.2f\",\n)\nprint(points.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>class XY(BaseSubComponent):\n    \"\"\"Points in problem coordinates.\n\n    .. code-block:: text\n\n        &lt; [x] [y] &gt;\n\n    Note\n    ----\n    Coordinates should be given in m when Cartesian coordinates are used or degrees\n    when Spherical coordinates are used (see command `COORD`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.base import XY\n        points = XY(\n            x=[172, 172, 172, 172.5, 173],\n            y=[-41, -40.5, -40, -40, -40],\n            fmt=\"0.2f\",\n        )\n        print(points.render())\n\n    \"\"\"\n\n    model_type: Literal[\"xy\", \"XY\"] = Field(\n        default=\"xy\",\n        description=\"Model type discriminator\",\n    )\n    x: list[float] = Field(description=\"Problem x-coordinate values\")\n    y: list[float] = Field(description=\"Problem y-coordinate values\")\n    fmt: str = Field(\n        default=\"0.8f\",\n        description=\"The format to render floats values\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_size(self) -&gt; \"XY\":\n        if len(self.x) != len(self.y):\n            raise ValueError(\"x and y must be the same size\")\n        return self\n\n    @property\n    def size(self):\n        return len(self.x)\n\n    def cmd(self) -&gt; str:\n        repr = \"\"\n        for x, y in zip(self.x, self.y):\n            repr += f\"\\n{x:{self.fmt}} {y:{self.fmt}}\"\n        return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY-attributes","title":"Attributes","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['xy', 'XY'] = Field(default='xy', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: list[float] = Field(description='Problem x-coordinate values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: list[float] = Field(description='Problem y-coordinate values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.fmt","title":"fmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmt: str = Field(default='0.8f', description='The format to render floats values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY-functions","title":"Functions","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.validate_size","title":"validate_size","text":"<pre><code>validate_size() -&gt; XY\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_size(self) -&gt; \"XY\":\n    if len(self.x) != len(self.y):\n        raise ValueError(\"x and y must be the same size\")\n    return self\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"\"\n    for x, y in zip(self.x, self.y):\n        repr += f\"\\n{x:{self.fmt}} {y:{self.fmt}}\"\n    return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ","title":"IJ","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Points in grid indices coordinates.</p> <p>.. code-block:: text</p> <pre><code>&lt; [x] [y] &gt;\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ--note","title":"Note","text":"<p>Coordinates should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.base import IJ\npoints = IJ(i=[0, 0, 5], j=[0, 19, 19])\nprint(points.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>class IJ(BaseSubComponent):\n    \"\"\"Points in grid indices coordinates.\n\n    .. code-block:: text\n\n        &lt; [x] [y] &gt;\n\n    Note\n    ----\n    Coordinates should be given in m when Cartesian coordinates are used or degrees\n    when Spherical coordinates are used (see command `COORD`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.base import IJ\n        points = IJ(i=[0, 0, 5], j=[0, 19, 19])\n        print(points.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ij\", \"IJ\"] = Field(\n        default=\"ij\",\n        description=\"Model type discriminator\",\n    )\n    i: list[int] = Field(description=\"i-index values\")\n    j: list[int] = Field(description=\"j-index values\")\n\n    @model_validator(mode=\"after\")\n    def validate_size(self) -&gt; \"IJ\":\n        if len(self.i) != len(self.j):\n            raise ValueError(\"i and j must be the same size\")\n        return self\n\n    @property\n    def size(self):\n        return len(self.i)\n\n    def cmd(self) -&gt; str:\n        repr = \"\"\n        for i, j in zip(self.i, self.j):\n            repr += f\"\\ni={i} j={j}\"\n        return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ-attributes","title":"Attributes","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ij', 'IJ'] = Field(default='ij', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.i","title":"i  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i: list[int] = Field(description='i-index values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.j","title":"j  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>j: list[int] = Field(description='j-index values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ-functions","title":"Functions","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.validate_size","title":"validate_size","text":"<pre><code>validate_size() -&gt; IJ\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_size(self) -&gt; \"IJ\":\n    if len(self.i) != len(self.j):\n        raise ValueError(\"i and j must be the same size\")\n    return self\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/base.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"\"\n    for i, j in zip(self.i, self.j):\n        repr += f\"\\ni={i} j={j}\"\n    return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/boundary/","title":"Boundary and initial conditions","text":"<p>Sub-commands to support the boundary and initial conditions components</p>"},{"location":"subcomponents/boundary/#boundary","title":"Boundary","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE","title":"SIDE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Boundary over one side of computational domain.</p> <p>.. code-block:: text</p> <pre><code>SIDE NORTH|NW|WEST|SW|SOUTH|SE|E|NE CCW|CLOCKWISE\n</code></pre> <p>The boundary is one full side of the computational grid (in 1D cases either of the two ends of the 1D-grid).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE--note","title":"Note","text":"<p>Should not be used in case of CURVILINEAR grids.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import SIDE\nside = SIDE(side=\"west\", direction=\"ccw\")\nprint(side.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class SIDE(BaseSubComponent):\n    \"\"\"Boundary over one side of computational domain.\n\n    .. code-block:: text\n\n        SIDE NORTH|NW|WEST|SW|SOUTH|SE|E|NE CCW|CLOCKWISE\n\n    The boundary is one full side of the computational grid (in 1D cases either of the\n    two ends of the 1D-grid).\n\n    Note\n    ----\n    Should not be used in case of CURVILINEAR grids.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import SIDE\n        side = SIDE(side=\"west\", direction=\"ccw\")\n        print(side.render())\n\n    \"\"\"\n\n    model_type: Literal[\"side\", \"SIDE\"] = Field(\n        default=\"side\",\n        description=\"Model type discriminator\",\n    )\n    side: Literal[\"north\", \"nw\", \"west\", \"sw\", \"south\", \"se\", \"east\", \"ne\"] = Field(\n        description=\"The side of the grid to apply the boundary to\",\n    )\n    direction: Literal[\"ccw\", \"clockwise\"] = Field(\n        default=\"ccw\",\n        description=\"The direction to apply the boundary in\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"SIDE {self.side.upper()} {self.direction.upper()} \"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['side', 'SIDE'] = Field(default='side', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: Literal['north', 'nw', 'west', 'sw', 'south', 'se', 'east', 'ne'] = Field(description='The side of the grid to apply the boundary to')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.direction","title":"direction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction: Literal['ccw', 'clockwise'] = Field(default='ccw', description='The direction to apply the boundary in')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"SIDE {self.side.upper()} {self.direction.upper()} \"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT","title":"SEGMENT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Boundary over a segment defined from points.</p> <p>.. code-block:: text</p> <pre><code>SEGMENT XY &lt; [x] [y] &gt;\nSEGMENT IJ &lt; [i] [j] &gt;\n</code></pre> <p>The segment is defined either by means of a series of points in terms of problem coordinates (<code>XY</code>) or by means of a series of points in terms of grid indices (<code>IJ</code>). The points do not have to include all or coincide with actual grid points.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import SEGMENT\nseg = SEGMENT(\n    points=dict(\n        model_type=\"xy\",\n        x=[172, 172, 172, 172.5, 173],\n        y=[-41, -40.5, -40, -40, -40],\n        fmt=\"0.2f\",\n    ),\n)\nprint(seg.render())\nseg = SEGMENT(\n    points=dict(\n        model_type=\"ij\",\n        i=[0, 0, 5],\n        j=[0, 19, 19],\n    ),\n)\nprint(seg.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class SEGMENT(BaseSubComponent):\n    \"\"\"Boundary over a segment defined from points.\n\n    .. code-block:: text\n\n        SEGMENT XY &lt; [x] [y] &gt;\n        SEGMENT IJ &lt; [i] [j] &gt;\n\n    The segment is defined either by means of a series of points in terms of problem\n    coordinates (`XY`) or by means of a series of points in terms of grid indices\n    (`IJ`). The points do not have to include all or coincide with actual grid points.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import SEGMENT\n        seg = SEGMENT(\n            points=dict(\n                model_type=\"xy\",\n                x=[172, 172, 172, 172.5, 173],\n                y=[-41, -40.5, -40, -40, -40],\n                fmt=\"0.2f\",\n            ),\n        )\n        print(seg.render())\n        seg = SEGMENT(\n            points=dict(\n                model_type=\"ij\",\n                i=[0, 0, 5],\n                j=[0, 19, 19],\n            ),\n        )\n        print(seg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"segment\", \"SEGMENT\"] = Field(\n        default=\"segment\",\n        description=\"Model type discriminator\",\n    )\n    points: Union[XY, IJ] = Field(\n        description=\"Points to define the segment\",\n        discriminator=\"model_type\",\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"SEGMENT {self.points.model_type.upper()} {self.points.render()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['segment', 'SEGMENT'] = Field(default='segment', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Union[XY, IJ] = Field(description='Points to define the segment', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"SEGMENT {self.points.model_type.upper()} {self.points.render()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR","title":"PAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spectral parameters.</p> <p>.. code-block:: text</p> <pre><code>PAR [hs] [per] [dir] [dd]\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import PAR\npar = PAR(hs=1.5, per=8.1, dir=225)\nprint(par.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class PAR(BaseSubComponent):\n    \"\"\"Spectral parameters.\n\n    .. code-block:: text\n\n        PAR [hs] [per] [dir] [dd]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import PAR\n        par = PAR(hs=1.5, per=8.1, dir=225)\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"par\"] = Field(\n        default=\"par\",\n        description=\"Model type discriminator\",\n    )\n    hs: float = Field(\n        description=\"The significant wave height (m)\",\n        gt=0.0,\n    )\n    per: float = Field(\n        description=(\n            \"The characteristic period (s) of the energy spectrum (relative \"\n            \"frequency; which is equal to absolute frequency in the absence of \"\n            \"currents); `per` is the value of the peak period if option PEAK is \"\n            \"chosen in command BOUND SHAPE or `per` is the value of the mean period, \"\n            \"if option MEAN was chosen in command BOUND SHAPE.\"\n        ),\n        gt=0.0,\n    )\n    dir: float = Field(\n        description=(\n            \"The peak wave direction thetapeak (degree), constant over frequencies\"\n        ),\n        ge=-360.0,\n        le=360.0,\n    )\n    dd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient of directional spreading; a `cos^m(\u03b8)` distribution is \"\n            \"assumed. `dd` is interpreted as the directional standard deviation in \"\n            \"degrees, if the option DEGREES is chosen in the command BOUND SHAPE \"\n            \"(SWAN default: 30). `dd` is interpreted as the power `m`, if the option \"\n            \"POWER is chosen in the command BOUND SHAPE (SWAN default: 2)\"\n        ),\n        ge=0.0,\n        le=360.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"PAR hs={self.hs} per={self.per} dir={self.dir}\"\n        if self.dd is not None:\n            repr += f\" dd={self.dd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['par'] = Field(default='par', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.hs","title":"hs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hs: float = Field(description='The significant wave height (m)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.per","title":"per  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per: float = Field(description='The characteristic period (s) of the energy spectrum (relative frequency; which is equal to absolute frequency in the absence of currents); `per` is the value of the peak period if option PEAK is chosen in command BOUND SHAPE or `per` is the value of the mean period, if option MEAN was chosen in command BOUND SHAPE.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: float = Field(description='The peak wave direction thetapeak (degree), constant over frequencies', ge=-360.0, le=360.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.dd","title":"dd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dd: Optional[float] = Field(default=None, description='Coefficient of directional spreading; a `cos^m(\u03b8)` distribution is assumed. `dd` is interpreted as the directional standard deviation in degrees, if the option DEGREES is chosen in the command BOUND SHAPE (SWAN default: 30). `dd` is interpreted as the power `m`, if the option POWER is chosen in the command BOUND SHAPE (SWAN default: 2)', ge=0.0, le=360.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"PAR hs={self.hs} per={self.per} dir={self.dir}\"\n    if self.dd is not None:\n        repr += f\" dd={self.dd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR","title":"CONSTANTPAR","text":"<p>               Bases: <code>PAR</code></p> <p>Constant spectral parameters.</p> <p>.. code-block:: text</p> <pre><code>CONSTANT PAR [hs] [per] [dir] ([dd])\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import CONSTANTPAR\npar = CONSTANTPAR(hs=1.5, per=8.1, dir=225)\nprint(par.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class CONSTANTPAR(PAR):\n    \"\"\"Constant spectral parameters.\n\n    .. code-block:: text\n\n        CONSTANT PAR [hs] [per] [dir] ([dd])\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import CONSTANTPAR\n        par = CONSTANTPAR(hs=1.5, per=8.1, dir=225)\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constantpar\", \"CONSTANTPAR\"] = Field(\n        default=\"constantpar\",\n        description=\"Model type discriminator\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"CONSTANT {super().cmd()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constantpar', 'CONSTANTPAR'] = Field(default='constantpar', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"CONSTANT {super().cmd()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR","title":"VARIABLEPAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Variable spectral parameter.</p> <p>.. code-block:: text</p> <pre><code>VARIABLE PAR &lt; [len] [hs] [per] [dir] [dd] &gt;\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import VARIABLEPAR\npar = VARIABLEPAR(\n    hs=[1.5, 1.4, 1.1],\n    per=[8.1, 8.0, 8.1],\n    dir=[225, 226, 228],\n    dd=[25, 22, 23],\n    len=[0, 0.5, 1.0],\n)\nprint(par.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class VARIABLEPAR(BaseSubComponent):\n    \"\"\"Variable spectral parameter.\n\n    .. code-block:: text\n\n        VARIABLE PAR &lt; [len] [hs] [per] [dir] [dd] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import VARIABLEPAR\n        par = VARIABLEPAR(\n            hs=[1.5, 1.4, 1.1],\n            per=[8.1, 8.0, 8.1],\n            dir=[225, 226, 228],\n            dd=[25, 22, 23],\n            len=[0, 0.5, 1.0],\n        )\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"variablepar\", \"VARIABLEPAR\"] = Field(\n        default=\"variablepar\",\n        description=\"Model type discriminator\",\n    )\n    hs: list[Annotated[float, Field(ge=0.0)]] = Field(\n        description=\"The significant wave height (m)\",\n    )\n    per: list[Annotated[float, Field(ge=0.0)]] = Field(\n        description=(\n            \"The characteristic period (s) of the energy spectrum (relative \"\n            \"frequency; which is equal to absolute frequency in the absence of \"\n            \"currents); `per` is the value of the peak period if option PEAK is \"\n            \"chosen in command BOUND SHAPE or `per` is the value of the mean period, \"\n            \"if option MEAN was chosen in command BOUND SHAPE\"\n        ),\n    )\n    dir: list[Annotated[float, Field(ge=-360.0, le=360.0)]] = Field(\n        description=(\n            \"The peak wave direction thetapeak (degrees), constant over frequencies\"\n        ),\n    )\n    dd: list[Annotated[float, Field(ge=0.0, le=360.0)]] = Field(\n        description=(\n            \"Coefficient of directional spreading; a $cos^m(\u03b8)$ distribution is \"\n            \"assumed. `dd` is interpreted as the directional standard deviation in \"\n            \"degrees, if the option DEGREES is chosen in the command BOUND SHAPE \"\n            \"(SWAN default: 30). `dd` is interpreted as the power `m`, if the option \"\n            \"POWER is chosen in the command BOUND SHAPE (SWAN default: 2)\"\n        ),\n    )\n    dist: list[Annotated[float, Field(ge=0)]] = Field(\n        alias=\"len\",\n        description=(\n            \"Is the distance from the first point of the side or segment to the point \"\n            \"along the side or segment for which the incident wave spectrum is \"\n            \"prescribed. Note: these points do no have to coincide with grid points of \"\n            \"the computational grid. `len` is the distance in m or degrees in the case \"\n            \"of spherical coordinates, not in grid steps. The values of `len` should \"\n            \"be given in ascending order. The length along a SIDE is measured in \"\n            \"clockwise or counterclockwise direction, depending on the options CCW or \"\n            \"CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT \"\n            \"the length is measured from the indicated begin point of the segment\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"VARIABLEPAR\":\n        for key in [\"hs\", \"per\", \"dir\", \"dd\"]:\n            if len(getattr(self, key)) != len(self.dist):\n                raise ValueError(f\"Size of dist and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = \"VARIABLE PAR\"\n        for dist, hs, per, dir, dd in zip(\n            self.dist, self.hs, self.per, self.dir, self.dd\n        ):\n            repr += f\" &amp;\\n\\tlen={dist} hs={hs} per={per} dir={dir} dd={dd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['variablepar', 'VARIABLEPAR'] = Field(default='variablepar', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.hs","title":"hs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hs: list[Annotated[float, Field(ge=0.0)]] = Field(description='The significant wave height (m)')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.per","title":"per  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per: list[Annotated[float, Field(ge=0.0)]] = Field(description='The characteristic period (s) of the energy spectrum (relative frequency; which is equal to absolute frequency in the absence of currents); `per` is the value of the peak period if option PEAK is chosen in command BOUND SHAPE or `per` is the value of the mean period, if option MEAN was chosen in command BOUND SHAPE')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: list[Annotated[float, Field(ge=-360.0, le=360.0)]] = Field(description='The peak wave direction thetapeak (degrees), constant over frequencies')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dd","title":"dd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dd: list[Annotated[float, Field(ge=0.0, le=360.0)]] = Field(description='Coefficient of directional spreading; a $cos^m(\u03b8)$ distribution is assumed. `dd` is interpreted as the directional standard deviation in degrees, if the option DEGREES is chosen in the command BOUND SHAPE (SWAN default: 30). `dd` is interpreted as the power `m`, if the option POWER is chosen in the command BOUND SHAPE (SWAN default: 2)')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dist","title":"dist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist: list[Annotated[float, Field(ge=0)]] = Field(alias='len', description='Is the distance from the first point of the side or segment to the point along the side or segment for which the incident wave spectrum is prescribed. Note: these points do no have to coincide with grid points of the computational grid. `len` is the distance in m or degrees in the case of spherical coordinates, not in grid steps. The values of `len` should be given in ascending order. The length along a SIDE is measured in clockwise or counterclockwise direction, depending on the options CCW or CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT the length is measured from the indicated begin point of the segment')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; VARIABLEPAR\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"VARIABLEPAR\":\n    for key in [\"hs\", \"per\", \"dir\", \"dd\"]:\n        if len(getattr(self, key)) != len(self.dist):\n            raise ValueError(f\"Size of dist and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = \"VARIABLE PAR\"\n    for dist, hs, per, dir, dd in zip(\n        self.dist, self.hs, self.per, self.dir, self.dd\n    ):\n        repr += f\" &amp;\\n\\tlen={dist} hs={hs} per={per} dir={dir} dd={dd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE","title":"CONSTANTFILE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Constant file specification.</p> <p>.. code-block:: text</p> <pre><code>CONSTANT FILE 'fname' [seq]\n</code></pre> <p>There are three types of files:</p> <ul> <li>TPAR files containing nonstationary wave parameters</li> <li>files containing stationary or nonstationary 1D spectra   (usually from measurements)</li> <li>files containing stationary or nonstationary 2D spectra   (from other computer programs or other SWAN runs)</li> </ul> <p>A TPAR file is for only one location; it has the string TPAR on the first line of the file and a number of lines which each contain 5 numbers, i.e.: Time (ISO-notation), Hs, Period (average or peak period depending on the choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian, depending on command SET), Directional spread (in degrees or as power of cos depending on the choice given in command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE--note","title":"Note","text":"<p>Example of a TPAR file:</p> <p>.. code-block:: text</p> <pre><code>TPAR\n19920516.130000 4.2 12. -110. 22.\n19920516.180000 4.2 12. -110. 22.\n19920517.000000 1.2 8. -110. 22.\n19920517.120000 1.4 8.5 -80. 26\n19920517.200000 0.9 6.5 -95. 28\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import CONSTANTFILE\npar = CONSTANTFILE(fname=\"tpar.txt\")\nprint(par.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class CONSTANTFILE(BaseSubComponent):\n    \"\"\"Constant file specification.\n\n    .. code-block:: text\n\n        CONSTANT FILE 'fname' [seq]\n\n    There are three types of files:\n\n    - TPAR files containing nonstationary wave parameters\n    - files containing stationary or nonstationary 1D spectra\n      (usually from measurements)\n    - files containing stationary or nonstationary 2D spectra\n      (from other computer programs or other SWAN runs)\n\n    A TPAR file is for only one location; it has the string TPAR on the first\n    line of the file and a number of lines which each contain 5 numbers, i.e.:\n    Time (ISO-notation), Hs, Period (average or peak period depending on the\n    choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian,\n    depending on command SET), Directional spread (in degrees or as power of cos\n    depending on the choice given in command BOUND SHAPE).\n\n    Note\n    ----\n    Example of a TPAR file:\n\n    .. code-block:: text\n\n        TPAR\n        19920516.130000 4.2 12. -110. 22.\n        19920516.180000 4.2 12. -110. 22.\n        19920517.000000 1.2 8. -110. 22.\n        19920517.120000 1.4 8.5 -80. 26\n        19920517.200000 0.9 6.5 -95. 28\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import CONSTANTFILE\n        par = CONSTANTFILE(fname=\"tpar.txt\")\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constantfile\", \"CONSTANTFILE\"] = Field(\n        default=\"constantfile\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the boundary condition.\",\n        max_length=36,\n    )\n    seq: Optional[int] = Field(\n        default=None,\n        description=(\n            \"sequence number of geographic location in the file (see Appendix D); \"\n            \"useful for files which contain spectra for more than one location. \"\n            \"Note: a TPAR file always contains only one location so in this case \"\n            \"`seq` must always be 1\"\n        ),\n        ge=1,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"CONSTANT FILE fname='{self.fname}'\"\n        if self.seq is not None:\n            repr += f\" seq={self.seq}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constantfile', 'CONSTANTFILE'] = Field(default='constantfile', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the boundary condition.', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.seq","title":"seq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seq: Optional[int] = Field(default=None, description='sequence number of geographic location in the file (see Appendix D); useful for files which contain spectra for more than one location. Note: a TPAR file always contains only one location so in this case `seq` must always be 1', ge=1)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"CONSTANT FILE fname='{self.fname}'\"\n    if self.seq is not None:\n        repr += f\" seq={self.seq}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE","title":"VARIABLEFILE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Variable file specification.</p> <p>.. code-block:: text</p> <pre><code>VARIABLE FILE &lt; [len] 'fname' [seq] &gt;\n</code></pre> <p>There are three types of files:</p> <ul> <li>TPAR files containing nonstationary wave parameters</li> <li>files containing stationary or nonstationary 1D spectra   (usually from measurements)</li> <li>files containing stationary or nonstationary 2D spectra   (from other computer programs or other SWAN runs)</li> </ul> <p>A TPAR file is for only one location; it has the string TPAR on the first line of the file and a number of lines which each contain 5 numbers, i.e.: Time (ISO-notation), Hs, Period (average or peak period depending on the choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian, depending on command SET), Directional spread (in degrees or as power of cos depending on the choice given in command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE--note","title":"Note","text":"<p>Example of a TPAR file:</p> <p>.. code-block:: text</p> <pre><code>TPAR\n19920516.130000 4.2 12. -110. 22.\n19920516.180000 4.2 12. -110. 22.\n19920517.000000 1.2 8. -110. 22.\n19920517.120000 1.4 8.5 -80. 26\n19920517.200000 0.9 6.5 -95. 28\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import VARIABLEFILE\npar = VARIABLEFILE(\n    fname=[\"tpar1.txt\", \"tpar2.txt\", \"tpar3.txt\"],\n    len=[0.0, 0.5, 1.0],\n)\nprint(par.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class VARIABLEFILE(BaseSubComponent):\n    \"\"\"Variable file specification.\n\n    .. code-block:: text\n\n        VARIABLE FILE &lt; [len] 'fname' [seq] &gt;\n\n    There are three types of files:\n\n    - TPAR files containing nonstationary wave parameters\n    - files containing stationary or nonstationary 1D spectra\n      (usually from measurements)\n    - files containing stationary or nonstationary 2D spectra\n      (from other computer programs or other SWAN runs)\n\n    A TPAR file is for only one location; it has the string TPAR on the first\n    line of the file and a number of lines which each contain 5 numbers, i.e.:\n    Time (ISO-notation), Hs, Period (average or peak period depending on the\n    choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian,\n    depending on command SET), Directional spread (in degrees or as power of cos\n    depending on the choice given in command BOUND SHAPE).\n\n    Note\n    ----\n    Example of a TPAR file:\n\n    .. code-block:: text\n\n        TPAR\n        19920516.130000 4.2 12. -110. 22.\n        19920516.180000 4.2 12. -110. 22.\n        19920517.000000 1.2 8. -110. 22.\n        19920517.120000 1.4 8.5 -80. 26\n        19920517.200000 0.9 6.5 -95. 28\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import VARIABLEFILE\n        par = VARIABLEFILE(\n            fname=[\"tpar1.txt\", \"tpar2.txt\", \"tpar3.txt\"],\n            len=[0.0, 0.5, 1.0],\n        )\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"variablefile\", \"VARIABLEFILE\"] = Field(\n        default=\"variablefile\",\n        description=\"Model type discriminator\",\n    )\n    fname: list[Annotated[str, Field(max_length=36)]] = Field(\n        description=\"Names of the files containing the boundary condition\",\n    )\n    seq: Optional[list[Annotated[int, Field(ge=1)]]] = Field(\n        default=None,\n        description=(\n            \"sequence number of geographic location in the file (see Appendix D); \"\n            \"useful for files which contain spectra for more than one location. \"\n            \"Note: a TPAR file always contains only one location so in this case \"\n            \"[seq] must always be 1.\"\n        ),\n    )\n    dist: list[Annotated[float, Field(ge=0)]] = Field(\n        alias=\"len\",\n        description=(\n            \"Is the distance from the first point of the side or segment to the point \"\n            \"along the side or segment for which the incident wave spectrum is \"\n            \"prescribed. Note: these points do no have to coincide with grid points \"\n            \"of the computational grid. [len] is the distance in m or degrees in the \"\n            \"case of spherical coordinates, not in grid steps. The values of `len` \"\n            \"should be given in ascending order. The length along a SIDE is measured \"\n            \"in clockwise or counterclockwise direction, depending on the options CCW \"\n            \"or CLOCKWISE (see above). The option CCW is default. In case of a \"\n            \"SEGMENT the length is measured from the indicated begin point of the \"\n            \"segment.\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"VARIABLEFILE\":\n        for key in [\"fname\", \"seq\"]:\n            attr = getattr(self, key)\n            if attr is not None and len(attr) != len(self.dist):\n                raise ValueError(f\"Size of dist and {key} must be the same\")\n        if self.seq is None:\n            self.seq = [1] * len(self.dist)\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = \"VARIABLE FILE\"\n        for dist, fname, seq in zip(self.dist, self.fname, self.seq):\n            repr += f\" &amp;\\n\\tlen={dist} fname='{fname}' seq={seq}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['variablefile', 'VARIABLEFILE'] = Field(default='variablefile', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: list[Annotated[str, Field(max_length=36)]] = Field(description='Names of the files containing the boundary condition')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.seq","title":"seq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seq: Optional[list[Annotated[int, Field(ge=1)]]] = Field(default=None, description='sequence number of geographic location in the file (see Appendix D); useful for files which contain spectra for more than one location. Note: a TPAR file always contains only one location so in this case [seq] must always be 1.')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.dist","title":"dist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist: list[Annotated[float, Field(ge=0)]] = Field(alias='len', description='Is the distance from the first point of the side or segment to the point along the side or segment for which the incident wave spectrum is prescribed. Note: these points do no have to coincide with grid points of the computational grid. [len] is the distance in m or degrees in the case of spherical coordinates, not in grid steps. The values of `len` should be given in ascending order. The length along a SIDE is measured in clockwise or counterclockwise direction, depending on the options CCW or CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT the length is measured from the indicated begin point of the segment.')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; VARIABLEFILE\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"VARIABLEFILE\":\n    for key in [\"fname\", \"seq\"]:\n        attr = getattr(self, key)\n        if attr is not None and len(attr) != len(self.dist):\n            raise ValueError(f\"Size of dist and {key} must be the same\")\n    if self.seq is None:\n        self.seq = [1] * len(self.dist)\n    return self\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = \"VARIABLE FILE\"\n    for dist, fname, seq in zip(self.dist, self.fname, self.seq):\n        repr += f\" &amp;\\n\\tlen={dist} fname='{fname}' seq={seq}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#initial-conditions","title":"Initial conditions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT","title":"DEFAULT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Default initial conditions.</p> <p>.. code-block:: text</p> <pre><code>DEFAULT\n</code></pre> <p>The initial spectra are computed from the local wind velocities, using the deep-water growth curve of Kahma and Calkoen (1992), cut off at values of significant wave height and peak frequency from Pierson and Moskowitz (1964). The average (over the model area) spatial step size is used as fetch with local wind. The shape of the spectrum is default JONSWAP with a cos2-directional distribution (options are available: see command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import DEFAULT\ninit = DEFAULT()\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class DEFAULT(BaseSubComponent):\n    \"\"\"Default initial conditions.\n\n    .. code-block:: text\n\n        DEFAULT\n\n    The initial spectra are computed from the local wind velocities, using the\n    deep-water growth curve of Kahma and Calkoen (1992), cut off at values of\n    significant wave height and peak frequency from Pierson and Moskowitz (1964).\n    The average (over the model area) spatial step size is used as fetch with local\n    wind. The shape of the spectrum is default JONSWAP with a cos2-directional\n    distribution (options are available: see command BOUND SHAPE).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import DEFAULT\n        init = DEFAULT()\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"default\", \"DEFAULT\"] = Field(\n        default=\"default\",\n        description=\"Model type discriminator\",\n    )\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['default', 'DEFAULT'] = Field(default='default', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO","title":"ZERO","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Zero initial conditions.</p> <p>.. code-block:: text</p> <pre><code>ZERO\n</code></pre> <p>The initial spectral densities are all 0; note that if waves are generated in the model only by wind, waves can become non-zero only by the presence of the \u201dA\u201d term in the growth model; see the keyword AGROW in command GEN3.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import ZERO\ninit = ZERO()\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class ZERO(BaseSubComponent):\n    \"\"\"Zero initial conditions.\n\n    .. code-block:: text\n\n        ZERO\n\n    The initial spectral densities are all 0; note that if waves are generated in the\n    model only by wind, waves can become non-zero only by the presence of the\n    \u201dA\u201d term in the growth model; see the keyword AGROW in command GEN3.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import ZERO\n        init = ZERO()\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"zero\", \"ZERO\"] = Field(\n        default=\"zero\",\n        description=\"Model type discriminator\",\n    )\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['zero', 'ZERO'] = Field(default='zero', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE","title":"HOTSINGLE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Hotstart single initial conditions.</p> <p>.. code-block:: text</p> <pre><code>HOTSTART SINGLE fname='fname' FREE|UNFORMATTED\n</code></pre> <p>Initial wave field is read from file; this file was generated in a previous SWAN run by means of the HOTFILE command. If the previous run was nonstationary, the time found on the file will be assumed to be the initial time of computation. It can also be used for stationary computation as first guess. The computational grid (both in geographical space and in spectral space) must be identical to the one in the run in which the initial wave field was computed</p> <p>Input will be read from a single (concatenated) hotfile. In the case of a previous parallel MPI run, the concatenated hotfile can be created from a set of multiple hotfiles using the program hcat.exe, see Implementation Manual.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import HOTSINGLE\ninit = HOTSINGLE(fname=\"hotstart.swn\", format=\"free\")\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class HOTSINGLE(BaseSubComponent):\n    \"\"\"Hotstart single initial conditions.\n\n    .. code-block:: text\n\n        HOTSTART SINGLE fname='fname' FREE|UNFORMATTED\n\n    Initial wave field is read from file; this file was generated in a previous SWAN\n    run by means of the HOTFILE command. If the previous run was nonstationary,\n    the time found on the file will be assumed to be the initial time of computation. It\n    can also be used for stationary computation as first guess. The computational grid\n    (both in geographical space and in spectral space) must be identical to the one in\n    the run in which the initial wave field was computed\n\n    Input will be read from a single (concatenated) hotfile. In the case of a previous\n    parallel MPI run, the concatenated hotfile can be created from a set of multiple\n    hotfiles using the program hcat.exe, see Implementation Manual.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import HOTSINGLE\n        init = HOTSINGLE(fname=\"hotstart.swn\", format=\"free\")\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotsingle\", \"HOTSINGLE\"] = Field(\n        default=\"hotsingle\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the initial wave field\",\n        max_length=36,\n    )\n    format: Literal[\"free\", \"unformatted\"] = Field(\n        default=\"free\",\n        description=(\n            \"Format of the file containing the initial wave field. \"\n            \"FREE: free format, UNFORMATTED: binary format\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"HOTSTART SINGLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotsingle', 'HOTSINGLE'] = Field(default='hotsingle', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the initial wave field', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['free', 'unformatted'] = Field(default='free', description='Format of the file containing the initial wave field. FREE: free format, UNFORMATTED: binary format')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"HOTSTART SINGLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE","title":"HOTMULTIPLE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Hotstart multiple initial conditions.</p> <p>.. code-block:: text</p> <pre><code>HOTSTART MULTIPLE fname='fname' FREE|UNFORMATTED\n</code></pre> <p>Initial wave field is read from file; this file was generated in a previous SWAN run by means of the HOTFILE command. If the previous run was nonstationary, the time found on the file will be assumed to be the initial time of computation. It can also be used for stationary computation as first guess. The computational grid (both in geographical space and in spectral space) must be identical to the one in the run in which the initial wave field was computed</p> <p>Input will be read from multiple hotfiles obtained from a previous parallel MPI run. The number of files equals the number of processors. Hence, for the present run the same number of processors must be chosen.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import HOTMULTIPLE\ninit = HOTMULTIPLE(fname=\"hotstart.swn\", format=\"free\")\nprint(init.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>class HOTMULTIPLE(BaseSubComponent):\n    \"\"\"Hotstart multiple initial conditions.\n\n    .. code-block:: text\n\n        HOTSTART MULTIPLE fname='fname' FREE|UNFORMATTED\n\n    Initial wave field is read from file; this file was generated in a previous SWAN\n    run by means of the HOTFILE command. If the previous run was nonstationary,\n    the time found on the file will be assumed to be the initial time of computation. It\n    can also be used for stationary computation as first guess. The computational grid\n    (both in geographical space and in spectral space) must be identical to the one in\n    the run in which the initial wave field was computed\n\n    Input will be read from multiple hotfiles obtained from a previous parallel MPI run.\n    The number of files equals the number of processors. Hence, for the present run the\n    same number of processors must be chosen.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import HOTMULTIPLE\n        init = HOTMULTIPLE(fname=\"hotstart.swn\", format=\"free\")\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotmultiple\", \"HOTMULTIPLE\"] = Field(\n        default=\"hotmultiple\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the initial wave field\",\n        max_length=36,\n    )\n    format: Literal[\"free\", \"unformatted\"] = Field(\n        default=\"free\",\n        description=(\n            \"Format of the file containing the initial wave field. \"\n            \"FREE: free format, UNFORMATTED: binary format\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"HOTSTART MULTIPLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotmultiple', 'HOTMULTIPLE'] = Field(default='hotmultiple', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the initial wave field', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['free', 'unformatted'] = Field(default='free', description='Format of the file containing the initial wave field. FREE: free format, UNFORMATTED: binary format')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"HOTSTART MULTIPLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/cgrid/","title":"Computational grid","text":"<p>Sub-commands to support the computational grid components</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN","title":"CARTESIAN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Cartesian coordinates.</p> <p>.. code-block:: text</p> <pre><code>CARTESIAN\n</code></pre> <p>All locations and distances are in m. Coordinates are given with respect to x- and y-axes chosen by the user in the various commands.</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import CARTESIAN\ncoords = CARTESIAN()\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>class CARTESIAN(BaseSubComponent):\n    \"\"\"Cartesian coordinates.\n\n    .. code-block:: text\n\n        CARTESIAN\n\n    All locations and distances are in m. Coordinates are given with respect\n    to x- and y-axes chosen by the user in the various commands.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import CARTESIAN\n        coords = CARTESIAN()\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"cartesian\", \"CARTESIAN\"] = Field(\n        default=\"cartesian\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN-attributes","title":"Attributes","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['cartesian', 'CARTESIAN'] = Field(default='cartesian', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL","title":"SPHERICAL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spherical coordinates.</p> <p>.. code-block:: text</p> <pre><code>SPHERICAL [-&gt;CCM|QC]\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL--notes","title":"Notes","text":"<p>projection options:</p> <ul> <li>CCM: central conformal Mercator. The horizontal and vertical scales are   uniform in terms of cm/degree over the area shown. In the centre of the scale   is identical to that of the conventional Mercator projection (but only at   that centre). The area in the projection centre is therefore exactly conformal.</li> <li>QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical   scales are equal to one another in terms of cm/degree.</li> </ul> <p>All coordinates of locations and geographical grid sizes are given in degrees;<code>x</code> is longitude with <code>x = 0</code> being the Greenwich meridian and <code>x &gt; 0</code> is East of this meridian; <code>y</code> is latitude with <code>y &gt; 0</code> being the Northern hemisphere. Input and output grids have to be oriented with their x-axis to the East; mesh sizes are in degrees. All other distances are in meters.</p> <p>Note that spherical coordinates can also be used for relatively small areas, say 10 or 20 km horizontal dimension. This may be useful if one obtains the boundary conditions by nesting in an oceanic model which is naturally formulated in spherical coordinates. Note that in case of spherical coordinates regular grids must always be oriented E-W, N-S, i.e. <code>alpc=0</code>, <code>alpinp=0</code>, <code>alpfr=0</code> (see commands CGRID, INPUT GRID and FRAME, respectively).</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SPHERICAL\ncoords = SPHERICAL()\nprint(coords.render())\ncoords = SPHERICAL(projection=\"qc\")\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>class SPHERICAL(BaseSubComponent):\n    \"\"\"Spherical coordinates.\n\n    .. code-block:: text\n\n        SPHERICAL [-&gt;CCM|QC]\n\n    Notes\n    -----\n\n    projection options:\n\n    * CCM: central conformal Mercator. The horizontal and vertical scales are\n      uniform in terms of cm/degree over the area shown. In the centre of the scale\n      is identical to that of the conventional Mercator projection (but only at\n      that centre). The area in the projection centre is therefore exactly conformal.\n    * QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical\n      scales are equal to one another in terms of cm/degree.\n\n    All coordinates of locations and geographical grid sizes are given in degrees;`x`\n    is longitude with `x = 0` being the Greenwich meridian and `x &gt; 0` is East of this\n    meridian; `y` is latitude with `y &gt; 0` being the Northern hemisphere. Input and\n    output grids have to be oriented with their x-axis to the East; mesh sizes are in\n    degrees. All other distances are in meters.\n\n    Note that spherical coordinates can also be used for relatively small areas, say 10\n    or 20 km horizontal dimension. This may be useful if one obtains the boundary\n    conditions by nesting in an oceanic model which is naturally formulated in\n    spherical coordinates. Note that in case of spherical coordinates regular grids\n    must always be oriented E-W, N-S, i.e. `alpc=0`, `alpinp=0`, `alpfr=0`\n    (see commands CGRID, INPUT GRID and FRAME, respectively).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SPHERICAL\n        coords = SPHERICAL()\n        print(coords.render())\n        coords = SPHERICAL(projection=\"qc\")\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spherical\", \"SPHERICAL\"] = Field(\n        default=\"spherical\", description=\"Model type discriminator\"\n    )\n    projection: Literal[\"ccm\", \"qc\"] = Field(\n        default=\"ccm\",\n        description=(\n            \"Defines the projection method in case of spherical coordinates, `ccm` \"\n            \"Central Conformal Mercator, `qc` means Quasi-cartesian\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        if self.projection is not None:\n            repr += f\" {self.projection.upper()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL-attributes","title":"Attributes","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spherical', 'SPHERICAL'] = Field(default='spherical', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.projection","title":"projection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projection: Literal['ccm', 'qc'] = Field(default='ccm', description='Defines the projection method in case of spherical coordinates, `ccm` Central Conformal Mercator, `qc` means Quasi-cartesian')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL-functions","title":"Functions","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    if self.projection is not None:\n        repr += f\" {self.projection.upper()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/","title":"Numerics","text":"<p>Sub-commands to support the numerics components</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT","title":"BSBT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>BSBT first order propagation scheme.</p> <p>.. code-block:: text</p> <pre><code>BSTB\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import BSBT\nscheme = BSBT()\nprint(scheme.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class BSBT(BaseSubComponent):\n    \"\"\"BSBT first order propagation scheme.\n\n    .. code-block:: text\n\n        BSTB\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import BSBT\n        scheme = BSBT()\n        print(scheme.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bsbt\", \"BSBT\"] = Field(\n        default=\"bsbt\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"BSBT\"\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bsbt', 'BSBT'] = Field(default='bsbt', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"BSBT\"\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE","title":"GSE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Garden-sprinkler effect.</p> <p>.. code-block:: text</p> <pre><code>GSE [waveage] Sec|MIn|HR|DAy\n</code></pre> <p>Garden-sprinkler effect is to be counteracted in the S&amp;L propagation scheme (default for nonstationary regular grid computations) or in the propagation scheme for unstructured grids by adding a diffusion term to the basic equation. This may affect the numerical stability of SWAN.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import GSE\nscheme = GSE(waveage=dict(delt=86400, dfmt=\"day\"))\nprint(scheme.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class GSE(BaseSubComponent):\n    \"\"\"Garden-sprinkler effect.\n\n    .. code-block:: text\n\n        GSE [waveage] Sec|MIn|HR|DAy\n\n    Garden-sprinkler effect is to be counteracted in the S&amp;L propagation scheme\n    (default for nonstationary regular grid computations) or in the propagation\n    scheme for unstructured grids by adding a diffusion term to the basic equation.\n    This may affect the numerical stability of SWAN.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import GSE\n        scheme = GSE(waveage=dict(delt=86400, dfmt=\"day\"))\n        print(scheme.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gse\", \"GSE\"] = Field(\n        default=\"gse\", description=\"Model type discriminator\"\n    )\n    waveage: Optional[Delt] = Field(\n        default=None,\n        description=(\n            \"The time interval used to determine the diffusion which counteracts the \"\n            \"so-called garden-sprinkler effect. The default value of `waveage` is \"\n            \"zero, i.e. no added diffusion. The value of `waveage` should correspond \"\n            \"to the travel time of the waves over the computational region.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"GSE\"\n        if self.waveage is not None:\n            repr += f\" waveage={self.waveage.render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gse', 'GSE'] = Field(default='gse', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.waveage","title":"waveage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>waveage: Optional[Delt] = Field(default=None, description='The time interval used to determine the diffusion which counteracts the so-called garden-sprinkler effect. The default value of `waveage` is zero, i.e. no added diffusion. The value of `waveage` should correspond to the travel time of the waves over the computational region.')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"GSE\"\n    if self.waveage is not None:\n        repr += f\" waveage={self.waveage.render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT","title":"STAT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Computation parameters in stationary computation.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class STAT(BaseSubComponent):\n    \"\"\"Computation parameters in stationary computation.\"\"\"\n\n    model_type: Literal[\"stat\", \"STAT\"] = Field(\n        default=\"stat\", description=\"Model type discriminator\"\n    )\n    mxitst: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of iterations for stationary computations. The \"\n            \"computation stops when this number is exceeded (SWAN default:  50)\"\n        ),\n    )\n    alfa: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality constant used in the frequency-dependent under-\"\n            \"relaxation technique. Based on experiences, a suggestion for this \"\n            \"parameter is `alfa = 0.01`. In case of diffraction computations, the use \"\n            \"of this parameter is recommended (SWAN default: 0.00)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"STATIONARY\"\n        if self.mxitst is not None:\n            repr += f\" mxitst={self.mxitst}\"\n        if self.alfa is not None:\n            repr += f\" alfa={self.alfa}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stat', 'STAT'] = Field(default='stat', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.mxitst","title":"mxitst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxitst: Optional[int] = Field(default=None, description='The maximum number of iterations for stationary computations. The computation stops when this number is exceeded (SWAN default:  50)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.alfa","title":"alfa  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alfa: Optional[float] = Field(default=None, description='Proportionality constant used in the frequency-dependent under-relaxation technique. Based on experiences, a suggestion for this parameter is `alfa = 0.01`. In case of diffraction computations, the use of this parameter is recommended (SWAN default: 0.00)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"STATIONARY\"\n    if self.mxitst is not None:\n        repr += f\" mxitst={self.mxitst}\"\n    if self.alfa is not None:\n        repr += f\" alfa={self.alfa}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT","title":"NONSTAT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Computation parameters in nonstationary computation.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class NONSTAT(BaseSubComponent):\n    \"\"\"Computation parameters in nonstationary computation.\"\"\"\n\n    model_type: Literal[\"nonstat\", \"NONSTAT\"] = Field(\n        default=\"nonstat\", description=\"Model type discriminator\"\n    )\n    mxitns: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of iterations per time step for nonstationary \"\n            \"computations. The computation moves to the next time step when this \"\n            \"number is exceeded (SWAN default: `mxitns = 1`\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NONSTATIONARY\"\n        if self.mxitns is not None:\n            repr += f\" mxitns={self.mxitns}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstat', 'NONSTAT'] = Field(default='nonstat', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.mxitns","title":"mxitns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxitns: Optional[int] = Field(default=None, description='The maximum number of iterations per time step for nonstationary computations. The computation moves to the next time step when this number is exceeded (SWAN default: `mxitns = 1`')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NONSTATIONARY\"\n    if self.mxitns is not None:\n        repr += f\" mxitns={self.mxitns}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC","title":"STOPC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stopping criteria of  Zijlema and Van der Westhuysen (2005).</p> <p>.. code-block:: text</p> <pre><code>STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter]\n</code></pre> <p>With this option the user can influence the criterion for terminating the iterative procedure in the SWAN computations (both stationary and nonstationary). The criterion makes use of the second derivative, or curvature, of the iteration curve of the significant wave height. As the solution of a simulation approaches full convergence, the curvature of the iteration curve will tend to zero. SWAN stops the process if the relative change in Hs from one iteration to the next is less than <code>drel</code> and the curvature of the iteration curve of Hs normalized with Hs is less than <code>curvat</code> or the absolute change in Hs from one iteration to the next is less than <code>dabs</code>. Both conditions need to be fulfilled in more than fraction <code>npnts</code> percent of all wet grid points.</p> <p>With respect to the QC modelling, another stopping criteria will be employed. Namely, SWAN stops the iteration process if the absolute change in Hs from one iterate to another is less than <code>dabs</code> * Hinc, where Hinc is the representative incident wave height, or the relative change in Hs from one to the next iteration is less than <code>drel</code>. These criteria must be fulfilled in more than <code>npnts</code> percent of all active, well-defined points.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC--references","title":"References","text":"<ul> <li>Zijlema, M. and Van der Westhuysen, A. (2005). On convergence behaviour and   numerical accuracy in stationary SWAN simulations of nearshore wind wave spectra,   Coastal Engineering, 52(3), p. 337-256.</li> </ul>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import STOPC\nstop = STOPC()\nprint(stop.render())\nstop = STOPC(\n    dabs=0.005,\n    drel=0.01,\n    curvat=0.005,\n    npnts=99.5,\n    mode=dict(model_type=\"nonstat\", mxitns=1),\n    limiter=0.1,\n)\nprint(stop.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class STOPC(BaseSubComponent):\n    \"\"\"Stopping criteria of  Zijlema and Van der Westhuysen (2005).\n\n    .. code-block:: text\n\n        STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter]\n\n    With this option the user can influence the criterion for terminating the iterative\n    procedure in the SWAN computations (both stationary and nonstationary). The\n    criterion makes use of the second derivative, or curvature, of the iteration curve\n    of the significant wave height. As the solution of a simulation approaches full\n    convergence, the curvature of the iteration curve will tend to zero. SWAN stops the\n    process if the relative change in Hs from one iteration to the next is less than\n    `drel` and the curvature of the iteration curve of Hs normalized with Hs is less\n    than `curvat` or the absolute change in Hs from one iteration to the next is less\n    than `dabs`. Both conditions need to be fulfilled in more than fraction `npnts`\n    percent of all wet grid points.\n\n    With respect to the QC modelling, another stopping criteria will be employed.\n    Namely, SWAN stops the iteration process if the absolute change in Hs from one\n    iterate to another is less than `dabs` * Hinc, where Hinc is the representative\n    incident wave height, or the relative change in Hs from one to the next iteration\n    is less than `drel`. These criteria must be fulfilled in more than `npnts`\n    percent of all active, well-defined points.\n\n    References\n    ----------\n    - Zijlema, M. and Van der Westhuysen, A. (2005). On convergence behaviour and\n      numerical accuracy in stationary SWAN simulations of nearshore wind wave spectra,\n      Coastal Engineering, 52(3), p. 337-256.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import STOPC\n        stop = STOPC()\n        print(stop.render())\n        stop = STOPC(\n            dabs=0.005,\n            drel=0.01,\n            curvat=0.005,\n            npnts=99.5,\n            mode=dict(model_type=\"nonstat\", mxitns=1),\n            limiter=0.1,\n        )\n        print(stop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stopc\", \"STOPC\"] = Field(\n        default=\"stopc\", description=\"Model type discriminator\"\n    )\n    dabs: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum absolute change in Hs from one iteration to the next \"\n            \"(SWAN default: 0.005 [m] or 0.05 [-] in case of QC model)\"\n        ),\n    )\n    drel: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum relative change in Hs from one iteration to the next \"\n            \"(SWAN default: 0.01 [-])\"\n        ),\n    )\n    curvat: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum curvature of the iteration curve of Hs normalised with Hs \"\n            \"(SWAN default: 0.005 [-] (not used in the QC model))\"\n        ),\n    )\n    npnts: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Percentage of points in the computational grid above which the stopping \"\n            \"criteria needs to be satisfied (SWAN default: 99.5 [-])\"\n        ),\n    )\n    mode: Optional[Union[STAT, NONSTAT]] = Field(\n        default=None,\n        description=\"Termination criteria for stationary or nonstationary runs\",\n        discriminator=\"model_type\",\n    )\n    limiter: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Determines the maximum change per iteration of the energy density per \"\n            \"spectral-bin given in terms of a fraction of the omni-directional \"\n            \"Phillips level (SWAN default: 0.1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"STOPC\"\n        if self.dabs is not None:\n            repr += f\" dabs={self.dabs}\"\n        if self.drel is not None:\n            repr += f\" drel={self.drel}\"\n        if self.curvat is not None:\n            repr += f\" curvat={self.curvat}\"\n        if self.npnts is not None:\n            repr += f\" npnts={self.npnts}\"\n        if self.mode is not None:\n            repr += f\" {self.mode.render()}\"\n        if self.limiter is not None:\n            repr += f\" limiter={self.limiter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stopc', 'STOPC'] = Field(default='stopc', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.dabs","title":"dabs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dabs: Optional[float] = Field(default=None, description='Maximum absolute change in Hs from one iteration to the next (SWAN default: 0.005 [m] or 0.05 [-] in case of QC model)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.drel","title":"drel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drel: Optional[float] = Field(default=None, description='Maximum relative change in Hs from one iteration to the next (SWAN default: 0.01 [-])')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.curvat","title":"curvat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curvat: Optional[float] = Field(default=None, description='Maximum curvature of the iteration curve of Hs normalised with Hs (SWAN default: 0.005 [-] (not used in the QC model))')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.npnts","title":"npnts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npnts: Optional[float] = Field(default=None, description='Percentage of points in the computational grid above which the stopping criteria needs to be satisfied (SWAN default: 99.5 [-])')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[Union[STAT, NONSTAT]] = Field(default=None, description='Termination criteria for stationary or nonstationary runs', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[float] = Field(default=None, description='Determines the maximum change per iteration of the energy density per spectral-bin given in terms of a fraction of the omni-directional Phillips level (SWAN default: 0.1)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"STOPC\"\n    if self.dabs is not None:\n        repr += f\" dabs={self.dabs}\"\n    if self.drel is not None:\n        repr += f\" drel={self.drel}\"\n    if self.curvat is not None:\n        repr += f\" curvat={self.curvat}\"\n    if self.npnts is not None:\n        repr += f\" npnts={self.npnts}\"\n    if self.mode is not None:\n        repr += f\" {self.mode.render()}\"\n    if self.limiter is not None:\n        repr += f\" limiter={self.limiter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR","title":"ACCUR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stop the iterative procedure.</p> <p>.. code-block:: text</p> <pre><code>ACCUR [drel] [dhoval] [dtoval] [npnts] -&gt;STAT|NONSTAT [limiter]\n</code></pre> <p>With this option the user can influence the criterion for terminating the iterative procedure in the SWAN computations (both stationary and non-stationary modes). SWAN stops the iterations if (a), (b) and (c) are all satisfied:</p> <p>a) The change in the local significant wave height Hs from one iteration to the    next is less than (1) fraction <code>drel</code> of that height or (2) fraction <code>dhoval</code>    of the average Hs over all grid points.</p> <p>b) The change in the local mean wave period Tm01 from one iteration to the next is    less than (1) fraction <code>drel</code> of that period or (2) fraction <code>dtoval</code> of the    average mean wave period over all wet grid points.</p> <p>c) Conditions (a) and (b) are fulfilled in more than fraction <code>npnts%</code> of all wet    grid points.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR--note","title":"Note","text":"<p>This command has become obsolete in SWAN 41.01. The command STOPC should be used.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import ACCUR\naccur = ACCUR()\nprint(accur.render())\naccur = ACCUR(\n    drel=0.01,\n    dhoval=0.02,\n    dtoval=0.02,\n    npnts=98.0,\n    mode=dict(model_type=\"nonstat\", mxitns=1),\n    limiter=0.1,\n)\nprint(accur.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class ACCUR(BaseSubComponent):\n    \"\"\"Stop the iterative procedure.\n\n    .. code-block:: text\n\n        ACCUR [drel] [dhoval] [dtoval] [npnts] -&gt;STAT|NONSTAT [limiter]\n\n    With this option the user can influence the criterion for terminating the iterative\n    procedure in the SWAN computations (both stationary and non-stationary modes).\n    SWAN stops the iterations if (a), (b) and (c) are all satisfied:\n\n    a) The change in the local significant wave height Hs from one iteration to the\n       next is less than (1) fraction `drel` of that height or (2) fraction `dhoval`\n       of the average Hs over all grid points.\n\n    b) The change in the local mean wave period Tm01 from one iteration to the next is\n       less than (1) fraction `drel` of that period or (2) fraction `dtoval` of the\n       average mean wave period over all wet grid points.\n\n    c) Conditions (a) and (b) are fulfilled in more than fraction `npnts%` of all wet\n       grid points.\n\n    Note\n    ----\n    This command has become obsolete in SWAN 41.01. The command STOPC should be used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import ACCUR\n        accur = ACCUR()\n        print(accur.render())\n        accur = ACCUR(\n            drel=0.01,\n            dhoval=0.02,\n            dtoval=0.02,\n            npnts=98.0,\n            mode=dict(model_type=\"nonstat\", mxitns=1),\n            limiter=0.1,\n        )\n        print(accur.render())\n\n    \"\"\"\n\n    model_type: Literal[\"accur\", \"ACCUR\"] = Field(\n        default=\"accur\", description=\"Model type discriminator\"\n    )\n    drel: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum relative change in Hs or Tm01 from one iteration to the next \"\n            \"(SWAN default: 0.02)\"\n        ),\n    )\n    dhoval: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Fraction of the average Hs over all wet grid points below which the \"\n            \"the stopping criteria needs to be satisfied (SWAN default: 0.02)\"\n        ),\n    )\n    dtoval: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Fraction of the average Tm01 over all wet grid points below which the \"\n            \"the stopping criteria needs to be satisfied (SWAN default: 0.02)\"\n        ),\n    )\n    npnts: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Percentage of points in the computational grid above which the stopping \"\n            \"criteria needs to be satisfied (SWAN default: 98)\"\n        ),\n    )\n    mode: Optional[Union[STAT, NONSTAT]] = Field(\n        default=None,\n        description=\"Termination criteria for stationary or nonstationary runs\",\n        discriminator=\"model_type\",\n    )\n    limiter: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Determines the maximum change per iteration of the energy density per \"\n            \"spectral-bin given in terms of a fraction of the omni-directional \"\n            \"Phillips level (SWAN default: 0.1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"ACCUR\"\n        if self.drel is not None:\n            repr += f\" drel={self.drel}\"\n        if self.dhoval is not None:\n            repr += f\" dhoval={self.dhoval}\"\n        if self.dtoval is not None:\n            repr += f\" dtoval={self.dtoval}\"\n        if self.npnts is not None:\n            repr += f\" npnts={self.npnts}\"\n        if self.mode is not None:\n            repr += f\" {self.mode.render()}\"\n        if self.limiter is not None:\n            repr += f\" limiter={self.limiter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['accur', 'ACCUR'] = Field(default='accur', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.drel","title":"drel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drel: Optional[float] = Field(default=None, description='Maximum relative change in Hs or Tm01 from one iteration to the next (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.dhoval","title":"dhoval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhoval: Optional[float] = Field(default=None, description='Fraction of the average Hs over all wet grid points below which the the stopping criteria needs to be satisfied (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.dtoval","title":"dtoval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtoval: Optional[float] = Field(default=None, description='Fraction of the average Tm01 over all wet grid points below which the the stopping criteria needs to be satisfied (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.npnts","title":"npnts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npnts: Optional[float] = Field(default=None, description='Percentage of points in the computational grid above which the stopping criteria needs to be satisfied (SWAN default: 98)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[Union[STAT, NONSTAT]] = Field(default=None, description='Termination criteria for stationary or nonstationary runs', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[float] = Field(default=None, description='Determines the maximum change per iteration of the energy density per spectral-bin given in terms of a fraction of the omni-directional Phillips level (SWAN default: 0.1)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"ACCUR\"\n    if self.drel is not None:\n        repr += f\" drel={self.drel}\"\n    if self.dhoval is not None:\n        repr += f\" dhoval={self.dhoval}\"\n    if self.dtoval is not None:\n        repr += f\" dtoval={self.dtoval}\"\n    if self.npnts is not None:\n        repr += f\" npnts={self.npnts}\"\n    if self.mode is not None:\n        repr += f\" {self.mode.render()}\"\n    if self.limiter is not None:\n        repr += f\" limiter={self.limiter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL","title":"DIRIMPL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Numerical scheme for refraction.</p> <p>.. code-block:: text</p> <pre><code>DIRIMPL [cdd]\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import DIRIMPL\ndirimpl = DIRIMPL()\nprint(dirimpl.render())\ndirimpl = DIRIMPL(cdd=0.5)\nprint(dirimpl.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class DIRIMPL(BaseSubComponent):\n    \"\"\"Numerical scheme for refraction.\n\n    .. code-block:: text\n\n        DIRIMPL [cdd]\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import DIRIMPL\n        dirimpl = DIRIMPL()\n        print(dirimpl.render())\n        dirimpl = DIRIMPL(cdd=0.5)\n        print(dirimpl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dirimpl\", \"DIRIMPL\"] = Field(\n        default=\"dirimpl\", description=\"Model type discriminator\"\n    )\n    cdd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"A value of `cdd=0` corresponds to a central scheme and has the largest \"\n            \"accuracy (diffusion \u2248 0) but the computation may more easily generate\"\n            \"spurious fluctuations. A value of `cdd=1` corresponds to a first order\"\n            \"upwind scheme and it is more diffusive and therefore preferable if \"\n            \"(strong) gradients in depth or current are present (SWAN default: 0.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"DIRIMPL\"\n        if self.cdd is not None:\n            repr += f\" cdd={self.cdd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dirimpl', 'DIRIMPL'] = Field(default='dirimpl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.cdd","title":"cdd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdd: Optional[float] = Field(default=None, description='A value of `cdd=0` corresponds to a central scheme and has the largest accuracy (diffusion \u2248 0) but the computation may more easily generatespurious fluctuations. A value of `cdd=1` corresponds to a first orderupwind scheme and it is more diffusive and therefore preferable if (strong) gradients in depth or current are present (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"DIRIMPL\"\n    if self.cdd is not None:\n        repr += f\" cdd={self.cdd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL","title":"SIGIMPL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency shifting accuracy.</p> <p>.. code-block:: text</p> <pre><code>SIGIMpl [cfl] [eps2] [outp] [niter]\n</code></pre> <p>Controls the accuracy of computing the frequency shifting and the stopping criterion and amount of output for the SIP solver (used in the computations in the presence of currents or time varying depth)</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import SIGIMPL\nsigimpl = SIGIMPL()\nprint(sigimpl.render())\nsigimpl = SIGIMPL(css=0.5, eps2=1e-4, outp=0, niter=20)\nprint(sigimpl.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class SIGIMPL(BaseSubComponent):\n    \"\"\"Frequency shifting accuracy.\n\n    .. code-block:: text\n\n        SIGIMpl [cfl] [eps2] [outp] [niter]\n\n    Controls the accuracy of computing the frequency shifting and the stopping\n    criterion and amount of output for the SIP solver (used in the computations in the\n    presence of currents or time varying depth)\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import SIGIMPL\n        sigimpl = SIGIMPL()\n        print(sigimpl.render())\n        sigimpl = SIGIMPL(css=0.5, eps2=1e-4, outp=0, niter=20)\n        print(sigimpl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"sigimpl\", \"SIGIMPL\"] = Field(\n        default=\"sigimpl\", description=\"Model type discriminator\"\n    )\n    css: Optional[float] = Field(\n        default=None,\n        description=(\n            \"A value of `css=0` corresponds to a central scheme and has the largest \"\n            \"accuracy (diffusion \u2248 0) but the computation may more easily generate \"\n            \"spurious fluctuations. A value of `css=1` corresponds to a first order \"\n            \"upwind scheme and it is more diffusive and therefore preferable if \"\n            \"(strong) gradients in depth or current are present (SWAN default: 0.5)\"\n        ),\n    )\n    eps2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Relative stopping criterion to terminate the linear solver (SIP or SOR). \"\n            \"(SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)\"\n        ),\n    )\n    outp: Optional[Literal[0, 1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional \"\n            \"information about the iteration process is written to the PRINT file \"\n            \"\\n* 2 = gives a maximal amount of output concerning the iteration \"\n            \"process\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)\"\n        ),\n    )\n    niter: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of iterations for the linear solver (SWAN default: 20 in \"\n            \"case of SIP and 1000 in case of SOR)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SIGIMPL\"\n        if self.css is not None:\n            repr += f\" css={self.css}\"\n        if self.eps2 is not None:\n            repr += f\" eps2={self.eps2}\"\n        if self.outp is not None:\n            repr += f\" outp={self.outp}\"\n        if self.niter is not None:\n            repr += f\" niter={self.niter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['sigimpl', 'SIGIMPL'] = Field(default='sigimpl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[float] = Field(default=None, description='A value of `css=0` corresponds to a central scheme and has the largest accuracy (diffusion \u2248 0) but the computation may more easily generate spurious fluctuations. A value of `css=1` corresponds to a first order upwind scheme and it is more diffusive and therefore preferable if (strong) gradients in depth or current are present (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.eps2","title":"eps2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps2: Optional[float] = Field(default=None, description='Relative stopping criterion to terminate the linear solver (SIP or SOR). (SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.outp","title":"outp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outp: Optional[Literal[0, 1, 2, 3]] = Field(default=None, description='Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional information about the iteration process is written to the PRINT file \\n* 2 = gives a maximal amount of output concerning the iteration process\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.niter","title":"niter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>niter: Optional[int] = Field(default=None, description='Maximum number of iterations for the linear solver (SWAN default: 20 in case of SIP and 1000 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SIGIMPL\"\n    if self.css is not None:\n        repr += f\" css={self.css}\"\n    if self.eps2 is not None:\n        repr += f\" eps2={self.eps2}\"\n    if self.outp is not None:\n        repr += f\" outp={self.outp}\"\n    if self.niter is not None:\n        repr += f\" niter={self.niter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA","title":"CTHETA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Prevents excessive directional turning.</p> <p>.. code-block:: text</p> <pre><code>CTheta [cfl]\n</code></pre> <p>This option prevents an excessive directional turning at a single grid point or vertex due to a very coarse bathymetry or current locally. This option limits the directional turning rate c\u03b8 based on the CFL restriction. (See Eq. 3.41 of Scientific/Technical documentation). See also the final remark in Section 2.6.3. Note that if this command is not specified, then the limiter is not activated.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import CTHETA\nctheta = CTHETA()\nprint(ctheta.render())\nctheta = CTHETA(cfl=0.9)\nprint(ctheta.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class CTHETA(BaseSubComponent):\n    \"\"\"Prevents excessive directional turning.\n\n    .. code-block:: text\n\n        CTheta [cfl]\n\n    This option prevents an excessive directional turning at a single grid point or\n    vertex due to a very coarse bathymetry or current locally. This option limits the\n    directional turning rate c\u03b8 based on the CFL restriction. (See Eq. 3.41 of\n    Scientific/Technical documentation). See also the final remark in Section 2.6.3.\n    Note that if this command is not specified, then the limiter is not activated.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import CTHETA\n        ctheta = CTHETA()\n        print(ctheta.render())\n        ctheta = CTHETA(cfl=0.9)\n        print(ctheta.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ctheta\", \"CTHETA\"] = Field(\n        default=\"ctheta\", description=\"Model type discriminator\"\n    )\n    cfl: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit for the CFL restriction for ctheta. A suggestion for this \"\n            \"parameter is `cfl = 0.9` (SWAN default: 0.9 when CTHETA is activated)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"CTHETA\"\n        if self.cfl is not None:\n            repr += f\" cfl={self.cfl}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ctheta', 'CTHETA'] = Field(default='ctheta', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.cfl","title":"cfl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfl: Optional[float] = Field(default=None, description='Upper limit for the CFL restriction for ctheta. A suggestion for this parameter is `cfl = 0.9` (SWAN default: 0.9 when CTHETA is activated)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"CTHETA\"\n    if self.cfl is not None:\n        repr += f\" cfl={self.cfl}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA","title":"CSIGMA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Prevents excessive directional turning.</p> <p>.. code-block:: text</p> <pre><code>CSigma [cfl]\n</code></pre> <p>This option prevents an excessive frequency shifting at a single grid point or vertex due to a very coarse bathymetry or current locally. This option limits the frequency shifting rate csigma based on the CFL restriction. See also the final remark in Section 2.6.3. Note that if this command is not specified, then the limiter is not activated.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import CSIGMA\ncsigma = CSIGMA()\nprint(csigma.render())\ncsigma = CSIGMA(cfl=0.9)\nprint(csigma.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class CSIGMA(BaseSubComponent):\n    \"\"\"Prevents excessive directional turning.\n\n    .. code-block:: text\n\n        CSigma [cfl]\n\n    This option prevents an excessive frequency shifting at a single grid point or\n    vertex due to a very coarse bathymetry or current locally. This option limits the\n    frequency shifting rate csigma based on the CFL restriction. See also the final\n    remark in Section 2.6.3. Note that if this command is not specified, then the\n    limiter is not activated.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import CSIGMA\n        csigma = CSIGMA()\n        print(csigma.render())\n        csigma = CSIGMA(cfl=0.9)\n        print(csigma.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ctheta\", \"CTHETA\"] = Field(\n        default=\"ctheta\", description=\"Model type discriminator\"\n    )\n    cfl: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit for the CFL restriction for csigma. A suggestion for this \"\n            \"parameter is `cfl = 0.9` (SWAN default: 0.9 when CSIGMA is activated)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"CSIGMA\"\n        if self.cfl is not None:\n            repr += f\" cfl={self.cfl}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ctheta', 'CTHETA'] = Field(default='ctheta', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.cfl","title":"cfl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfl: Optional[float] = Field(default=None, description='Upper limit for the CFL restriction for csigma. A suggestion for this parameter is `cfl = 0.9` (SWAN default: 0.9 when CSIGMA is activated)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"CSIGMA\"\n    if self.cfl is not None:\n        repr += f\" cfl={self.cfl}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP","title":"SETUP","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stop criteria in the computation of wave setup.</p> <p>.. code-block:: text</p> <pre><code>SETUP [eps2] [outp] [niter]\n</code></pre> <p>Controls the stopping criterion and amount of output for the SOR solver in the computation of the wave-induced set-up.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import SETUP\nsetup = SETUP()\nprint(setup.render())\nsetup = SETUP(eps2=1e-4, outp=0, niter=20)\nprint(setup.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>class SETUP(BaseSubComponent):\n    \"\"\"Stop criteria in the computation of wave setup.\n\n    .. code-block:: text\n\n        SETUP [eps2] [outp] [niter]\n\n    Controls the stopping criterion and amount of output for the SOR solver in the\n    computation of the wave-induced set-up.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import SETUP\n        setup = SETUP()\n        print(setup.render())\n        setup = SETUP(eps2=1e-4, outp=0, niter=20)\n        print(setup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"setup\", \"SETUP\"] = Field(\n        default=\"setup\", description=\"Model type discriminator\"\n    )\n    eps2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Relative stopping criterion to terminate the linear solver (SIP or SOR). \"\n            \"(SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)\"\n        ),\n    )\n    outp: Optional[Literal[0, 1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional \"\n            \"information about the iteration process is written to the PRINT file \"\n            \"\\n* 2 = gives a maximal amount of output concerning the iteration process \"\n            \"\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)\"\n        ),\n    )\n    niter: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of iterations for the linear solver (SWAN default: 20 in \"\n            \"case of SIP and 1000 in case of SOR)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SETUP\"\n        if self.eps2 is not None:\n            repr += f\" eps2={self.eps2}\"\n        if self.outp is not None:\n            repr += f\" outp={self.outp}\"\n        if self.niter is not None:\n            repr += f\" niter={self.niter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['setup', 'SETUP'] = Field(default='setup', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.eps2","title":"eps2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps2: Optional[float] = Field(default=None, description='Relative stopping criterion to terminate the linear solver (SIP or SOR). (SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.outp","title":"outp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outp: Optional[Literal[0, 1, 2, 3]] = Field(default=None, description='Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional information about the iteration process is written to the PRINT file \\n* 2 = gives a maximal amount of output concerning the iteration process \\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.niter","title":"niter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>niter: Optional[int] = Field(default=None, description='Maximum number of iterations for the linear solver (SWAN default: 20 in case of SIP and 1000 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>src/rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SETUP\"\n    if self.eps2 is not None:\n        repr += f\" eps2={self.eps2}\"\n    if self.outp is not None:\n        repr += f\" outp={self.outp}\"\n    if self.niter is not None:\n        repr += f\" niter={self.niter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/output/","title":"Output","text":"<p>Sub-commands to support the output components</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D","title":"SPEC1D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency 1D spectra.</p> <p>.. code-block:: text</p> <pre><code>SPEC1D\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import SPEC1D\nspec = SPEC1D()\nprint(spec.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>class SPEC1D(BaseSubComponent):\n    \"\"\"Frequency 1D spectra.\n\n    .. code-block:: text\n\n        SPEC1D\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import SPEC1D\n        spec = SPEC1D()\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spec1d\", \"SPEC1D\"] = Field(\n        default=\"spec1d\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spec1d', 'SPEC1D'] = Field(default='spec1d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D","title":"SPEC2D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency-direction 2D spectra.</p> <p>.. code-block:: text</p> <pre><code>SPEC2D\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import SPEC2D\nspec = SPEC2D()\nprint(spec.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>class SPEC2D(BaseSubComponent):\n    \"\"\"Frequency-direction 2D spectra.\n\n    .. code-block:: text\n\n        SPEC2D\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import SPEC2D\n        spec = SPEC2D()\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spec2d\", \"SPEC2D\"] = Field(\n        default=\"spec2d\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spec2d', 'SPEC2D'] = Field(default='spec2d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS","title":"ABS","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Absolute frequency spectra.</p> <p>.. code-block:: text</p> <pre><code>ABS\n</code></pre> <p>Spectra are computed as a function of absolute frequency, i.e., the frequency as measured in a fixed point.</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import ABS\nfreq = ABS()\nprint(freq.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>class ABS(BaseSubComponent):\n    \"\"\"Absolute frequency spectra.\n\n    .. code-block:: text\n\n        ABS\n\n    Spectra are computed as a function of absolute frequency, i.e., the frequency as\n    measured in a fixed point.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import ABS\n        freq = ABS()\n        print(freq.render())\n\n    \"\"\"\n\n    model_type: Literal[\"abs\", \"ABS\"] = Field(\n        default=\"abs\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"ABS\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['abs', 'ABS'] = Field(default='abs', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"ABS\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL","title":"REL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Relative frequency spectra.</p> <p>.. code-block:: text</p> <pre><code>REL\n</code></pre> <p>Spectra are computed as a function of relative frequency, i.e., the frequency as measured when moving with current.</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import REL\nfreq = REL()\nprint(freq.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>class REL(BaseSubComponent):\n    \"\"\"Relative frequency spectra.\n\n    .. code-block:: text\n\n        REL\n\n    Spectra are computed as a function of relative frequency, i.e., the frequency as\n    measured when moving with current.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import REL\n        freq = REL()\n        print(freq.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rel\", \"REL\"] = Field(\n        default=\"rel\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"REL\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rel', 'REL'] = Field(default='rel', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"REL\"\n</code></pre>"},{"location":"subcomponents/physics/","title":"Physics","text":"<p>Sub-commands to support the physics components</p>"},{"location":"subcomponents/physics/#source-terms","title":"Source terms","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN","title":"JANSSEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Janssen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>JANSSEN [cds1] [delta] (AGROW [a])\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN--references","title":"References","text":"<p>Janssen, P.A., 1989. Wave-induced stress and the drag of air flow over sea waves. Journal of Physical Oceanography, 19(6), pp.745-754.</p> <p>Janssen, P.A.E.M., Lionello, P. and Zambresky, L., 1989. On the interaction of wind and waves. Philosophical transactions of the royal society of London. Series A, Mathematical and Physical Sciences, 329(1604), pp.289-301.</p> <p>Janssen, P.A., 1991. Quasi-linear theory of wind-wave generation applied to wave forecasting. Journal of physical oceanography, 21(11), pp.1631-1642.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import JANSSEN\njanssen = JANSSEN()\nprint(janssen.render())\njanssen = JANSSEN(cds1=4.5, delta=0.5, agrow=True)\nprint(janssen.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class JANSSEN(SourceTerms):\n    \"\"\"Janssen source terms subcomponent.\n\n    .. code-block:: text\n\n        JANSSEN [cds1] [delta] (AGROW [a])\n\n    References\n    ----------\n    Janssen, P.A., 1989. Wave-induced stress and the drag of air flow over sea waves.\n    Journal of Physical Oceanography, 19(6), pp.745-754.\n\n    Janssen, P.A.E.M., Lionello, P. and Zambresky, L., 1989. On the interaction of wind\n    and waves. Philosophical transactions of the royal society of London. Series A,\n    Mathematical and Physical Sciences, 329(1604), pp.289-301.\n\n    Janssen, P.A., 1991. Quasi-linear theory of wind-wave generation applied to wave\n    forecasting. Journal of physical oceanography, 21(11), pp.1631-1642.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import JANSSEN\n        janssen = JANSSEN()\n        print(janssen.render())\n        janssen = JANSSEN(cds1=4.5, delta=0.5, agrow=True)\n        print(janssen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"janssen\", \"JANSSEN\"] = Field(\n        default=\"janssen\", description=\"Model type discriminator\"\n    )\n    cds1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation \"\n            \"($Cds / s^4_{PM}$) (SWAN default: 4.5)\"\n        ),\n    )\n    delta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the dependency of the whitecapping on wave \"\n            \"number (mix with Komen et al. formulation) (SWAN default: 0.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"JANSSEN\"\n        if self.cds1 is not None:\n            repr += f\" cds1={self.cds1}\"\n        if self.delta is not None:\n            repr += f\" delta={self.delta}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['janssen', 'JANSSEN'] = Field(default='janssen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.cds1","title":"cds1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds1: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation ($Cds / s^4_{PM}$) (SWAN default: 4.5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: Optional[float] = Field(default=None, description='Coefficient which determines the dependency of the whitecapping on wave number (mix with Komen et al. formulation) (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"JANSSEN\"\n    if self.cds1 is not None:\n        repr += f\" cds1={self.cds1}\"\n    if self.delta is not None:\n        repr += f\" delta={self.delta}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN","title":"KOMEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Komen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>KOMEN [cds2] [stpm] (AGROW [a])\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN--references","title":"References","text":"<p>Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import KOMEN\nkomen = KOMEN()\nprint(komen.render())\nkomen = KOMEN(cds2=2.36e-5, stpm=3.02e-3, agrow=True, a=0.0015)\nprint(komen.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class KOMEN(SourceTerms):\n    \"\"\"Komen source terms subcomponent.\n\n    .. code-block:: text\n\n        KOMEN [cds2] [stpm] (AGROW [a])\n\n    References\n    ----------\n    Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully\n    developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import KOMEN\n        komen = KOMEN()\n        print(komen.render())\n        komen = KOMEN(cds2=2.36e-5, stpm=3.02e-3, agrow=True, a=0.0015)\n        print(komen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"komen\", \"KOMEN\"] = Field(\n        default=\"komen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation \"\n            \"(`Cds`) (SWAN default: 2.36e-5)\"\n        ),\n    )\n    stpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Value of the wave steepness for a Pierson-Moskowitz spectrum \"\n            \"(`s^2_PM`) (SWAN default: 3.02e-3)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"KOMEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.stpm is not None:\n            repr += f\" stpm={self.stpm}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['komen', 'KOMEN'] = Field(default='komen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation (`Cds`) (SWAN default: 2.36e-5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.stpm","title":"stpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stpm: Optional[float] = Field(default=None, description='Value of the wave steepness for a Pierson-Moskowitz spectrum (`s^2_PM`) (SWAN default: 3.02e-3)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"KOMEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.stpm is not None:\n        repr += f\" stpm={self.stpm}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN","title":"WESTHUYSEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Westhuysen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>WESTHUYSEN [cds2] [br] (AGROW [a])\n</code></pre> <p>Nonlinear saturation-based whitecapping combined with wind input of Yan (1987).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--notes","title":"Notes","text":"<p>The two arguments are specified in the Appendix C of the User manual but not in the command description for WESTH in Section 4.5.4. They are also options in the WCAPPING command. It is not entirely clear if they should/could be specified here.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--references","title":"References","text":"<p>van der Westhuysen, A.J., Zijlema, M. and Battjes, J.A., 2007. Nonlinear saturation-based whitecapping dissipation in SWAN for deep and shallow water. Coastal Engineering, 54(2), pp.151-170.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import WESTHUYSEN\nwesthuysen = WESTHUYSEN()\nprint(westhuysen.render())\nwesthuysen = WESTHUYSEN(cds2=5.0e-5, br=1.75e-3)\nprint(westhuysen.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class WESTHUYSEN(SourceTerms):\n    \"\"\"Westhuysen source terms subcomponent.\n\n    .. code-block:: text\n\n        WESTHUYSEN [cds2] [br] (AGROW [a])\n\n    Nonlinear saturation-based whitecapping combined with wind input of Yan (1987).\n\n    Notes\n    -----\n    The two arguments are specified in the Appendix C of the User manual but not in the\n    command description for WESTH in Section 4.5.4. They are also options in the\n    WCAPPING command. It is not entirely clear if they should/could be specified here.\n\n    References\n    ----------\n    van der Westhuysen, A.J., Zijlema, M. and Battjes, J.A., 2007. Nonlinear\n    saturation-based whitecapping dissipation in SWAN for deep and shallow water.\n    Coastal Engineering, 54(2), pp.151-170.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import WESTHUYSEN\n        westhuysen = WESTHUYSEN()\n        print(westhuysen.render())\n        westhuysen = WESTHUYSEN(cds2=5.0e-5, br=1.75e-3)\n        print(westhuysen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"westhuysen\", \"WESTHUYSEN\"] = Field(\n        default=\"westhuysen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"proportionality coefficient due to Alves and Banner (2003) \"\n            \"(SWAN default: 5.0e-5).\"\n        ),\n    )\n    br: Optional[float] = Field(\n        default=None, description=\"Threshold saturation level\t(SWAN default: 1.75e-3)\"\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"WESTHUYSEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.br is not None:\n            repr += f\" br={self.br}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['westhuysen', 'WESTHUYSEN'] = Field(default='westhuysen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='proportionality coefficient due to Alves and Banner (2003) (SWAN default: 5.0e-5).')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.br","title":"br  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>br: Optional[float] = Field(default=None, description='Threshold saturation level\\t(SWAN default: 1.75e-3)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"WESTHUYSEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.br is not None:\n        repr += f\" br={self.br}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6","title":"ST6","text":"<p>               Bases: <code>SourceTerms</code></p> <p>St6 source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>ST6 [a1sds] [a2sds] [p1sds] [p2sds] UP|DOWN HWANG|FAN|ECMWF VECTAU|SCATAU &amp;\n    TRUE10|U10PROXY [windscaling] DEBIAS [cdfac] (AGROW [a])\n</code></pre> <p>wind input and whitecapping from Rogers et al. (2012) (RBW12).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--notes","title":"Notes","text":"<p>The two arguments are specified in the Appendix C of the User manual but not in the command description for WESTH in Section 4.5.4. They are also options in the WCAPPING command. It is not entirely clear if they should/could be specified here.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--references","title":"References","text":"<p>Fan, Y., Lin, S.J., Held, I.M., Yu, Z. and Tolman, H.L., 2012. Global ocean surface wave simulation using a coupled atmosphere\u2013wave model. Journal of Climate, 25(18), pp.6233-6252.</p> <p>Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and whitecapping dissipation in a model for wind-generated surface waves: Description and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9), pp.1329-1346.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6\nst6 = ST6(a1sds=4.7e-7, a2sds=6.6e-6)\nprint(st6.render())\nkwargs = dict(\n    a1sds=2.8e-6,\n    a2sds=3.5e-5,\n    normalization=\"up\",\n    wind_drag=\"hwang\",\n    tau=\"vectau\",\n    u10=\"u10proxy\",\n    windscaling=32.0,\n    cdfac=0.89,\n    agrow=True,\n    a=0.0015,\n)\nst6 = ST6(**kwargs)\nprint(st6.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6(SourceTerms):\n    \"\"\"St6 source terms subcomponent.\n\n    .. code-block:: text\n\n        ST6 [a1sds] [a2sds] [p1sds] [p2sds] UP|DOWN HWANG|FAN|ECMWF VECTAU|SCATAU &amp;\n            TRUE10|U10PROXY [windscaling] DEBIAS [cdfac] (AGROW [a])\n\n    wind input and whitecapping from Rogers et al. (2012) (RBW12).\n\n    Notes\n    -----\n    The two arguments are specified in the Appendix C of the User manual but not in the\n    command description for WESTH in Section 4.5.4. They are also options in the\n    WCAPPING command. It is not entirely clear if they should/could be specified here.\n\n    References\n    ----------\n    Fan, Y., Lin, S.J., Held, I.M., Yu, Z. and Tolman, H.L., 2012. Global ocean surface\n    wave simulation using a coupled atmosphere\u2013wave model. Journal of Climate, 25(18),\n    pp.6233-6252.\n\n    Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and\n    whitecapping dissipation in a model for wind-generated surface waves: Description\n    and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9),\n    pp.1329-1346.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6\n        st6 = ST6(a1sds=4.7e-7, a2sds=6.6e-6)\n        print(st6.render())\n        kwargs = dict(\n            a1sds=2.8e-6,\n            a2sds=3.5e-5,\n            normalization=\"up\",\n            wind_drag=\"hwang\",\n            tau=\"vectau\",\n            u10=\"u10proxy\",\n            windscaling=32.0,\n            cdfac=0.89,\n            agrow=True,\n            a=0.0015,\n        )\n        st6 = ST6(**kwargs)\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6\"] = Field(\n        default=\"st6\", description=\"Model type discriminator\"\n    )\n    a1sds: float = Field(\n        description=\"Coefficient related to local dissipation term T1 (a1 in RBW12)\"\n    )\n    a2sds: float = Field(\n        description=\"Coefficient related to local dissipation term T2 (a2 in RBW12)\"\n    )\n    p1sds: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power coefficient controlling strength of dissipation term T1 \"\n            \"(L in RBW12, SWAN default: 4)\"\n        ),\n    )\n    p2sds: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power coefficient controlling strength of dissipation term T2 \"\n            \"(M in RBW12, SWAN default: 4)\"\n        ),\n    )\n    normalization: Literal[\"up\", \"down\"] = Field(\n        default=\"up\",\n        description=(\n            \"Selection of normalization of exceedance level by ET(f) (`up`) or E(f) \"\n            \"(`down`) as in RBW12 (right column, page 1333), `up` is default and \"\n            \"strongly recommended\"\n        ),\n    )\n    wind_drag: Literal[\"hwang\", \"fan\", \"ecmwf\"] = Field(\n        default=\"hwang\",\n        description=(\n            \"Wind drag formula, `hwang` is the default and is unchanged from RBW12, \"\n            \"`fan` is from Fan et al. (2012), `ecmwf` follows WAM Cycle 4 methodology\"\n        ),\n    )\n    tau: Literal[\"vectau\", \"scatau\"] = Field(\n        default=\"vectau\",\n        description=(\n            \"Use vector (vectau) or scalar (scatau) calculation for the wind strerss \"\n            \"(Eq. 12 in RBW12), `vectau` is the default and strongly recommended\"\n        ),\n    )\n    u10: Literal[\"u10proxy\", \"true10\"] = Field(\n        default=\"u10proxy\",\n        description=\"Wind velocity definition\",\n    )\n    windscaling: Optional[float] = Field(\n        default=32.0,\n        description=\"Factor to scale U10 with U* when using U10PROXY\",\n    )\n    cdfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Counter bias in the input wind fields by providing a multiplier \"\n            \"on the drag coefficient\"\n        ),\n        gt=0.0,\n    )\n\n    @model_validator(mode=\"after\")\n    def debias_only_with_hwang(self) -&gt; \"ST6\":\n        if self.cdfac is not None and self.wind_drag != \"hwang\":\n            raise ValueError(\n                f\"Debias is only supported with hwang wind drag, not {self.wind_drag}\"\n            )\n        return self\n\n    @property\n    def u10_cmd(self) -&gt; str:\n        if self.u10 == \"true10\":\n            return \"TRUE10\"\n        else:\n            return f\"U10PROXY windscaling={self.windscaling}\"\n\n    def cmd(self) -&gt; str:\n        repr = f\"ST6 a1sds={self.a1sds} a2sds={self.a2sds}\"\n        if self.p1sds is not None:\n            repr += f\" p1sds={self.p1sds}\"\n        if self.p2sds is not None:\n            repr += f\" p2sds={self.p2sds}\"\n        repr += f\" {self.normalization.upper()}\"\n        repr += f\" {self.wind_drag.upper()}\"\n        repr += f\" {self.tau.upper()}\"\n        repr += f\" {self.u10_cmd}\"\n        if self.cdfac is not None:\n            repr += f\" DEBIAS cdfac={self.cdfac}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6'] = Field(default='st6', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: float = Field(description='Coefficient related to local dissipation term T1 (a1 in RBW12)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: float = Field(description='Coefficient related to local dissipation term T2 (a2 in RBW12)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.p1sds","title":"p1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p1sds: Optional[float] = Field(default=None, description='Power coefficient controlling strength of dissipation term T1 (L in RBW12, SWAN default: 4)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.p2sds","title":"p2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p2sds: Optional[float] = Field(default=None, description='Power coefficient controlling strength of dissipation term T2 (M in RBW12, SWAN default: 4)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.normalization","title":"normalization  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normalization: Literal['up', 'down'] = Field(default='up', description='Selection of normalization of exceedance level by ET(f) (`up`) or E(f) (`down`) as in RBW12 (right column, page 1333), `up` is default and strongly recommended')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.wind_drag","title":"wind_drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wind_drag: Literal['hwang', 'fan', 'ecmwf'] = Field(default='hwang', description='Wind drag formula, `hwang` is the default and is unchanged from RBW12, `fan` is from Fan et al. (2012), `ecmwf` follows WAM Cycle 4 methodology')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.tau","title":"tau  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tau: Literal['vectau', 'scatau'] = Field(default='vectau', description='Use vector (vectau) or scalar (scatau) calculation for the wind strerss (Eq. 12 in RBW12), `vectau` is the default and strongly recommended')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.u10","title":"u10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>u10: Literal['u10proxy', 'true10'] = Field(default='u10proxy', description='Wind velocity definition')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Optional[float] = Field(default=32.0, description='Factor to scale U10 with U* when using U10PROXY')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Optional[float] = Field(default=None, description='Counter bias in the input wind fields by providing a multiplier on the drag coefficient', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.u10_cmd","title":"u10_cmd  <code>property</code>","text":"<pre><code>u10_cmd: str\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.debias_only_with_hwang","title":"debias_only_with_hwang","text":"<pre><code>debias_only_with_hwang() -&gt; ST6\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef debias_only_with_hwang(self) -&gt; \"ST6\":\n    if self.cdfac is not None and self.wind_drag != \"hwang\":\n        raise ValueError(\n            f\"Debias is only supported with hwang wind drag, not {self.wind_drag}\"\n        )\n    return self\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"ST6 a1sds={self.a1sds} a2sds={self.a2sds}\"\n    if self.p1sds is not None:\n        repr += f\" p1sds={self.p1sds}\"\n    if self.p2sds is not None:\n        repr += f\" p2sds={self.p2sds}\"\n    repr += f\" {self.normalization.upper()}\"\n    repr += f\" {self.wind_drag.upper()}\"\n    repr += f\" {self.tau.upper()}\"\n    repr += f\" {self.u10_cmd}\"\n    if self.cdfac is not None:\n        repr += f\" DEBIAS cdfac={self.cdfac}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#st6-presets","title":"ST6 presets","text":"<p>Combinations of calibrated coefficients for ST6 are defined in the SWAN Manual. The following presets are available:</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1","title":"ST6C1","text":"<p>               Bases: <code>ST6</code></p> <p>First ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C1\nst6 = ST6C1()\nprint(st6.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C1(ST6):\n    \"\"\"First ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C1\n        st6 = ST6C1()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c1\"] = Field(default=\"st6c1\")\n    a1sds: Literal[4.7e-7] = Field(default=4.7e-7)\n    a2sds: Literal[6.6e-6] = Field(default=6.6e-6)\n    p1sds: Literal[4.0] = Field(default=4.0)\n    p2sds: Literal[4.0] = Field(default=4.0)\n    windscaling: Literal[28.0] = Field(default=28.0)\n    agrow: Literal[True] = Field(default=True)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c1'] = Field(default='st6c1')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[4.7e-07] = Field(default=4.7e-07)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[6.6e-06] = Field(default=6.6e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.p1sds","title":"p1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p1sds: Literal[4.0] = Field(default=4.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.p2sds","title":"p2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p2sds: Literal[4.0] = Field(default=4.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[28.0] = Field(default=28.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.agrow","title":"agrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>agrow: Literal[True] = Field(default=True)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2","title":"ST6C2","text":"<p>               Bases: <code>ST6C1</code></p> <p>Second ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP FAN VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C2\nst6 = ST6C2()\nprint(st6.render())\n</code></pre> <p>TODO: Ensure validator is reused here so fan and debias are not used together.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C2(ST6C1):\n    \"\"\"Second ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP FAN VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C2\n        st6 = ST6C2()\n        print(st6.render())\n\n    TODO: Ensure validator is reused here so fan and debias are not used together.\n\n    \"\"\"\n\n    model_type: Literal[\"st6c2\"] = Field(default=\"st6c2\")\n    wind_drag: Literal[\"fan\"] = Field(default=\"fan\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c2'] = Field(default='st6c2')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2.wind_drag","title":"wind_drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wind_drag: Literal['fan'] = Field(default='fan')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3","title":"ST6C3","text":"<p>               Bases: <code>ST6C1</code></p> <p>Third ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C3\nst6 = ST6C3()\nprint(st6.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C3(ST6C1):\n    \"\"\"Third ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C3\n        st6 = ST6C3()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c3\"] = Field(default=\"st6c3\")\n    a1sds: Literal[2.8e-6] = Field(default=2.8e-6)\n    a2sds: Literal[3.5e-5] = Field(default=3.5e-5)\n    windscaling: Literal[32.0] = Field(default=32.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c3'] = Field(default='st6c3')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[2.8e-06] = Field(default=2.8e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[3.5e-05] = Field(default=3.5e-05)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[32.0] = Field(default=32.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4","title":"ST6C4","text":"<p>               Bases: <code>ST6C3</code></p> <p>Fourth ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 DEBIAS 0.89 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C4\nst6 = ST6C4()\nprint(st6.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C4(ST6C3):\n    \"\"\"Fourth ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 DEBIAS 0.89 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C4\n        st6 = ST6C4()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c4\"] = Field(default=\"st6c4\")\n    cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c4'] = Field(default='st6c4')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5","title":"ST6C5","text":"<p>               Bases: <code>ST6C1</code></p> <p>Fifth ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C5\nst6 = ST6C5()\nprint(st6.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C5(ST6C1):\n    \"\"\"Fifth ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C5\n        st6 = ST6C5()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c5\"] = Field(default=\"st6c5\")\n    cdfac: Literal[0.89] = Field(default=0.89)\n    a1sds: Literal[6.5e-6] = Field(default=6.5e-6)\n    a2sds: Literal[8.5e-5] = Field(default=8.5e-5)\n    windscaling: Literal[35.0] = Field(default=35.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c5'] = Field(default='st6c5')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[6.5e-06] = Field(default=6.5e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[8.5e-05] = Field(default=8.5e-05)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[35.0] = Field(default=35.0)\n</code></pre>"},{"location":"subcomponents/physics/#biphase","title":"Biphase","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY","title":"ELDEBERKY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Biphase of Eldeberky (1999).</p> <p>.. code-block:: text</p> <pre><code>BIPHASE ELDEBERKY [urcrit]\n</code></pre> <p>Biphase parameterisation as a funtion of the Ursell number of Eldeberky (1999).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY--references","title":"References","text":"<p>Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for modeling triad interactions in dispersive waves. In Coastal Engineering 1996 (pp. 1088-1101).</p> <p>Eldeberky, Y. and Madsen, P.A., 1999. Deterministic and stochastic evolution equations for fully dispersive and weakly nonlinear waves. Coastal Engineering, 38(1), pp.1-24.</p> <p>Doering, J.C. and Bowen, A.J., 1995. Parametrization of orbital velocity asymmetries of shoaling and breaking waves using bispectral analysis. Coastal engineering, 26(1-2), pp.15-33.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ELDEBERKY\nbiphase = ELDEBERKY()\nprint(biphase.render())\nbiphase = ELDEBERKY(urcrit=0.63)\nprint(biphase.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class ELDEBERKY(BaseSubComponent):\n    \"\"\"Biphase of Eldeberky (1999).\n\n    .. code-block:: text\n\n        BIPHASE ELDEBERKY [urcrit]\n\n    Biphase parameterisation as a funtion of the Ursell number of Eldeberky (1999).\n\n    References\n    ----------\n    Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for\n    modeling triad interactions in dispersive waves. In Coastal Engineering 1996\n    (pp. 1088-1101).\n\n    Eldeberky, Y. and Madsen, P.A., 1999. Deterministic and stochastic evolution\n    equations for fully dispersive and weakly nonlinear waves. Coastal Engineering,\n    38(1), pp.1-24.\n\n    Doering, J.C. and Bowen, A.J., 1995. Parametrization of orbital velocity\n    asymmetries of shoaling and breaking waves using bispectral analysis. Coastal\n    engineering, 26(1-2), pp.15-33.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ELDEBERKY\n        biphase = ELDEBERKY()\n        print(biphase.render())\n        biphase = ELDEBERKY(urcrit=0.63)\n        print(biphase.render())\n\n    \"\"\"\n\n    model_type: Literal[\"eldeberky\"] = Field(\n        default=\"eldeberky\", description=\"Model type discriminator\"\n    )\n    urcrit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The critical Ursell number appearing in the parametrization. Note: the \"\n            \"value of `urcrit` is setted by Eldeberky (1996) at 0.2 based on a \"\n            \"laboratory experiment, whereas Doering and Bowen (1995) employed the \"\n            \"value of 0.63 based on the field experiment data (SWAN default: 0.63)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"BIPHASE ELDEBERKY\"\n        if self.urcrit is not None:\n            repr += f\" urcrit={self.urcrit}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['eldeberky'] = Field(default='eldeberky', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.urcrit","title":"urcrit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urcrit: Optional[float] = Field(default=None, description='The critical Ursell number appearing in the parametrization. Note: the value of `urcrit` is setted by Eldeberky (1996) at 0.2 based on a laboratory experiment, whereas Doering and Bowen (1995) employed the value of 0.63 based on the field experiment data (SWAN default: 0.63)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"BIPHASE ELDEBERKY\"\n    if self.urcrit is not None:\n        repr += f\" urcrit={self.urcrit}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT","title":"DEWIT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Biphase of De Wit (2022).</p> <p>.. code-block:: text</p> <pre><code>BIPHASE DEWIT [lpar]\n</code></pre> <p>Biphase parameterization based on bed slope and peak period of De Wit (2022).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT--references","title":"References","text":"<p>De Wit, F.P., 2022. Wave shape prediction in complex coastal systems (Doctoral dissertation, PhD. thesis. Delft University of Technology. https://repository. tudelft. nl/islandora/object/uuid% 3A0fb850a4-4294-4181-9d74-857de21265c2).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import DEWIT\nbiphase = DEWIT()\nprint(biphase.render())\nbiphase = DEWIT(lpar=0.0)\nprint(biphase.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class DEWIT(BaseSubComponent):\n    \"\"\"Biphase of De Wit (2022).\n\n    .. code-block:: text\n\n        BIPHASE DEWIT [lpar]\n\n    Biphase parameterization based on bed slope and peak period of De Wit (2022).\n\n    References\n    ----------\n    De Wit, F.P., 2022. Wave shape prediction in complex coastal systems (Doctoral\n    dissertation, PhD. thesis. Delft University of Technology. https://repository.\n    tudelft. nl/islandora/object/uuid% 3A0fb850a4-4294-4181-9d74-857de21265c2).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import DEWIT\n        biphase = DEWIT()\n        print(biphase.render())\n        biphase = DEWIT(lpar=0.0)\n        print(biphase.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dewit\"] = Field(\n        default=\"dewit\", description=\"Model type discriminator\"\n    )\n    lpar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scales spatial averaging of the De Wit's biphase in terms of a multiple \"\n            \"of peak wave length of the incident wave field. Note: `lpar` = 0` means \"\n            \"no averaging (SWAN default: 0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"BIPHASE DEWIT\"\n        if self.lpar is not None:\n            repr += f\" lpar={self.lpar}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dewit'] = Field(default='dewit', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.lpar","title":"lpar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lpar: Optional[float] = Field(default=None, description=\"Scales spatial averaging of the De Wit's biphase in terms of a multiple of peak wave length of the incident wave field. Note: `lpar` = 0` means no averaging (SWAN default: 0)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"BIPHASE DEWIT\"\n    if self.lpar is not None:\n        repr += f\" lpar={self.lpar}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#transmission-and-reflection","title":"Transmission and reflection","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM","title":"TRANSM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Constant transmission coefficient.</p> <p>.. code-block:: text</p> <pre><code>TRANSM [trcoef]\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANSM\ntransm = TRANSM()\nprint(transm.render())\ntransm = TRANSM(trcoef=0.5)\nprint(transm.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANSM(BaseSubComponent):\n    \"\"\"Constant transmission coefficient.\n\n    .. code-block:: text\n\n        TRANSM [trcoef]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANSM\n        transm = TRANSM()\n        print(transm.render())\n        transm = TRANSM(trcoef=0.5)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"transm\", \"TRANSM\"] = Field(\n        default=\"transm\", description=\"Model type discriminator\"\n    )\n    trcoef: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Constant transmission coefficient (ratio of transmitted over incoming \"\n            \"significant wave height) (SWAN default: 0.0) (no transmission = complete \"\n            \"blockage)\"\n        ),\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"TRANSM\"\n        if self.trcoef is not None:\n            repr += f\" trcoef={self.trcoef}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['transm', 'TRANSM'] = Field(default='transm', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: Optional[float] = Field(default=None, description='Constant transmission coefficient (ratio of transmitted over incoming significant wave height) (SWAN default: 0.0) (no transmission = complete blockage)', ge=0.0, le=1.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"TRANSM\"\n    if self.trcoef is not None:\n        repr += f\" trcoef={self.trcoef}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D","title":"TRANS1D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency dependent transmission.</p> <p>.. code-block:: text</p> <pre><code>TRANS1D &lt; [trcoef] &gt;\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANS1D\ntransm = TRANS1D(trcoef=[0.0, 0.0, 0.2, 0.5, 0.2, 0.0, 0.0])\nprint(transm.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANS1D(BaseSubComponent):\n    \"\"\"Frequency dependent transmission.\n\n    .. code-block:: text\n\n        TRANS1D &lt; [trcoef] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANS1D\n        transm = TRANS1D(trcoef=[0.0, 0.0, 0.2, 0.5, 0.2, 0.0, 0.0])\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"trans1d\", \"TRANS1D\"] = Field(\n        default=\"trans1d\", description=\"Model type discriminator\"\n    )\n    trcoef: list[Annotated[float, Field(ge=0.0, le=1.0)]] = Field(\n        description=(\n            \"Transmission coefficient (ratio of transmitted over incoming significant \"\n            \"wave height) per frequency. The number of these transmission values must \"\n            \"be equal to the number of frequencies, i.e. `msc` + 1\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return f\"TRANS1D {' '.join(str(v) for v in self.trcoef)}\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['trans1d', 'TRANS1D'] = Field(default='trans1d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: list[Annotated[float, Field(ge=0.0, le=1.0)]] = Field(description='Transmission coefficient (ratio of transmitted over incoming significant wave height) per frequency. The number of these transmission values must be equal to the number of frequencies, i.e. `msc` + 1')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return f\"TRANS1D {' '.join(str(v) for v in self.trcoef)}\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D","title":"TRANS2D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency-direction dependent transmission.</p> <p>.. code-block:: text</p> <pre><code>TRANS2D &lt; [trcoef] &gt;\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANS2D\ntrcoef = np.array([[0.0, 0.0], [0.1, 0.1], [0.2, 0.2]])\ntransm = TRANS2D(trcoef=trcoef)\nprint(transm.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANS2D(BaseSubComponent):\n    \"\"\"Frequency-direction dependent transmission.\n\n    .. code-block:: text\n\n        TRANS2D &lt; [trcoef] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANS2D\n        trcoef = np.array([[0.0, 0.0], [0.1, 0.1], [0.2, 0.2]])\n        transm = TRANS2D(trcoef=trcoef)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"trans2d\", \"TRANS2D\"] = Field(\n        default=\"trans2d\", description=\"Model type discriminator\"\n    )\n    trcoef: Np2DArray = Field(\n        description=(\n            \"Transmission coefficient (ratio of transmitted over incoming significant \"\n            \"wave height) per frequency and direction, rows represent directions and \"\n            \"columns represent frequencies\"\n        ),\n    )\n\n    @field_validator(\"trcoef\")\n    @classmethod\n    def constrained_0_1(cls, value: float) -&gt; float:\n        \"\"\"Ensure all directions have the same number of frequencies.\"\"\"\n        if value.min() &lt; 0 or value.max() &gt; 1:\n            raise ValueError(\"Transmission coefficients must be between 0.0 and 1.0\")\n        return value\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"TRANS2D\"\n        for coef in self.trcoef:\n            repr += f\" &amp;\\n\\t{' '.join(str(v) for v in coef)}\"\n        return f\"{repr} &amp;\\n\\t\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['trans2d', 'TRANS2D'] = Field(default='trans2d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: Np2DArray = Field(description='Transmission coefficient (ratio of transmitted over incoming significant wave height) per frequency and direction, rows represent directions and columns represent frequencies')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.constrained_0_1","title":"constrained_0_1  <code>classmethod</code>","text":"<pre><code>constrained_0_1(value: float) -&gt; float\n</code></pre> <p>Ensure all directions have the same number of frequencies.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>@field_validator(\"trcoef\")\n@classmethod\ndef constrained_0_1(cls, value: float) -&gt; float:\n    \"\"\"Ensure all directions have the same number of frequencies.\"\"\"\n    if value.min() &lt; 0 or value.max() &gt; 1:\n        raise ValueError(\"Transmission coefficients must be between 0.0 and 1.0\")\n    return value\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"TRANS2D\"\n    for coef in self.trcoef:\n        repr += f\" &amp;\\n\\t{' '.join(str(v) for v in coef)}\"\n    return f\"{repr} &amp;\\n\\t\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA","title":"GODA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>DAM transmission of Goda/Seelig (1979).</p> <p>.. code-block:: text</p> <pre><code>DAM GODA [hgt] [alpha] [beta]\n</code></pre> <p>This option specified transmission coefficients dependent on the incident wave conditions at the obstacle and on the obstacle height (which may be submerged).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA--references","title":"References","text":"<p>Goda, Y. and Suzuki, Y., 1976. Estimation of incident and reflected waves in random wave experiments. In Coastal Engineering 1976 (pp. 828-845).</p> <p>Seelig, W.N., 1979. Effects of breakwaters on waves: Laboratory test of wave transmission by overtopping. In Proc. Conf. Coastal Structures, 1979 (Vol. 79, No. 2, pp. 941-961).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import GODA\ntransm = GODA(hgt=3.0)\nprint(transm.render())\ntransm = GODA(hgt=3.0, alpha=2.6, beta=0.15)\nprint(transm.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class GODA(BaseSubComponent):\n    \"\"\"DAM transmission of Goda/Seelig (1979).\n\n    .. code-block:: text\n\n        DAM GODA [hgt] [alpha] [beta]\n\n    This option specified transmission coefficients dependent on the incident wave\n    conditions at the obstacle and on the obstacle height (which may be submerged).\n\n    References\n    ----------\n    Goda, Y. and Suzuki, Y., 1976. Estimation of incident and reflected waves in random\n    wave experiments. In Coastal Engineering 1976 (pp. 828-845).\n\n    Seelig, W.N., 1979. Effects of breakwaters on waves: Laboratory test of wave\n    transmission by overtopping. In Proc. Conf. Coastal Structures, 1979\n    (Vol. 79, No. 2, pp. 941-961).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import GODA\n        transm = GODA(hgt=3.0)\n        print(transm.render())\n        transm = GODA(hgt=3.0, alpha=2.6, beta=0.15)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"goda\", \"GODA\"] = Field(\n        default=\"goda\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle above reference level (same \"\n            \"reference level as for bottom etc.); use a negative value if the top is \"\n            \"below that reference level\"\n        ),\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"coefficient determining the transmission coefficient for Goda's \"\n            \"transmission formula (SWAN default: 2.6)\"\n        ),\n    )\n    beta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Another coefficient determining the transmission coefficient for Goda's \"\n            \"transmission formula (SWAN default: 0.15)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"DAM {self.model_type.upper()} hgt={self.hgt}\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.beta is not None:\n            repr += f\" beta={self.beta}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['goda', 'GODA'] = Field(default='goda', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle above reference level (same reference level as for bottom etc.); use a negative value if the top is below that reference level')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description=\"coefficient determining the transmission coefficient for Goda's transmission formula (SWAN default: 2.6)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.beta","title":"beta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>beta: Optional[float] = Field(default=None, description=\"Another coefficient determining the transmission coefficient for Goda's transmission formula (SWAN default: 0.15)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"DAM {self.model_type.upper()} hgt={self.hgt}\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.beta is not None:\n        repr += f\" beta={self.beta}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND","title":"DANGREMOND","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>DAM transmission of d'Angremond et al. (1996).</p> <p>.. code-block:: text</p> <pre><code>DAM DANGREMOND [hgt] [slope] [Bk]\n</code></pre> <p>This option specifies transmission coefficients dependent on the incident wave conditions at the obstacle and on the obstacle height (which may be submerged).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND--references","title":"References","text":"<p>d'Angremond, K., Van Der Meer, J.W. and De Jong, R.J., 1996. Wave transmission at low-crested structures. In Coastal Engineering 1996 (pp. 2418-2427).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import DANGREMOND\ntransm = DANGREMOND(hgt=3.0, slope=60, Bk=10.0)\nprint(transm.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class DANGREMOND(BaseSubComponent):\n    \"\"\"DAM transmission of d'Angremond et al. (1996).\n\n    .. code-block:: text\n\n        DAM DANGREMOND [hgt] [slope] [Bk]\n\n    This option specifies transmission coefficients dependent on the incident wave\n    conditions at the obstacle and on the obstacle height (which may be submerged).\n\n    References\n    ----------\n    d'Angremond, K., Van Der Meer, J.W. and De Jong, R.J., 1996. Wave transmission at\n    low-crested structures. In Coastal Engineering 1996 (pp. 2418-2427).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import DANGREMOND\n        transm = DANGREMOND(hgt=3.0, slope=60, Bk=10.0)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dangremond\", \"DANGREMOND\"] = Field(\n        default=\"dangremond\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle above reference level (same \"\n            \"reference level as for bottom etc.); use a negative value if the top is \"\n            \"below that reference level\"\n        ),\n    )\n    slope: float = Field(\n        description=\"The slope of the obstacle (in degrees)\", ge=0.0, le=90.0\n    )\n    Bk: float = Field(description=\"The crest width of the obstacle\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"DAM {self.model_type.upper()}\"\n        repr += f\" hgt={self.hgt} slope={self.slope} Bk={self.Bk}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dangremond', 'DANGREMOND'] = Field(default='dangremond', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle above reference level (same reference level as for bottom etc.); use a negative value if the top is below that reference level')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: float = Field(description='The slope of the obstacle (in degrees)', ge=0.0, le=90.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.Bk","title":"Bk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bk: float = Field(description='The crest width of the obstacle')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"DAM {self.model_type.upper()}\"\n    repr += f\" hgt={self.hgt} slope={self.slope} Bk={self.Bk}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL","title":"REFL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Obstacle reflections.</p> <p>.. code-block:: text</p> <pre><code>REFL [reflc]\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import REFL\nrefl = REFL()\nprint(refl.render())\nrefl = REFL(reflc=0.5)\nprint(refl.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class REFL(BaseSubComponent):\n    \"\"\"Obstacle reflections.\n\n    .. code-block:: text\n\n        REFL [reflc]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import REFL\n        refl = REFL()\n        print(refl.render())\n        refl = REFL(reflc=0.5)\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"refl\", \"REFL\"] = Field(\n        default=\"refl\", description=\"Model type discriminator\"\n    )\n    reflc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Constant reflection coefficient (ratio of reflected over incoming \"\n            \"significant wave height) (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"REFL\"\n        if self.reflc is not None:\n            repr += f\" reflc={self.reflc}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['refl', 'REFL'] = Field(default='refl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.reflc","title":"reflc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflc: Optional[float] = Field(default=None, description='Constant reflection coefficient (ratio of reflected over incoming significant wave height) (SWAN default: 1.0)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"REFL\"\n    if self.reflc is not None:\n        repr += f\" reflc={self.reflc}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC","title":"RSPEC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Specular reflection.</p> <p>.. code-block:: text</p> <pre><code>RSPEC\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import RSPEC\nrefl = RSPEC()\nprint(refl.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class RSPEC(BaseSubComponent):\n    \"\"\"Specular reflection.\n\n    .. code-block:: text\n\n        RSPEC\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import RSPEC\n        refl = RSPEC()\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rspec\", \"RSPEC\"] = Field(\n        default=\"rspec\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"RSPEC\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rspec', 'RSPEC'] = Field(default='rspec', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"RSPEC\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF","title":"RDIFF","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Diffuse reflection.</p> <p>.. code-block:: text</p> <pre><code>RDIFF [pown]\n</code></pre> <p>Specular reflection where incident waves are scattered over reflected direction.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import RDIFF\nrefl = RDIFF()\nprint(refl.render())\nrefl = RDIFF(pown=1.0)\nprint(refl.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class RDIFF(BaseSubComponent):\n    \"\"\"Diffuse reflection.\n\n    .. code-block:: text\n\n        RDIFF [pown]\n\n    Specular reflection where incident waves are scattered over reflected direction.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import RDIFF\n        refl = RDIFF()\n        print(refl.render())\n        refl = RDIFF(pown=1.0)\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rdiff\", \"RDIFF\"] = Field(\n        default=\"rdiff\", description=\"Model type discriminator\"\n    )\n    pown: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Each incoming direction \u03b8 is scattered over reflected direction \u03b8_refl \"\n            \"according to cos^pown(\u03b8-\u03b8_refl). The parameter `pown` indicates the width\"\n            \"of the redistribution function (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"RDIFF\"\n        if self.pown is not None:\n            repr += f\" pown={self.pown}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rdiff', 'RDIFF'] = Field(default='rdiff', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.pown","title":"pown  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pown: Optional[float] = Field(default=None, description='Each incoming direction \u03b8 is scattered over reflected direction \u03b8_refl according to cos^pown(\u03b8-\u03b8_refl). The parameter `pown` indicates the widthof the redistribution function (SWAN default: 1.0)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"RDIFF\"\n    if self.pown is not None:\n        repr += f\" pown={self.pown}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD","title":"FREEBOARD","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Freeboard dependent transmission and reflection.</p> <p>.. code-block:: text</p> <pre><code>FREEBOARD [hgt] [gammat] [gammar] [QUAY]\n</code></pre> <p>With this option the user indicates that the fixed transmission <code>trcoef</code> and reflection <code>reflc</code> coefficients are freeboard dependent. The freeboard dependency has no effect on the transmission coefficient as computed using the DAM option.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD--notes","title":"Notes","text":"<p>See the Scientific/Technical documentation for background information on the <code>gammat</code> and <code>gammar</code> shape parameters.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import FREEBOARD\nfreeboard = FREEBOARD(hgt=2.0)\nprint(freeboard.render())\nfreeboard = FREEBOARD(hgt=2.0, gammat=1.0, gammar=1.0, quay=True)\nprint(freeboard.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class FREEBOARD(BaseSubComponent):\n    \"\"\"Freeboard dependent transmission and reflection.\n\n    .. code-block:: text\n\n        FREEBOARD [hgt] [gammat] [gammar] [QUAY]\n\n    With this option the user indicates that the fixed transmission `trcoef` and\n    reflection `reflc` coefficients are freeboard dependent. The freeboard dependency\n    has no effect on the transmission coefficient as computed using the DAM option.\n\n    Notes\n    -----\n    See the Scientific/Technical documentation for background information on the\n    `gammat` and `gammar` shape parameters.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import FREEBOARD\n        freeboard = FREEBOARD(hgt=2.0)\n        print(freeboard.render())\n        freeboard = FREEBOARD(hgt=2.0, gammat=1.0, gammar=1.0, quay=True)\n        print(freeboard.render())\n\n    \"\"\"\n\n    model_type: Literal[\"freeboard\", \"FREEBOARD\"] = Field(\n        default=\"freeboard\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle or height of the quay above the \"\n            \"reference level (same reference level as for the bottom). Use a negative \"\n            \"value if the top is below that reference level. In case `hgt` is also \"\n            \"specified in the DAM option, both values of `hgt` should be equal for \"\n            \"consistency\"\n        ),\n    )\n    gammat: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape parameter of relative freeboard dependency of transmission \"\n            \"coefficient. This parameter should be higher than zero (SWAN default 1.0)\"\n        ),\n        gt=0.0,\n    )\n    gammar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape parameter of relative freeboard dependency of reflection \"\n            \"coefficient. This parameter should be higher than zero (SWAN default 1.0)\"\n        ),\n        gt=0.0,\n    )\n    quay: bool = Field(\n        default=False,\n        description=(\n            \"With this option the user indicates that the freeboard dependency of the \"\n            \"transmission and reflection coefficients also depends on the relative \"\n            \"position of an obstacle-linked grid point with respect to the position \"\n            \"of the obstacle line representing the edge of a quay. In case the active \"\n            \"grid point is on the deeper side of the obstacle, then the correction \"\n            \"factors are applied using the parameters `hgt`, `gammat` and `gammar`.\"\n            \"In case the active grid point is on the shallower side of the obstacle, \"\n            \"the reflection coefficient is set to 0 and the transmission coefficient \"\n            \"to 1.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"FREEBOARD\"\n        if self.hgt is not None:\n            repr += f\" hgt={self.hgt}\"\n        if self.gammat is not None:\n            repr += f\" gammat={self.gammat}\"\n        if self.gammar is not None:\n            repr += f\" gammar={self.gammar}\"\n        if self.quay:\n            repr += \" QUAY\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['freeboard', 'FREEBOARD'] = Field(default='freeboard', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle or height of the quay above the reference level (same reference level as for the bottom). Use a negative value if the top is below that reference level. In case `hgt` is also specified in the DAM option, both values of `hgt` should be equal for consistency')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.gammat","title":"gammat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gammat: Optional[float] = Field(default=None, description='Shape parameter of relative freeboard dependency of transmission coefficient. This parameter should be higher than zero (SWAN default 1.0)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.gammar","title":"gammar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gammar: Optional[float] = Field(default=None, description='Shape parameter of relative freeboard dependency of reflection coefficient. This parameter should be higher than zero (SWAN default 1.0)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.quay","title":"quay  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quay: bool = Field(default=False, description='With this option the user indicates that the freeboard dependency of the transmission and reflection coefficients also depends on the relative position of an obstacle-linked grid point with respect to the position of the obstacle line representing the edge of a quay. In case the active grid point is on the deeper side of the obstacle, then the correction factors are applied using the parameters `hgt`, `gammat` and `gammar`.In case the active grid point is on the shallower side of the obstacle, the reflection coefficient is set to 0 and the transmission coefficient to 1.')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"FREEBOARD\"\n    if self.hgt is not None:\n        repr += f\" hgt={self.hgt}\"\n    if self.gammat is not None:\n        repr += f\" gammat={self.gammat}\"\n    if self.gammar is not None:\n        repr += f\" gammar={self.gammar}\"\n    if self.quay:\n        repr += \" QUAY\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE","title":"LINE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Line of points to define obstacle location.</p> <p>.. code-block:: text</p> <pre><code>LINE &lt; [xp] [yp] &gt;\n</code></pre> <p>With this option the user indicates that the fixed transmission <code>trcoef</code> and reflection <code>reflc</code> coefficients are freeboard dependent. The freeboard dependency has no effect on the transmission coefficient as computed using the DAM option.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE--notes","title":"Notes","text":"<p>Points coordinates should be provided in m If Cartesian coordinates are used or in degrees if spherical coordinates are used (see command <code>COORD</code>). At least two corner points must be provided.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import LINE\nline = LINE(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1])\nprint(line.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>class LINE(BaseSubComponent):\n    \"\"\"Line of points to define obstacle location.\n\n    .. code-block:: text\n\n        LINE &lt; [xp] [yp] &gt;\n\n    With this option the user indicates that the fixed transmission `trcoef` and\n    reflection `reflc` coefficients are freeboard dependent. The freeboard dependency\n    has no effect on the transmission coefficient as computed using the DAM option.\n\n    Notes\n    -----\n    Points coordinates should be provided in m If Cartesian coordinates are used or in\n    degrees if spherical coordinates are used (see command `COORD`). At least two\n    corner points must be provided.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import LINE\n        line = LINE(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1])\n        print(line.render())\n\n    \"\"\"\n\n    model_type: Literal[\"line\", \"LINE\"] = Field(\n        default=\"line\", description=\"Model type discriminator\"\n    )\n    xp: list[float] = Field(\n        description=\"The x-coordinates of the points defining the line\", min_length=2\n    )\n    yp: list[float] = Field(\n        description=\"The y-coordinates of the points defining the line\", min_length=2\n    )\n\n    @model_validator(mode=\"after\")\n    def check_length(self) -&gt; \"LINE\":\n        \"\"\"Check that the length of xp and yp are the same.\"\"\"\n        if len(self.xp) != len(self.yp):\n            raise ValueError(\"xp and yp must be the same length\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"LINE\"\n        for xp, yp in zip(self.xp, self.yp):\n            repr += f\" {xp} {yp}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['line', 'LINE'] = Field(default='line', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='The x-coordinates of the points defining the line', min_length=2)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='The y-coordinates of the points defining the line', min_length=2)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.check_length","title":"check_length","text":"<pre><code>check_length() -&gt; LINE\n</code></pre> <p>Check that the length of xp and yp are the same.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_length(self) -&gt; \"LINE\":\n    \"\"\"Check that the length of xp and yp are the same.\"\"\"\n    if len(self.xp) != len(self.yp):\n        raise ValueError(\"xp and yp must be the same length\")\n    return self\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"LINE\"\n    for xp, yp in zip(self.xp, self.yp):\n        repr += f\" {xp} {yp}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/","title":"Grid reader","text":"<p>Sub-commands to support file reading. These are in technically components in that they render a full command line however they are not intended to be used directly but rather as sub-components of CGRID and INPGRID commands.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR","title":"GRIDREGULAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>SWAN Regular Grid subcomponent.</p> <p>.. code-block:: text</p> <pre><code>xp yp alp xlen ylen mx my\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--note","title":"Note","text":"<p>The direction of the x-axis <code>alp</code> must be 0 in case of spherical coordinates</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import GRIDREGULAR\nkwargs = dict(xp=173, yp=-40, alp=0, xlen=2, ylen=2, mx=199, my=199)\ngrid = GRIDREGULAR(suffix=\"c\", **kwargs)\nprint(grid.render())\ngrid = GRIDREGULAR(suffix=\"inp\", **kwargs)\nprint(grid.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>class GRIDREGULAR(BaseSubComponent):\n    \"\"\"SWAN Regular Grid subcomponent.\n\n    .. code-block:: text\n\n        xp yp alp xlen ylen mx my\n\n    Note\n    ----\n    The direction of the x-axis `alp` must be 0 in case of spherical coordinates\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import GRIDREGULAR\n        kwargs = dict(xp=173, yp=-40, alp=0, xlen=2, ylen=2, mx=199, my=199)\n        grid = GRIDREGULAR(suffix=\"c\", **kwargs)\n        print(grid.render())\n        grid = GRIDREGULAR(suffix=\"inp\", **kwargs)\n        print(grid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gridregular\", \"GRIDREGULAR\"] = Field(\n        default=\"gridregular\", description=\"Model type discriminator\"\n    )\n    xp: float = Field(\n        description=\"The x-coordinate of the origin in problem coordinates\",\n    )\n    yp: float = Field(\n        description=\"The y-coordinate of the origin in problem coordinates\",\n    )\n    alp: Optional[float] = Field(\n        default=0.0,\n        description=\"Direction of the xaxis in degrees\",\n    )\n    xlen: float = Field(\n        description=\"Length of the computational grid in the x-direction\"\n    )\n    ylen: float = Field(\n        description=\"Length of the computational grid in the y-direction\"\n    )\n    mx: int = Field(\n        description=(\n            \"Number of meshes in computational grid in x-direction (this number is \"\n            \"one less than the number of grid points in this domain)\"\n        ),\n    )\n    my: int = Field(\n        description=(\n            \"Number of meshes in computational grid in y-direction (this number is \"\n            \"one less than the number of grid points in this domain)\"\n        ),\n    )\n    suffix: Optional[str] = Field(\n        default=\"\", description=\"Suffix for rendering with each output grid parameter.\"\n    )\n\n    @property\n    def dx(self):\n        \"\"\"Grid spacing in x-direction.\"\"\"\n        return self.xlen / self.mx\n\n    @property\n    def dy(self):\n        \"\"\"Grid spacing in y-direction.\"\"\"\n        return self.ylen / self.my\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"xp{self.suffix}={self.xp}\"\n        repr += f\" yp{self.suffix}={self.yp}\"\n        repr += f\" alp{self.suffix}={self.alp}\"\n        repr += f\" xlen{self.suffix}={self.xlen}\"\n        repr += f\" ylen{self.suffix}={self.ylen}\"\n        repr += f\" mx{self.suffix}={self.mx}\"\n        repr += f\" my{self.suffix}={self.my}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gridregular', 'GRIDREGULAR'] = Field(default='gridregular', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: float = Field(description='The x-coordinate of the origin in problem coordinates')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: float = Field(description='The y-coordinate of the origin in problem coordinates')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.alp","title":"alp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alp: Optional[float] = Field(default=0.0, description='Direction of the xaxis in degrees')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.xlen","title":"xlen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xlen: float = Field(description='Length of the computational grid in the x-direction')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.ylen","title":"ylen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ylen: float = Field(description='Length of the computational grid in the y-direction')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.mx","title":"mx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mx: int = Field(description='Number of meshes in computational grid in x-direction (this number is one less than the number of grid points in this domain)')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.my","title":"my  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>my: int = Field(description='Number of meshes in computational grid in y-direction (this number is one less than the number of grid points in this domain)')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: Optional[str] = Field(default='', description='Suffix for rendering with each output grid parameter.')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.dx","title":"dx  <code>property</code>","text":"<pre><code>dx\n</code></pre> <p>Grid spacing in x-direction.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.dy","title":"dy  <code>property</code>","text":"<pre><code>dy\n</code></pre> <p>Grid spacing in y-direction.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"xp{self.suffix}={self.xp}\"\n    repr += f\" yp{self.suffix}={self.yp}\"\n    repr += f\" alp{self.suffix}={self.alp}\"\n    repr += f\" xlen{self.suffix}={self.xlen}\"\n    repr += f\" ylen{self.suffix}={self.ylen}\"\n    repr += f\" mx{self.suffix}={self.mx}\"\n    repr += f\" my{self.suffix}={self.my}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD","title":"READCOORD","text":"<p>               Bases: <code>READGRID</code></p> <p>SWAN coordinates reader.</p> <p>.. code-block:: text</p> <pre><code>READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n    FREE|FORMAT ('form'|idfm)\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import READCOORD\nreadcoord = READCOORD(\n    fac=1.0,\n    fname=\"coords.txt\",\n    idla=3,\n    format=\"free\",\n)\nprint(readcoord.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>class READCOORD(READGRID):\n    \"\"\"SWAN coordinates reader.\n\n    .. code-block:: text\n\n        READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n            FREE|FORMAT ('form'|idfm)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import READCOORD\n        readcoord = READCOORD(\n            fac=1.0,\n            fname=\"coords.txt\",\n            idla=3,\n            format=\"free\",\n        )\n        print(readcoord.render())\n\n    \"\"\"\n\n    model_type: Literal[\"readcoord\", \"READCOORD\"] = Field(\n        default=\"readcoord\", description=\"Model type discriminator\"\n    )\n    grid_type: Literal[\"coordinates\"] = Field(\n        default=\"coordinates\", description=\"Type of the SWAN grid file\"\n    )\n    fname: str = Field(description=\"Name of the SWAN coordinates file\")\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"READGRID COORDINATES fac={self.fac} fname='{self.fname}' \"\n            f\"idla={self.idla} nhedf={self.nhedf} nhedvec={self.nhedvec} \"\n            f\"{self.format_repr}\"\n        )\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['readcoord', 'READCOORD'] = Field(default='readcoord', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['coordinates'] = Field(default='coordinates', description='Type of the SWAN grid file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the SWAN coordinates file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"READGRID COORDINATES fac={self.fac} fname='{self.fname}' \"\n        f\"idla={self.idla} nhedf={self.nhedf} nhedvec={self.nhedvec} \"\n        f\"{self.format_repr}\"\n    )\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP","title":"READINP","text":"<p>               Bases: <code>READGRID</code></p> <p>SWAN input grid reader.</p> <p>.. code-block:: text</p> <pre><code>READINP GRID_TYPE [fac] ('fname1' | SERIES 'fname2') [idla] [nhedf] &amp;\n    ([nhedt]) [nhedvec] FREE|FORMAT ('form'|idfm)|UNFORMATTED`\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import READINP\nreadinp = READINP(\n    grid_type=\"wind\",\n    fname1=\"wind.txt\",\n    fac=1.0,\n    idla=3,\n    format=\"free\",\n)\nprint(readinp.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>class READINP(READGRID):\n    \"\"\"SWAN input grid reader.\n\n    .. code-block:: text\n\n        READINP GRID_TYPE [fac] ('fname1' | SERIES 'fname2') [idla] [nhedf] &amp;\n            ([nhedt]) [nhedvec] FREE|FORMAT ('form'|idfm)|UNFORMATTED`\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import READINP\n        readinp = READINP(\n            grid_type=\"wind\",\n            fname1=\"wind.txt\",\n            fac=1.0,\n            idla=3,\n            format=\"free\",\n        )\n        print(readinp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"readinp\", \"READINP\"] = Field(\n        default=\"readinp\", description=\"Model type discriminator\"\n    )\n    grid_type: Optional[GridOptions] = Field(\n        default=None, description=\"Type of the SWAN grid file\"\n    )\n    fname1: str = Field(\n        description=\"Name of the file with the values of the variable.\",\n    )\n    fname2: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of file that contains the names of the files where the variables \"\n            \"are given when the SERIES option is used. These names are to be given in \"\n            \"proper time sequence. SWAN reads the next file when the previous file \"\n            \"end has been encountered. In these files the input should be given in \"\n            \"the same format as in the above file 'fname1' (that implies that a file \"\n            \"should start with the start of an input time step)\"\n        ),\n    )\n    nhedt: int = Field(\n        default=0,\n        description=(\n            \"Only if variable is time dependent: number of header lines in the file \"\n            \"at the start of each time level. A time step may start with more header \"\n            \"lines than `nhedt` because the variable may be a vector variable which \"\n            \"has its own header lines (see `nhedvec`)\"\n        ),\n        ge=0,\n    )\n\n    @field_validator(\"grid_type\")\n    @classmethod\n    def set_undefined(cls, v: str | None) -&gt; str:\n        \"\"\"Allow for undefined value so it can be redefined in INPGRID components.\"\"\"\n        if v is None:\n            return \"undefined\"\n        return v\n\n    def cmd(self) -&gt; str:\n        repr = f\"READINP {self.grid_type.upper()} fac={self.fac} fname1='{self.fname1}'\"\n        if self.fname2:\n            repr += f\" SERIES fname2='{self.fname2}'\"\n        repr += f\" idla={self.idla} nhedf={self.nhedf} nhedt={self.nhedt} nhedvec={self.nhedvec} {self.format_repr}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['readinp', 'READINP'] = Field(default='readinp', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Optional[GridOptions] = Field(default=None, description='Type of the SWAN grid file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.fname1","title":"fname1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname1: str = Field(description='Name of the file with the values of the variable.')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.fname2","title":"fname2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname2: Optional[str] = Field(default=None, description=\"Name of file that contains the names of the files where the variables are given when the SERIES option is used. These names are to be given in proper time sequence. SWAN reads the next file when the previous file end has been encountered. In these files the input should be given in the same format as in the above file 'fname1' (that implies that a file should start with the start of an input time step)\")\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.nhedt","title":"nhedt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nhedt: int = Field(default=0, description='Only if variable is time dependent: number of header lines in the file at the start of each time level. A time step may start with more header lines than `nhedt` because the variable may be a vector variable which has its own header lines (see `nhedvec`)', ge=0)\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.set_undefined","title":"set_undefined  <code>classmethod</code>","text":"<pre><code>set_undefined(v: str | None) -&gt; str\n</code></pre> <p>Allow for undefined value so it can be redefined in INPGRID components.</p> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>@field_validator(\"grid_type\")\n@classmethod\ndef set_undefined(cls, v: str | None) -&gt; str:\n    \"\"\"Allow for undefined value so it can be redefined in INPGRID components.\"\"\"\n    if v is None:\n        return \"undefined\"\n    return v\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"READINP {self.grid_type.upper()} fac={self.fac} fname1='{self.fname1}'\"\n    if self.fname2:\n        repr += f\" SERIES fname2='{self.fname2}'\"\n    repr += f\" idla={self.idla} nhedf={self.nhedf} nhedt={self.nhedt} nhedvec={self.nhedvec} {self.format_repr}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/","title":"Spectrum","text":"<p>Sub-commands to support spectrum definition</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM","title":"SPECTRUM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>SWAN spectrum specification.</p> <p>.. code-block:: text</p> <pre><code>-&gt;CIRCLE|SECTOR ([dir1] [dir2]) [mdc] [flow] [fhigh] [msc]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM--notes","title":"Notes","text":"<p>Directions in the spectra are defined either as a CIRCLE or as a SECTOR. In the case of a SECTOR, both <code>dir1</code> and <code>dir2</code> must be specified. In the case of a CIRCLE, neither <code>dir1</code> nor <code>dir2</code> should be specified.</p> <p>At least two of <code>flow</code>, <code>fhigh</code> and <code>msc</code> must be specified in which case the third parameter will be calculated by SWAN such that the frequency resolution <code>df/f = 0.1</code> (10% increments).</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import SPECTRUM\nspec = SPECTRUM(mdc=36, flow=0.04, fhigh=1.0)\nprint(spec.render())\nspec = SPECTRUM(mdc=36, dir1=0, dir2=180, flow=0.04, msc=31)\nprint(spec.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class SPECTRUM(BaseSubComponent):\n    \"\"\"SWAN spectrum specification.\n\n    .. code-block:: text\n\n        -&gt;CIRCLE|SECTOR ([dir1] [dir2]) [mdc] [flow] [fhigh] [msc]\n\n    Notes\n    -----\n\n    Directions in the spectra are defined either as a CIRCLE or as a SECTOR. In the\n    case of a SECTOR, both `dir1` and `dir2` must be specified. In the case of a\n    CIRCLE, neither `dir1` nor `dir2` should be specified.\n\n    At least two of `flow`, `fhigh` and `msc` must be specified in which case the\n    third parameter will be calculated by SWAN such that the frequency resolution\n    `df/f = 0.1` (10% increments).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import SPECTRUM\n        spec = SPECTRUM(mdc=36, flow=0.04, fhigh=1.0)\n        print(spec.render())\n        spec = SPECTRUM(mdc=36, dir1=0, dir2=180, flow=0.04, msc=31)\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spectrum\", \"SPECTRUM\"] = Field(\n        default=\"spectrum\", description=\"Model type discriminator\"\n    )\n    mdc: int = Field(\n        description=(\n            \"Number of meshes in theta-space. In the case of CIRCLE, this is the \"\n            \"number of subdivisions of the 360 degrees of a circle so \"\n            \"`dtheta = [360]/[mdc]` is the spectral directional resolution. In the \"\n            \"case of SECTOR, `dtheta = ([dir2] - [dir1])/[mdc]`. The minimum number \"\n            \"of directional bins is 3 per directional quadrant.\"\n        )\n    )\n    flow: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Lowest discrete frequency that is used in the calculation (in Hz).\"\n        ),\n    )\n    fhigh: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Highest discrete frequency that is used in the calculation (in Hz).\"\n        ),\n    )\n    msc: Optional[int] = Field(\n        default=None,\n        description=(\n            \"One less than the number of frequencies. This defines the grid \"\n            \"resolution in frequency-space between the lowest discrete frequency \"\n            \"`flow` and the highest discrete frequency `fhigh`. This resolution is \"\n            \"not constant, since the frequencies are distributed logarithmical: \"\n            \"`fi+1 = yfi` where `y` is a constant. The minimum number of frequencies \"\n            \"is 4\"\n        ),\n        ge=3,\n    )\n    dir1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The direction of the right-hand boundary of the sector when looking \"\n            \"outward from the sector (required for option SECTOR) in degrees.\"\n        ),\n    )\n    dir2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The direction of the left-hand boundary of the sector when looking \"\n            \"outward from the sector (required for option SECTOR) in degrees.\"\n        ),\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_direction_definition(cls, data: Any) -&gt; Any:\n        \"\"\"Check that dir1 and dir2 are specified together.\"\"\"\n        dir1 = data.get(\"dir1\")\n        dir2 = data.get(\"dir2\")\n        if None in [dir1, dir2] and dir1 != dir2:\n            raise ValueError(\"dir1 and dir2 must be specified together\")\n        return data\n\n    @model_validator(mode=\"after\")\n    def check_frequency_definition(self) -&gt; \"SPECTRUM\":\n        \"\"\"Check spectral frequencies are prescribed correctly.\"\"\"\n        args = [self.flow, self.fhigh, self.msc]\n        if None in args:\n            args = [arg for arg in args if arg is not None]\n            if len(args) != 2:\n                raise ValueError(\"You must specify at least 2 of [flow, fhigh, msc]\")\n        if self.flow is not None and self.fhigh is not None and self.flow &gt;= self.fhigh:\n            raise ValueError(\"flow must be less than fhigh\")\n        return self\n\n    @property\n    def dir_sector(self):\n        if self.dir1 is None and self.dir2 is None:\n            return \"CIRCLE\"\n        else:\n            return f\"SECTOR {self.dir1} {self.dir2}\"\n\n    def cmd(self) -&gt; str:\n        repr = f\"{self.dir_sector} mdc={self.mdc}\"\n        if self.flow is not None:\n            repr += f\" flow={self.flow}\"\n        if self.fhigh is not None:\n            repr += f\" fhigh={self.fhigh}\"\n        if self.msc is not None:\n            repr += f\" msc={self.msc}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spectrum', 'SPECTRUM'] = Field(default='spectrum', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.mdc","title":"mdc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mdc: int = Field(description='Number of meshes in theta-space. In the case of CIRCLE, this is the number of subdivisions of the 360 degrees of a circle so `dtheta = [360]/[mdc]` is the spectral directional resolution. In the case of SECTOR, `dtheta = ([dir2] - [dir1])/[mdc]`. The minimum number of directional bins is 3 per directional quadrant.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.flow","title":"flow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flow: Optional[float] = Field(default=None, description='Lowest discrete frequency that is used in the calculation (in Hz).')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.fhigh","title":"fhigh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fhigh: Optional[float] = Field(default=None, description='Highest discrete frequency that is used in the calculation (in Hz).')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.msc","title":"msc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>msc: Optional[int] = Field(default=None, description='One less than the number of frequencies. This defines the grid resolution in frequency-space between the lowest discrete frequency `flow` and the highest discrete frequency `fhigh`. This resolution is not constant, since the frequencies are distributed logarithmical: `fi+1 = yfi` where `y` is a constant. The minimum number of frequencies is 4', ge=3)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir1","title":"dir1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir1: Optional[float] = Field(default=None, description='The direction of the right-hand boundary of the sector when looking outward from the sector (required for option SECTOR) in degrees.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir2","title":"dir2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir2: Optional[float] = Field(default=None, description='The direction of the left-hand boundary of the sector when looking outward from the sector (required for option SECTOR) in degrees.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir_sector","title":"dir_sector  <code>property</code>","text":"<pre><code>dir_sector\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.check_direction_definition","title":"check_direction_definition  <code>classmethod</code>","text":"<pre><code>check_direction_definition(data: Any) -&gt; Any\n</code></pre> <p>Check that dir1 and dir2 are specified together.</p> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef check_direction_definition(cls, data: Any) -&gt; Any:\n    \"\"\"Check that dir1 and dir2 are specified together.\"\"\"\n    dir1 = data.get(\"dir1\")\n    dir2 = data.get(\"dir2\")\n    if None in [dir1, dir2] and dir1 != dir2:\n        raise ValueError(\"dir1 and dir2 must be specified together\")\n    return data\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.check_frequency_definition","title":"check_frequency_definition","text":"<pre><code>check_frequency_definition() -&gt; SPECTRUM\n</code></pre> <p>Check spectral frequencies are prescribed correctly.</p> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_frequency_definition(self) -&gt; \"SPECTRUM\":\n    \"\"\"Check spectral frequencies are prescribed correctly.\"\"\"\n    args = [self.flow, self.fhigh, self.msc]\n    if None in args:\n        args = [arg for arg in args if arg is not None]\n        if len(args) != 2:\n            raise ValueError(\"You must specify at least 2 of [flow, fhigh, msc]\")\n    if self.flow is not None and self.fhigh is not None and self.flow &gt;= self.fhigh:\n        raise ValueError(\"flow must be less than fhigh\")\n    return self\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"{self.dir_sector} mdc={self.mdc}\"\n    if self.flow is not None:\n        repr += f\" flow={self.flow}\"\n    if self.fhigh is not None:\n        repr += f\" fhigh={self.fhigh}\"\n    if self.msc is not None:\n        repr += f\" msc={self.msc}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC","title":"SHAPESPEC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spectral shape specification.</p> <p>.. code-block:: text</p> <pre><code>BOUND SHAPESPEC JONSWAP|PM|GAUSS|BIN|TMA PEAK|MEAN DSPR [POWER|DEGREES]\n</code></pre> <p>This command BOUND SHAPESPEC defines the shape of the spectra (both in frequency and direction) at the boundary of the computational grid in case of parametric spectral input.</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC--notes","title":"Notes","text":"<p>While technically a component <code>BOUND SHAPESPEC</code>, this is only intended to be used as a subcomponent of the <code>BOUNDSPEC</code> component.</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import SHAPESPEC\nshapespec = SHAPESPEC()\nprint(shapespec.render())\nshapespec = SHAPESPEC(\n    shape=dict(model_type=\"tma\", gamma=3.1, d=12),\n    per_type=\"mean\",\n    dspr_type=\"degrees\",\n)\nprint(shapespec.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class SHAPESPEC(BaseSubComponent):\n    \"\"\"Spectral shape specification.\n\n    .. code-block:: text\n\n        BOUND SHAPESPEC JONSWAP|PM|GAUSS|BIN|TMA PEAK|MEAN DSPR [POWER|DEGREES]\n\n    This command BOUND SHAPESPEC defines the shape of the spectra (both in frequency\n    and direction) at the boundary of the computational grid in case of parametric\n    spectral input.\n\n    Notes\n    -----\n    While technically a component `BOUND SHAPESPEC`, this is only intended to be used\n    as a subcomponent of the `BOUNDSPEC` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import SHAPESPEC\n        shapespec = SHAPESPEC()\n        print(shapespec.render())\n        shapespec = SHAPESPEC(\n            shape=dict(model_type=\"tma\", gamma=3.1, d=12),\n            per_type=\"mean\",\n            dspr_type=\"degrees\",\n        )\n        print(shapespec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"shapespec\", \"SHAPESPEC\"] = Field(\n        default=\"shapespec\", description=\"Model type discriminator\"\n    )\n    shape: JONSWAP | PM | GAUSS | BIN | TMA = Field(\n        default_factory=JONSWAP,\n        description=\"The spectral shape\",\n    )\n    per_type: Literal[\"peak\", \"mean\"] = Field(\n        default=\"peak\",\n        description=\"The type of characteristic wave period\",\n    )\n    dspr_type: Literal[\"power\", \"degrees\"] = Field(\n        default=\"power\",\n        description=\"The type of directional spreading\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"BOUND SHAPESPEC {self.shape.render()} {self.per_type.upper()} \"\n            f\"DSPR {self.dspr_type.upper()}\"\n        )\n        return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['shapespec', 'SHAPESPEC'] = Field(default='shapespec', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.shape","title":"shape  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shape: JONSWAP | PM | GAUSS | BIN | TMA = Field(default_factory=JONSWAP, description='The spectral shape')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.per_type","title":"per_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per_type: Literal['peak', 'mean'] = Field(default='peak', description='The type of characteristic wave period')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.dspr_type","title":"dspr_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dspr_type: Literal['power', 'degrees'] = Field(default='power', description='The type of directional spreading')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"BOUND SHAPESPEC {self.shape.render()} {self.per_type.upper()} \"\n        f\"DSPR {self.dspr_type.upper()}\"\n    )\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP","title":"JONSWAP","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Jonswap spectral shape.</p> <p>.. code-block:: text</p> <pre><code>JONSWAP [gamma]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import JONSWAP\nshape = JONSWAP(gamma=3.3)\nprint(shape.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class JONSWAP(BaseSubComponent):\n    \"\"\"Jonswap spectral shape.\n\n    .. code-block:: text\n\n        JONSWAP [gamma]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import JONSWAP\n        shape = JONSWAP(gamma=3.3)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"jonswap\", \"JONSWAP\"] = Field(\n        default=\"jonswap\", description=\"Model type discriminator\"\n    )\n    gamma: float = Field(\n        default=3.3,\n        description=\"Peak enhancement parameter of the JONSWAP spectrum.\",\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} gamma={self.gamma}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['jonswap', 'JONSWAP'] = Field(default='jonswap', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.gamma","title":"gamma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma: float = Field(default=3.3, description='Peak enhancement parameter of the JONSWAP spectrum.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} gamma={self.gamma}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA","title":"TMA","text":"<p>               Bases: <code>JONSWAP</code></p> <p>TMA spectral shape.</p> <p>.. code-block:: text</p> <pre><code>TMA [gamma] [d]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import TMA\nshape = TMA(gamma=2.0, d=18)\nprint(shape.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class TMA(JONSWAP):\n    \"\"\"TMA spectral shape.\n\n    .. code-block:: text\n\n        TMA [gamma] [d]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import TMA\n        shape = TMA(gamma=2.0, d=18)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"tma\", \"TMA\"] = Field(\n        default=\"tma\", description=\"Model type discriminator\"\n    )\n    d: float = Field(\n        description=\"The reference depth at the wave maker in meters.\",\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} d={self.d}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['tma', 'TMA'] = Field(default='tma', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.d","title":"d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>d: float = Field(description='The reference depth at the wave maker in meters.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} d={self.d}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS","title":"GAUSS","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Gaussian spectral shape.</p> <p>.. code-block:: text</p> <pre><code>GAUSS [sigfr]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import GAUSS\nshape = GAUSS(sigfr=0.02)\nprint(shape.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class GAUSS(BaseSubComponent):\n    \"\"\"Gaussian spectral shape.\n\n    .. code-block:: text\n\n        GAUSS [sigfr]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import GAUSS\n        shape = GAUSS(sigfr=0.02)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gauss\", \"GAUSS\"] = Field(\n        default=\"gauss\", description=\"Model type discriminator\"\n    )\n    sigfr: float = Field(\n        description=(\n            \"Width of the Gaussian frequency spectrum expressed \"\n            \"as a standard deviation in Hz.\"\n        ),\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} sigfr={self.sigfr}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gauss', 'GAUSS'] = Field(default='gauss', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.sigfr","title":"sigfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigfr: float = Field(description='Width of the Gaussian frequency spectrum expressed as a standard deviation in Hz.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} sigfr={self.sigfr}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM","title":"PM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Pearson-Moskowitz spectral shape.</p> <p>.. code-block:: text</p> <pre><code>PM\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import PM\nshape = PM()\nprint(shape.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class PM(BaseSubComponent):\n    \"\"\"Pearson-Moskowitz spectral shape.\n\n    .. code-block:: text\n\n        PM\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import PM\n        shape = PM()\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"pm\", \"PM\"] = Field(\n        default=\"pm\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['pm', 'PM'] = Field(default='pm', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN","title":"BIN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Single frequency bin spectral shape.</p> <p>.. code-block:: text</p> <pre><code>BIN\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import BIN\nshape = BIN()\nprint(shape.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/spectrum.py</code> <pre><code>class BIN(BaseSubComponent):\n    \"\"\"Single frequency bin spectral shape.\n\n    .. code-block:: text\n\n        BIN\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import BIN\n        shape = BIN()\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bin\", \"BIN\"] = Field(\n        default=\"bin\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bin', 'BIN'] = Field(default='bin', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/","title":"Startup","text":"<p>Sub-commands to support the startup components</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN","title":"CARTESIAN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Cartesian coordinates.</p> <p>.. code-block:: text</p> <pre><code>CARTESIAN\n</code></pre> <p>All locations and distances are in m. Coordinates are given with respect to x- and y-axes chosen by the user in the various commands.</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import CARTESIAN\ncoords = CARTESIAN()\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>class CARTESIAN(BaseSubComponent):\n    \"\"\"Cartesian coordinates.\n\n    .. code-block:: text\n\n        CARTESIAN\n\n    All locations and distances are in m. Coordinates are given with respect\n    to x- and y-axes chosen by the user in the various commands.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import CARTESIAN\n        coords = CARTESIAN()\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"cartesian\", \"CARTESIAN\"] = Field(\n        default=\"cartesian\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN-attributes","title":"Attributes","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['cartesian', 'CARTESIAN'] = Field(default='cartesian', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL","title":"SPHERICAL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spherical coordinates.</p> <p>.. code-block:: text</p> <pre><code>SPHERICAL [-&gt;CCM|QC]\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL--notes","title":"Notes","text":"<p>projection options:</p> <ul> <li>CCM: central conformal Mercator. The horizontal and vertical scales are   uniform in terms of cm/degree over the area shown. In the centre of the scale   is identical to that of the conventional Mercator projection (but only at   that centre). The area in the projection centre is therefore exactly conformal.</li> <li>QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical   scales are equal to one another in terms of cm/degree.</li> </ul> <p>All coordinates of locations and geographical grid sizes are given in degrees;<code>x</code> is longitude with <code>x = 0</code> being the Greenwich meridian and <code>x &gt; 0</code> is East of this meridian; <code>y</code> is latitude with <code>y &gt; 0</code> being the Northern hemisphere. Input and output grids have to be oriented with their x-axis to the East; mesh sizes are in degrees. All other distances are in meters.</p> <p>Note that spherical coordinates can also be used for relatively small areas, say 10 or 20 km horizontal dimension. This may be useful if one obtains the boundary conditions by nesting in an oceanic model which is naturally formulated in spherical coordinates. Note that in case of spherical coordinates regular grids must always be oriented E-W, N-S, i.e. <code>alpc=0</code>, <code>alpinp=0</code>, <code>alpfr=0</code> (see commands CGRID, INPUT GRID and FRAME, respectively).</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SPHERICAL\ncoords = SPHERICAL()\nprint(coords.render())\ncoords = SPHERICAL(projection=\"qc\")\nprint(coords.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>class SPHERICAL(BaseSubComponent):\n    \"\"\"Spherical coordinates.\n\n    .. code-block:: text\n\n        SPHERICAL [-&gt;CCM|QC]\n\n    Notes\n    -----\n\n    projection options:\n\n    * CCM: central conformal Mercator. The horizontal and vertical scales are\n      uniform in terms of cm/degree over the area shown. In the centre of the scale\n      is identical to that of the conventional Mercator projection (but only at\n      that centre). The area in the projection centre is therefore exactly conformal.\n    * QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical\n      scales are equal to one another in terms of cm/degree.\n\n    All coordinates of locations and geographical grid sizes are given in degrees;`x`\n    is longitude with `x = 0` being the Greenwich meridian and `x &gt; 0` is East of this\n    meridian; `y` is latitude with `y &gt; 0` being the Northern hemisphere. Input and\n    output grids have to be oriented with their x-axis to the East; mesh sizes are in\n    degrees. All other distances are in meters.\n\n    Note that spherical coordinates can also be used for relatively small areas, say 10\n    or 20 km horizontal dimension. This may be useful if one obtains the boundary\n    conditions by nesting in an oceanic model which is naturally formulated in\n    spherical coordinates. Note that in case of spherical coordinates regular grids\n    must always be oriented E-W, N-S, i.e. `alpc=0`, `alpinp=0`, `alpfr=0`\n    (see commands CGRID, INPUT GRID and FRAME, respectively).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SPHERICAL\n        coords = SPHERICAL()\n        print(coords.render())\n        coords = SPHERICAL(projection=\"qc\")\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spherical\", \"SPHERICAL\"] = Field(\n        default=\"spherical\", description=\"Model type discriminator\"\n    )\n    projection: Literal[\"ccm\", \"qc\"] = Field(\n        default=\"ccm\",\n        description=(\n            \"Defines the projection method in case of spherical coordinates, `ccm` \"\n            \"Central Conformal Mercator, `qc` means Quasi-cartesian\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        if self.projection is not None:\n            repr += f\" {self.projection.upper()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL-attributes","title":"Attributes","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spherical', 'SPHERICAL'] = Field(default='spherical', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.projection","title":"projection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projection: Literal['ccm', 'qc'] = Field(default='ccm', description='Defines the projection method in case of spherical coordinates, `ccm` Central Conformal Mercator, `qc` means Quasi-cartesian')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL-functions","title":"Functions","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    if self.projection is not None:\n        repr += f\" {self.projection.upper()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/","title":"Time","text":"<p>Sub-commands to support time definition</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time","title":"Time","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Time specification in SWAN.</p> <p>.. code-block:: text</p> <pre><code>[time]\n</code></pre> <p>Time is rendered in one of the following formats:</p> <ul> <li>1: ISO-notation 19870530.153000</li> <li>2: (as in HP compiler) '30-May-87 15:30:00'</li> <li>3: (as in Lahey compiler) 05/30/87.15:30:00</li> <li>4: 15:30:00</li> <li>5: 87/05/30 15:30:00'</li> <li>6: as in WAM 8705301530</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time--note","title":"Note","text":"<p>The <code>time</code> field can be specified as:</p> <ul> <li>existing datetime object</li> <li>int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or   milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.</li> <li>ISO 8601 time string.</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import Time\nfrom datetime import datetime\ntime = Time(time=datetime(1990, 1, 1))\nprint(time.render())\ntime = Time(time=\"2012-01-01T00:00:00\", tfmt=2)\nprint(time.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class Time(BaseSubComponent):\n    \"\"\"Time specification in SWAN.\n\n    .. code-block:: text\n\n        [time]\n\n    Time is rendered in one of the following formats:\n\n    * 1: ISO-notation 19870530.153000\n    * 2: (as in HP compiler) '30-May-87 15:30:00'\n    * 3: (as in Lahey compiler) 05/30/87.15:30:00\n    * 4: 15:30:00\n    * 5: 87/05/30 15:30:00'\n    * 6: as in WAM 8705301530\n\n    Note\n    ----\n    The `time` field can be specified as:\n\n    * existing datetime object\n    * int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or\n      milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.\n    * ISO 8601 time string.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import Time\n        from datetime import datetime\n        time = Time(time=datetime(1990, 1, 1))\n        print(time.render())\n        time = Time(time=\"2012-01-01T00:00:00\", tfmt=2)\n        print(time.render())\n\n    \"\"\"\n\n    model_type: Literal[\"time\", \"Time\", \"TIME\"] = Field(\n        default=\"time\", description=\"Model type discriminator\"\n    )\n    time: datetime = Field(description=\"Datetime specification\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n        validate_default=True,\n    )\n\n    @field_validator(\"tfmt\")\n    @classmethod\n    def set_time_format(cls, v: int | str) -&gt; str:\n        \"\"\"Set the time format to render.\"\"\"\n        if isinstance(v, str):\n            return v\n        return TIME_FORMAT[v]\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"{self.time.strftime(self.tfmt)}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['time', 'Time', 'TIME'] = Field(default='time', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: datetime = Field(description='Datetime specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification', validate_default=True)\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.set_time_format","title":"set_time_format  <code>classmethod</code>","text":"<pre><code>set_time_format(v: int | str) -&gt; str\n</code></pre> <p>Set the time format to render.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>@field_validator(\"tfmt\")\n@classmethod\ndef set_time_format(cls, v: int | str) -&gt; str:\n    \"\"\"Set the time format to render.\"\"\"\n    if isinstance(v, str):\n        return v\n    return TIME_FORMAT[v]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"{self.time.strftime(self.tfmt)}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt","title":"Delt","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Time interval specification in SWAN.</p> <p>.. code-block:: text</p> <pre><code>[delt] SEC|MIN|HR|DAY\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt--note","title":"Note","text":"<p>The <code>tdelta</code> field can be specified as:</p> <ul> <li>existing timedelta object</li> <li>int or float, assumed as seconds</li> <li> <p>ISO 8601 duration string, following formats work:</p> </li> <li> <p><code>[-][DD ][HH:MM]SS[.ffffff]</code></p> </li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 format for timedelta)</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import Delt\nfrom datetime import timedelta\ndelt = Delt(delt=timedelta(minutes=30))\nprint(delt.render())\ndelt = Delt(delt=\"PT1H\", dfmt=\"hr\")\nprint(delt.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class Delt(BaseSubComponent):\n    \"\"\"Time interval specification in SWAN.\n\n    .. code-block:: text\n\n        [delt] SEC|MIN|HR|DAY\n\n    Note\n    ----\n    The `tdelta` field can be specified as:\n\n    * existing timedelta object\n    * int or float, assumed as seconds\n    * ISO 8601 duration string, following formats work:\n\n      * `[-][DD ][HH:MM]SS[.ffffff]`\n      * `[\u00b1]P[DD]DT[HH]H[MM]M[SS]S` (ISO 8601 format for timedelta)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import Delt\n        from datetime import timedelta\n        delt = Delt(delt=timedelta(minutes=30))\n        print(delt.render())\n        delt = Delt(delt=\"PT1H\", dfmt=\"hr\")\n        print(delt.render())\n\n    \"\"\"\n\n    model_type: Literal[\"delt\"] = Field(\n        default=\"delt\", description=\"Model type discriminator\"\n    )\n    delt: timedelta = Field(description=\"Time interval\")\n    dfmt: Literal[\"sec\", \"min\", \"hr\", \"day\"] = Field(\n        default=\"sec\",\n        description=\"Format to render time interval specification\",\n    )\n\n    @property\n    def delt_float(self):\n        delt_scaling = {\"sec\": 1, \"min\": 60, \"hr\": 3600, \"day\": 86400}\n        return self.delt.total_seconds() / delt_scaling[self.dfmt]\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"{self.delt_float} {self.dfmt.upper()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['delt'] = Field(default='delt', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.dfmt","title":"dfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dfmt: Literal['sec', 'min', 'hr', 'day'] = Field(default='sec', description='Format to render time interval specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.delt_float","title":"delt_float  <code>property</code>","text":"<pre><code>delt_float\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"{self.delt_float} {self.dfmt.upper()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen","title":"TimeRangeOpen","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Regular times with an open boundary.</p> <p>.. code-block:: text</p> <pre><code>[tbeg] [delt] SEC|MIN|HR|DAY\n</code></pre> <p>Time is rendered in one of the following formats:</p> <ul> <li>1: ISO-notation 19870530.153000</li> <li>2: (as in HP compiler) '30-May-87 15:30:00'</li> <li>3: (as in Lahey compiler) 05/30/87.15:30:00</li> <li>4: 15:30:00</li> <li>5: 87/05/30 15:30:00'</li> <li>6: as in WAM 8705301530</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note","title":"Note","text":"<p>The <code>tbeg</code> field can be specified as:</p> <ul> <li>existing datetime object</li> <li>int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or   milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.</li> <li>ISO 8601 time string.</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note_1","title":"Note","text":"<p>The <code>tdelta</code> field can be specified as:</p> <ul> <li>existing timedelta object</li> <li>int or float, assumed as seconds</li> <li> <p>ISO 8601 duration string, following formats work:</p> <ul> <li><code>[-][DD ][HH:MM]SS[.ffffff]</code></li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 format for timedelta)</li> </ul> </li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note_2","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import TimeRangeOpen\nfrom datetime import datetime, timedelta\ntimes = TimeRangeOpen(\n    tbeg=datetime(1990, 1, 1), delt=timedelta(minutes=30), dfmt=\"min\"\n)\nprint(times.render())\ntimes = TimeRangeOpen(\n    tbeg=\"2012-01-01T00:00:00\", delt=\"PT1H\", tfmt=2, dfmt=\"hr\", suffix=\"blk\"\n)\nprint(times.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class TimeRangeOpen(BaseSubComponent):\n    \"\"\"Regular times with an open boundary.\n\n    .. code-block:: text\n\n        [tbeg] [delt] SEC|MIN|HR|DAY\n\n    Time is rendered in one of the following formats:\n\n    * 1: ISO-notation 19870530.153000\n    * 2: (as in HP compiler) '30-May-87 15:30:00'\n    * 3: (as in Lahey compiler) 05/30/87.15:30:00\n    * 4: 15:30:00\n    * 5: 87/05/30 15:30:00'\n    * 6: as in WAM 8705301530\n\n    Note\n    ----\n    The `tbeg` field can be specified as:\n\n    * existing datetime object\n    * int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or\n      milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.\n    * ISO 8601 time string.\n\n    Note\n    ----\n    The `tdelta` field can be specified as:\n\n    * existing timedelta object\n    * int or float, assumed as seconds\n    * ISO 8601 duration string, following formats work:\n\n        * `[-][DD ][HH:MM]SS[.ffffff]`\n        * `[\u00b1]P[DD]DT[HH]H[MM]M[SS]S` (ISO 8601 format for timedelta)\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import TimeRangeOpen\n        from datetime import datetime, timedelta\n        times = TimeRangeOpen(\n            tbeg=datetime(1990, 1, 1), delt=timedelta(minutes=30), dfmt=\"min\"\n        )\n        print(times.render())\n        times = TimeRangeOpen(\n            tbeg=\"2012-01-01T00:00:00\", delt=\"PT1H\", tfmt=2, dfmt=\"hr\", suffix=\"blk\"\n        )\n        print(times.render())\n\n    \"\"\"\n\n    model_type: Literal[\"open\", \"OPEN\"] = Field(\n        default=\"open\", description=\"Model type discriminator\"\n    )\n    tbeg: datetime = Field(default=DEFAULT_TIME, description=\"Start time\")\n    delt: timedelta = Field(default=DEFAULT_DELT, description=\"Time interval\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n    )\n    dfmt: Literal[\"sec\", \"min\", \"hr\", \"day\"] = Field(\n        default=\"sec\",\n        description=\"Format to render time interval specification\",\n    )\n    suffix: str = Field(\n        default=\"\",\n        description=\"Suffix to prepend to argument names when rendering\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"tbeg{self.suffix}={Time(time=self.tbeg, tfmt=self.tfmt).render()}\"\n        repr += f\" delt{self.suffix}={Delt(delt=self.delt, dfmt=self.dfmt).render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['open', 'OPEN'] = Field(default='open', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.tbeg","title":"tbeg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbeg: datetime = Field(default=DEFAULT_TIME, description='Start time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(default=DEFAULT_DELT, description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.dfmt","title":"dfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dfmt: Literal['sec', 'min', 'hr', 'day'] = Field(default='sec', description='Format to render time interval specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: str = Field(default='', description='Suffix to prepend to argument names when rendering')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"tbeg{self.suffix}={Time(time=self.tbeg, tfmt=self.tfmt).render()}\"\n    repr += f\" delt{self.suffix}={Delt(delt=self.delt, dfmt=self.dfmt).render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed","title":"TimeRangeClosed","text":"<p>               Bases: <code>TimeRangeOpen</code></p> <p>Regular times with a closed boundary.</p> <p>.. code-block:: text</p> <pre><code>[tbeg] [delt] SEC|MIN|HR|DAY [tend]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed--note","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import TimeRangeClosed\nfrom datetime import datetime, timedelta\ntimes = TimeRangeClosed(\n    tbeg=datetime(1990, 1, 1),\n    tend=datetime(1990, 1, 7),\n    delt=timedelta(minutes=30),\n    dfmt=\"min\",\n)\nprint(times.render())\ntimes = TimeRangeClosed(\n    tbeg=\"2012-01-01T00:00:00\",\n    tend=\"2012-02-01T00:00:00\",\n    delt=\"PT1H\",\n    tfmt=2,\n    dfmt=\"hr\",\n    suffix=\"blk\",\n)\nprint(times.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class TimeRangeClosed(TimeRangeOpen):\n    \"\"\"Regular times with a closed boundary.\n\n    .. code-block:: text\n\n        [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import TimeRangeClosed\n        from datetime import datetime, timedelta\n        times = TimeRangeClosed(\n            tbeg=datetime(1990, 1, 1),\n            tend=datetime(1990, 1, 7),\n            delt=timedelta(minutes=30),\n            dfmt=\"min\",\n        )\n        print(times.render())\n        times = TimeRangeClosed(\n            tbeg=\"2012-01-01T00:00:00\",\n            tend=\"2012-02-01T00:00:00\",\n            delt=\"PT1H\",\n            tfmt=2,\n            dfmt=\"hr\",\n            suffix=\"blk\",\n        )\n        print(times.render())\n\n    \"\"\"\n\n    model_type: Literal[\"closed\", \"CLOSED\"] = Field(\n        default=\"closed\", description=\"Model type discriminator\"\n    )\n    tend: datetime = Field(default=DEFAULT_TEND, description=\"End time\")\n\n    def __call__(self) -&gt; list[Time]:\n        \"\"\"Returns the list of Time objects.\"\"\"\n        times = pd.date_range(start=self.tbeg, end=self.tend, freq=self.delt)\n        return [time.to_pydatetime() for time in times]\n\n    def __getitem__(self, index) -&gt; datetime | list[datetime]:\n        \"\"\"Slicing from the times array.\"\"\"\n        return self.__call__()[index]\n\n    def __len__(self):\n        \"\"\"Returns the length of the times array.\"\"\"\n        return len(self())\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        repr += f\" tend{self.suffix}={Time(time=self.tend, tfmt=self.tfmt).render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['closed', 'CLOSED'] = Field(default='closed', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.tend","title":"tend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tend: datetime = Field(default=DEFAULT_TEND, description='End time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    repr += f\" tend{self.suffix}={Time(time=self.tend, tfmt=self.tfmt).render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY","title":"NONSTATIONARY","text":"<p>               Bases: <code>TimeRangeClosed</code></p> <p>Nonstationary time specification.</p> <p>.. code-block:: text</p> <pre><code>NONSTATIONARY [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY--note","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import NONSTATIONARY\nnonstat = NONSTATIONARY(\n    tbeg=\"2012-01-01T00:00:00\",\n    tend=\"2012-02-01T00:00:00\",\n    delt=\"PT1H\",\n    dfmt=\"hr\",\n)\nprint(nonstat.render())\nfrom datetime import datetime, timedelta\nnonstat = NONSTATIONARY(\n    tbeg=datetime(1990, 1, 1),\n    tend=datetime(1990, 1, 7),\n    delt=timedelta(minutes=30),\n    tfmt=1,\n    dfmt=\"min\",\n    suffix=\"tbl\",\n)\nprint(nonstat.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class NONSTATIONARY(TimeRangeClosed):\n    \"\"\"Nonstationary time specification.\n\n    .. code-block:: text\n\n        NONSTATIONARY [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import NONSTATIONARY\n        nonstat = NONSTATIONARY(\n            tbeg=\"2012-01-01T00:00:00\",\n            tend=\"2012-02-01T00:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        )\n        print(nonstat.render())\n        from datetime import datetime, timedelta\n        nonstat = NONSTATIONARY(\n            tbeg=datetime(1990, 1, 1),\n            tend=datetime(1990, 1, 7),\n            delt=timedelta(minutes=30),\n            tfmt=1,\n            dfmt=\"min\",\n            suffix=\"tbl\",\n        )\n        print(nonstat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nonstationary\", \"NONSTATIONARY\"] = Field(\n        default=\"nonstationary\", description=\"Model type discriminator\"\n    )\n    tbeg: datetime = Field(default=DEFAULT_TIME, description=\"Start time\")\n    tend: datetime = Field(default=DEFAULT_TEND, description=\"End time\")\n    delt: timedelta = Field(default=DEFAULT_DELT, description=\"Time interval\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"NONSTATIONARY {super().cmd()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstationary', 'NONSTATIONARY'] = Field(default='nonstationary', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.tbeg","title":"tbeg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbeg: datetime = Field(default=DEFAULT_TIME, description='Start time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.tend","title":"tend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tend: datetime = Field(default=DEFAULT_TEND, description='End time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(default=DEFAULT_DELT, description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"NONSTATIONARY {super().cmd()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY","title":"STATIONARY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stationary time specification.</p> <p>.. code-block:: text</p> <pre><code>STATIONARY [time]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY--note","title":"Note","text":"<p>The field <code>time</code> is optional to allow for the case where the user wants to set the time dynamically after instantiating this component.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import STATIONARY\nstat = STATIONARY(time=\"2012-01-01T00:00:00\")\nprint(stat.render())\n</code></pre> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>class STATIONARY(BaseSubComponent):\n    \"\"\"Stationary time specification.\n\n    .. code-block:: text\n\n        STATIONARY [time]\n\n    Note\n    ----\n    The field `time` is optional to allow for the case where the user wants to set the\n    time dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import STATIONARY\n        stat = STATIONARY(time=\"2012-01-01T00:00:00\")\n        print(stat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stationary\", \"STATIONARY\"] = Field(\n        default=\"stationary\", description=\"Model type discriminator\"\n    )\n    time: datetime = Field(default=DEFAULT_TIME, description=\"Stationary time\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n    )\n\n    def __call__(self) -&gt; list[Time]:\n        \"\"\"Returns the list of Time object for consistency with NONSTATIONARY.\"\"\"\n        return [self.time]\n\n    def __getitem__(self, index) -&gt; Time | list[Time]:\n        \"\"\"Slicing from the times array.\"\"\"\n        return self.__call__()[index]\n\n    def __len__(self):\n        \"\"\"Returns the length of the times array.\"\"\"\n        return len(self())\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"STATIONARY time={Time(time=self.time, tfmt=self.tfmt).render()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stationary', 'STATIONARY'] = Field(default='stationary', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: datetime = Field(default=DEFAULT_TIME, description='Stationary time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>src/rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"STATIONARY time={Time(time=self.time, tfmt=self.tfmt).render()}\"\n</code></pre>"},{"location":"user-guide/architecture/","title":"Rompy-SWAN Architecture","text":"<p>This document describes the architecture of rompy-swan, explaining how SWAN commands are organised into Python components and why this structure was chosen.</p>"},{"location":"user-guide/architecture/#design-philosophy","title":"Design Philosophy","text":"<p>Rompy-swan's component structure mirrors the SWAN command file syntax. This design makes the Python interface familiar to existing SWAN users while providing validation and discoverability for new users.</p> <p>SWAN Command Structure</p> <p>SWAN uses a command-based input file where each line specifies a command with keywords and data. Commands must appear in a specific sequence: startup commands first, then model description (grid, input, boundary, physics, numerics), followed by output commands, and finally lock-up commands (COMPUTE, STOP). Rompy-swan enforces this ordering automatically.</p>"},{"location":"user-guide/architecture/#mapping-swan-syntax-to-python","title":"Mapping SWAN Syntax to Python","text":"SWAN Concept Rompy-swan Class Purpose Command (e.g., <code>GEN3</code>, <code>CGRID</code>) Component Represents a complete SWAN command Command options with branches Subcomponent Represents options that branch into different parameter sets Mutually exclusive options Discriminated Union Type-safe selection between alternatives Related command groups Group Component Aggregates related components (e.g., all physics commands) <p>For example, the SWAN <code>BOUNDSPEC</code> command has a <code>SIDE</code> option that accepts different parameters than the <code>SEGMENT</code> option. In rompy-swan, these are separate subcomponent classes, ensuring you only specify parameters valid for your chosen option.</p> <pre><code># SIDE and SEGMENT are different subcomponents with their own parameters\nfrom rompy_swan.subcomponents.boundary import SIDE, SEGMENT\n\n# Using SIDE - only side-specific parameters available\nboundary = BOUNDSPEC(location=SIDE(side=\"west\"), ...)\n\n# Using SEGMENT - only segment-specific parameters available  \nboundary = BOUNDSPEC(location=SEGMENT(ixp=0, iyp=0, ixq=10, iyq=0), ...)\n</code></pre> <p>This approach:</p> <ul> <li>Feels familiar to SWAN users \u2014 the structure matches the command file</li> <li>Prevents errors \u2014 you can't mix incompatible options</li> <li>Enables discovery \u2014 IDE autocomplete shows valid options for each branch</li> </ul>"},{"location":"user-guide/architecture/#the-swanconfig-class","title":"The SwanConfig Class","text":"<p>The <code>SwanConfig</code> class is the main entry point. It orchestrates all SWAN commands and generates the input file.</p> <pre><code>from rompy_swan.config import SwanConfig\nfrom rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT\nfrom rompy_swan.components.group import STARTUP, PHYSICS\n\nconfig = SwanConfig(\n    cgrid=REGULAR(\n        spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n    ),\n    startup=STARTUP(\n        project=PROJECT(name=\"Example\", nr=\"001\"),\n        set=SET(level=0.0),\n        mode=MODE(),\n        coordinates=COORDINATES(),\n    ),\n    physics=PHYSICS(\n        gen=GEN3(),\n        breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    ),\n)\n</code></pre> <p>When called, <code>SwanConfig</code> renders all components to SWAN commands:</p> <pre><code>PROJECT 'Example' '001'\nSET level=0.0\nMODE NONSTATIONARY TWODIMENSIONAL\nCOORDINATES CARTESIAN\nCGRID REGULAR 0 0 0 100000 50000 100 50 CIRCLE 36 0.04 1.0\nGEN3\nBREAKING CONSTANT alpha=1.0 gamma=0.73\n</code></pre>"},{"location":"user-guide/architecture/#component-hierarchy","title":"Component Hierarchy","text":"<p>SWAN commands are organised into components based on their function:</p> <pre><code>SwanConfig\n\u251c\u2500\u2500 cgrid              # Computational grid (CGRID command)\n\u2502   \u251c\u2500\u2500 REGULAR        # Regular rectangular grid\n\u2502   \u251c\u2500\u2500 CURVILINEAR    # Curvilinear grid\n\u2502   \u2514\u2500\u2500 UNSTRUCTURED   # Unstructured mesh\n\u251c\u2500\u2500 startup            # Startup commands (PROJECT, SET, MODE, etc.)\n\u2502   \u251c\u2500\u2500 project        # PROJECT command\n\u2502   \u251c\u2500\u2500 set            # SET command\n\u2502   \u251c\u2500\u2500 mode           # MODE command\n\u2502   \u2514\u2500\u2500 coordinates    # COORDINATES command\n\u251c\u2500\u2500 inpgrid            # Input grids (INPGRID/READINP commands)\n\u2502   \u251c\u2500\u2500 bottom         # Bathymetry grid\n\u2502   \u251c\u2500\u2500 wind           # Wind forcing grid\n\u2502   \u251c\u2500\u2500 current        # Current forcing grid\n\u2502   \u2514\u2500\u2500 ...            # Other input grids\n\u251c\u2500\u2500 boundary           # Boundary conditions (BOUNDSPEC, BOUNDNEST)\n\u251c\u2500\u2500 initial            # Initial conditions (INITIAL command)\n\u251c\u2500\u2500 physics            # Physics commands\n\u2502   \u251c\u2500\u2500 gen            # Wave generation (GEN1, GEN2, GEN3)\n\u2502   \u251c\u2500\u2500 breaking       # Wave breaking\n\u2502   \u251c\u2500\u2500 friction       # Bottom friction\n\u2502   \u251c\u2500\u2500 triad          # Triad interactions\n\u2502   \u2514\u2500\u2500 ...            # Other physics\n\u251c\u2500\u2500 prop               # Propagation scheme (PROP command)\n\u251c\u2500\u2500 numeric            # Numerics (NUMERIC command)\n\u251c\u2500\u2500 output             # Output commands (BLOCK, TABLE, etc.)\n\u2514\u2500\u2500 lockup             # Lockup commands (COMPUTE, STOP)\n</code></pre>"},{"location":"user-guide/architecture/#components-and-subcomponents","title":"Components and Subcomponents","text":""},{"location":"user-guide/architecture/#components","title":"Components","text":"<p>Components represent complete SWAN commands. Each component class corresponds to a SWAN command like <code>GEN3</code>, <code>CGRID</code>, or <code>BOUNDSPEC</code>.</p> <pre><code>from rompy_swan.components.physics import GEN3, BREAKING_CONSTANT\n\n# Each component maps to a SWAN command\ngen = GEN3()                                    # -&gt; GEN3\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)  # -&gt; BREAKING CONSTANT alpha=1.0 gamma=0.73\n</code></pre> <p>Components use a <code>model_type</code> field for discriminated unions, enabling instantiation from YAML/JSON configuration files.</p>"},{"location":"user-guide/architecture/#subcomponents","title":"Subcomponents","text":"<p>Subcomponents represent branching options within SWAN commands. When a SWAN command has mutually exclusive options that each accept different parameters, these become separate subcomponent classes.</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nfrom rompy_swan.subcomponents.boundary import SIDE, CONSTANTPAR\n\n# SIDE is a subcomponent - one way to specify boundary location\n# CONSTANTPAR is a subcomponent - one way to specify boundary data\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"jonswap\", gamma=3.3),\n    location=SIDE(side=\"west\"),\n    data=CONSTANTPAR(hs=2.0, per=10.0, dir=270.0, dd=30.0),\n)\n</code></pre> <p>This mirrors how SWAN commands work: <code>BOUNDSPEC</code> can use <code>SIDE</code> or <code>SEGMENT</code> for location, and <code>PAR</code> or <code>FILE</code> for data. Each option has its own valid parameters.</p>"},{"location":"user-guide/architecture/#group-components","title":"Group Components","text":"<p>Group components aggregate related commands that typically appear together:</p> <pre><code>from rompy_swan.components.group import PHYSICS\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_JONSWAP\n\nphysics = PHYSICS(\n    gen=GEN3(),\n    breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    friction=FRICTION_JONSWAP(cfjon=0.067),\n)\n</code></pre>"},{"location":"user-guide/architecture/#why-components","title":"Why Components?","text":""},{"location":"user-guide/architecture/#1-validation","title":"1. Validation","text":"<p>Components enable parameter validation before running SWAN:</p> <pre><code>from rompy_swan.components.physics import BREAKING_CONSTANT\n\n# This raises a validation error immediately\nbreaking = BREAKING_CONSTANT(alpha=-1.0)  # alpha must be positive\n</code></pre>"},{"location":"user-guide/architecture/#2-discoverability","title":"2. Discoverability","text":"<p>Related commands are grouped together. Need friction settings? Look in <code>physics.friction</code>:</p> <pre><code>from rompy_swan.components.physics import (\n    FRICTION_JONSWAP,\n    FRICTION_COLLINS,\n    FRICTION_MADSEN,\n)\n</code></pre>"},{"location":"user-guide/architecture/#3-type-safety","title":"3. Type Safety","text":"<p>IDE autocomplete shows available options:</p> <pre><code>from rompy_swan.components.cgrid import REGULAR\n\ncgrid = REGULAR(\n    spectrum=...,  # IDE shows spectrum options\n    grid=...,      # IDE shows grid options\n)\n</code></pre>"},{"location":"user-guide/architecture/#4-declarative-configuration","title":"4. Declarative Configuration","text":"<p>Components can be instantiated from dictionaries (YAML/JSON):</p> <pre><code>physics:\n  gen:\n    model_type: gen3\n  breaking:\n    model_type: constant\n    alpha: 1.0\n    gamma: 0.73\n</code></pre>"},{"location":"user-guide/architecture/#data-interfaces","title":"Data Interfaces","text":"<p>Interface classes bridge external data with SWAN components:</p>"},{"location":"user-guide/architecture/#datainterface","title":"DataInterface","text":"<p>Connects data sources to input grids:</p> <pre><code>from rompy_swan.interface import DataInterface\n\ndata = DataInterface(\n    bottom=dict(\n        model_type=\"swan_data_grid\",\n        source=dict(uri=\"bathymetry.nc\"),\n        var=\"elevation\",\n    ),\n)\n</code></pre>"},{"location":"user-guide/architecture/#boundaryinterface","title":"BoundaryInterface","text":"<p>Connects spectral data to boundary conditions:</p> <pre><code>from rompy_swan.interface import BoundaryInterface\n\nboundary = BoundaryInterface(\n    source=dict(uri=\"spectra.nc\"),\n    sel=dict(method=\"nearest\"),\n)\n</code></pre>"},{"location":"user-guide/architecture/#outputinterface","title":"OutputInterface","text":"<p>Configures output based on time range:</p> <pre><code>from rompy_swan.interface import OutputInterface\n\noutput = OutputInterface(\n    block=dict(fname=\"output.nc\", output=[\"hsign\", \"tps\"]),\n)\n</code></pre>"},{"location":"user-guide/architecture/#swan-input-file-generation","title":"SWAN Input File Generation","text":"<p><code>SwanConfig</code> handles the conversion from Python objects to SWAN input files. When you call the config, it collects all components and writes them in the correct order:</p> <pre><code>config = SwanConfig(...)\n\n# Generate the input file content\nswan_input = str(config)\n\n# Or write directly to a file\nwith open(\"INPUT\", \"w\") as f:\n    f.write(str(config))\n</code></pre> <p>Internal Methods</p> <p>Components have internal <code>cmd()</code> and <code>render()</code> methods that handle command generation. You typically don't need to call these directly \u2014 <code>SwanConfig</code> manages the rendering process.</p>"},{"location":"user-guide/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration \u2014 Detailed configuration options</li> <li>Components \u2014 Reference for all components</li> <li>Data Interfaces \u2014 Connect external data</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration Guide","text":"<p>This guide covers the different ways to configure SWAN simulations with rompy-swan.</p>"},{"location":"user-guide/configuration/#configuration-methods","title":"Configuration Methods","text":"<p>Rompy-swan supports two main configuration approaches:</p> <ol> <li>Python API \u2014 Direct instantiation of components</li> <li>YAML/JSON \u2014 Declarative configuration files</li> </ol> <p>Both approaches produce identical results and can be mixed.</p>"},{"location":"user-guide/configuration/#python-api","title":"Python API","text":""},{"location":"user-guide/configuration/#direct-instantiation","title":"Direct Instantiation","text":"<pre><code>from rompy_swan.config import SwanConfig\nfrom rompy_swan.components.cgrid import REGULAR\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT\nfrom rompy_swan.components.group import PHYSICS\n\nconfig = SwanConfig(\n    cgrid=REGULAR(\n        spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n    ),\n    physics=PHYSICS(\n        gen=GEN3(),\n        breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    ),\n)\n</code></pre>"},{"location":"user-guide/configuration/#using-dictionaries","title":"Using Dictionaries","text":"<p>Components accept dictionaries that are converted to subcomponents:</p> <pre><code># These are equivalent:\ncgrid = REGULAR(\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n    grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n)\n\n# Explicit subcomponent instantiation\nfrom rompy_swan.subcomponents.spectrum import SPECTRUM\nfrom rompy_swan.subcomponents.cgrid import REGULAR as REGULAR_GRID\n\ncgrid = REGULAR(\n    spectrum=SPECTRUM(mdc=36, flow=0.04, fhigh=1.0),\n    grid=REGULAR_GRID(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n)\n</code></pre>"},{"location":"user-guide/configuration/#yaml-configuration","title":"YAML Configuration","text":""},{"location":"user-guide/configuration/#basic-structure","title":"Basic Structure","text":"<pre><code># config.yml\nmodel_type: swan\n\ncgrid:\n  model_type: regular\n  spectrum:\n    mdc: 36\n    flow: 0.04\n    fhigh: 1.0\n  grid:\n    xp: 0\n    yp: 0\n    alp: 0\n    xlen: 100000\n    ylen: 50000\n    mx: 100\n    my: 50\n\nstartup:\n  project:\n    name: MySimulation\n    nr: \"001\"\n  set:\n    level: 0.0\n  mode:\n    kind: nonstationary\n    dim: twodimensional\n\nphysics:\n  gen:\n    model_type: gen3\n  breaking:\n    model_type: constant\n    alpha: 1.0\n    gamma: 0.73\n  friction:\n    model_type: jonswap\n    cfjon: 0.067\n</code></pre>"},{"location":"user-guide/configuration/#loading-yaml","title":"Loading YAML","text":"<pre><code>import yaml\nfrom rompy_swan.config import SwanConfig\n\nwith open(\"config.yml\") as f:\n    config_dict = yaml.safe_load(f)\n\nconfig = SwanConfig(**config_dict)\n</code></pre>"},{"location":"user-guide/configuration/#discriminated-unions","title":"Discriminated Unions","text":"<p>When a field accepts multiple types, use <code>model_type</code> to specify which:</p> <pre><code># Breaking can be CONSTANT, BKD, etc.\nphysics:\n  breaking:\n    model_type: constant  # Selects BREAKING_CONSTANT\n    alpha: 1.0\n    gamma: 0.73\n\n# Or use BKD formulation\nphysics:\n  breaking:\n    model_type: bkd  # Selects BREAKING_BKD\n    alpha: 1.0\n    gamma0: 0.73\n</code></pre>"},{"location":"user-guide/configuration/#swanconfig-fields","title":"SwanConfig Fields","text":"Field Type Description <code>cgrid</code> REGULAR, CURVILINEAR, UNSTRUCTURED Computational grid (required) <code>startup</code> STARTUP Startup commands (PROJECT, SET, MODE, etc.) <code>inpgrid</code> INPGRIDS, DataInterface Input grids for bathymetry, wind, etc. <code>boundary</code> BOUNDSPEC, BOUNDNEST1-3, BoundaryInterface Boundary conditions <code>initial</code> INITIAL Initial conditions <code>physics</code> PHYSICS Physics commands <code>prop</code> PROP Propagation scheme <code>numeric</code> NUMERIC Numerical settings <code>output</code> OUTPUT Output configuration <code>lockup</code> LOCKUP Compute and stop commands"},{"location":"user-guide/configuration/#component-groups","title":"Component Groups","text":""},{"location":"user-guide/configuration/#startup","title":"STARTUP","text":"<p>Groups startup commands:</p> <pre><code>from rompy_swan.components.group import STARTUP\nfrom rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\n\nstartup = STARTUP(\n    project=PROJECT(name=\"Example\", nr=\"001\"),\n    set=SET(level=0.0, depmin=0.05),\n    mode=MODE(kind=\"nonstationary\", dim=\"twodimensional\"),\n    coordinates=COORDINATES(kind=\"cartesian\"),\n)\n</code></pre>"},{"location":"user-guide/configuration/#physics","title":"PHYSICS","text":"<p>Groups physics commands:</p> <pre><code>from rompy_swan.components.group import PHYSICS\nfrom rompy_swan.components.physics import GEN3, BREAKING_CONSTANT, FRICTION_JONSWAP\n\nphysics = PHYSICS(\n    gen=GEN3(),\n    breaking=BREAKING_CONSTANT(alpha=1.0, gamma=0.73),\n    friction=FRICTION_JONSWAP(cfjon=0.067),\n    triad=True,  # Enable with defaults\n)\n</code></pre>"},{"location":"user-guide/configuration/#inpgrids","title":"INPGRIDS","text":"<p>Groups input grids:</p> <pre><code>from rompy_swan.components.group import INPGRIDS\nfrom rompy_swan.components.inpgrid import REGULAR\n\ninpgrid = INPGRIDS(\n    bottom=REGULAR(\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=100, my=50),\n        readinp=dict(fname=\"bottom.txt\"),\n    ),\n    wind=REGULAR(\n        grid=dict(xp=0, yp=0, alp=0, xlen=100000, ylen=50000, mx=10, my=5),\n        readinp=dict(fname=\"wind.txt\"),\n    ),\n)\n</code></pre>"},{"location":"user-guide/configuration/#output","title":"OUTPUT","text":"<p>Groups output commands:</p> <pre><code>from rompy_swan.components.group import OUTPUT\nfrom rompy_swan.components.output import BLOCK, TABLE, QUANTITY\n\noutput = OUTPUT(\n    block=BLOCK(\n        sname=\"COMPGRID\",\n        fname=\"output.nc\",\n        output=[\"hsign\", \"tps\", \"dir\"],\n    ),\n    table=TABLE(\n        sname=\"COMPGRID\",\n        fname=\"output.tab\",\n        output=[\"hsign\", \"tps\"],\n    ),\n    quantity=[\n        QUANTITY(output=[\"hsign\"], hexp=100.0),\n    ],\n)\n</code></pre>"},{"location":"user-guide/configuration/#validation","title":"Validation","text":"<p>Components validate parameters at construction:</p> <pre><code>from rompy_swan.components.physics import BREAKING_CONSTANT\n\n# Raises ValidationError: alpha must be positive\nbreaking = BREAKING_CONSTANT(alpha=-1.0, gamma=0.73)\n</code></pre> <p>Validation includes:</p> <ul> <li>Type checking \u2014 Correct types for each field</li> <li>Range validation \u2014 Values within valid ranges</li> <li>Cross-field validation \u2014 Consistent parameter combinations</li> </ul>"},{"location":"user-guide/configuration/#environment-variables","title":"Environment Variables","text":"<p>Some settings can be configured via environment variables:</p> <pre><code>export SWAN_EXECUTABLE=/path/to/swan\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#1-use-yaml-for-reproducibility","title":"1. Use YAML for Reproducibility","text":"<p>Store configurations in version control:</p> <pre><code># experiments/exp001.yml\nmodel_type: swan\ncgrid: ...\nphysics: ...\n</code></pre>"},{"location":"user-guide/configuration/#2-use-python-for-dynamic-configuration","title":"2. Use Python for Dynamic Configuration","text":"<p>Generate configurations programmatically:</p> <pre><code>for gamma in [0.6, 0.7, 0.8]:\n    config = SwanConfig(\n        physics=PHYSICS(\n            breaking=BREAKING_CONSTANT(alpha=1.0, gamma=gamma),\n        ),\n        ...\n    )\n</code></pre>"},{"location":"user-guide/configuration/#3-validate-early","title":"3. Validate Early","text":"<p>Check configurations before running:</p> <pre><code>config = SwanConfig(...)\n# Validation happens at construction\n# If no error, configuration is valid\n</code></pre>"},{"location":"user-guide/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Components \u2014 Reference for all components</li> <li>Data Interfaces \u2014 Connect external data</li> <li>API Reference \u2014 Complete API documentation</li> </ul>"}]}