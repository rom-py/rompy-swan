{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SWAN","text":"<p>TODO: Ensure the <code>model_type</code> is shown next to each class in the autosummaries.</p> <p>TODO: Fix broken links to classes and modules.</p>"},{"location":"#grid","title":"Grid","text":""},{"location":"#rompy_swan.grid.SwanGrid","title":"SwanGrid","text":"<p>               Bases: <code>RegularGrid</code></p> <p>Regular SWAN grid in geographic space.</p> Source code in <code>rompy_swan/grid.py</code> <pre><code>class SwanGrid(RegularGrid):\n    \"\"\"Regular SWAN grid in geographic space.\"\"\"\n\n    grid_type: Literal[\"REG\", \"CURV\"] = Field(\n        \"REG\", description=\"Type of grid (REG=regular, CURV=curvilinear)\"\n    )\n    exc: Optional[float] = Field(None, description=\"Missing value\")\n    gridfile: Optional[str] = Field(\n        None, description=\"Name of grid file to load\", max_length=36\n    )\n\n    @field_validator(\"grid_type\")\n    @classmethod\n    def validate_grid_type(cls, v):\n        if v not in [\"REG\", \"CURV\"]:\n            raise ValueError(\"grid_type must be one of REG or CURV\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_curvilinear_grid(self) -&gt; \"SwanGrid\":\n        if self.grid_type == \"CURV\" and self.gridfile is None:\n            raise ValueError(\"gridfile must be provided for CURV grid\")\n        return self\n\n    def _regen_grid(self):\n        if self.grid_type == \"REG\":\n            _x, _y = self._gen_reg_cgrid()\n        elif self.grid_type == \"CURV\":\n            _x, _y = self._gen_curv_cgrid()\n        self.x = _x\n        self.y = _y\n\n    def _gen_curv_cgrid(self):\n        \"\"\"loads a SWAN curvilinear grid and returns cgrid lat/lons and\n        command to be used in SWAN contol file. The Default grid is one I made using\n        Deltares' RGFGrid tool and converted to a SWAN-friendly formate using Deltares\n        OpenEarth code \"swan_io_grd.m\"\n\n        \"\"\"\n        # number of grid cells in the 'x' and 'y' directions:\n        # (you can get this from d3d_qp.m or other Deltares OpenEarth code)\n        nX = self.nx\n        nY = self.ny\n\n        grid_Data = open(self.gridpath).readlines()\n        ix = grid_Data.index(\"x-coordinates\\n\")\n        iy = grid_Data.index(\"y-coordinates\\n\")\n        lons = []\n        lats = []\n        for idx in np.arange(ix + 1, iy):\n            lons.append(re.sub(\"\\n\", \"\", grid_Data[idx]).split())\n        for idx in np.arange(iy + 1, len(grid_Data)):\n            lats.append(re.sub(\"\\n\", \"\", grid_Data[idx]).split())\n\n        def flatten(l):\n            return [item for sublist in l for item in sublist]\n\n        lons = np.array(flatten(lons)).astype(np.float)\n        lats = np.array(flatten(lats)).astype(np.float)\n\n        x = np.reshape(lats, (nX, nY))\n        y = np.reshape(lons, (nX, nY))\n\n        return x, y\n\n    @property\n    def inpgrid(self):\n        if self.grid_type == \"REG\":\n            inpstr = f\"REG {self.x0} {self.y0} {self.rot} {self.nx-1:0.0f} {self.ny-1:0.0f} {self.dx} {self.dy}\"\n            if self.exc is not None:\n                inpstr += f\" EXC {self.exc}\"\n            return inpstr\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return f'CURVilinear {self.nx-1:0.0f} {self.ny-1:0.0f} \\nREADGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE'\n\n    @property\n    def cgrid(self):\n        if self.grid_type == \"REG\":\n            return f\"REG {self.x0} {self.y0} {self.rot} {self.xlen} {self.ylen} {self.nx-1:0.0f} {self.ny-1:0.0f}\"\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return (f'CURVilinear {self.nx-1:0.0f} {self.ny-1:0.0f}',f'READGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE')\n\n    @property\n    def cgrid_read(self):\n        if self.grid_type == \"REG\":\n            return \"\"\n        elif self.grid_type == \"CURV\":\n            raise NotImplementedError(\"Curvilinear grids not supported yet\")\n            # return f'READGRID COOR 1 \\'{os.path.basename(self.gridpath)}\\' 1 0 1 FREE'\n\n    @property\n    def component(self):\n        \"\"\"Return the respective SWAN component for this grid.\"\"\"\n        if self.grid_type == \"REG\":\n            return GRIDREGULAR(\n                xp=self.x0,\n                yp=self.y0,\n                alp=self.rot,\n                xlen=self.xlen,\n                ylen=self.ylen,\n                mx=self.nx - 1,\n                my=self.ny - 1,\n            )\n        else:\n            raise NotImplementedError(\"Only regular grid is currently supported\")\n\n    def __call__(self):\n        output = f\"CGRID {self.cgrid} CIRCLE 36 0.0464 1. 31\\n\"\n        output += f\"{self.cgrid_read}\\n\"\n        return output\n\n    def boundary(self, *args, **kwargs) -&gt; tuple:\n        \"\"\"Returns the grid boundary polygon.\n\n        Override the parent method to use the actual points from the regular grid\n        boundary instead of the convex hull which is not always the boundary.\n\n        \"\"\"\n        x = np.concatenate(\n            [self.x[0, :], self.x[1:, -1], self.x[-1, -2::-1], self.x[-2::-1, 0]]\n        )\n        y = np.concatenate(\n            [self.y[0, :], self.y[1:, -1], self.y[-1, -2::-1], self.y[-2::-1, 0]]\n        )\n        return Polygon(zip(x, y))\n\n    def nearby_spectra(self, ds_spec, dist_thres=0.05, plot=True):\n        \"\"\"Find points nearby and project to the boundary\n\n        Parameters\n        ----------\n        ds_spec: xarray.Dataset\n            an XArray dataset of wave spectra at a number of points.\n            Dataset variable names standardised using wavespectra.read_*\n            functions.\n\n            See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n        dist_thres: float, optional [Default: 0.05]\n            Maximum distance to translate the input spectra to the grid boundary\n        plot: boolean, optional [Default: True]\n            Generate a plot that shows the applied projections\n\n        Returns\n        -------\n        xarray.Dataset\n            A subset of ds_spec with lat and lon coordinates projected to the boundary\n        \"\"\"\n\n        bbox = self.bbox(buffer=dist_thres)\n        minLon, minLat, maxLon, maxLat = bbox\n\n        inds = np.where(\n            (ds_spec.lon &gt; minLon)\n            &amp; (ds_spec.lon &lt; maxLon)\n            &amp; (ds_spec.lat &gt; minLat)\n            &amp; (ds_spec.lat &lt; maxLat)\n        )[0]\n        ds_spec = ds_spec.isel(site=inds)\n\n        # Work out the closest spectral points\n        def _nearestPointOnLine(p1, p2, p3):\n            # calculate the distance of p3 from the line between p1 and p2 and return\n            # the closest point on the line\n\n            from math import fabs, sqrt\n\n            a = p2[1] - p1[1]\n            b = -1.0 * (p2[0] - p1[0])\n            c = p2[0] * p1[1] - p2[1] * p1[0]\n\n            dist = fabs(a * p3[0] + b * p3[1] + c) / sqrt(a**2 + b**2)\n            x = (b * (b * p3[0] - a * p3[1]) - a * c) / (a**2 + b**2)\n            y = (a * (-b * p3[0] + a * p3[1]) - b * c) / (a**2 + b**2)\n\n            return dist, x, y\n\n        bx, by = self.boundary_points()\n        pol = np.stack([bx, by])\n\n        # Spectra points\n        ds_spec.lon.load()\n        ds_spec.lat.load()\n        ds_spec[\"lon_original\"] = ds_spec[\"lon\"]\n        ds_spec[\"lat_original\"] = ds_spec[\"lat\"]\n        p3s = list(zip(ds_spec.lon.values, ds_spec.lat.values))\n\n        if plot:\n            fig, ax = self.plot()\n            ax.scatter(ds_spec.lon, ds_spec.lat)\n\n        specPoints = []\n        for i in range(pol.shape[1] - 1):\n            p1 = pol[:, i]\n            p2 = pol[:, i + 1]\n            np.stack((p1, p2))\n            output = np.array(\n                list(map(lambda xi: _nearestPointOnLine(p1, p2, xi), p3s))\n            )\n            dists = output[:, 0]\n            segmentPoints = output[:, 1:]\n            inds = np.where((dists &lt; dist_thres))[0]\n\n            # Loop through the points projected onto the line\n            for ind in inds:\n                specPoint = ds_spec.isel(site=ind)\n\n                segLon = segmentPoints[ind, 0]\n                segLat = segmentPoints[ind, 1]\n\n                if plot:\n                    ax.plot(\n                        [segLon, specPoint.lon],\n                        [segLat, specPoint.lat],\n                        color=\"r\",\n                        lw=2,\n                    )\n                    ax.scatter(specPoint.lon, specPoint.lat, marker=\"o\", color=\"b\")\n                    ax.scatter(segLon, segLat, marker=\"x\", color=\"g\")\n\n                specPoint[\"lon\"] = segLon\n                specPoint[\"lat\"] = segLat\n                specPoints.append(specPoint)\n\n            logger.debug(f\"Segment {i} - Indices {inds}\")\n\n        if plot:\n            fig.show()\n\n        ds_boundary = xr.concat(specPoints, dim=\"site\")\n        return ds_boundary\n\n    def __repr__(self):\n        return f\"SwanGrid: {self.grid_type}, {self.nx}x{self.ny}\"\n\n    def __str__(self):\n        return f\"SwanGrid: {self.grid_type}, {self.nx}x{self.ny}\"\n\n    @classmethod\n    def from_component(cls, component: GRIDREGULAR) -&gt; \"SwanGrid\":\n        \"\"\"Swan grid from an existing component.\n\n        Parameters\n        ----------\n        component: GRIDREGULAR\n            A GRIDREGULAR SWAN component.\n\n        Returns\n        -------\n        SwanGrid\n            A SwanGrid object.\n\n        \"\"\"\n        return cls(\n            x0=component.xp,\n            y0=component.yp,\n            rot=component.alp,\n            dx=component.dx,\n            dy=component.dy,\n            nx=component.mx + 1,\n            ny=component.my + 1,\n        )\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.grid.SwanGrid.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['REG', 'CURV'] = Field('REG', description='Type of grid (REG=regular, CURV=curvilinear)')\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.exc","title":"exc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exc: Optional[float] = Field(None, description='Missing value')\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.gridfile","title":"gridfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gridfile: Optional[str] = Field(None, description='Name of grid file to load', max_length=36)\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.inpgrid","title":"inpgrid  <code>property</code>","text":"<pre><code>inpgrid\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.cgrid","title":"cgrid  <code>property</code>","text":"<pre><code>cgrid\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.cgrid_read","title":"cgrid_read  <code>property</code>","text":"<pre><code>cgrid_read\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Return the respective SWAN component for this grid.</p>"},{"location":"#rompy_swan.grid.SwanGrid-functions","title":"Functions","text":""},{"location":"#rompy_swan.grid.SwanGrid.validate_grid_type","title":"validate_grid_type  <code>classmethod</code>","text":"<pre><code>validate_grid_type(v)\n</code></pre> Source code in <code>rompy_swan/grid.py</code> <pre><code>@field_validator(\"grid_type\")\n@classmethod\ndef validate_grid_type(cls, v):\n    if v not in [\"REG\", \"CURV\"]:\n        raise ValueError(\"grid_type must be one of REG or CURV\")\n    return v\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.validate_curvilinear_grid","title":"validate_curvilinear_grid","text":"<pre><code>validate_curvilinear_grid() -&gt; SwanGrid\n</code></pre> Source code in <code>rompy_swan/grid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_curvilinear_grid(self) -&gt; \"SwanGrid\":\n    if self.grid_type == \"CURV\" and self.gridfile is None:\n        raise ValueError(\"gridfile must be provided for CURV grid\")\n    return self\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.boundary","title":"boundary","text":"<pre><code>boundary(*args, **kwargs) -&gt; tuple\n</code></pre> <p>Returns the grid boundary polygon.</p> <p>Override the parent method to use the actual points from the regular grid boundary instead of the convex hull which is not always the boundary.</p> Source code in <code>rompy_swan/grid.py</code> <pre><code>def boundary(self, *args, **kwargs) -&gt; tuple:\n    \"\"\"Returns the grid boundary polygon.\n\n    Override the parent method to use the actual points from the regular grid\n    boundary instead of the convex hull which is not always the boundary.\n\n    \"\"\"\n    x = np.concatenate(\n        [self.x[0, :], self.x[1:, -1], self.x[-1, -2::-1], self.x[-2::-1, 0]]\n    )\n    y = np.concatenate(\n        [self.y[0, :], self.y[1:, -1], self.y[-1, -2::-1], self.y[-2::-1, 0]]\n    )\n    return Polygon(zip(x, y))\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.nearby_spectra","title":"nearby_spectra","text":"<pre><code>nearby_spectra(ds_spec, dist_thres=0.05, plot=True)\n</code></pre> <p>Find points nearby and project to the boundary</p>"},{"location":"#rompy_swan.grid.SwanGrid.nearby_spectra--parameters","title":"Parameters","text":"<p>ds_spec: xarray.Dataset     an XArray dataset of wave spectra at a number of points.     Dataset variable names standardised using wavespectra.read_*     functions.</p> <pre><code>See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n</code></pre> <p>dist_thres: float, optional [Default: 0.05]     Maximum distance to translate the input spectra to the grid boundary plot: boolean, optional [Default: True]     Generate a plot that shows the applied projections</p>"},{"location":"#rompy_swan.grid.SwanGrid.nearby_spectra--returns","title":"Returns","text":"<p>xarray.Dataset     A subset of ds_spec with lat and lon coordinates projected to the boundary</p> Source code in <code>rompy_swan/grid.py</code> <pre><code>def nearby_spectra(self, ds_spec, dist_thres=0.05, plot=True):\n    \"\"\"Find points nearby and project to the boundary\n\n    Parameters\n    ----------\n    ds_spec: xarray.Dataset\n        an XArray dataset of wave spectra at a number of points.\n        Dataset variable names standardised using wavespectra.read_*\n        functions.\n\n        See https://wavespectra.readthedocs.io/en/latest/api.html#input-functions\n    dist_thres: float, optional [Default: 0.05]\n        Maximum distance to translate the input spectra to the grid boundary\n    plot: boolean, optional [Default: True]\n        Generate a plot that shows the applied projections\n\n    Returns\n    -------\n    xarray.Dataset\n        A subset of ds_spec with lat and lon coordinates projected to the boundary\n    \"\"\"\n\n    bbox = self.bbox(buffer=dist_thres)\n    minLon, minLat, maxLon, maxLat = bbox\n\n    inds = np.where(\n        (ds_spec.lon &gt; minLon)\n        &amp; (ds_spec.lon &lt; maxLon)\n        &amp; (ds_spec.lat &gt; minLat)\n        &amp; (ds_spec.lat &lt; maxLat)\n    )[0]\n    ds_spec = ds_spec.isel(site=inds)\n\n    # Work out the closest spectral points\n    def _nearestPointOnLine(p1, p2, p3):\n        # calculate the distance of p3 from the line between p1 and p2 and return\n        # the closest point on the line\n\n        from math import fabs, sqrt\n\n        a = p2[1] - p1[1]\n        b = -1.0 * (p2[0] - p1[0])\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n\n        dist = fabs(a * p3[0] + b * p3[1] + c) / sqrt(a**2 + b**2)\n        x = (b * (b * p3[0] - a * p3[1]) - a * c) / (a**2 + b**2)\n        y = (a * (-b * p3[0] + a * p3[1]) - b * c) / (a**2 + b**2)\n\n        return dist, x, y\n\n    bx, by = self.boundary_points()\n    pol = np.stack([bx, by])\n\n    # Spectra points\n    ds_spec.lon.load()\n    ds_spec.lat.load()\n    ds_spec[\"lon_original\"] = ds_spec[\"lon\"]\n    ds_spec[\"lat_original\"] = ds_spec[\"lat\"]\n    p3s = list(zip(ds_spec.lon.values, ds_spec.lat.values))\n\n    if plot:\n        fig, ax = self.plot()\n        ax.scatter(ds_spec.lon, ds_spec.lat)\n\n    specPoints = []\n    for i in range(pol.shape[1] - 1):\n        p1 = pol[:, i]\n        p2 = pol[:, i + 1]\n        np.stack((p1, p2))\n        output = np.array(\n            list(map(lambda xi: _nearestPointOnLine(p1, p2, xi), p3s))\n        )\n        dists = output[:, 0]\n        segmentPoints = output[:, 1:]\n        inds = np.where((dists &lt; dist_thres))[0]\n\n        # Loop through the points projected onto the line\n        for ind in inds:\n            specPoint = ds_spec.isel(site=ind)\n\n            segLon = segmentPoints[ind, 0]\n            segLat = segmentPoints[ind, 1]\n\n            if plot:\n                ax.plot(\n                    [segLon, specPoint.lon],\n                    [segLat, specPoint.lat],\n                    color=\"r\",\n                    lw=2,\n                )\n                ax.scatter(specPoint.lon, specPoint.lat, marker=\"o\", color=\"b\")\n                ax.scatter(segLon, segLat, marker=\"x\", color=\"g\")\n\n            specPoint[\"lon\"] = segLon\n            specPoint[\"lat\"] = segLat\n            specPoints.append(specPoint)\n\n        logger.debug(f\"Segment {i} - Indices {inds}\")\n\n    if plot:\n        fig.show()\n\n    ds_boundary = xr.concat(specPoints, dim=\"site\")\n    return ds_boundary\n</code></pre>"},{"location":"#rompy_swan.grid.SwanGrid.from_component","title":"from_component  <code>classmethod</code>","text":"<pre><code>from_component(component: GRIDREGULAR) -&gt; SwanGrid\n</code></pre> <p>Swan grid from an existing component.</p>"},{"location":"#rompy_swan.grid.SwanGrid.from_component--parameters","title":"Parameters","text":"<p>component: GRIDREGULAR     A GRIDREGULAR SWAN component.</p>"},{"location":"#rompy_swan.grid.SwanGrid.from_component--returns","title":"Returns","text":"<p>SwanGrid     A SwanGrid object.</p> Source code in <code>rompy_swan/grid.py</code> <pre><code>@classmethod\ndef from_component(cls, component: GRIDREGULAR) -&gt; \"SwanGrid\":\n    \"\"\"Swan grid from an existing component.\n\n    Parameters\n    ----------\n    component: GRIDREGULAR\n        A GRIDREGULAR SWAN component.\n\n    Returns\n    -------\n    SwanGrid\n        A SwanGrid object.\n\n    \"\"\"\n    return cls(\n        x0=component.xp,\n        y0=component.yp,\n        rot=component.alp,\n        dx=component.dx,\n        dy=component.dy,\n        nx=component.mx + 1,\n        ny=component.my + 1,\n    )\n</code></pre>"},{"location":"#data","title":"Data","text":""},{"location":"#rompy_swan.data.SwanDataGrid","title":"SwanDataGrid","text":"<p>               Bases: <code>DataGrid</code></p> <p>This class is used to write SWAN data from a dataset.</p> Source code in <code>rompy_swan/data.py</code> <pre><code>class SwanDataGrid(DataGrid):\n    \"\"\"This class is used to write SWAN data from a dataset.\"\"\"\n\n    z1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the data variable in dataset representing either a scaler \"\n            \"parameter or the u-componet of a vector field\"\n        ),\n    )\n    z2: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the data variable in dataset representing \"\n            \"the v-componet of a vector field\"\n        ),\n    )\n    var: GridOptions = Field(description=\"SWAN input grid name\")\n    fac: float = Field(\n        description=(\n            \"SWAN multiplies all values that are read from file by `fac`. For \"\n            \"instance if the values are given in unit decimeter, one should make \"\n            \"`fac=0.1` to obtain values in m. To change sign use a negative `fac`\"\n        ),\n        default=1.0,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_z1_in_data_vars(self) -&gt; \"SwanDataGrid\":\n        data_vars = self.variables\n        for z in [self.z1, self.z2]:\n            if z and z not in data_vars:\n                logger.debug(f\"Adding {z} to data_vars\")\n                data_vars.append(z)\n        self.variables = data_vars\n        return self\n\n    def get(\n        self,\n        destdir: str | Path,\n        grid: Optional[SwanGrid] = None,\n        time: Optional[TimeRange] = None,\n    ) -&gt; Path:\n        \"\"\"Write the data source to a new location.\n\n        Parameters\n        ----------\n        destdir : str | Path\n            The destination directory to write the netcdf data to.\n        grid: SwanGrid, optional\n            The grid to filter the data to, only used if `self.filter_grid` is True.\n        time: TimeRange, optional\n            The times to filter the data to, only used if `self.filter_time` is True.\n\n        Returns\n        -------\n        cmd: str\n            The command line string with the INPGRID/READINP commands ready to be\n            written to the SWAN input file.\n\n        Note\n        ----\n        The data are assumed to not have been rotated. We cannot use the grid.rot attr\n        as this is the rotation from the model grid object which is not necessarily the\n        same as the rotation of the data.\n\n        \"\"\"\n        if self.crop_data:\n            if grid is not None:\n                self._filter_grid(grid)\n            if time is not None:\n                self._filter_time(time)\n\n        output_file = os.path.join(destdir, f\"{self.var.value}.grd\")\n\n        # Create a formatted box for logging\n        log_box(\n            title=f\"WRITING {self.var.value.upper()} GRID DATA\",\n            logger=logger,\n            add_empty_line=False,\n        )\n\n        # Log output file and dataset information using bullet points\n        items = [f\"Output file: {output_file}\"]\n\n        # Add variable information if available\n        if self.z1:\n            shape_info = f\"{self.ds[self.z1].shape}\"\n            items.append(f\"Variable: {self.z1} with shape {shape_info}\")\n        if self.z2:\n            shape_info = f\"{self.ds[self.z2].shape}\"\n            items.append(f\"Variable: {self.z2} with shape {shape_info}\")\n\n        # Add scaling factor\n        items.append(f\"Scaling factor: {self.fac}\")\n\n        # Log all items as a bulleted list\n        logger.bullet_list(items, indent=2)\n\n        start_time = time_module.time()\n        if self.var.value == \"bottom\":\n            inpgrid, readgrid = self.ds.swan.to_bottom_grid(\n                output_file,\n                fmt=\"%4.2f\",\n                x=self.coords.x,\n                y=self.coords.y,\n                z=self.z1,\n                fac=self.fac,\n                rot=0.0,\n                vmin=float(\"-inf\"),\n            )\n        else:\n            inpgrid, readgrid = self.ds.swan.to_inpgrid(\n                output_file=output_file,\n                x=self.coords.x,\n                y=self.coords.y,\n                z1=self.z1,\n                z2=self.z2,\n                fac=self.fac,\n                rot=0.0,\n                var=self.var.name,\n            )\n\n        # Log completion and processing time\n        elapsed_time = time_module.time() - start_time\n        file_size = Path(output_file).stat().st_size / (1024 * 1024)  # Size in MB\n\n        # Use the centralized functions from rompy package\n\n        # Log completion information as a bulleted list\n        logger.bullet_list(\n            [\n                f\"Completed in {elapsed_time:.2f} seconds\",\n                f\"File size: {file_size:.2f} MB\",\n            ],\n            indent=2,\n        )\n\n        return f\"{inpgrid}\\n{readgrid}\\n\"\n\n    def __str__(self):\n        return f\"SWANDataGrid {self.var.name}\"\n\n    def _format_value(self, obj):\n        \"\"\"Format SwanDataGrid values using the new formatting framework.\n\n        This method provides special formatting for SwanDataGrid objects.\n\n        Args:\n            obj: The object to format\n\n        Returns:\n            A formatted string or None to use default formatting\n        \"\"\"\n        # Only format SwanDataGrid objects\n        if not isinstance(obj, SwanDataGrid):\n            return None\n\n        # Use the new formatting framework\n        from rompy.formatting import format_value\n\n        return format_value(obj)\n        lines.append(f\"  {bullet} Variable:   {obj.var.name}\")\n\n        # Add source information if available\n        if hasattr(obj, \"source\") and obj.source:\n            source_type = getattr(obj.source, \"model_type\", \"unknown\")\n            lines.append(f\"  {bullet} Source:     {source_type}\")\n\n            # Add dataset information if available\n            if hasattr(obj.source, \"dataset_id\"):\n                lines.append(f\"  {bullet} Dataset ID: {obj.source.dataset_id}\")\n\n        # Add coordinate information if available\n        if hasattr(obj, \"coords\") and obj.coords:\n            coords = [f\"{k}={v}\" for k, v in obj.coords.items()]\n            coords_str = \", \".join(coords)\n            lines.append(f\"  {bullet} Coordinates: {coords_str}\")\n\n        # Add scaling factor if available\n        if hasattr(obj, \"fac\"):\n            lines.append(f\"  {bullet} Scale factor: {obj.fac}\")\n\n        # Add z variables information if available\n        if hasattr(obj, \"z1\") and obj.z1:\n            lines.append(f\"  {bullet} Z1 variable: {obj.z1}\")\n        if hasattr(obj, \"z2\") and obj.z2:\n            lines.append(f\"  {bullet} Z2 variable: {obj.z2}\")\n\n        # Close with footer\n        lines.append(footer)\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.data.SwanDataGrid.z1","title":"z1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z1: Optional[str] = Field(default=None, description='Name of the data variable in dataset representing either a scaler parameter or the u-componet of a vector field')\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid.z2","title":"z2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z2: Optional[str] = Field(default=None, description='Name of the data variable in dataset representing the v-componet of a vector field')\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid.var","title":"var  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>var: GridOptions = Field(description='SWAN input grid name')\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid.fac","title":"fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fac: float = Field(description='SWAN multiplies all values that are read from file by `fac`. For instance if the values are given in unit decimeter, one should make `fac=0.1` to obtain values in m. To change sign use a negative `fac`', default=1.0)\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid-functions","title":"Functions","text":""},{"location":"#rompy_swan.data.SwanDataGrid.ensure_z1_in_data_vars","title":"ensure_z1_in_data_vars","text":"<pre><code>ensure_z1_in_data_vars() -&gt; SwanDataGrid\n</code></pre> Source code in <code>rompy_swan/data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_z1_in_data_vars(self) -&gt; \"SwanDataGrid\":\n    data_vars = self.variables\n    for z in [self.z1, self.z2]:\n        if z and z not in data_vars:\n            logger.debug(f\"Adding {z} to data_vars\")\n            data_vars.append(z)\n    self.variables = data_vars\n    return self\n</code></pre>"},{"location":"#rompy_swan.data.SwanDataGrid.get","title":"get","text":"<pre><code>get(destdir: str | Path, grid: Optional[SwanGrid] = None, time: Optional[TimeRange] = None) -&gt; Path\n</code></pre> <p>Write the data source to a new location.</p>"},{"location":"#rompy_swan.data.SwanDataGrid.get--parameters","title":"Parameters","text":"<p>destdir : str | Path     The destination directory to write the netcdf data to. grid: SwanGrid, optional     The grid to filter the data to, only used if <code>self.filter_grid</code> is True. time: TimeRange, optional     The times to filter the data to, only used if <code>self.filter_time</code> is True.</p>"},{"location":"#rompy_swan.data.SwanDataGrid.get--returns","title":"Returns","text":"<p>cmd: str     The command line string with the INPGRID/READINP commands ready to be     written to the SWAN input file.</p>"},{"location":"#rompy_swan.data.SwanDataGrid.get--note","title":"Note","text":"<p>The data are assumed to not have been rotated. We cannot use the grid.rot attr as this is the rotation from the model grid object which is not necessarily the same as the rotation of the data.</p> Source code in <code>rompy_swan/data.py</code> <pre><code>def get(\n    self,\n    destdir: str | Path,\n    grid: Optional[SwanGrid] = None,\n    time: Optional[TimeRange] = None,\n) -&gt; Path:\n    \"\"\"Write the data source to a new location.\n\n    Parameters\n    ----------\n    destdir : str | Path\n        The destination directory to write the netcdf data to.\n    grid: SwanGrid, optional\n        The grid to filter the data to, only used if `self.filter_grid` is True.\n    time: TimeRange, optional\n        The times to filter the data to, only used if `self.filter_time` is True.\n\n    Returns\n    -------\n    cmd: str\n        The command line string with the INPGRID/READINP commands ready to be\n        written to the SWAN input file.\n\n    Note\n    ----\n    The data are assumed to not have been rotated. We cannot use the grid.rot attr\n    as this is the rotation from the model grid object which is not necessarily the\n    same as the rotation of the data.\n\n    \"\"\"\n    if self.crop_data:\n        if grid is not None:\n            self._filter_grid(grid)\n        if time is not None:\n            self._filter_time(time)\n\n    output_file = os.path.join(destdir, f\"{self.var.value}.grd\")\n\n    # Create a formatted box for logging\n    log_box(\n        title=f\"WRITING {self.var.value.upper()} GRID DATA\",\n        logger=logger,\n        add_empty_line=False,\n    )\n\n    # Log output file and dataset information using bullet points\n    items = [f\"Output file: {output_file}\"]\n\n    # Add variable information if available\n    if self.z1:\n        shape_info = f\"{self.ds[self.z1].shape}\"\n        items.append(f\"Variable: {self.z1} with shape {shape_info}\")\n    if self.z2:\n        shape_info = f\"{self.ds[self.z2].shape}\"\n        items.append(f\"Variable: {self.z2} with shape {shape_info}\")\n\n    # Add scaling factor\n    items.append(f\"Scaling factor: {self.fac}\")\n\n    # Log all items as a bulleted list\n    logger.bullet_list(items, indent=2)\n\n    start_time = time_module.time()\n    if self.var.value == \"bottom\":\n        inpgrid, readgrid = self.ds.swan.to_bottom_grid(\n            output_file,\n            fmt=\"%4.2f\",\n            x=self.coords.x,\n            y=self.coords.y,\n            z=self.z1,\n            fac=self.fac,\n            rot=0.0,\n            vmin=float(\"-inf\"),\n        )\n    else:\n        inpgrid, readgrid = self.ds.swan.to_inpgrid(\n            output_file=output_file,\n            x=self.coords.x,\n            y=self.coords.y,\n            z1=self.z1,\n            z2=self.z2,\n            fac=self.fac,\n            rot=0.0,\n            var=self.var.name,\n        )\n\n    # Log completion and processing time\n    elapsed_time = time_module.time() - start_time\n    file_size = Path(output_file).stat().st_size / (1024 * 1024)  # Size in MB\n\n    # Use the centralized functions from rompy package\n\n    # Log completion information as a bulleted list\n    logger.bullet_list(\n        [\n            f\"Completed in {elapsed_time:.2f} seconds\",\n            f\"File size: {file_size:.2f} MB\",\n        ],\n        indent=2,\n    )\n\n    return f\"{inpgrid}\\n{readgrid}\\n\"\n</code></pre>"},{"location":"#rompy_swan.boundary.Boundnest1","title":"Boundnest1","text":"<p>               Bases: <code>BoundaryWaveStation</code></p> <p>SWAN BOUNDNEST1 NEST data class.</p> Source code in <code>rompy_swan/boundary.py</code> <pre><code>class Boundnest1(BoundaryWaveStation):\n    \"\"\"SWAN BOUNDNEST1 NEST data class.\"\"\"\n\n    model_type: Literal[\"boundnest1\", \"BOUNDNEST1\"] = Field(\n        default=\"boundnest1\", description=\"Model type discriminator\"\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Defines whether boundary is defined over an closed or open rectangle\"\n        ),\n    )\n\n    def get(\n        self, destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None\n    ) -&gt; str:\n        \"\"\"Write the data source to a new location.\n\n        Parameters\n        ----------\n        destdir : str | Path\n            Destination directory for the SWAN ASCII file.\n        grid : RegularGrid\n            Grid instance to use for selecting the boundary points.\n        time: TimeRange, optional\n            The times to filter the data to, only used if `self.crop_data` is True.\n\n        Returns\n        -------\n        filename: Path\n            The filename of the written boundary file.\n        cmd : str\n            Boundary command string to render in the SWAN INPUT file\n\n        \"\"\"\n        if self.crop_data and time is not None:\n            self._filter_time(time)\n        if self.crop_data and grid is not None:\n            self._filter_grid(grid)\n\n        ds = self._sel_boundary(grid).sortby(\"dir\")\n\n        # If nearest, ensure points are returned at the requested positions\n        if self.sel_method == \"nearest\":\n            xbnd, ybnd = self._boundary_points(grid=grid)\n            ds[\"lon\"].values = xbnd\n            ds[\"lat\"].values = ybnd\n\n        filename = Path(destdir) / f\"{self.id}.bnd\"\n        ds.spec.to_swan(filename)\n        cmd = f\"BOUNDNEST1 NEST '{filename.name}' {self.rectangle.upper()}\"\n        return filename, cmd\n</code></pre>"},{"location":"#rompy_swan.boundary.Boundnest1-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.boundary.Boundnest1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest1', 'BOUNDNEST1'] = Field(default='boundnest1', description='Model type discriminator')\n</code></pre>"},{"location":"#rompy_swan.boundary.Boundnest1.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Defines whether boundary is defined over an closed or open rectangle')\n</code></pre>"},{"location":"#rompy_swan.boundary.Boundnest1-functions","title":"Functions","text":""},{"location":"#rompy_swan.boundary.Boundnest1.get","title":"get","text":"<pre><code>get(destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None) -&gt; str\n</code></pre> <p>Write the data source to a new location.</p>"},{"location":"#rompy_swan.boundary.Boundnest1.get--parameters","title":"Parameters","text":"<p>destdir : str | Path     Destination directory for the SWAN ASCII file. grid : RegularGrid     Grid instance to use for selecting the boundary points. time: TimeRange, optional     The times to filter the data to, only used if <code>self.crop_data</code> is True.</p>"},{"location":"#rompy_swan.boundary.Boundnest1.get--returns","title":"Returns","text":"<p>filename: Path     The filename of the written boundary file. cmd : str     Boundary command string to render in the SWAN INPUT file</p> Source code in <code>rompy_swan/boundary.py</code> <pre><code>def get(\n    self, destdir: str, grid: SwanGrid, time: Optional[TimeRange] = None\n) -&gt; str:\n    \"\"\"Write the data source to a new location.\n\n    Parameters\n    ----------\n    destdir : str | Path\n        Destination directory for the SWAN ASCII file.\n    grid : RegularGrid\n        Grid instance to use for selecting the boundary points.\n    time: TimeRange, optional\n        The times to filter the data to, only used if `self.crop_data` is True.\n\n    Returns\n    -------\n    filename: Path\n        The filename of the written boundary file.\n    cmd : str\n        Boundary command string to render in the SWAN INPUT file\n\n    \"\"\"\n    if self.crop_data and time is not None:\n        self._filter_time(time)\n    if self.crop_data and grid is not None:\n        self._filter_grid(grid)\n\n    ds = self._sel_boundary(grid).sortby(\"dir\")\n\n    # If nearest, ensure points are returned at the requested positions\n    if self.sel_method == \"nearest\":\n        xbnd, ybnd = self._boundary_points(grid=grid)\n        ds[\"lon\"].values = xbnd\n        ds[\"lat\"].values = ybnd\n\n    filename = Path(destdir) / f\"{self.id}.bnd\"\n    ds.spec.to_swan(filename)\n    cmd = f\"BOUNDNEST1 NEST '{filename.name}' {self.rectangle.upper()}\"\n    return filename, cmd\n</code></pre>"},{"location":"#components","title":"Components","text":"<p>SWAN command instructions are described in Rompy by a set of pydantic models defined as <code>components</code>. Each component defines a full command instruction such as <code>PROJECT</code>, <code>CGRID</code>, <code>GEN3</code>, NUMERIC, etc. Inputs to the components may include other pydantic models called <code>subcomponents</code> to handle more complex arguments.</p> <p>Components are subclasses of <code>rompy_swan.components.base.BaseComponent</code>. The base component class implements the following attribues:</p> <ul> <li> <p>The model_type field that should be overwritten in each component subclass. The   <code>model_type</code> field is defined as a <code>Literal</code> type and is used to discriminate the   exact components to use in fields defined by a <code>Union</code> type of two or more components   in a declarative framework (i.e., instantiating with a dict from yaml or json file).</p> </li> <li> <p>The cmd() method that must be overwritten in each component subclass. The <code>cmd()</code>   method should return either a string or a list of strings to fully define a SWAN   command line instruction. A list of strings defines multiple command line   instructions that are executed in sequence such as the INPGRID/READGRID components.</p> </li> <li> <p>The render() method that constructs the command line instruction from the content   returned from the <code>cmd()</code> method. The <code>render()</code> method is typically called inside   the <code>__call__</code> method of the config class to construct the specific command line   instruction from that component, taking care of maximum line size, line break and   line continuation.</p> </li> </ul> <p>Components are defined within the <code>rompy_swan.components</code> subpackage and render an entire SWAN command line specification. The following modules are available:</p> <ul> <li>Startup Components</li> <li>CGRID Components</li> <li>INPGRID Components</li> <li>Boundary Components</li> <li>Physics Components</li> <li>Numerics Components</li> <li>Output Components</li> <li>Lockup Components</li> <li>Group Components</li> </ul>"},{"location":"#subcomponents","title":"Subcomponents","text":"<p>Subcomponents are defined within the <code>rompy_swan.subcomponents</code> subpackage and render part of a SWAN command line specification. They typically define specific arguments to one or more component. The following modules are available:</p> <ul> <li>Base Subcomponents</li> <li>Startup Subcomponents</li> <li>Spectrum Subcomponents</li> <li>Time Subcomponents</li> <li>CGRID Subcomponents</li> <li>READGRID Subcomponents</li> <li>Boundary Subcomponents</li> <li>Physics Subcomponents</li> <li>Numerics Subcomponents</li> <li>Output Subcomponents</li> </ul>"},{"location":"#interface","title":"Interface","text":"<p>Interface classes provide an interface between swan components and higher level objects such as <code>TimeRange</code>, <code>Data</code> and <code>Grid</code> objects. They are used inside the <code>__call__</code> method of the config classes to pass instances of these objects to the appropriate components and define consistent parameters to the config after instantiating them.</p>"},{"location":"#rompy_swan.interface.DataInterface","title":"DataInterface","text":"<p>               Bases: <code>RompyBaseModel</code></p> <p>SWAN forcing data interface.</p>"},{"location":"#rompy_swan.interface.DataInterface--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.interface import DataInterface\n</code></pre> Source code in <code>rompy_swan/interface.py</code> <pre><code>class DataInterface(RompyBaseModel):\n    \"\"\"SWAN forcing data interface.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.interface import DataInterface\n\n    \"\"\"\n\n    model_type: Literal[\"data_interface\", \"DATA_INTERFACE\"] = Field(\n        default=\"data_interface\", description=\"Model type discriminator\"\n    )\n    bottom: Optional[SwanDataGrid] = Field(default=None, description=\"Bathymetry data\")\n    input: list[SwanDataGrid] = Field(default=[], description=\"Input grid data\")\n\n    @field_validator(\"input\")\n    @classmethod\n    def ensure_unique_var(\n        cls, input: list[SwanDataGrid], info: ValidationInfo\n    ) -&gt; list[SwanDataGrid]:\n        \"\"\"Ensure that each input var is unique.\"\"\"\n        vars = []\n        if info.data[\"bottom\"] is not None:\n            vars.append(info.data[\"bottom\"].var)\n        vars.extend([inp.var for inp in input])\n        if len(vars) != len(set(vars)):\n            raise ValueError(\"Each var must be unique in input\")\n        return input\n\n    def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n        inputs = []\n        if self.bottom is not None:\n            inputs.append(self.bottom)\n        inputs.extend(self.input)\n        cmds = []\n        for input in inputs:\n            cmds.append(input.get(destdir=staging_dir, grid=grid, time=period))\n        return \"\\n\".join(cmds)\n\n    def render(self, *args, **kwargs):\n        \"\"\"Make this class consistent with the components API.\"\"\"\n        return self.get(*args, **kwargs)\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.interface.DataInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['data_interface', 'DATA_INTERFACE'] = Field(default='data_interface', description='Model type discriminator')\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface.bottom","title":"bottom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bottom: Optional[SwanDataGrid] = Field(default=None, description='Bathymetry data')\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface.input","title":"input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input: list[SwanDataGrid] = Field(default=[], description='Input grid data')\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface-functions","title":"Functions","text":""},{"location":"#rompy_swan.interface.DataInterface.ensure_unique_var","title":"ensure_unique_var  <code>classmethod</code>","text":"<pre><code>ensure_unique_var(input: list[SwanDataGrid], info: ValidationInfo) -&gt; list[SwanDataGrid]\n</code></pre> <p>Ensure that each input var is unique.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>@field_validator(\"input\")\n@classmethod\ndef ensure_unique_var(\n    cls, input: list[SwanDataGrid], info: ValidationInfo\n) -&gt; list[SwanDataGrid]:\n    \"\"\"Ensure that each input var is unique.\"\"\"\n    vars = []\n    if info.data[\"bottom\"] is not None:\n        vars.append(info.data[\"bottom\"].var)\n    vars.extend([inp.var for inp in input])\n    if len(vars) != len(set(vars)):\n        raise ValueError(\"Each var must be unique in input\")\n    return input\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface.get","title":"get","text":"<pre><code>get(staging_dir: Path, grid: SwanGrid, period: TimeRange)\n</code></pre> Source code in <code>rompy_swan/interface.py</code> <pre><code>def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n    inputs = []\n    if self.bottom is not None:\n        inputs.append(self.bottom)\n    inputs.extend(self.input)\n    cmds = []\n    for input in inputs:\n        cmds.append(input.get(destdir=staging_dir, grid=grid, time=period))\n    return \"\\n\".join(cmds)\n</code></pre>"},{"location":"#rompy_swan.interface.DataInterface.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Make this class consistent with the components API.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>def render(self, *args, **kwargs):\n    \"\"\"Make this class consistent with the components API.\"\"\"\n    return self.get(*args, **kwargs)\n</code></pre>"},{"location":"#rompy_swan.interface.BoundaryInterface","title":"BoundaryInterface","text":"<p>               Bases: <code>RompyBaseModel</code></p> <p>SWAN forcing boundary interface.</p>"},{"location":"#rompy_swan.interface.BoundaryInterface--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.interface import BoundaryInterface\n</code></pre> Source code in <code>rompy_swan/interface.py</code> <pre><code>class BoundaryInterface(RompyBaseModel):\n    \"\"\"SWAN forcing boundary interface.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.interface import BoundaryInterface\n\n    \"\"\"\n\n    model_type: Literal[\"boundary_interface\", \"BOUNDARY_INTERFACE\"] = Field(\n        default=\"boundary_interface\", description=\"Model type discriminator\"\n    )\n    kind: Union[Boundnest1, BoundspecSide, BoundspecSegmentXY] = Field(\n        default=None, description=\"Boundary data object\"\n    )\n\n    def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n        filename, cmd = self.kind.get(destdir=staging_dir, grid=grid, time=period)\n        logger.info(f\"Generating boundary file: {filename}\")\n        return cmd\n\n    def render(self, *args, **kwargs):\n        \"\"\"Make this class consistent with the components API.\"\"\"\n        return self.get(*args, **kwargs)\n</code></pre>"},{"location":"#rompy_swan.interface.BoundaryInterface-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.interface.BoundaryInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundary_interface', 'BOUNDARY_INTERFACE'] = Field(default='boundary_interface', description='Model type discriminator')\n</code></pre>"},{"location":"#rompy_swan.interface.BoundaryInterface.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Union[Boundnest1, BoundspecSide, BoundspecSegmentXY] = Field(default=None, description='Boundary data object')\n</code></pre>"},{"location":"#rompy_swan.interface.BoundaryInterface-functions","title":"Functions","text":""},{"location":"#rompy_swan.interface.BoundaryInterface.get","title":"get","text":"<pre><code>get(staging_dir: Path, grid: SwanGrid, period: TimeRange)\n</code></pre> Source code in <code>rompy_swan/interface.py</code> <pre><code>def get(self, staging_dir: Path, grid: SwanGrid, period: TimeRange):\n    filename, cmd = self.kind.get(destdir=staging_dir, grid=grid, time=period)\n    logger.info(f\"Generating boundary file: {filename}\")\n    return cmd\n</code></pre>"},{"location":"#rompy_swan.interface.BoundaryInterface.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Make this class consistent with the components API.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>def render(self, *args, **kwargs):\n    \"\"\"Make this class consistent with the components API.\"\"\"\n    return self.get(*args, **kwargs)\n</code></pre>"},{"location":"#rompy_swan.interface.OutputInterface","title":"OutputInterface","text":"<p>               Bases: <code>TimeInterface</code></p> <p>Output group component with consistent times.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>class OutputInterface(TimeInterface):\n    \"\"\"Output group component with consistent times.\"\"\"\n\n    model_type: Literal[\"outputinterface\", \"OUTPUTINTERFACE\"] = Field(\n        default=\"outputinterface\", description=\"Model type discriminator\"\n    )\n\n    @model_validator(mode=\"after\")\n    def time_interface(self) -&gt; \"OutputInterface\":\n        \"\"\"Set the time parameter for all WRITE components.\"\"\"\n        for component in self.group._write_fields:\n            obj = getattr(self.group, component)\n            if obj is not None:\n                times = obj.times or TimeRangeOpen()\n                obj.times = self._timerange(times.tfmt, times.dfmt, obj.suffix)\n\n    def _timerange(self, tfmt: int, dfmt: str, suffix: str) -&gt; TimeRangeOpen:\n        \"\"\"Convert generic TimeRange into the Swan TimeRangeOpen subcomponent.\"\"\"\n        return TimeRangeOpen(\n            tbeg=self.period.start,\n            delt=self.period.interval,\n            tfmt=tfmt,\n            dfmt=dfmt,\n            suffix=suffix,\n        )\n</code></pre>"},{"location":"#rompy_swan.interface.OutputInterface-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.interface.OutputInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['outputinterface', 'OUTPUTINTERFACE'] = Field(default='outputinterface', description='Model type discriminator')\n</code></pre>"},{"location":"#rompy_swan.interface.OutputInterface-functions","title":"Functions","text":""},{"location":"#rompy_swan.interface.OutputInterface.time_interface","title":"time_interface","text":"<pre><code>time_interface() -&gt; OutputInterface\n</code></pre> <p>Set the time parameter for all WRITE components.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>@model_validator(mode=\"after\")\ndef time_interface(self) -&gt; \"OutputInterface\":\n    \"\"\"Set the time parameter for all WRITE components.\"\"\"\n    for component in self.group._write_fields:\n        obj = getattr(self.group, component)\n        if obj is not None:\n            times = obj.times or TimeRangeOpen()\n            obj.times = self._timerange(times.tfmt, times.dfmt, obj.suffix)\n</code></pre>"},{"location":"#rompy_swan.interface.LockupInterface","title":"LockupInterface","text":"<p>               Bases: <code>TimeInterface</code></p> <p>Lockup group component with consistent times.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>class LockupInterface(TimeInterface):\n    \"\"\"Lockup group component with consistent times.\"\"\"\n\n    model_type: Literal[\"lockupinterface\", \"LOCKUPINTERFACE\"] = Field(\n        default=\"lockupinterface\", description=\"Model type discriminator\"\n    )\n\n    def _nonstationary(self, tfmt: str, dfmt: str) -&gt; NONSTATIONARY:\n        return NONSTATIONARY(\n            tbeg=self.period.start,\n            tend=self.period.end,\n            delt=self.period.interval,\n            tfmt=tfmt,\n            dfmt=dfmt,\n            suffix=\"c\",\n        )\n\n    def _stationary(self, tfmt: str) -&gt; STATIONARY:\n        return STATIONARY(time=self.period.start, tfmt=tfmt)\n\n    @model_validator(mode=\"after\")\n    def time_interface(self) -&gt; \"LockupInterface\":\n        \"\"\"Set the time parameter for COMPUTE components.\"\"\"\n        times = self.group.compute.times or NONSTATIONARY()\n        if isinstance(times, NONSTATIONARY):\n            times = self._nonstationary(times.tfmt, times.dfmt)\n        elif isinstance(times, STATIONARY):\n            times = self._stationary(times.tfmt)\n        else:\n            raise ValueError(f\"Unknown time type {type(times)}\")\n        self.group.compute.times = times\n</code></pre>"},{"location":"#rompy_swan.interface.LockupInterface-attributes","title":"Attributes","text":""},{"location":"#rompy_swan.interface.LockupInterface.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lockupinterface', 'LOCKUPINTERFACE'] = Field(default='lockupinterface', description='Model type discriminator')\n</code></pre>"},{"location":"#rompy_swan.interface.LockupInterface-functions","title":"Functions","text":""},{"location":"#rompy_swan.interface.LockupInterface.time_interface","title":"time_interface","text":"<pre><code>time_interface() -&gt; LockupInterface\n</code></pre> <p>Set the time parameter for COMPUTE components.</p> Source code in <code>rompy_swan/interface.py</code> <pre><code>@model_validator(mode=\"after\")\ndef time_interface(self) -&gt; \"LockupInterface\":\n    \"\"\"Set the time parameter for COMPUTE components.\"\"\"\n    times = self.group.compute.times or NONSTATIONARY()\n    if isinstance(times, NONSTATIONARY):\n        times = self._nonstationary(times.tfmt, times.dfmt)\n    elif isinstance(times, STATIONARY):\n        times = self._stationary(times.tfmt)\n    else:\n        raise ValueError(f\"Unknown time type {type(times)}\")\n    self.group.compute.times = times\n</code></pre>"},{"location":"#types","title":"Types","text":"<p>SWAN types provide valid values for a specific SWAN command line argument.</p> <ul> <li>Types Reference</li> </ul> <p>Link: Literal</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome! Please see the main rompy repository for contributing guidelines.</p>"},{"location":"installation/","title":"Installation","text":"<p>To install rompy-swan, run:</p> <pre><code>pip install rompy-swan\n</code></pre>"},{"location":"types/","title":"Enum Types","text":""},{"location":"types/#rompy_swan.types.IDLA","title":"IDLA","text":"<p>               Bases: <code>IntEnum</code></p> <p>Order of values in the input files.</p>"},{"location":"types/#rompy_swan.types.IDLA--attributes","title":"Attributes","text":"<p>ONE: 1     SWAN reads the map from left to right starting in the upper-left-hand corner of     the map. A new line in the map should start on a new line in the file. TWO: 2     As <code>1</code> but a new line in the map need not start on a new line in the file. THREE: 3     SWAN reads the map from left to right starting in the lower-left-hand corner of     the map. A new line in the map should start on a new line in the file. FOUR: 4     As <code>3</code> but a new line in the map need not start on a new line in the file. FIVE: 5     SWAN reads the map from top to bottom starting in the lower-left-hand corner of     the map. A new column in the map should start on a new line in the file. SIX: 6     As <code>5</code> but a new column in the map need not start on a new line in the file.</p>"},{"location":"types/#rompy_swan.types.IDLA--notes","title":"Notes","text":"<p>It is assumed that the x-axis of the grid is pointing to the right and the y-axis upwards.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class IDLA(IntEnum):\n    \"\"\"Order of values in the input files.\n\n    Attributes\n    ----------\n    ONE: 1\n        SWAN reads the map from left to right starting in the upper-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    TWO: 2\n        As `1` but a new line in the map need not start on a new line in the file.\n    THREE: 3\n        SWAN reads the map from left to right starting in the lower-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    FOUR: 4\n        As `3` but a new line in the map need not start on a new line in the file.\n    FIVE: 5\n        SWAN reads the map from top to bottom starting in the lower-left-hand corner of\n        the map. A new column in the map should start on a new line in the file.\n    SIX: 6\n        As `5` but a new column in the map need not start on a new line in the file.\n\n    Notes\n    -----\n    It is assumed that the x-axis of the grid is pointing to the right and the y-axis\n    upwards.\n\n    \"\"\"\n\n    ONE = 1\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.IDLA.ONE","title":"ONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ONE = 1\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA.TWO","title":"TWO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TWO = 2\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA.THREE","title":"THREE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THREE = 3\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA.FOUR","title":"FOUR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOUR = 4\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA.FIVE","title":"FIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIVE = 5\n</code></pre>"},{"location":"types/#rompy_swan.types.IDLA.SIX","title":"SIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIX = 6\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions","title":"GridOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the input grid type.</p>"},{"location":"types/#rompy_swan.types.GridOptions--attributes","title":"Attributes","text":"<p>BOTTOM: \"bottom\"     Bottom level grid. WLEVEL: \"wlevel\"     Water level grid. CURRENT: \"current\"     Current field grid. VX: \"vx\"     Current field x-component grid. VY: \"vy\"     Current field y-component grid. WIND: \"wind\"     Wind velocity grid. WX: \"wx\"     Wind velocity x-component grid. WY: \"wy\"     Wind velocity y-component grid. FRICTION: \"friction\"     Bottom friction grid. NPLANTS: \"nplants\"     Horizontally varying vegetation density grid. TURBVISC: \"turbvisc\"     Horizontally varying turbulent viscosity grid. MUDLAYER: \"mudlayer\"     Horizontally varying mud layer thickness grid. AICE: \"aice\"     Areal ice fraction grid, a number between 0 and 1. HICE: \"hice\"     Ice thickness grid. HSS: \"hss\"     Sea-swell significant wave height grid. TSS: \"tss\"     Sea-swell mean wave period.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class GridOptions(str, Enum):\n    \"\"\"Valid options for the input grid type.\n\n    Attributes\n    ----------\n    BOTTOM: \"bottom\"\n        Bottom level grid.\n    WLEVEL: \"wlevel\"\n        Water level grid.\n    CURRENT: \"current\"\n        Current field grid.\n    VX: \"vx\"\n        Current field x-component grid.\n    VY: \"vy\"\n        Current field y-component grid.\n    WIND: \"wind\"\n        Wind velocity grid.\n    WX: \"wx\"\n        Wind velocity x-component grid.\n    WY: \"wy\"\n        Wind velocity y-component grid.\n    FRICTION: \"friction\"\n        Bottom friction grid.\n    NPLANTS: \"nplants\"\n        Horizontally varying vegetation density grid.\n    TURBVISC: \"turbvisc\"\n        Horizontally varying turbulent viscosity grid.\n    MUDLAYER: \"mudlayer\"\n        Horizontally varying mud layer thickness grid.\n    AICE: \"aice\"\n        Areal ice fraction grid, a number between 0 and 1.\n    HICE: \"hice\"\n        Ice thickness grid.\n    HSS: \"hss\"\n        Sea-swell significant wave height grid.\n    TSS: \"tss\"\n        Sea-swell mean wave period.\n\n    \"\"\"\n\n    BOTTOM = \"bottom\"\n    WLEVEL = \"wlevel\"\n    CURRENT = \"current\"\n    VX = \"vx\"\n    VY = \"vy\"\n    WIND = \"wind\"\n    WX = \"wx\"\n    WY = \"wy\"\n    FRICTION = \"friction\"\n    NPLANTS = \"nplants\"\n    TURBVISC = \"turbvisc\"\n    MUDLAYER = \"mudlayer\"\n    AICE = \"aice\"\n    HICE = \"hice\"\n    HSS = \"hss\"\n    TSS = \"tss\"\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.GridOptions.BOTTOM","title":"BOTTOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTTOM = 'bottom'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.WLEVEL","title":"WLEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLEVEL = 'wlevel'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.CURRENT","title":"CURRENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT = 'current'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.VX","title":"VX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VX = 'vx'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.VY","title":"VY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VY = 'vy'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.WX","title":"WX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WX = 'wx'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.WY","title":"WY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WY = 'wy'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.FRICTION","title":"FRICTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRICTION = 'friction'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.TURBVISC","title":"TURBVISC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TURBVISC = 'turbvisc'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.MUDLAYER","title":"MUDLAYER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUDLAYER = 'mudlayer'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.HICE","title":"HICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HICE = 'hice'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.HSS","title":"HSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSS = 'hss'\n</code></pre>"},{"location":"types/#rompy_swan.types.GridOptions.TSS","title":"TSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSS = 'tss'\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions","title":"BoundShapeOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"types/#rompy_swan.types.BoundShapeOptions--attributes","title":"Attributes","text":"<p>JONSWAP: \"jonswap\"     JONSWAP spectrum. PM: \"pm\"     Pierson-Moskowitz spectrum. GAUSS: \"gauss\"     Gaussian spectrum. BIN: \"bin\"     Energy at a single bin spectrum. TMA: \"tma\"     TMA spectrum.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class BoundShapeOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    JONSWAP: \"jonswap\"\n        JONSWAP spectrum.\n    PM: \"pm\"\n        Pierson-Moskowitz spectrum.\n    GAUSS: \"gauss\"\n        Gaussian spectrum.\n    BIN: \"bin\"\n        Energy at a single bin spectrum.\n    TMA: \"tma\"\n        TMA spectrum.\n\n    \"\"\"\n\n    JONSWAP = \"jonswap\"\n    PM = \"pm\"\n    GAUSS = \"gauss\"\n    BIN = \"bin\"\n    TMA = \"tma\"\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.BoundShapeOptions.JONSWAP","title":"JONSWAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JONSWAP = 'jonswap'\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions.PM","title":"PM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PM = 'pm'\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions.GAUSS","title":"GAUSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAUSS = 'gauss'\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions.BIN","title":"BIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIN = 'bin'\n</code></pre>"},{"location":"types/#rompy_swan.types.BoundShapeOptions.TMA","title":"TMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMA = 'tma'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions","title":"SideOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"types/#rompy_swan.types.SideOptions--attributes","title":"Attributes","text":"<p>NORTH: \"north\"     North side. NW: \"nw\"     North-west side. WEST: \"west\"     West side. SW: \"sw\"     South-west side. SOUTH: \"south\"     South side. SE: \"se\"     South-east side. EAST: \"east\"     East side. NE: \"ne\"     North-east side.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class SideOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    NORTH: \"north\"\n        North side.\n    NW: \"nw\"\n        North-west side.\n    WEST: \"west\"\n        West side.\n    SW: \"sw\"\n        South-west side.\n    SOUTH: \"south\"\n        South side.\n    SE: \"se\"\n        South-east side.\n    EAST: \"east\"\n        East side.\n    NE: \"ne\"\n        North-east side.\n\n    \"\"\"\n\n    NORTH = \"north\"\n    NW = \"nw\"\n    WEST = \"west\"\n    SW = \"sw\"\n    SOUTH = \"south\"\n    SE = \"se\"\n    EAST = \"east\"\n    NE = \"ne\"\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.SideOptions.NORTH","title":"NORTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NORTH = 'north'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.NW","title":"NW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NW = 'nw'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.WEST","title":"WEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEST = 'west'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.SW","title":"SW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SW = 'sw'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.SOUTH","title":"SOUTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOUTH = 'south'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.SE","title":"SE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SE = 'se'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.EAST","title":"EAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EAST = 'east'\n</code></pre>"},{"location":"types/#rompy_swan.types.SideOptions.NE","title":"NE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NE = 'ne'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff","title":"PhysicsOff","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Physics commands to be switched off.</p>"},{"location":"types/#rompy_swan.types.PhysicsOff--attributes","title":"Attributes","text":"<p>WINDGROWTH : str = \"windgrowth\"     Switches off wind growth (in commands GEN1, GEN2, GEN3). QUADRUPL : str = \"quadrupl\"     Switches off quadruplet wave interactions (in command GEN3). WCAPPING : str = \"wcapping\"     Switches off whitecapping (in command GEN3). BREAKING : str = \"breaking\"     Switches off wave breaking dissipation. REFRAC : str = \"refrac\"     Switches off wave refraction (action transport in theta space). FSHIFT : str = \"fshift\"     Switches off frequency shifting (action transport in sigma space). BNDCHK : str = \"bndchk\"     Switches off the checking of the delta imposed and computed Hs at the boundary.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class PhysicsOff(str, Enum):\n    \"\"\"Physics commands to be switched off.\n\n    Attributes\n    ----------\n    WINDGROWTH : str = \"windgrowth\"\n        Switches off wind growth (in commands GEN1, GEN2, GEN3).\n    QUADRUPL : str = \"quadrupl\"\n        Switches off quadruplet wave interactions (in command GEN3).\n    WCAPPING : str = \"wcapping\"\n        Switches off whitecapping (in command GEN3).\n    BREAKING : str = \"breaking\"\n        Switches off wave breaking dissipation.\n    REFRAC : str = \"refrac\"\n        Switches off wave refraction (action transport in theta space).\n    FSHIFT : str = \"fshift\"\n        Switches off frequency shifting (action transport in sigma space).\n    BNDCHK : str = \"bndchk\"\n        Switches off the checking of the delta imposed and computed Hs at the boundary.\n\n    \"\"\"\n\n    WINDGROWTH = \"windgrowth\"\n    QUADRUPL = \"quadrupl\"\n    WCAPPING = \"wcapping\"\n    BREAKING = \"breaking\"\n    REFRAC = \"refrac\"\n    FSHIFT = \"fshift\"\n    BNDCHK = \"bndchk\"\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.PhysicsOff.WINDGROWTH","title":"WINDGROWTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDGROWTH = 'windgrowth'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.QUADRUPL","title":"QUADRUPL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUADRUPL = 'quadrupl'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.WCAPPING","title":"WCAPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WCAPPING = 'wcapping'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.BREAKING","title":"BREAKING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BREAKING = 'breaking'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.REFRAC","title":"REFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REFRAC = 'refrac'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.FSHIFT","title":"FSHIFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSHIFT = 'fshift'\n</code></pre>"},{"location":"types/#rompy_swan.types.PhysicsOff.BNDCHK","title":"BNDCHK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BNDCHK = 'bndchk'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions","title":"BlockOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for block output parameters.</p>"},{"location":"types/#rompy_swan.types.BlockOptions--attributes","title":"Attributes","text":"<p>HSIGN: \"hsign\"     Significant wave height (in m). HSWELL: \"hswell\"     Swell wave height (in m). DIR: \"dir\"     Mean wave direction (in degrees). DPM: \"dpm\"     Mean wave direction at the peak frequency (in degrees). PDIR: \"pdir\"     Peak wave direction (in degrees). TDIR: \"tdir\"     Direction of energy transport (in degrees). TM01: \"tm01\"     Mean absolute wave period (in s). RTM01: \"rtm01\"     Mean relative wave period (in s). RTP: \"rtp\"     Peak period of the (relative frequency) variance density spectrum (in s). TPS: \"tps\"     Smoothed peak period (in s). PER: \"per\"     Mean absolute wave period (in s). RPER: \"rper\"     Mean relative wave period (in s). TMM10: \"tmm10\"     Mean absolute wave period (in s). RTMM10: \"rtmm10\"     Mean relative wave period (in s). TM02: \"tm02\"     Mean absolute zero-crossing period (in s). FSPR: \"fspr\"     The normalised width of the frequency spectrum. DSPR: \"dspr\"     Directional spreading of the waves (in degrees). QP: \"qp\"     Peakedness of the wave spectrum (dimensionless). DEPTH: \"depth\"     Water depth (in m). WATLEV: \"watlev\"     Water level (in m). BOTLEV: \"botlev\"     Bottom level (in m). VEL: \"vel\"     Current velocity (vector; in m/s). FRCOEF: \"frcoef\"     Friction coefficient (equal to <code>cfw</code> or <code>kn</code> in command <code>FRICTION</code>). WIND: \"wind\"     Wind velocity (vector; in m/s). AICE: \"aice\"     Ice concentration (as a fraction from 0 to 1). PROPAGAT: \"propagat\"     Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s). PROPXY: \"propxy\"     Energy propagation in geographic space; sum of x- and y-direction     (in W/m2 or m2/s). PROPTHETA: \"proptheta\"     Energy propagation in theta space (in W/m2 or m2/s). PROPSIGMA: \"propsigma\"     Energy propagation in sigma space (in W/m2 or m2/s). GENERAT: \"generat\"     Total energy generation (in W/m2 or m2/s). GENWIND: \"genwind\"     Energy generation due to wind (in W/m2 or m2/s). REDIST: \"redist\"     Total energy redistribution (in W/m2 or m2/s). REDQUAD: \"redquad\"     Energy redistribution due to quadruplets (in W/m2 or m2/s). REDTRIAD: \"redtriad\"     Energy redistribution due to triads (in W/m2 or m2/s). DISSIP: \"dissip\"     Total energy dissipation (in W/m2 or m2/s). DISBOT: \"disbot\"     Energy dissipation due to bottom friction (in W/m2 or m2/s). DISSURF: \"dissurf\"     Energy dissipation due to surf breaking (in W/m2 or m2/s). DISWCAP: \"diswcap\"     Energy dissipation due to whitecapping (in W/m2 or m2/s). DISSWELL: \"disswell\"     Energy dissipation due to swell dissipation (in W/m2 or m2/s). DISVEG: \"disveg\"     Energy dissipation due to vegetation (in W/m2 or m2/s). DISMUD: \"dismud\"     Energy dissipation due to mud (in W/m2 or m2/s). DISICE: \"disice\"     Energy dissipation due to sea ice (in W/m2 or m2/s). RADSTR: \"radstr\"     Energy transfer between waves and currents due to radiation stress     (in W/m2 or m2/s). QB: \"qb\"     Fraction of breaking waves due to depth-induced breaking. TRANSP: \"transp\"     Transport of energy (vector; in W/m2 or m2/s). FORCE: \"force\"     Wave-induced force per unit surface area (vector; in N/m2). UBOT: \"ubot\"     The rms-value of the maxima of the orbital velocity near the bottom (in m/s). URMS: \"urms\"     The rms-value of the orbital velocity near the bottom (in m/s). TMBOT: \"tmbot\"     The bottom wave period (in s). WLENGTH: \"wlength\"     Average wave length (in m). LWAVP: \"lwavp\"     Peak wave length (in m). STEEPNESS: \"steepness\"     Average wave steepness (dimensionless). BFI: \"bfi\"     Benjamin-Feir index (dimensionless). NPLANTS: \"nplants\"     Number of plants per square meter. DHSIGN: \"dhsign\"     Difference in significant wave height from the last two iterations (in m). DRTM01: \"drtm01\"     Difference in average wave period (RTM01) from the last two iterations (in s). LEAK: \"leak\"     Numerical loss of energy equal to <code>cthetaE(omega,theta)</code> across boundaries. TIME: \"time\"     Full date-time string as part of line used in TABLE only. TSEC: \"tsec\"     Time in seconds with respect to a reference time (see command QUANTITY). XP: \"xp\"     The x-coordinate in the problem coordinate system of the output location. YP: \"yp\"     The y-coordinate in the problem coordinate system of the output location. DIST: \"dist\"     If output has been requested along a curve then the distance along the curve     can be obtained with the command TABLE. DIST is the distance along the curve     measured from teh first point on the curve to the output location on the curve     in meters (also in the case of spherical coordinates). SETUP: \"setup\"     Set-up due to waves (in m). PTHSIGN: \"pthsign\"     Watershed partitions of the significant wave height (in m). PTRTP: \"ptrtp\"     Watershed partitions of the relative peak period (in s). PTWLEN: \"ptwlen\"     Watershed partitions of the average wave length (in m). PTDIR: \"ptdir\"     Watershed partitions of the peak wave direction (in degrees). PTDSPR: \"ptdspr\"     Watershed partitions of the directional spreading (in degrees). PTWFRAC: \"ptwfrac\"     Watershed partitions of the wind fraction (dimensionless). PTSTEEPNE: \"ptsteepne\"     Watershed partition of the wave steepness (dimensionless). PARTITION: \"partition\"     The raw spectral partition for wave system tracking post-processing.</p>"},{"location":"types/#rompy_swan.types.BlockOptions--note","title":"Note","text":"<p>Energy given in W/m2 or m2/s depending on command SET.</p>"},{"location":"types/#rompy_swan.types.BlockOptions--note_1","title":"Note","text":"<p>UBOT and URMS required command <code>FRICTION</code> to be used. If friction is ignored in the computation, then one should use the command <code>FRICTION</code> with the value of the friction set to zero (e.g., <code>FRICTION COLLINS 0</code>).</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class BlockOptions(str, Enum):\n    \"\"\"Valid options for block output parameters.\n\n    Attributes\n    ----------\n    HSIGN: \"hsign\"\n        Significant wave height (in m).\n    HSWELL: \"hswell\"\n        Swell wave height (in m).\n    DIR: \"dir\"\n        Mean wave direction (in degrees).\n    DPM: \"dpm\"\n        Mean wave direction at the peak frequency (in degrees).\n    PDIR: \"pdir\"\n        Peak wave direction (in degrees).\n    TDIR: \"tdir\"\n        Direction of energy transport (in degrees).\n    TM01: \"tm01\"\n        Mean absolute wave period (in s).\n    RTM01: \"rtm01\"\n        Mean relative wave period (in s).\n    RTP: \"rtp\"\n        Peak period of the (relative frequency) variance density spectrum (in s).\n    TPS: \"tps\"\n        Smoothed peak period (in s).\n    PER: \"per\"\n        Mean absolute wave period (in s).\n    RPER: \"rper\"\n        Mean relative wave period (in s).\n    TMM10: \"tmm10\"\n        Mean absolute wave period (in s).\n    RTMM10: \"rtmm10\"\n        Mean relative wave period (in s).\n    TM02: \"tm02\"\n        Mean absolute zero-crossing period (in s).\n    FSPR: \"fspr\"\n        The normalised width of the frequency spectrum.\n    DSPR: \"dspr\"\n        Directional spreading of the waves (in degrees).\n    QP: \"qp\"\n        Peakedness of the wave spectrum (dimensionless).\n    DEPTH: \"depth\"\n        Water depth (in m).\n    WATLEV: \"watlev\"\n        Water level (in m).\n    BOTLEV: \"botlev\"\n        Bottom level (in m).\n    VEL: \"vel\"\n        Current velocity (vector; in m/s).\n    FRCOEF: \"frcoef\"\n        Friction coefficient (equal to `cfw` or `kn` in command `FRICTION`).\n    WIND: \"wind\"\n        Wind velocity (vector; in m/s).\n    AICE: \"aice\"\n        Ice concentration (as a fraction from 0 to 1).\n    PROPAGAT: \"propagat\"\n        Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s).\n    PROPXY: \"propxy\"\n        Energy propagation in geographic space; sum of x- and y-direction\n        (in W/m2 or m2/s).\n    PROPTHETA: \"proptheta\"\n        Energy propagation in theta space (in W/m2 or m2/s).\n    PROPSIGMA: \"propsigma\"\n        Energy propagation in sigma space (in W/m2 or m2/s).\n    GENERAT: \"generat\"\n        Total energy generation (in W/m2 or m2/s).\n    GENWIND: \"genwind\"\n        Energy generation due to wind (in W/m2 or m2/s).\n    REDIST: \"redist\"\n        Total energy redistribution (in W/m2 or m2/s).\n    REDQUAD: \"redquad\"\n        Energy redistribution due to quadruplets (in W/m2 or m2/s).\n    REDTRIAD: \"redtriad\"\n        Energy redistribution due to triads (in W/m2 or m2/s).\n    DISSIP: \"dissip\"\n        Total energy dissipation (in W/m2 or m2/s).\n    DISBOT: \"disbot\"\n        Energy dissipation due to bottom friction (in W/m2 or m2/s).\n    DISSURF: \"dissurf\"\n        Energy dissipation due to surf breaking (in W/m2 or m2/s).\n    DISWCAP: \"diswcap\"\n        Energy dissipation due to whitecapping (in W/m2 or m2/s).\n    DISSWELL: \"disswell\"\n        Energy dissipation due to swell dissipation (in W/m2 or m2/s).\n    DISVEG: \"disveg\"\n        Energy dissipation due to vegetation (in W/m2 or m2/s).\n    DISMUD: \"dismud\"\n        Energy dissipation due to mud (in W/m2 or m2/s).\n    DISICE: \"disice\"\n        Energy dissipation due to sea ice (in W/m2 or m2/s).\n    RADSTR: \"radstr\"\n        Energy transfer between waves and currents due to radiation stress\n        (in W/m2 or m2/s).\n    QB: \"qb\"\n        Fraction of breaking waves due to depth-induced breaking.\n    TRANSP: \"transp\"\n        Transport of energy (vector; in W/m2 or m2/s).\n    FORCE: \"force\"\n        Wave-induced force per unit surface area (vector; in N/m2).\n    UBOT: \"ubot\"\n        The rms-value of the maxima of the orbital velocity near the bottom (in m/s).\n    URMS: \"urms\"\n        The rms-value of the orbital velocity near the bottom (in m/s).\n    TMBOT: \"tmbot\"\n        The bottom wave period (in s).\n    WLENGTH: \"wlength\"\n        Average wave length (in m).\n    LWAVP: \"lwavp\"\n        Peak wave length (in m).\n    STEEPNESS: \"steepness\"\n        Average wave steepness (dimensionless).\n    BFI: \"bfi\"\n        Benjamin-Feir index (dimensionless).\n    NPLANTS: \"nplants\"\n        Number of plants per square meter.\n    DHSIGN: \"dhsign\"\n        Difference in significant wave height from the last two iterations (in m).\n    DRTM01: \"drtm01\"\n        Difference in average wave period (RTM01) from the last two iterations (in s).\n    LEAK: \"leak\"\n        Numerical loss of energy equal to `cthetaE(omega,theta)` across boundaries.\n    TIME: \"time\"\n        Full date-time string as part of line used in TABLE only.\n    TSEC: \"tsec\"\n        Time in seconds with respect to a reference time (see command QUANTITY).\n    XP: \"xp\"\n        The x-coordinate in the problem coordinate system of the output location.\n    YP: \"yp\"\n        The y-coordinate in the problem coordinate system of the output location.\n    DIST: \"dist\"\n        If output has been requested along a curve then the distance along the curve\n        can be obtained with the command TABLE. DIST is the distance along the curve\n        measured from teh first point on the curve to the output location on the curve\n        in meters (also in the case of spherical coordinates).\n    SETUP: \"setup\"\n        Set-up due to waves (in m).\n    PTHSIGN: \"pthsign\"\n        Watershed partitions of the significant wave height (in m).\n    PTRTP: \"ptrtp\"\n        Watershed partitions of the relative peak period (in s).\n    PTWLEN: \"ptwlen\"\n        Watershed partitions of the average wave length (in m).\n    PTDIR: \"ptdir\"\n        Watershed partitions of the peak wave direction (in degrees).\n    PTDSPR: \"ptdspr\"\n        Watershed partitions of the directional spreading (in degrees).\n    PTWFRAC: \"ptwfrac\"\n        Watershed partitions of the wind fraction (dimensionless).\n    PTSTEEPNE: \"ptsteepne\"\n        Watershed partition of the wave steepness (dimensionless).\n    PARTITION: \"partition\"\n        The raw spectral partition for wave system tracking post-processing.\n\n    Note\n    ----\n    Energy given in W/m2 or m2/s depending on command SET.\n\n    Note\n    ----\n    UBOT and URMS required command `FRICTION` to be used. If friction is ignored in the\n    computation, then one should use the command `FRICTION` with the value of the\n    friction set to zero (e.g., `FRICTION COLLINS 0`).\n\n    \"\"\"\n\n    HSIGN = \"hsign\"\n    HSWELL = \"hswell\"\n    DIR = \"dir\"\n    DPM = \"dpm\"\n    PDIR = \"pdir\"\n    TDIR = \"tdir\"\n    TM01 = \"tm01\"\n    RTM01 = \"rtm01\"\n    RTP = \"rtp\"\n    TPS = \"tps\"\n    PER = \"per\"\n    RPER = \"rper\"\n    TMM10 = \"tmm10\"\n    RTMM10 = \"rtmm10\"\n    TM02 = \"tm02\"\n    FSPR = \"fspr\"\n    DSPR = \"dspr\"\n    QP = \"qp\"\n    DEPTH = \"depth\"\n    WATLEV = \"watlev\"\n    BOTLEV = \"botlev\"\n    VEL = \"vel\"\n    FRCOEF = \"frcoef\"\n    WIND = \"wind\"\n    AICE = \"aice\"\n    PROPAGAT = \"propagat\"\n    PROPXY = \"propxy\"\n    PROPTHETA = \"proptheta\"\n    PROPSIGMA = \"propsigma\"\n    GENERAT = \"generat\"\n    GENWIND = \"genwind\"\n    REDIST = \"redist\"\n    REDQUAD = \"redquad\"\n    REDTRIAD = \"redtriad\"\n    DISSIP = \"dissip\"\n    DISBOT = \"disbot\"\n    DISSURF = \"dissurf\"\n    DISWCAP = \"diswcap\"\n    DISSWELL = \"disswell\"\n    DISVEG = \"disveg\"\n    DISMUD = \"dismud\"\n    DISICE = \"disice\"\n    RADSTR = \"radstr\"\n    QB = \"qb\"\n    TRANSP = \"transp\"\n    FORCE = \"force\"\n    UBOT = \"ubot\"\n    URMS = \"urms\"\n    TMBOT = \"tmbot\"\n    WLENGTH = \"wlength\"\n    LWAVP = \"lwavp\"\n    STEEPNESS = \"steepness\"\n    BFI = \"bfi\"\n    NPLANTS = \"nplants\"\n    DHSIGN = \"dhsign\"\n    DRTM01 = \"drtm01\"\n    LEAK = \"leak\"\n    TIME = \"time\"\n    TSEC = \"tsec\"\n    XP = \"xp\"\n    YP = \"yp\"\n    DIST = \"dist\"\n    SETUP = \"setup\"\n    PTHSIGN = \"pthsign\"\n    PTRTP = \"ptrtp\"\n    PTWLEN = \"ptwlen\"\n    PTDIR = \"ptdir\"\n    PTDSPR = \"ptdspr\"\n    PTWFRAC = \"ptwfrac\"\n    PTSTEEPNE = \"ptsteepne\"\n    PARTITION = \"partition\"\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions-attributes","title":"Attributes","text":""},{"location":"types/#rompy_swan.types.BlockOptions.HSIGN","title":"HSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSIGN = 'hsign'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.HSWELL","title":"HSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSWELL = 'hswell'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DIR","title":"DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIR = 'dir'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DPM","title":"DPM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DPM = 'dpm'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PDIR","title":"PDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PDIR = 'pdir'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TDIR","title":"TDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TDIR = 'tdir'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TM01","title":"TM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM01 = 'tm01'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.RTM01","title":"RTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTM01 = 'rtm01'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.RTP","title":"RTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTP = 'rtp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TPS","title":"TPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TPS = 'tps'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PER","title":"PER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PER = 'per'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.RPER","title":"RPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RPER = 'rper'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TMM10","title":"TMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMM10 = 'tmm10'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.RTMM10","title":"RTMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTMM10 = 'rtmm10'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TM02","title":"TM02  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM02 = 'tm02'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.FSPR","title":"FSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSPR = 'fspr'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DSPR","title":"DSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DSPR = 'dspr'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.QP","title":"QP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QP = 'qp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DEPTH","title":"DEPTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEPTH = 'depth'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.WATLEV","title":"WATLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WATLEV = 'watlev'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.BOTLEV","title":"BOTLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTLEV = 'botlev'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.VEL","title":"VEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VEL = 'vel'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.FRCOEF","title":"FRCOEF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRCOEF = 'frcoef'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PROPAGAT","title":"PROPAGAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPAGAT = 'propagat'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PROPXY","title":"PROPXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPXY = 'propxy'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PROPTHETA","title":"PROPTHETA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPTHETA = 'proptheta'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PROPSIGMA","title":"PROPSIGMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPSIGMA = 'propsigma'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.GENERAT","title":"GENERAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAT = 'generat'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.GENWIND","title":"GENWIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENWIND = 'genwind'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.REDIST","title":"REDIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDIST = 'redist'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.REDQUAD","title":"REDQUAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDQUAD = 'redquad'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.REDTRIAD","title":"REDTRIAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDTRIAD = 'redtriad'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISSIP","title":"DISSIP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSIP = 'dissip'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISBOT","title":"DISBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISBOT = 'disbot'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISSURF","title":"DISSURF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSURF = 'dissurf'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISWCAP","title":"DISWCAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISWCAP = 'diswcap'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISSWELL","title":"DISSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSWELL = 'disswell'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISVEG","title":"DISVEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISVEG = 'disveg'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISMUD","title":"DISMUD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISMUD = 'dismud'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DISICE","title":"DISICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISICE = 'disice'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.RADSTR","title":"RADSTR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RADSTR = 'radstr'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.QB","title":"QB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QB = 'qb'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TRANSP","title":"TRANSP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSP = 'transp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.FORCE","title":"FORCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCE = 'force'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.UBOT","title":"UBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UBOT = 'ubot'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.URMS","title":"URMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>URMS = 'urms'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TMBOT","title":"TMBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMBOT = 'tmbot'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.WLENGTH","title":"WLENGTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLENGTH = 'wlength'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.LWAVP","title":"LWAVP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LWAVP = 'lwavp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.STEEPNESS","title":"STEEPNESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STEEPNESS = 'steepness'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.BFI","title":"BFI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BFI = 'bfi'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DHSIGN","title":"DHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DHSIGN = 'dhsign'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DRTM01","title":"DRTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRTM01 = 'drtm01'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.LEAK","title":"LEAK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LEAK = 'leak'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TIME","title":"TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME = 'time'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.TSEC","title":"TSEC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSEC = 'tsec'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.XP","title":"XP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XP = 'xp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.YP","title":"YP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YP = 'yp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.DIST","title":"DIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIST = 'dist'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.SETUP","title":"SETUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SETUP = 'setup'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTHSIGN","title":"PTHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTHSIGN = 'pthsign'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTRTP","title":"PTRTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTRTP = 'ptrtp'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTWLEN","title":"PTWLEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWLEN = 'ptwlen'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTDIR","title":"PTDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDIR = 'ptdir'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTDSPR","title":"PTDSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDSPR = 'ptdspr'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTWFRAC","title":"PTWFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWFRAC = 'ptwfrac'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PTSTEEPNE","title":"PTSTEEPNE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTSTEEPNE = 'ptsteepne'\n</code></pre>"},{"location":"types/#rompy_swan.types.BlockOptions.PARTITION","title":"PARTITION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTITION = 'partition'\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Rompy SWAN plugin provides functionality for SWAN wave model configuration and execution.</p>"},{"location":"components/boundary/","title":"Boundary and initial conditions","text":"<p>SWAN boundary and initial conditions commands</p>"},{"location":"components/boundary/#boundary","title":"Boundary","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC","title":"BOUNDSPEC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary along sides or segment.</p> <p>.. code-block:: text</p> <pre><code>BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n</code></pre> <p>This command BOUNDSPEC defines parametric spectra at the boundary. It consists of two parts, the first part defines the boundary side or segment where the spectra will be given, the second part defines the spectral parameters of these spectra. Note that in fact only the incoming wave components of these spectra are used by SWAN. The fact that complete spectra are calculated at the model boundaries from the spectral parameters should not be misinterpreted. Only the incoming components are effective in the computation.</p> <p>TODO: Add support for unstructured grid (k).</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDSPEC\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\nboundary = BOUNDSPEC(\n    shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n    location=dict(\n        model_type=\"segment\",\n        points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n    ),\n    data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n)\nprint(boundary.render())\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>class BOUNDSPEC(BaseComponent):\n    \"\"\"Boundary along sides or segment.\n\n    .. code-block:: text\n\n        BOUNDSPEC -&gt;SIDE|SEGMENT CONSTANT|VARIABLE PAR|FILE\n\n    This command BOUNDSPEC defines parametric spectra at the boundary. It consists of\n    two parts, the first part defines the boundary side or segment where the spectra\n    will be given, the second part defines the spectral parameters of these spectra.\n    Note that in fact only the incoming wave components of these spectra are used by\n    SWAN. The fact that complete spectra are calculated at the model boundaries from\n    the spectral parameters should not be misinterpreted. Only the incoming components\n    are effective in the computation.\n\n    TODO: Add support for unstructured grid (k).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDSPEC\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(model_type=\"side\", side=\"west\", direction=\"ccw\"),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n        boundary = BOUNDSPEC(\n            shapespec=dict(model_type=\"shapespec\", shape=dict(model_type=\"pm\")),\n            location=dict(\n                model_type=\"segment\",\n                points=dict(model_type=\"ij\", i=[0, 0], j=[0, 3])\n            ),\n            data=dict(model_type=\"constantpar\", hs=2, per=8, dir=270, dd=30),\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundspec\", \"BOUNDSPEC\"] = Field(\n        default=\"boundspec\",\n        description=\"Model type discriminator\",\n    )\n    shapespec: SHAPESPEC = Field(\n        default_factory=SHAPESPEC,\n        description=\"Spectral shape specification\",\n    )\n    location: SIDE | SEGMENT = Field(\n        description=\"Location to apply the boundary\",\n    )\n    data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(\n        description=\"Spectral data\",\n    )\n\n    def cmd(self) -&gt; list:\n        repr = [f\"{self.shapespec.render()}\"]\n        repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundspec', 'BOUNDSPEC'] = Field(default='boundspec', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.shapespec","title":"shapespec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shapespec: SHAPESPEC = Field(default_factory=SHAPESPEC, description='Spectral shape specification')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SIDE | SEGMENT = Field(description='Location to apply the boundary')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: CONSTANTPAR | CONSTANTFILE | VARIABLEPAR | VARIABLEFILE = Field(description='Spectral data')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDSPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = [f\"{self.shapespec.render()}\"]\n    repr += [f\"BOUNDSPEC {self.location.render()}{self.data.render()}\"]\n    return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1","title":"BOUNDNEST1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from a coarser SWAN nest.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid SWAN run (generated in that previous SWAN run with command NESTOUT). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid run, use command NGRID. For the nested run, use the command CGRID with identical geographical information except the number of meshes (which will be much higher for the nested run). This BOUNDNEST1 command is not available for 1D computations; in such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A nested SWAN run must use the same coordinate system as the coarse grid SWAN run. For a curvilinear grid, it is advised to use the commands POINTS or CURVE and SPECOUT instead of NGRID and NESTOUT.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST1\nboundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\nprint(boundary.render())\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST1(BaseComponent):\n    \"\"\"Boundary spectra from a coarser SWAN nest.\n\n    .. code-block:: text\n\n        BOUNDNEST1 NEST 'fname' -&gt;CLOSED|OPEN\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid SWAN run (generated in that previous SWAN\n    run with command NESTOUT). The spectral frequencies and directions of the coarse\n    grid run do not have to coincide with the frequencies and directions used in the\n    nested SWAN run; SWAN will interpolate to these frequencies and directions in the\n    nested run (see Section 2.6.3). To generate the nest boundary in the coarse grid\n    run, use command NGRID. For the nested run, use the command CGRID with identical\n    geographical information except the number of meshes (which will be much higher for\n    the nested run). This BOUNDNEST1 command is not available for 1D computations; in\n    such cases the commands SPECOUT and BOUNDSPEC can be used for the same purpose. A\n    nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n    For a curvilinear grid, it is advised to use the commands POINTS or CURVE and\n    SPECOUT instead of NGRID and NESTOUT.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST1\n        boundary = BOUNDNEST1(fname=\"boundary.swn\", rectangle=\"closed\")\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest1\", \"BOUNDNEST1\"] = Field(\n        default=\"boundnest1\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"Name of the file containing the boundary conditions for the present run, \"\n            \"created by the previous SWAN coarse grid run. This file is structured \"\n            \"according to the rules given in Appendix D for 2D spectra\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest1', 'BOUNDNEST1'] = Field(default='boundnest1', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the boundary conditions for the present run, created by the previous SWAN coarse grid run. This file is structured according to the rules given in Appendix D for 2D spectra', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST1.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"BOUNDNEST1 NEST fname='{self.fname}' {self.rectangle.upper()}\"\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2","title":"BOUNDNEST2","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAM.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n</code></pre> <p>With this optional command (not fully tested) a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5, source code as distributed by the Max Planck Institute in Hamburg). The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). Note that SWAN will accept output of a WAM output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAM output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAM output locations. This BOUNDNEST2 command is not available for 1D computations. Only boundary conditions generated by WAM Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries. WAM output files are unformatted (binary); this usually implies that WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN run on different types of machines (binary files do not transfer properly), the option FREE is available in this command. The distributed version of WAM does not support the required free format nesting output; WAM users who modify WAM such that it can make formatted output, must modify WAM such that the files made by WAM can be read in free format, i.e. with at least a blank or comma between numbers.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2--note","title":"Note","text":"<p>the contents of 'fname' file could look like:</p> <p>.. code-block:: text</p> <pre><code>CBO9212010000\nCBO9212020000\nCBO9212030000\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST2\nboundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\nprint(boundary.render())\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST2(BaseComponent):\n    \"\"\"Boundary spectra from WAM.\n\n    .. code-block:: text\n\n        BOUNDNEST2 WAMNEST 'fname' FREE|UNFORMATTED -&gt;CRAY|WKSTAT [xgc] [ygc] [lwdate]\n\n    With this optional command (not fully tested) a nested SWAN run can be carried out\n    with the boundary conditions obtained from a coarse grid WAM run (WAM Cycle 4.5,\n    source code as distributed by the Max Planck Institute in Hamburg). The spectral\n    frequencies and directions of the coarse grid run do not have to coincide with the\n    frequencies and directions used in the nested SWAN run; SWAN will interpolate to\n    these frequencies and directions in the nested run (see Section 2.6.3). Note that\n    SWAN will accept output of a WAM output location only if the SWAN grid point on the\n    nest boundary lies within a rectangle between two consecutive WAM output locations\n    with a width equal to 0.1 times the distance between these output locations on\n    either side of the line between these WAM output locations. This BOUNDNEST2 command\n    is not available for 1D computations. Only boundary conditions generated by WAM\n    Cycle 4.5 can be read properly by SWAN. A nested SWAN run may use either Cartesian\n    or spherical coordinates. A curvilinear grid may be used in the nested grid but the\n    boundaries of this nest should conform to the rectangular course grid nest\n    boundaries. WAM output files are unformatted (binary); this usually implies that\n    WAM and SWAN have to run on the same computer. For those cases where WAM and SWAN\n    run on different types of machines (binary files do not transfer properly), the\n    option FREE is available in this command. The distributed version of WAM does not\n    support the required free format nesting output; WAM users who modify WAM such that\n    it can make formatted output, must modify WAM such that the files made by WAM can\n    be read in free format, i.e. with at least a blank or comma between numbers.\n\n    Note\n    ----\n    the contents of 'fname' file could look like:\n\n    .. code-block:: text\n\n        CBO9212010000\n        CBO9212020000\n        CBO9212030000\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST2\n        boundary = BOUNDNEST2(fname=\"boundary.wam\", format=\"cray\", lwdate=12)\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest2\", \"BOUNDNEST2\"] = Field(\n        default=\"boundnest2\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"A file name that contains all the names of WAM files containing the \"\n            \"nested boundary conditions in time-sequence (usually one file per day)\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"cray\", \"wkstat\", \"free\"] = Field(\n        description=(\n            \"Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: \"\n            \"WORKSTATION version of WAM, `free`: Free format (these files are not \"\n            \"generated standard by WAM)\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file\"\n        ),\n    )\n    lwdate: Literal[10, 12, 14] = Field(\n        default=12,\n        description=(\n            \"Length of character string for date-time as used in the WAM files. \"\n            \"Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) \"\n            \"or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)\"\n        ),\n    )\n\n    @property\n    def format_str(self):\n        if self.format == \"cray\":\n            return \"UNFORMATTED CRAY\"\n        elif self.format == \"wkstat\":\n            return \"UNFORMATTED WKSTAT\"\n        elif self.format == \"free\":\n            return \"FREE\"\n        else:\n            raise ValueError(f\"Unknown format {self.format}\")\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        repr += f\" lwdate={self.lwdate}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest2', 'BOUNDNEST2'] = Field(default='boundnest2', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='A file name that contains all the names of WAM files containing the nested boundary conditions in time-sequence (usually one file per day)', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['cray', 'wkstat', 'free'] = Field(description='Format of the WAM file. `cray`: CRAY version of WAM, `wkstat`: WORKSTATION version of WAM, `free`: Free format (these files are not generated standard by WAM)')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.lwdate","title":"lwdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lwdate: Literal[10, 12, 14] = Field(default=12, description='Length of character string for date-time as used in the WAM files. Possible values are: 10 (i.e. YYMMDDHHMM), 12 (i.e. YYMMDDHHMMSS) or 14 (i.e. YYYYMMDDHHMMSS) (SWAN default: `lwdate` = 12)')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.format_str","title":"format_str  <code>property</code>","text":"<pre><code>format_str\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST2.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST2 WAMNEST fname='{self.fname}' {self.format_str}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    repr += f\" lwdate={self.lwdate}\"\n    return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3","title":"BOUNDNEST3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Boundary spectra from WAVEWATCHIII.</p> <p>.. code-block:: text</p> <pre><code>BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n</code></pre> <p>With this optional command a nested SWAN run can be carried out with the boundary conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies and directions of the coarse grid run do not have to coincide with the frequencies and directions used in the nested SWAN run; SWAN will interpolate to these frequencies and directions in the nested run (see Section 2.6.3). The output files of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub type 3) at the locations along the nest boundary (i.e. computational grid points in WAVEWATCH III). These locations are equal to the corner points of the SWAN nested grid and optionally also distributed between the corner points of the SWAN nested grid (the boundary of the WAVEWATCH III nested grid need not be closed and may cover land). The locations should be output by WAVEWATCH III in sequence (going along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept output of a WAVEWATCH III output location only if the SWAN grid point on the nest boundary lies within a rectangle between two consecutive WAVEWATCH III output locations with a width equal to 0.1 times the distance between these output locations on either side of the line between these WAVEWATCH III output locations. This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may use either Cartesian or spherical coordinates. A curvilinear grid may be used in the nested grid but the boundaries of this nest should conform to the rectangular course grid nest boundaries.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import BOUNDNEST3\nboundary = BOUNDNEST3(\n    fname=\"boundary.ww3\",\n    format=\"free\",\n    rectangle=\"closed\",\n)\nprint(boundary.render())\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>class BOUNDNEST3(BaseComponent):\n    \"\"\"Boundary spectra from WAVEWATCHIII.\n\n    .. code-block:: text\n\n        BOUNDNEST3 WW3 'fname' FREE|UNFORMATTED -&gt;CLOSED|OPEN [xgc] [ygc]\n\n    With this optional command a nested SWAN run can be carried out with the boundary\n    conditions obtained from a coarse grid WAVEWATCH III run. The spectral frequencies\n    and directions of the coarse grid run do not have to coincide with the frequencies\n    and directions used in the nested SWAN run; SWAN will interpolate to these\n    frequencies and directions in the nested run (see Section 2.6.3). The output files\n    of WAVEWATCH III have to be created with the post-processor of WAVEWATCH III as\n    output transfer files (formatted or unformatted) with WW_3 OUTP (output type 1 sub\n    type 3) at the locations along the nest boundary (i.e. computational grid points in\n    WAVEWATCH III). These locations are equal to the corner points of the SWAN nested\n    grid and optionally also distributed between the corner points of the SWAN nested\n    grid (the boundary of the WAVEWATCH III nested grid need not be closed and may\n    cover land). The locations should be output by WAVEWATCH III in sequence (going\n    along the nest boundary, clockwise or counterclockwise). Note that SWAN will accept\n    output of a WAVEWATCH III output location only if the SWAN grid point on the nest\n    boundary lies within a rectangle between two consecutive WAVEWATCH III output\n    locations with a width equal to 0.1 times the distance between these output\n    locations on either side of the line between these WAVEWATCH III output locations.\n    This BOUNDNEST3 command is not available for 1D computations. A nested SWAN run may\n    use either Cartesian or spherical coordinates. A curvilinear grid may be used in\n    the nested grid but the boundaries of this nest should conform to the rectangular\n    course grid nest boundaries.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import BOUNDNEST3\n        boundary = BOUNDNEST3(\n            fname=\"boundary.ww3\",\n            format=\"free\",\n            rectangle=\"closed\",\n        )\n        print(boundary.render())\n\n    \"\"\"\n\n    model_type: Literal[\"boundnest3\", \"BOUNDNEST3\"] = Field(\n        default=\"boundnest3\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=(\n            \"The name of the file that contains the spectra computed by WAVEWATCH III\"\n        ),\n        min_length=1,\n        max_length=36,\n    )\n    format: Literal[\"unformatted\", \"free\"] = Field(\n        description=(\n            \"Format of the WW3 file. `unformatted`: The input WW3 files are binary, \"\n            \"`free`: The input WW3 files are formatted\"\n        ),\n    )\n    rectangle: Literal[\"closed\", \"open\"] = Field(\n        default=\"closed\",\n        description=(\n            \"Boundary is defined over a closed (default) or an open rectangle. \"\n            \"Boundary generated from the NESTOUT command is aways closed\"\n        ),\n    )\n    xgc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: longitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `xgc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n    ygc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"If SWAN is used with Cartesian coordinates: latitude of south-west \"\n            \"corner of SWAN computational grid (in degrees); if the south-west \"\n            \"corner of the nest in the WAM computation is on land this value is \"\n            \"required. If SWAN is used with spherical coordinates then `ygc` is \"\n            \"ignored by SWAN (SWAN default: the location of the first spectrum \"\n            \"encountered in the nest file. \"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n        repr += f\"{self.rectangle.upper()}\"\n        if self.xgc is not None:\n            repr += f\" xgc={self.xgc}\"\n        if self.ygc is not None:\n            repr += f\" ygc={self.ygc}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['boundnest3', 'BOUNDNEST3'] = Field(default='boundnest3', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='The name of the file that contains the spectra computed by WAVEWATCH III', min_length=1, max_length=36)\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['unformatted', 'free'] = Field(description='Format of the WW3 file. `unformatted`: The input WW3 files are binary, `free`: The input WW3 files are formatted')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.rectangle","title":"rectangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rectangle: Literal['closed', 'open'] = Field(default='closed', description='Boundary is defined over a closed (default) or an open rectangle. Boundary generated from the NESTOUT command is aways closed')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.xgc","title":"xgc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xgc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: longitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `xgc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.ygc","title":"ygc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ygc: Optional[float] = Field(default=None, description='If SWAN is used with Cartesian coordinates: latitude of south-west corner of SWAN computational grid (in degrees); if the south-west corner of the nest in the WAM computation is on land this value is required. If SWAN is used with spherical coordinates then `ygc` is ignored by SWAN (SWAN default: the location of the first spectrum encountered in the nest file. ')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.BOUNDNEST3.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"BOUNDNEST3 WW3 fname='{self.fname}' {self.format.upper()} \"\n    repr += f\"{self.rectangle.upper()}\"\n    if self.xgc is not None:\n        repr += f\" xgc={self.xgc}\"\n    if self.ygc is not None:\n        repr += f\" ygc={self.ygc}\"\n    return repr\n</code></pre>"},{"location":"components/boundary/#initial-conditions","title":"Initial conditions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL","title":"INITIAL","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Initial conditions.</p> <p>.. code-block:: text</p> <pre><code>INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n</code></pre> <p>This command can be used to specify the initial values for a stationary (INITIAL HOTSTART only) or nonstationary computation. The initial values thus specified override the default initialization (see Section 2.6.3). Note that it is possible to obtain an initial state by carrying out a previous stationary or nonstationary computation.</p>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.boundary import INITIAL\ninit = INITIAL()\nprint(init.render())\ninit = INITIAL(\n    kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n)\nprint(init.render())\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>class INITIAL(BaseComponent):\n    \"\"\"Initial conditions.\n\n    .. code-block:: text\n\n        INITIAL -&gt; DEFAULT|ZERO|PAR|HOTSTART\n\n    This command can be used to specify the initial values for a stationary (INITIAL\n    HOTSTART only) or nonstationary computation. The initial values thus specified\n    override the default initialization (see Section 2.6.3). Note that it is possible\n    to obtain an initial state by carrying out a previous stationary or nonstationary\n    computation.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.boundary import INITIAL\n        init = INITIAL()\n        print(init.render())\n        init = INITIAL(\n            kind=dict(model_type=\"hotmultiple\", fname=\"hotstart.swn\", format=\"free\")\n        )\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"initial\", \"INITIAL\"] = Field(\n        default=\"initial\",\n        description=\"Model type discriminator\",\n    )\n    kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(\n        default_factory=DEFAULT,\n        description=\"Initial condition type\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"INITIAL {self.kind.render()}\"\n        return repr\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL-attributes","title":"Attributes","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['initial', 'INITIAL'] = Field(default='initial', description='Model type discriminator')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: DEFAULT | ZERO | PAR | HOTSINGLE | HOTMULTIPLE = Field(default_factory=DEFAULT, description='Initial condition type')\n</code></pre>"},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL-functions","title":"Functions","text":""},{"location":"components/boundary/#rompy_swan.components.boundary.INITIAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"INITIAL {self.kind.render()}\"\n    return repr\n</code></pre>"},{"location":"components/cgrid/","title":"Computational grid","text":"<p>SWAN computational grid commands</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR","title":"REGULAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN regular computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR--note","title":"Note","text":"<p>In 1D-mode, <code>alpc</code> should be equal to the direction <code>alpinp</code>.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import REGULAR\ncgrid = REGULAR(\n    grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>class REGULAR(CGRID):\n    \"\"\"SWAN regular computational grid.\n\n    .. code-block:: text\n\n        CGRID REGULAR [xpc] [ypc] [alpc] [xlenc] [ylenc] [mxc] [myc] &amp;\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Note\n    ----\n    In 1D-mode, `alpc` should be equal to the direction `alpinp`.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import REGULAR\n        cgrid = REGULAR(\n            grid=dict(xp=0, yp=0, alp=0, xlen=2000, ylen=1300, mx=100, my=100),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"regular\", \"REGULAR\"] = Field(\n        default=\"regular\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"Computational grid definition\")\n\n    @model_validator(mode=\"after\")\n    def grid_suffix(self) -&gt; \"REGULAR\":\n        \"\"\"Set expected grid suffix.\"\"\"\n        if self.grid.suffix != \"c\":\n            logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n            self.grid.suffix = \"c\"\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['regular', 'REGULAR'] = Field(default='regular', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='Computational grid definition')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.grid_suffix","title":"grid_suffix","text":"<pre><code>grid_suffix() -&gt; REGULAR\n</code></pre> <p>Set expected grid suffix.</p> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef grid_suffix(self) -&gt; \"REGULAR\":\n    \"\"\"Set expected grid suffix.\"\"\"\n    if self.grid.suffix != \"c\":\n        logger.debug(f\"Set grid suffix 'c' instead of {self.grid.suffix}\")\n        self.grid.suffix = \"c\"\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.REGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID REGULAR {self.grid.render()} {self.spectrum.render()}\"\n    return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR","title":"CURVILINEAR","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN curvilinear computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n    -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n    FREE|FORMAT ('form'|[idfm])\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import CURVILINEAR\ncgrid = CURVILINEAR(\n    mxc=199,\n    myc=199,\n    readcoord=dict(fname=\"./coords.txt\"),\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>class CURVILINEAR(CGRID):\n    \"\"\"SWAN curvilinear computational grid.\n\n    .. code-block:: text\n\n        CGRID CURVILINEAR [mxc] [myc] (EXCEPTION [xexc] [yexc])\n            -&gt;CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n            FREE|FORMAT ('form'|[idfm])\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import CURVILINEAR\n        cgrid = CURVILINEAR(\n            mxc=199,\n            myc=199,\n            readcoord=dict(fname=\"./coords.txt\"),\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curvilinear\", \"CURVILINEAR\"] = Field(\n        default=\"curvilinear\", description=\"Model type discriminator\"\n    )\n    mxc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03be-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    myc: int = Field(\n        description=(\n            \"Number of meshes in computational grid in \u03b7-direction (this number is \"\n            \"one less than the number of grid points in this domain).\"\n        ),\n    )\n    xexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the x-coordinate considered in the file of the \"\n            \"x-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    yexc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"the value which the user uses to indicate that a grid point is to be \"\n            \"ignored in the computations (this value is provided by the user at the \"\n            \"location of the y-coordinate considered in the file of the \"\n            \"y-coordinates, see command READGRID COOR).\"\n        ),\n    )\n    readcoord: READCOORD = Field(\n        description=\"Grid coordinates reader.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n        if [self.xexc, self.yexc].count(None) == 1:\n            raise ValueError(\"xexc and yexc must be specified together\")\n        return self\n\n    @property\n    def exception(self):\n        if self.xexc is not None:\n            return f\"EXCEPTION xexc={self.xexc} xexc={self.yexc}\"\n        else:\n            return \"\"\n\n    @property\n    def format_repr(self):\n        if self.format == \"free\":\n            repr = \"FREE\"\n        elif self.format == \"fixed\" and self.form:\n            repr = f\"FORMAT form='{self.form}'\"\n        elif self.format == \"fixed\" and self.idfm:\n            repr = f\"FORMAT idfm={self.idfm}\"\n        elif self.format == \"unformatted\":\n            repr = \"UNFORMATTED\"\n        return repr\n\n    def cmd(self) -&gt; str:\n        repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n        if self.exception:\n            repr += f\" {self.exception}\"\n        repr += f\" {self.spectrum.render()}\"\n        repr = [repr] + [self.readcoord.render()]\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curvilinear', 'CURVILINEAR'] = Field(default='curvilinear', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.mxc","title":"mxc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxc: int = Field(description='Number of meshes in computational grid in \u03be-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.myc","title":"myc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myc: int = Field(description='Number of meshes in computational grid in \u03b7-direction (this number is one less than the number of grid points in this domain).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.xexc","title":"xexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the x-coordinate considered in the file of the x-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.yexc","title":"yexc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yexc: Optional[float] = Field(default=None, description='the value which the user uses to indicate that a grid point is to be ignored in the computations (this value is provided by the user at the location of the y-coordinate considered in the file of the y-coordinates, see command READGRID COOR).')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.readcoord","title":"readcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readcoord: READCOORD = Field(description='Grid coordinates reader.')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.exception","title":"exception  <code>property</code>","text":"<pre><code>exception\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.format_repr","title":"format_repr  <code>property</code>","text":"<pre><code>format_repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.xexc_and_yexc_or_neither","title":"xexc_and_yexc_or_neither","text":"<pre><code>xexc_and_yexc_or_neither() -&gt; CURVILINEAR\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef xexc_and_yexc_or_neither(self) -&gt; \"CURVILINEAR\":\n    if [self.xexc, self.yexc].count(None) == 1:\n        raise ValueError(\"xexc and yexc must be specified together\")\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.CURVILINEAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"CGRID CURVILINEAR mxc={self.mxc} myc={self.myc}\"\n    if self.exception:\n        repr += f\" {self.exception}\"\n    repr += f\" {self.spectrum.render()}\"\n    repr = [repr] + [self.readcoord.render()]\n    return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED","title":"UNSTRUCTURED","text":"<p>               Bases: <code>CGRID</code></p> <p>SWAN unstructured computational grid.</p> <p>.. code-block:: text</p> <pre><code>CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\nREADGRID UNSTRUCTURED [grid_type] ('fname')\n</code></pre> <p>This is a group component that includes a <code>CGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.cgrid import UNSTRUCTURED\ncgrid = UNSTRUCTURED(\n    grid_type=\"adcirc\",\n    spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n)\nprint(cgrid.render())\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>class UNSTRUCTURED(CGRID):\n    \"\"\"SWAN unstructured computational grid.\n\n    .. code-block:: text\n\n        CGRID UNSTRUCTURED CIRCLE|SECTOR [mdc] [flow] [fhigh] [msc]\n        READGRID UNSTRUCTURED [grid_type] ('fname')\n\n    This is a group component that includes a `CGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.cgrid import UNSTRUCTURED\n        cgrid = UNSTRUCTURED(\n            grid_type=\"adcirc\",\n            spectrum=dict(mdc=36, flow=0.04, fhigh=1.0),\n        )\n        print(cgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"unstructured\"] = Field(\n        default=\"unstructured\", description=\"Model type discriminator\"\n    )\n    grid_type: Literal[\"adcirc\", \"triangle\", \"easymesh\"] = Field(\n        default=\"adcirc\",\n        description=\"Unstructured grid type\",\n    )\n    fname: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file containing the unstructured grid\",\n        max_length=36,\n    )\n\n    @model_validator(mode=\"after\")\n    def check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n        \"\"\"Check that fname needs to be provided.\"\"\"\n        if self.grid_type == \"adcirc\" and self.fname is not None:\n            raise ValueError(\"fname must not be specified for ADCIRC grid\")\n        elif self.grid_type != \"adcirc\" and self.fname is None:\n            raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n        return self\n\n    def cmd(self) -&gt; str:\n        repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n        repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n        if self.grid_type in [\"triangle\", \"easymesh\"]:\n            repr[-1] += f\" fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['unstructured'] = Field(default='unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['adcirc', 'triangle', 'easymesh'] = Field(default='adcirc', description='Unstructured grid type')\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: Optional[str] = Field(default=None, description='Name of the file containing the unstructured grid', max_length=36)\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.check_fname_required","title":"check_fname_required","text":"<pre><code>check_fname_required() -&gt; UNSTRUCTURED\n</code></pre> <p>Check that fname needs to be provided.</p> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_fname_required(self) -&gt; \"UNSTRUCTURED\":\n    \"\"\"Check that fname needs to be provided.\"\"\"\n    if self.grid_type == \"adcirc\" and self.fname is not None:\n        raise ValueError(\"fname must not be specified for ADCIRC grid\")\n    elif self.grid_type != \"adcirc\" and self.fname is None:\n        raise ValueError(f\"fname must be specified for {self.grid_type} grid\")\n    return self\n</code></pre>"},{"location":"components/cgrid/#rompy_swan.components.cgrid.UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/cgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = [f\"CGRID UNSTRUCTURED {self.spectrum.cmd()}\"]\n    repr += [f\"READGRID UNSTRUCTURED {self.grid_type.upper()}\"]\n    if self.grid_type in [\"triangle\", \"easymesh\"]:\n        repr[-1] += f\" fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/group/","title":"Group","text":"<p>SWAN group commands</p>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent","title":"BaseGroupComponent","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Base group component.</p> <p>Base class for SWAN group components. This base class modifies the <code>render()</code> method to allow rendering of a list of components. It is not intended to be used directly but to be subclassed by other group components.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class BaseGroupComponent(BaseComponent):\n    \"\"\"Base group component.\n\n    Base class for SWAN group components. This base class modifies the `render()`\n    method to allow rendering of a list of components. It is not intended to be used\n    directly but to be subclassed by other group components.\n\n    \"\"\"\n\n    model_type: Literal[\"group\", \"GROUP\"] = Field(\n        default=\"group\", description=\"Model type discriminator\"\n    )\n\n    def render(self, *args, **kwargs) -&gt; str:\n        \"\"\"Override base class to allow rendering list of components.\"\"\"\n        cmds = []\n        for cmd in self.cmd():\n            cmds.append(super().render(cmd))\n        return \"\\n\\n\".join(cmds)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['group', 'GROUP'] = Field(default='group', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.BaseGroupComponent.render","title":"render","text":"<pre><code>render(*args, **kwargs) -&gt; str\n</code></pre> <p>Override base class to allow rendering list of components.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; str:\n    \"\"\"Override base class to allow rendering list of components.\"\"\"\n    cmds = []\n    for cmd in self.cmd():\n        cmds.append(super().render(cmd))\n    return \"\\n\\n\".join(cmds)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP","title":"STARTUP","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Startup group component.</p> <p>.. code-block:: text</p> <pre><code>PROJECT ...\nSET ...\nMODE ...\nCOORDINATES ...\n</code></pre> <p>This group component is used to group individual startup components. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"components/group/#rompy_swan.components.group.STARTUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\nfrom rompy_swan.components.group import STARTUP\nproj = PROJECT(nr=\"01\")\nset = SET(level=0.5, direction_convention=\"nautical\")\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\ncoords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\nstartup = STARTUP(\n    project=proj,\n    set=set,\n    mode=mode,\n    coordinates=coords,\n)\nprint(startup.render())\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class STARTUP(BaseGroupComponent):\n    \"\"\"Startup group component.\n\n    .. code-block:: text\n\n        PROJECT ...\n        SET ...\n        MODE ...\n        COORDINATES ...\n\n    This group component is used to group individual startup components. Only fields\n    that are explicitly prescribed are rendered by this group component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT, SET, MODE, COORDINATES\n        from rompy_swan.components.group import STARTUP\n        proj = PROJECT(nr=\"01\")\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        coords = COORDINATES(kind=dict(model_type=\"spherical\", projection=\"ccm\"))\n        startup = STARTUP(\n            project=proj,\n            set=set,\n            mode=mode,\n            coordinates=coords,\n        )\n        print(startup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"startup\", \"STARTUP\"] = Field(\n        default=\"startup\", description=\"Model type discriminator\"\n    )\n    project: Optional[PROJECT_TYPE] = Field(default=None)\n    set: Optional[SET_TYPE] = Field(default=None)\n    mode: Optional[MODE_TYPE] = Field(default=None)\n    coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.project is not None:\n            repr += [f\"{self.project.cmd()}\"]\n        if self.set is not None:\n            repr += [f\"{self.set.cmd()}\"]\n        if self.mode is not None:\n            repr += [f\"{self.mode.cmd()}\"]\n        if self.coordinates is not None:\n            repr += [f\"{self.coordinates.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.STARTUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['startup', 'STARTUP'] = Field(default='startup', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.project","title":"project  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project: Optional[PROJECT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.set","title":"set  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set: Optional[SET_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[MODE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP.coordinates","title":"coordinates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coordinates: Optional[COORDINATES_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.STARTUP-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.STARTUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.project is not None:\n        repr += [f\"{self.project.cmd()}\"]\n    if self.set is not None:\n        repr += [f\"{self.set.cmd()}\"]\n    if self.mode is not None:\n        repr += [f\"{self.mode.cmd()}\"]\n    if self.coordinates is not None:\n        repr += [f\"{self.coordinates.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS","title":"INPGRIDS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>SWAN input grids group component.</p> <p>.. code-block:: text</p> <pre><code>INPGRID ...\nREADGRID ...\n\nINPGRID ...\nREADGRID ...\n\n...\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of input grid components.</p>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR, ICE\nfrom rompy_swan.components.group import INPGRIDS\ninpgrid_bottom = REGULAR(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"bottom.txt\"),\n)\ninpgrid_wind = REGULAR(\n    grid_type=\"wind\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\ninpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\ninpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\nprint(inpgrids.render())\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class INPGRIDS(BaseGroupComponent):\n    \"\"\"SWAN input grids group component.\n\n    .. code-block:: text\n\n        INPGRID ...\n        READGRID ...\n\n        INPGRID ...\n        READGRID ...\n\n        ...\n\n    This group component is a convenience to allow defining and rendering\n    a list of input grid components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import REGULAR, ICE\n        from rompy_swan.components.group import INPGRIDS\n        inpgrid_bottom = REGULAR(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"bottom.txt\"),\n        )\n        inpgrid_wind = REGULAR(\n            grid_type=\"wind\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        inpgrid_ice_cte = ICE(aice=0.8, hice=2.0)\n        inpgrids = INPGRIDS(inpgrids=[inpgrid_bottom, inpgrid_wind, inpgrid_ice_cte])\n        print(inpgrids.render())\n\n    \"\"\"\n\n    model_type: Literal[\"inpgrids\"] = Field(\n        default=\"inpgrids\", description=\"Model type discriminator\"\n    )\n    inpgrids: list[INPGRID_TYPE] = Field(\n        min_length=1,\n        description=\"List of input grid components\",\n    )\n\n    @field_validator(\"inpgrids\")\n    @classmethod\n    def ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n        \"\"\"Ensure that each grid type is unique.\"\"\"\n        grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n        if len(grid_types) != len(set(grid_types)):\n            raise ValueError(\"Each grid type must be unique\")\n        return inpgrids\n\n    def cmd(self) -&gt; str | list:\n        repr = []\n        for inpgrid in self.inpgrids:\n            repr += [inpgrid.cmd()]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['inpgrids'] = Field(default='inpgrids', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.inpgrids","title":"inpgrids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inpgrids: list[INPGRID_TYPE] = Field(min_length=1, description='List of input grid components')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.ensure_unique_grid_type","title":"ensure_unique_grid_type  <code>classmethod</code>","text":"<pre><code>ensure_unique_grid_type(inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE\n</code></pre> <p>Ensure that each grid type is unique.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@field_validator(\"inpgrids\")\n@classmethod\ndef ensure_unique_grid_type(cls, inpgrids: INPGRID_TYPE) -&gt; INPGRID_TYPE:\n    \"\"\"Ensure that each grid type is unique.\"\"\"\n    grid_types = [inp.grid_type for inp in inpgrids if hasattr(inp, \"grid_type\")]\n    if len(grid_types) != len(set(grid_types)):\n        raise ValueError(\"Each grid type must be unique\")\n    return inpgrids\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.INPGRIDS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str | list\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; str | list:\n    repr = []\n    for inpgrid in self.inpgrids:\n        repr += [inpgrid.cmd()]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS","title":"PHYSICS","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Physics group component.</p> <p>The physics group component is a convenience to allow specifying several individual components in a single command and check for consistency between them.</p>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS--exemples","title":"Exemples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import PHYSICS\ngen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\nphys = PHYSICS(gen=gen)\nprint(phys.render())\nphys = PHYSICS(\n    gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n    negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n    sswell={\"model_type\": \"zieger\"},\n    breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n    friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n)\nprint(phys.render())\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class PHYSICS(BaseGroupComponent):\n    \"\"\"Physics group component.\n\n    The physics group component is a convenience to allow specifying several individual\n    components in a single command and check for consistency between them.\n\n    Exemples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import PHYSICS\n        gen = {\"model_type\": \"gen3\", \"source_terms\": {\"model_type\": \"komen\"}}\n        phys = PHYSICS(gen=gen)\n        print(phys.render())\n        phys = PHYSICS(\n            gen=dict(model_type=\"gen3\", source_terms={\"model_type\": \"st6c1\"}),\n            negatinp={\"model_type\": \"negatinp\", \"rdcoef\": 0.04},\n            sswell={\"model_type\": \"zieger\"},\n            breaking={\"model_type\": \"constant\", \"alpha\": 1.0, \"gamma\": 0.73},\n            friction={\"model_type\": \"jonswap\", \"cfjon\": 0.038},\n        )\n        print(phys.render())\n\n    \"\"\"\n\n    model_type: Literal[\"physics\", \"PHYSICS\"] = Field(\n        default=\"physics\", description=\"Model type discriminator\"\n    )\n    gen: Optional[GEN_TYPE] = Field(default=None)\n    sswell: Optional[SSWELL_TYPE] = Field(default=None)\n    negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n    wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n    quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n    breaking: Optional[BREAKING_TYPE] = Field(default=None)\n    friction: Optional[FRICTION_TYPE] = Field(default=None)\n    triad: Optional[TRIAD_TYPE] = Field(default=None)\n    vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n    mud: Optional[MUD_TYPE] = Field(default=None)\n    sice: Optional[SICE_TYPE] = Field(default=None)\n    turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n    bragg: Optional[BRAGG_TYPE] = Field(default=None)\n    limiter: Optional[LIMITER_TYPE] = Field(default=None)\n    obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n    setup: Optional[SETUP_TYPE] = Field(default=None)\n    diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n    surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n    scat: Optional[SCAT_TYPE] = Field(default=None)\n    deactivate: Optional[OFF_TYPE] = Field(default=None)\n\n    @field_validator(\"deactivate\")\n    @classmethod\n    def deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n        \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n        for phys in PhysicsOff:\n            print(phys.value)\n        return off\n\n    @model_validator(mode=\"after\")\n    def negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n        \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n        if self.negatinp is None:\n            return self\n        elif self.sswell is None:\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n            )\n        elif self.sswell.model_type != \"zieger\":\n            logger.warning(\n                \"The negative wind input NEGATINP is only intended to use with the \"\n                \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n                f\"{self.sswell.model_type.upper()} has been specified.\"\n            )\n        return self\n\n    def cmd(self):\n        repr = []\n        if self.gen is not None:\n            repr += [self.gen.cmd()]\n        if self.sswell is not None:\n            repr += [f\"{self.sswell.cmd()}\"]\n        if self.negatinp is not None:\n            repr += [self.negatinp.cmd()]\n        if self.wcapping is not None:\n            repr += [self.wcapping.cmd()]\n        if self.quadrupl is not None:\n            repr += [self.quadrupl.cmd()]\n        if self.breaking is not None:\n            repr += [self.breaking.cmd()]\n        if self.friction is not None:\n            repr += [self.friction.cmd()]\n        if self.triad is not None:\n            repr += [self.triad.cmd()]\n        if self.vegetation is not None:\n            repr += [self.vegetation.cmd()]\n        if self.mud is not None:\n            repr += [self.mud.cmd()]\n        if self.sice is not None:\n            repr += [self.sice.cmd()]\n        if self.turbulence is not None:\n            repr += [self.turbulence.cmd()]\n        if self.bragg is not None:\n            repr += [self.bragg.cmd()]\n        if self.limiter is not None:\n            repr += [self.limiter.cmd()]\n        if self.obstacle is not None:\n            repr += self.obstacle.cmd()  # Object returns a list of components\n        if self.setup is not None:\n            repr += [self.setup.cmd()]\n        if self.diffraction is not None:\n            repr += [self.diffraction.cmd()]\n        if self.surfbeat is not None:\n            repr += [self.surfbeat.cmd()]\n        if self.scat is not None:\n            repr += [self.scat.cmd()]\n        if self.deactivate is not None:\n            repr += self.deactivate.cmd()  # Object returns a list of components\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.PHYSICS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['physics', 'PHYSICS'] = Field(default='physics', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.gen","title":"gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gen: Optional[GEN_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.sswell","title":"sswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sswell: Optional[SSWELL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.negatinp","title":"negatinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>negatinp: Optional[NEGATINP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.wcapping","title":"wcapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wcapping: Optional[WCAPPING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.quadrupl","title":"quadrupl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrupl: Optional[QUADRUPL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.breaking","title":"breaking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>breaking: Optional[BREAKING_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>friction: Optional[FRICTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.triad","title":"triad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>triad: Optional[TRIAD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.vegetation","title":"vegetation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vegetation: Optional[VEGETATION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.mud","title":"mud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mud: Optional[MUD_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.sice","title":"sice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sice: Optional[SICE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.turbulence","title":"turbulence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>turbulence: Optional[TURBULENCE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.bragg","title":"bragg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bragg: Optional[BRAGG_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[LIMITER_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.obstacle","title":"obstacle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacle: Optional[OBSTACLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.diffraction","title":"diffraction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diffraction: Optional[DIFFRACTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.surfbeat","title":"surfbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>surfbeat: Optional[SURFBEAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.scat","title":"scat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scat: Optional[SCAT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.deactivate","title":"deactivate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deactivate: Optional[OFF_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.PHYSICS.deactivate_physics","title":"deactivate_physics  <code>classmethod</code>","text":"<pre><code>deactivate_physics(off: OFF_TYPE) -&gt; OFF_TYPE\n</code></pre> <p>Convert OFF to OFFS so list is rendered.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@field_validator(\"deactivate\")\n@classmethod\ndef deactivate_physics(cls, off: OFF_TYPE) -&gt; OFF_TYPE:\n    \"\"\"Convert OFF to OFFS so list is rendered.\"\"\"\n    for phys in PhysicsOff:\n        print(phys.value)\n    return off\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.negatinp_only_with_zieger","title":"negatinp_only_with_zieger","text":"<pre><code>negatinp_only_with_zieger() -&gt; PHYSICS\n</code></pre> <p>Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef negatinp_only_with_zieger(self) -&gt; \"PHYSICS\":\n    \"\"\"Log a warning if NEGATINP is used with a non-ZIEGER SSWELL.\"\"\"\n    if self.negatinp is None:\n        return self\n    elif self.sswell is None:\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but no SSWELL has been specified.\"\n        )\n    elif self.sswell.model_type != \"zieger\":\n        logger.warning(\n            \"The negative wind input NEGATINP is only intended to use with the \"\n            \"swell dissipation SSWELL ZIEGER but the SSWELL \"\n            f\"{self.sswell.model_type.upper()} has been specified.\"\n        )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.PHYSICS.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def cmd(self):\n    repr = []\n    if self.gen is not None:\n        repr += [self.gen.cmd()]\n    if self.sswell is not None:\n        repr += [f\"{self.sswell.cmd()}\"]\n    if self.negatinp is not None:\n        repr += [self.negatinp.cmd()]\n    if self.wcapping is not None:\n        repr += [self.wcapping.cmd()]\n    if self.quadrupl is not None:\n        repr += [self.quadrupl.cmd()]\n    if self.breaking is not None:\n        repr += [self.breaking.cmd()]\n    if self.friction is not None:\n        repr += [self.friction.cmd()]\n    if self.triad is not None:\n        repr += [self.triad.cmd()]\n    if self.vegetation is not None:\n        repr += [self.vegetation.cmd()]\n    if self.mud is not None:\n        repr += [self.mud.cmd()]\n    if self.sice is not None:\n        repr += [self.sice.cmd()]\n    if self.turbulence is not None:\n        repr += [self.turbulence.cmd()]\n    if self.bragg is not None:\n        repr += [self.bragg.cmd()]\n    if self.limiter is not None:\n        repr += [self.limiter.cmd()]\n    if self.obstacle is not None:\n        repr += self.obstacle.cmd()  # Object returns a list of components\n    if self.setup is not None:\n        repr += [self.setup.cmd()]\n    if self.diffraction is not None:\n        repr += [self.diffraction.cmd()]\n    if self.surfbeat is not None:\n        repr += [self.surfbeat.cmd()]\n    if self.scat is not None:\n        repr += [self.scat.cmd()]\n    if self.deactivate is not None:\n        repr += self.deactivate.cmd()  # Object returns a list of components\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT","title":"OUTPUT","text":"<p>               Bases: <code>BaseGroupComponent</code></p> <p>Output group component.</p> <p>.. code-block:: text</p> <pre><code>FRAME 'sname' ...\nGROUP 'sname' ...\nCURVE 'sname' ...\nRAY 'rname' ...\nISOLINE 'sname' 'rname' ...\nPOINTS 'sname ...\nNGRID 'sname' ...\nQUANTITY ...\nOUTPUT OPTIONS ...\nBLOCK 'sname' ...\nTABLE 'sname' ...\nSPECOUT 'sname' ...\nNESTOUT 'sname ...\n</code></pre> <p>This group component is used to define multiple types of output locations and write components in a single model. Only fields that are explicitly prescribed are rendered by this group component.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT--note","title":"Note","text":"<p>The components prescribed are validated according to some constraints as defined in the SWAN manual:</p> <ul> <li>The name <code>'sname'</code> of each Locations component must be unique.</li> <li>The Locations <code>'sname'</code> assigned to each write component must be defined.</li> <li>The BLOCK component must be associated with either a <code>FRAME</code> or <code>GROUP</code>.</li> <li>The ISOLINE write component must be associated with a <code>RAY</code> component.</li> <li>The NGRID and NESTOUT components must be defined together.</li> </ul>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\nfrom rompy_swan.components.group import OUTPUT\npoints = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\nquantity = QUANTITIES(\n    quantities=[\n        dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n    ]\n)\ntimes = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\nblock = BLOCK(\n    model_type=\"block\",\n    sname=\"COMPGRID\",\n    fname=\"./swangrid.nc\",\n    output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n    times=times,\n)\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./swantable.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=times,\n)\nout = OUTPUT(\n    points=points,\n    quantity=quantity,\n    block=block,\n    table=table,\n)\nprint(out.render())\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class OUTPUT(BaseGroupComponent):\n    \"\"\"Output group component.\n\n    .. code-block:: text\n\n        FRAME 'sname' ...\n        GROUP 'sname' ...\n        CURVE 'sname' ...\n        RAY 'rname' ...\n        ISOLINE 'sname' 'rname' ...\n        POINTS 'sname ...\n        NGRID 'sname' ...\n        QUANTITY ...\n        OUTPUT OPTIONS ...\n        BLOCK 'sname' ...\n        TABLE 'sname' ...\n        SPECOUT 'sname' ...\n        NESTOUT 'sname ...\n\n    This group component is used to define multiple types of output locations and\n    write components in a single model. Only fields that are explicitly prescribed are\n    rendered by this group component.\n\n    Note\n    ----\n    The components prescribed are validated according to some constraints as defined\n    in the SWAN manual:\n\n    - The name `'sname'` of each Locations component must be unique.\n    - The Locations `'sname'` assigned to each write component must be defined.\n    - The BLOCK component must be associated with either a `FRAME` or `GROUP`.\n    - The ISOLINE write component must be associated with a `RAY` component.\n    - The NGRID and NESTOUT components must be defined together.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS, BLOCK, QUANTITIES, TABLE\n        from rompy_swan.components.group import OUTPUT\n        points = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n        quantity = QUANTITIES(\n            quantities=[\n                dict(output=[\"depth\", \"hsign\", \"tps\", \"dir\", \"tm01\"], excv=-9),\n            ]\n        )\n        times = dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", tfmt=1, dfmt=\"min\")\n        block = BLOCK(\n            model_type=\"block\",\n            sname=\"COMPGRID\",\n            fname=\"./swangrid.nc\",\n            output=[\"depth\", \"hsign\", \"tps\", \"dir\"],\n            times=times,\n        )\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./swantable.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=times,\n        )\n        out = OUTPUT(\n            points=points,\n            quantity=quantity,\n            block=block,\n            table=table,\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"output\", \"OUTPUT\"] = Field(\n        default=\"output\", description=\"Model type discriminator\"\n    )\n    frame: Optional[FRAME_TYPE] = Field(default=None)\n    group: Optional[GROUP_TYPE] = Field(default=None)\n    curve: Optional[CURVE_TYPE] = Field(default=None)\n    ray: Optional[RAY_TYPE] = Field(default=None)\n    isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n    points: Optional[POINTS_TYPE] = Field(default=None)\n    ngrid: Optional[NGRID_TYPE] = Field(default=None)\n    quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n    output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n    block: Optional[BLOCK_TYPE] = Field(default=None)\n    table: Optional[TABLE_TYPE] = Field(default=None)\n    specout: Optional[SPECOUT_TYPE] = Field(default=None)\n    nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n    test: Optional[TEST_TYPE] = Field(default=None)\n    _location_fields: list = [\"frame\", \"group\", \"curve\", \"isoline\", \"points\", \"ngrid\"]\n    _write_fields: list = [\"block\", \"table\", \"specout\", \"nestout\"]\n\n    @model_validator(mode=\"after\")\n    def write_locations_exists(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n        for write in self.write_set:\n            obj = getattr(self, write)\n            if obj is None:\n                continue\n            snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for sname in snames:\n                if sname in SPECIAL_NAMES:\n                    return self\n                try:\n                    self._filter_location(sname)\n                except ValueError as err:\n                    raise ValueError(\n                        f\"Write component '{write}' specified with sname='{sname}' but \"\n                        f\"no location component with sname='{sname}' has been defined\"\n                    ) from err\n        return self\n\n    @model_validator(mode=\"after\")\n    def locations_sname_unique(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n        duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n        if duplicates:\n            raise ValueError(\n                \"The following snames are used to define more than one set of output \"\n                f\"components: {duplicates}, please ensure each location component has \"\n                \"a unique `sname`\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n        if self.block is not None:\n            snames = self.block.sname\n            if isinstance(snames, str):\n                snames = [self.block.sname]\n            for sname in snames:\n                if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                    location = self._filter_location(sname)\n                    component = location.model_type.upper().split(\"_\")[0]\n                    if component not in [\"FRAME\", \"GROUP\"]:\n                        raise ValueError(\n                            f\"Block sname='{sname}' specified with {component} \"\n                            \"location component but only only FRAME or GROUP \"\n                            \"components are supported\"\n                        )\n        return self\n\n    @model_validator(mode=\"after\")\n    def isoline_ray_defined(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure the isoline ray has been defined.\"\"\"\n        if self.isoline is not None:\n            if self.ray is None:\n                raise ValueError(\n                    f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                    \" but no RAY component has been defined\"\n                )\n            elif self.ray.rname != self.isoline.rname:\n                raise ValueError(\n                    f\"Isoline rname='{self.isoline.rname}' does not match \"\n                    f\"the ray rname='{self.ray.rname}'\"\n                )\n        return self\n\n    @model_validator(mode=\"after\")\n    def ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n        \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n        if self.ngrid is not None and self.nestout is None:\n            raise ValueError(\n                \"NGRID component specified but no NESTOUT component has been defined\"\n            )\n        elif self.ngrid is None and self.nestout is not None:\n            raise ValueError(\n                \"NESTOUT component specified but no NGRID component has been defined\"\n            )\n        elif self.ngrid is not None and self.nestout is not None:\n            if self.ngrid.sname != self.nestout.sname:\n                raise ValueError(\n                    f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                    f\"the NESTOUT sname='{self.nestout.sname}'\"\n                )\n        return self\n\n    @property\n    def locations_set(self):\n        \"\"\"List of specified location fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._location_fields]\n\n    @property\n    def write_set(self):\n        \"\"\"List of specified write fields.\"\"\"\n        return [fld for fld in self.model_fields_set if fld in self._write_fields]\n\n    @property\n    def snames(self):\n        \"\"\"List of snames from specified location components.\"\"\"\n        snames = []\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            sname = obj.sname\n            if isinstance(sname, str):\n                sname = [sname]\n            snames.extend(sname)\n        return snames\n\n    def _filter_location(self, sname):\n        \"\"\"Filter the location component defined with the specified sname.\"\"\"\n        for field in self.locations_set:\n            obj = getattr(self, field)\n            if obj is None:\n                continue\n            obj_snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n            for obj_sname in obj_snames:\n                if obj_sname == sname:\n                    return obj\n        raise ValueError(f\"Location component with sname='{sname}' not found\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        if self.frame is not None:\n            repr += [f\"{self.frame.cmd()}\"]\n        if self.group is not None:\n            repr += [f\"{self.group.cmd()}\"]\n        if self.curve is not None:\n            # Component renders a list\n            repr += self.curve.cmd()\n        if self.ray is not None:\n            repr += [f\"{self.ray.cmd()}\"]\n        if self.isoline is not None:\n            repr += [f\"{self.isoline.cmd()}\"]\n        if self.points is not None:\n            repr += [f\"{self.points.cmd()}\"]\n        if self.ngrid is not None:\n            repr += [f\"{self.ngrid.cmd()}\"]\n        if self.quantity is not None:\n            # Component renders a list\n            repr += self.quantity.cmd()\n        if self.output_options is not None:\n            repr += [f\"{self.output_options.cmd()}\"]\n        if self.block is not None:\n            # Component may or may not render a list, handles both\n            cmds = self.block.cmd()\n            if not isinstance(cmds, list):\n                cmds = [cmds]\n            for cmd in cmds:\n                repr += [f\"{cmd}\"]\n        if self.table is not None:\n            repr += [f\"{self.table.cmd()}\"]\n        if self.specout is not None:\n            repr += [f\"{self.specout.cmd()}\"]\n        if self.nestout is not None:\n            repr += [f\"{self.nestout.cmd()}\"]\n        if self.test is not None:\n            repr += [f\"{self.test.cmd()}\"]\n        return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.OUTPUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['output', 'OUTPUT'] = Field(default='output', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.frame","title":"frame  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame: Optional[FRAME_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: Optional[GROUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curve: Optional[CURVE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ray","title":"ray  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ray: Optional[RAY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.isoline","title":"isoline  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isoline: Optional[ISOLINE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Optional[POINTS_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ngrid","title":"ngrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ngrid: Optional[NGRID_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Optional[QUANTITY_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.output_options","title":"output_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_options: Optional[OUTOPT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Optional[BLOCK_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: Optional[TABLE_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.specout","title":"specout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specout: Optional[SPECOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.nestout","title":"nestout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nestout: Optional[NESTOUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.test","title":"test  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>test: Optional[TEST_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.locations_set","title":"locations_set  <code>property</code>","text":"<pre><code>locations_set\n</code></pre> <p>List of specified location fields.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.write_set","title":"write_set  <code>property</code>","text":"<pre><code>write_set\n</code></pre> <p>List of specified write fields.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.snames","title":"snames  <code>property</code>","text":"<pre><code>snames\n</code></pre> <p>List of snames from specified location components.</p>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.OUTPUT.write_locations_exists","title":"write_locations_exists","text":"<pre><code>write_locations_exists() -&gt; OUTPUT\n</code></pre> <p>Ensure the location component requested by a write component exists.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef write_locations_exists(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the location component requested by a write component exists.\"\"\"\n    for write in self.write_set:\n        obj = getattr(self, write)\n        if obj is None:\n            continue\n        snames = obj.sname if isinstance(obj.sname, list) else [obj.sname]\n        for sname in snames:\n            if sname in SPECIAL_NAMES:\n                return self\n            try:\n                self._filter_location(sname)\n            except ValueError as err:\n                raise ValueError(\n                    f\"Write component '{write}' specified with sname='{sname}' but \"\n                    f\"no location component with sname='{sname}' has been defined\"\n                ) from err\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.locations_sname_unique","title":"locations_sname_unique","text":"<pre><code>locations_sname_unique() -&gt; OUTPUT\n</code></pre> <p>Ensure same <code>sname</code> isn't used in more than one set of output locations.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef locations_sname_unique(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure same `sname` isn't used in more than one set of output locations.\"\"\"\n    duplicates = {x for x in self.snames if self.snames.count(x) &gt; 1}\n    if duplicates:\n        raise ValueError(\n            \"The following snames are used to define more than one set of output \"\n            f\"components: {duplicates}, please ensure each location component has \"\n            \"a unique `sname`\"\n        )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.block_with_frame_or_group","title":"block_with_frame_or_group","text":"<pre><code>block_with_frame_or_group() -&gt; OUTPUT\n</code></pre> <p>Ensure Block is only defined for FRAME or GROUP locations.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef block_with_frame_or_group(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure Block is only defined for FRAME or GROUP locations.\"\"\"\n    if self.block is not None:\n        snames = self.block.sname\n        if isinstance(snames, str):\n            snames = [self.block.sname]\n        for sname in snames:\n            if sname not in [\"BOTTGRID\", \"COMPGRID\"]:\n                location = self._filter_location(sname)\n                component = location.model_type.upper().split(\"_\")[0]\n                if component not in [\"FRAME\", \"GROUP\"]:\n                    raise ValueError(\n                        f\"Block sname='{sname}' specified with {component} \"\n                        \"location component but only only FRAME or GROUP \"\n                        \"components are supported\"\n                    )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.isoline_ray_defined","title":"isoline_ray_defined","text":"<pre><code>isoline_ray_defined() -&gt; OUTPUT\n</code></pre> <p>Ensure the isoline ray has been defined.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef isoline_ray_defined(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure the isoline ray has been defined.\"\"\"\n    if self.isoline is not None:\n        if self.ray is None:\n            raise ValueError(\n                f\"Isoline {self.isoline} requires RAY rname='{self.isoline.rname}'\"\n                \" but no RAY component has been defined\"\n            )\n        elif self.ray.rname != self.isoline.rname:\n            raise ValueError(\n                f\"Isoline rname='{self.isoline.rname}' does not match \"\n                f\"the ray rname='{self.ray.rname}'\"\n            )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.ngrid_and_nestout","title":"ngrid_and_nestout","text":"<pre><code>ngrid_and_nestout() -&gt; OUTPUT\n</code></pre> <p>Ensure NGRID and NESTOUT are specified together.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ngrid_and_nestout(self) -&gt; \"OUTPUT\":\n    \"\"\"Ensure NGRID and NESTOUT are specified together.\"\"\"\n    if self.ngrid is not None and self.nestout is None:\n        raise ValueError(\n            \"NGRID component specified but no NESTOUT component has been defined\"\n        )\n    elif self.ngrid is None and self.nestout is not None:\n        raise ValueError(\n            \"NESTOUT component specified but no NGRID component has been defined\"\n        )\n    elif self.ngrid is not None and self.nestout is not None:\n        if self.ngrid.sname != self.nestout.sname:\n            raise ValueError(\n                f\"NGRID sname='{self.ngrid.sname}' does not match \"\n                f\"the NESTOUT sname='{self.nestout.sname}'\"\n            )\n    return self\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.OUTPUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    if self.frame is not None:\n        repr += [f\"{self.frame.cmd()}\"]\n    if self.group is not None:\n        repr += [f\"{self.group.cmd()}\"]\n    if self.curve is not None:\n        # Component renders a list\n        repr += self.curve.cmd()\n    if self.ray is not None:\n        repr += [f\"{self.ray.cmd()}\"]\n    if self.isoline is not None:\n        repr += [f\"{self.isoline.cmd()}\"]\n    if self.points is not None:\n        repr += [f\"{self.points.cmd()}\"]\n    if self.ngrid is not None:\n        repr += [f\"{self.ngrid.cmd()}\"]\n    if self.quantity is not None:\n        # Component renders a list\n        repr += self.quantity.cmd()\n    if self.output_options is not None:\n        repr += [f\"{self.output_options.cmd()}\"]\n    if self.block is not None:\n        # Component may or may not render a list, handles both\n        cmds = self.block.cmd()\n        if not isinstance(cmds, list):\n            cmds = [cmds]\n        for cmd in cmds:\n            repr += [f\"{cmd}\"]\n    if self.table is not None:\n        repr += [f\"{self.table.cmd()}\"]\n    if self.specout is not None:\n        repr += [f\"{self.specout.cmd()}\"]\n    if self.nestout is not None:\n        repr += [f\"{self.nestout.cmd()}\"]\n    if self.test is not None:\n        repr += [f\"{self.test.cmd()}\"]\n    return repr\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP","title":"LOCKUP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Lockup group component.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE ...\nHOTFILE ...\nCOMPUTE ...\nHOTFILE ...\n...\nSTOP\n</code></pre> <p>This is a group component to specify SWAN \"Lockup\" commands including multiple <code>COMPUTE</code> commands that may or may not be interleaved with <code>HOTFILE</code> commands, and a final <code>STOP</code> command.</p>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.group import LOCKUP\nlockup = LOCKUP(\n    compute=dict(\n        model_type=\"stat\",\n        times=dict(\n            model_type=\"nonstationary\",\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-01-01T03:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        ),\n        hotfile=dict(fname=\"hotfile\"),\n        hottimes=[-1],\n    ),\n)\nprint(lockup.render())\n</code></pre> Source code in <code>rompy_swan/components/group.py</code> <pre><code>class LOCKUP(BaseComponent):\n    \"\"\"Lockup group component.\n\n    .. code-block:: text\n\n        COMPUTE ...\n        HOTFILE ...\n        COMPUTE ...\n        HOTFILE ...\n        ...\n        STOP\n\n    This is a group component to specify SWAN \"Lockup\" commands including multiple\n    `COMPUTE` commands that may or may not be interleaved with `HOTFILE` commands,\n    and a final `STOP` command.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.group import LOCKUP\n        lockup = LOCKUP(\n            compute=dict(\n                model_type=\"stat\",\n                times=dict(\n                    model_type=\"nonstationary\",\n                    tbeg=\"1990-01-01T00:00:00\",\n                    tend=\"1990-01-01T03:00:00\",\n                    delt=\"PT1H\",\n                    dfmt=\"hr\",\n                ),\n                hotfile=dict(fname=\"hotfile\"),\n                hottimes=[-1],\n            ),\n        )\n        print(lockup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"lockup\", \"LOCKUP\"] = Field(\n        default=\"lockup\", description=\"Model type discriminator\"\n    )\n    compute: COMPUTE_TYPE = Field(description=\"Compute components\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP-attributes","title":"Attributes","text":""},{"location":"components/group/#rompy_swan.components.group.LOCKUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lockup', 'LOCKUP'] = Field(default='lockup', description='Model type discriminator')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP.compute","title":"compute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compute: COMPUTE_TYPE = Field(description='Compute components')\n</code></pre>"},{"location":"components/group/#rompy_swan.components.group.LOCKUP-functions","title":"Functions","text":""},{"location":"components/group/#rompy_swan.components.group.LOCKUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>rompy_swan/components/group.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    return self.compute.cmd() + [STOP().render()]\n</code></pre>"},{"location":"components/inpgrid/","title":"Input grids","text":"<p>SWAN input grids commands</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR","title":"REGULAR","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN regular input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] REGULAR [xpinp] [ypinp] [alpinp] [mxinp] [myinp] &amp;\n    [dxinp] [dyinp] (EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import REGULAR\ninpgrid = REGULAR(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"bottom.txt\"),\n)\nprint(inpgrid.render())\ninpgrid = REGULAR(\n    grid_type=\"wind\",\n    excval=-99.0,\n    xpinp=172.0,\n    ypinp=-41.0,\n    alpinp=0.0,\n    mxinp=99,\n    myinp=99,\n    dxinp=0.005,\n    dyinp=0.005,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> <p>TODO: Use grid object, requires different grid parameters to be allowed.</p> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>class REGULAR(INPGRID):\n    \"\"\"SWAN regular input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] REGULAR [xpinp] [ypinp] [alpinp] [mxinp] [myinp] &amp;\n            [dxinp] [dyinp] (EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import REGULAR\n        inpgrid = REGULAR(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"bottom.txt\"),\n        )\n        print(inpgrid.render())\n        inpgrid = REGULAR(\n            grid_type=\"wind\",\n            excval=-99.0,\n            xpinp=172.0,\n            ypinp=-41.0,\n            alpinp=0.0,\n            mxinp=99,\n            myinp=99,\n            dxinp=0.005,\n            dyinp=0.005,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    TODO: Use grid object, requires different grid parameters to be allowed.\n\n    \"\"\"\n\n    model_type: Literal[\"regular\", \"REGULAR\"] = Field(\n        default=\"regular\",\n        description=\"Model type discriminator\",\n    )\n    xpinp: float = Field(\n        description=(\n            \"Geographic location (x-coordinate) of the origin of the input grid in \"\n            \"problem coordinates (in m) if Cartesian coordinates are used or in \"\n            \"degrees if spherical coordinates are used. In case of spherical \"\n            \"coordinates there is no default\"\n        ),\n    )\n    ypinp: float = Field(\n        description=(\n            \"Geographic location (y-coordinate) of the origin of the input grid in \"\n            \"problem coordinates (in m) if Cartesian coordinates are used or in \"\n            \"degrees if spherical coordinates are used. In case of spherical \"\n            \"coordinates there is no default\"\n        ),\n    )\n    alpinp: Optional[float] = Field(\n        default=0.0,\n        description=(\n            \"Direction of the positive x-axis of the input grid \"\n            \"(in degrees, Cartesian convention)\"\n        ),\n    )\n    mxinp: int = Field(\n        description=(\n            \"Number of meshes in x-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n    myinp: int = Field(\n        description=(\n            \"Number of meshes in y-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction). In 1D-mode, \"\n            \"`myinp` should be 0\"\n        ),\n    )\n    dxinp: float = Field(\n        description=(\n            \"Mesh size in x-direction of the input grid, in m in case of Cartesian \"\n            \"coordinates or in degrees if spherical coordinates are used\"\n        ),\n    )\n    dyinp: float = Field(\n        description=(\n            \"Mesh size in y-direction of the input grid, in m in case of Cartesian \"\n            \"coordinates or in degrees if spherical coordinates are used. \"\n            \"In 1D-mode, `dyinp` may have any value\"\n        ),\n    )\n\n    def cmd(self) -&gt; list:\n        repr = (\n            f\"{super().cmd()} REGULAR xpinp={self.xpinp} ypinp={self.ypinp} \"\n            f\"alpinp={self.alpinp} mxinp={self.mxinp} myinp={self.myinp} \"\n            f\"dxinp={self.dxinp} dyinp={self.dyinp}\"\n        )\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['regular', 'REGULAR'] = Field(default='regular', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.xpinp","title":"xpinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xpinp: float = Field(description='Geographic location (x-coordinate) of the origin of the input grid in problem coordinates (in m) if Cartesian coordinates are used or in degrees if spherical coordinates are used. In case of spherical coordinates there is no default')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.ypinp","title":"ypinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ypinp: float = Field(description='Geographic location (y-coordinate) of the origin of the input grid in problem coordinates (in m) if Cartesian coordinates are used or in degrees if spherical coordinates are used. In case of spherical coordinates there is no default')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.alpinp","title":"alpinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpinp: Optional[float] = Field(default=0.0, description='Direction of the positive x-axis of the input grid (in degrees, Cartesian convention)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.mxinp","title":"mxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxinp: int = Field(description='Number of meshes in x-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.myinp","title":"myinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myinp: int = Field(description='Number of meshes in y-direction of the input grid (this number is one less than the number of grid points in this direction). In 1D-mode, `myinp` should be 0')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.dxinp","title":"dxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dxinp: float = Field(description='Mesh size in x-direction of the input grid, in m in case of Cartesian coordinates or in degrees if spherical coordinates are used')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.dyinp","title":"dyinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dyinp: float = Field(description='Mesh size in y-direction of the input grid, in m in case of Cartesian coordinates or in degrees if spherical coordinates are used. In 1D-mode, `dyinp` may have any value')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.REGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = (\n        f\"{super().cmd()} REGULAR xpinp={self.xpinp} ypinp={self.ypinp} \"\n        f\"alpinp={self.alpinp} mxinp={self.mxinp} myinp={self.myinp} \"\n        f\"dxinp={self.dxinp} dyinp={self.dyinp}\"\n    )\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR","title":"CURVILINEAR","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN curvilinear input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] CURVILINEAR [stagrx] [stagry] [mxinp] [myinp] &amp;\n    (EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import CURVILINEAR\ninpgrid = CURVILINEAR(\n    grid_type=\"wind\",\n    stagrx=0.0,\n    stagry=0.0,\n    mxinp=199,\n    myinp=199,\n    excval=-99.0,\n    readinp=dict(fname1=\"wind.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> <p>TODO: Handle (or not) setting default values for mxinp and myinp from cgrid.</p> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>class CURVILINEAR(INPGRID):\n    \"\"\"SWAN curvilinear input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] CURVILINEAR [stagrx] [stagry] [mxinp] [myinp] &amp;\n            (EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import CURVILINEAR\n        inpgrid = CURVILINEAR(\n            grid_type=\"wind\",\n            stagrx=0.0,\n            stagry=0.0,\n            mxinp=199,\n            myinp=199,\n            excval=-99.0,\n            readinp=dict(fname1=\"wind.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    TODO: Handle (or not) setting default values for mxinp and myinp from cgrid.\n\n    \"\"\"\n\n    model_type: Literal[\"curvilinear\", \"CURVILINEAR\"] = Field(\n        default=\"curvilinear\", description=\"Model type discriminator\"\n    )\n    stagrx: float = Field(\n        default=0.0,\n        description=(\n            \"Staggered x'-direction with respect to computational grid, e.g., \"\n            \"`stagrx=0.5` means that the input grid points are shifted a half step \"\n            \"in x'-direction; in many flow models x-velocities are defined in points \"\n            \"shifted a half step in x'-direction\"\n        ),\n    )\n    stagry: float = Field(\n        default=0.0,\n        description=(\n            \"Staggered y'-direction with respect to computational grid, e.g., \"\n            \"`stagry=0.5` means that the input grid points are shifted a half step \"\n            \"in y'-direction; in many flow models y-velocities are defined in points \"\n            \"shifted a half step in y'-direction\"\n        ),\n    )\n    mxinp: int = Field(\n        description=(\n            \"Number of meshes in \u03be-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n    myinp: int = Field(\n        description=(\n            \"Number of meshes in \u03b7-direction of the input grid (this number is one \"\n            \"less than the number of grid points in this direction)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"{super().cmd()} CURVILINEAR stagrx={self.stagrx} \"\n            f\"stagry={self.stagry} mxinp={self.mxinp} myinp={self.myinp} \"\n        )\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curvilinear', 'CURVILINEAR'] = Field(default='curvilinear', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.stagrx","title":"stagrx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stagrx: float = Field(default=0.0, description=\"Staggered x'-direction with respect to computational grid, e.g., `stagrx=0.5` means that the input grid points are shifted a half step in x'-direction; in many flow models x-velocities are defined in points shifted a half step in x'-direction\")\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.stagry","title":"stagry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stagry: float = Field(default=0.0, description=\"Staggered y'-direction with respect to computational grid, e.g., `stagry=0.5` means that the input grid points are shifted a half step in y'-direction; in many flow models y-velocities are defined in points shifted a half step in y'-direction\")\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.mxinp","title":"mxinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxinp: int = Field(description='Number of meshes in \u03be-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.myinp","title":"myinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>myinp: int = Field(description='Number of meshes in \u03b7-direction of the input grid (this number is one less than the number of grid points in this direction)')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.CURVILINEAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"{super().cmd()} CURVILINEAR stagrx={self.stagrx} \"\n        f\"stagry={self.stagry} mxinp={self.mxinp} myinp={self.myinp} \"\n    )\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED","title":"UNSTRUCTURED","text":"<p>               Bases: <code>INPGRID</code></p> <p>SWAN unstructured input grid.</p> <p>.. code-block:: text</p> <pre><code>INPGRID [grid_type] UNSTRUCTURED EXCEPTION [excval]) &amp;\n    (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\nREADGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n    -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n</code></pre> <p>This is a group component that includes an <code>INPGRID</code> and a <code>READGRID</code> component.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import UNSTRUCTURED\ninpgrid = UNSTRUCTURED(\n    grid_type=\"bottom\",\n    excval=-99.0,\n    readinp=dict(fname1=\"bottom.txt\"),\n    nonstationary=dict(\n        tbeg=\"2019-01-01T00:00:00\",\n        tend=\"2019-01-07 00:00:00\",\n        delt=3600,\n        dfmt=\"hr\",\n    ),\n)\nprint(inpgrid.render())\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>class UNSTRUCTURED(INPGRID):\n    \"\"\"SWAN unstructured input grid.\n\n    .. code-block:: text\n\n        INPGRID [grid_type] UNSTRUCTURED EXCEPTION [excval]) &amp;\n            (NONSTATIONARY [tbeginp] [deltinp] -&gt;SEC|MIN|HR|DAY [tendinp])\n        READGRID [grid_type] [fac] 'fname1' [idla] [nhedf] ([nhedt]) ([nhedvec]) &amp;\n            -&gt;FREE|FORMAT|UNFORMATTED ('form'|[idfm])\n\n    This is a group component that includes an `INPGRID` and a `READGRID` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import UNSTRUCTURED\n        inpgrid = UNSTRUCTURED(\n            grid_type=\"bottom\",\n            excval=-99.0,\n            readinp=dict(fname1=\"bottom.txt\"),\n            nonstationary=dict(\n                tbeg=\"2019-01-01T00:00:00\",\n                tend=\"2019-01-07 00:00:00\",\n                delt=3600,\n                dfmt=\"hr\",\n            ),\n        )\n        print(inpgrid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"unstructured\", \"UNSTRUCTURED\"] = Field(\n        default=\"unstructured\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"{super().cmd()} UNSTRUCTURED\"\n        if self.excval is not None:\n            repr += f\" EXCEPTION excval={self.excval}\"\n        if self.nonstationary is not None:\n            repr += f\" {self.nonstationary.render()}\"\n        repr = [repr] + [self.readinp.render()]\n        return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['unstructured', 'UNSTRUCTURED'] = Field(default='unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"{super().cmd()} UNSTRUCTURED\"\n    if self.excval is not None:\n        repr += f\" EXCEPTION excval={self.excval}\"\n    if self.nonstationary is not None:\n        repr += f\" {self.nonstationary.render()}\"\n    repr = [repr] + [self.readinp.render()]\n    return repr\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND","title":"WIND","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wind input field.</p> <p>.. code-block:: text</p> <pre><code>WIND [vel] [dir]\n</code></pre> <p>With this optional command, the user indicates that the wind field is constant.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import WIND\nwind = WIND(vel=10.0, dir=270.0)\nprint(wind.render())\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>class WIND(BaseComponent):\n    \"\"\"Constant wind input field.\n\n    .. code-block:: text\n\n        WIND [vel] [dir]\n\n    With this optional command, the user indicates that the wind field is constant.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import WIND\n        wind = WIND(vel=10.0, dir=270.0)\n        print(wind.render())\n\n    \"\"\"\n\n    model_type: Literal[\"wind\", \"WIND\"] = Field(\n        default=\"wind\", description=\"Model type discriminator\"\n    )\n    vel: float = Field(description=\"Wind velocity at 10 m elevation (m/s)\", ge=0.0)\n    dir: float = Field(\n        description=(\n            \"Wind direction at 10 m elevation (in degrees, Cartesian or Nautical \"\n            \"convention, see command SET)\"\n        ),\n        ge=-180.0,\n        le=360.0,\n    )\n\n    def cmd(self):\n        return f\"WIND vel={self.vel} dir={self.dir}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['wind', 'WIND'] = Field(default='wind', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.vel","title":"vel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vel: float = Field(description='Wind velocity at 10 m elevation (m/s)', ge=0.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: float = Field(description='Wind direction at 10 m elevation (in degrees, Cartesian or Nautical convention, see command SET)', ge=-180.0, le=360.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.WIND.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self):\n    return f\"WIND vel={self.vel} dir={self.dir}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE","title":"ICE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wind input field.</p> <p>.. code-block:: text</p> <pre><code>ICE [aice] [hice]\n</code></pre> <p>With this optional command, the user indicates that one or more ice fields are constant.</p>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.inpgrid import ICE\nice = ICE(aice=0.1, hice=0.1)\nprint(ice.render())\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>class ICE(BaseComponent):\n    \"\"\"Constant wind input field.\n\n    .. code-block:: text\n\n        ICE [aice] [hice]\n\n    With this optional command, the user indicates that one or more ice fields are\n    constant.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.inpgrid import ICE\n        ice = ICE(aice=0.1, hice=0.1)\n        print(ice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ice\", \"ICE\"] = Field(\n        default=\"ice\", description=\"Model type discriminator\"\n    )\n    aice: float = Field(\n        description=\"Areal ice fraction, a number from 0 to 1\", ge=0.0, le=1.0\n    )\n    hice: float = Field(description=\"Ice thickness (m)\", ge=0.0)\n\n    def cmd(self):\n        return f\"ICE aice={self.aice} hice={self.hice}\"\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE-attributes","title":"Attributes","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ice', 'ICE'] = Field(default='ice', description='Model type discriminator')\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.aice","title":"aice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aice: float = Field(description='Areal ice fraction, a number from 0 to 1', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.hice","title":"hice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hice: float = Field(description='Ice thickness (m)', ge=0.0)\n</code></pre>"},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE-functions","title":"Functions","text":""},{"location":"components/inpgrid/#rompy_swan.components.inpgrid.ICE.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> Source code in <code>rompy_swan/components/inpgrid.py</code> <pre><code>def cmd(self):\n    return f\"ICE aice={self.aice} hice={self.hice}\"\n</code></pre>"},{"location":"components/lockup/","title":"Lock-up","text":"<p>SWAN lock-up commands</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE","title":"COMPUTE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Start SWAN computation.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE STATIONARY|NONSTATIONARY\n</code></pre> <p>If the SWAN mode is stationary (see command <code>MODE</code>), then only the command <code>COMPUTE</code> should be given here.</p> <p>If the SWAN mode is nonstationary (see command <code>MODE</code>), then the computation can be:</p> <ul> <li>stationary (at the specified time: option STATIONARY here).</li> <li>nonstationary (over the specified period of time.</li> </ul> <p>To verify input to SWAN (e.g., all input fields such as water depth, wind fields, etc), SWAN can be run without computations (that is: zero iterations by using command <code>NUM ACCUR MXITST=0</code>).</p> <p>In the case <code>MODE NONSTATIONARY</code> several commands COMPUTE can appear, where the wave state at the end of one computation is used as initial state for the next one, unless a command <code>INIT</code> appears in between the two COMPUTE commands. This enables the user to make a stationary computation to obtain the initial state for a nonstationary computation and/or to change the computational time step during a computation, to change a boundary condition etc. This also has the advantage of not using a hotfile since, it can be very large in size.</p> <p>For small domains, i.e. less than 100 km or 1 deg, a stationary computation is recommended. Otherwise, a nonstationary computation is advised.</p> <p>For a nonstationary computation, a time step of at most 10 minutes is advised (when you are choosing a time step larger than 10 minutes, the action density limiter (see command <code>NUM</code>) becomes probably a part of the physics).</p> <p>Also, the time step should be chosen such that the Courant number is smaller than 10 for the fastest (or dominant) wave. Otherwise, a first order upwind scheme is recommended in that case; see command <code>PROP BSBT</code>. If you want to run a high resolution model with a very large time step, e.g. 1 hour, you may apply multiple COMPUT STAT commands. For a small time step (&lt;= 10 minutes), no more than 1 iteration per time step is recommended (see command <code>NUM ... NONSTAT mxitns</code>).</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import COMPUTE\ncomp = COMPUTE()\nprint(comp.render())\ncomp = COMPUTE(\n    times=dict(model_type=\"stationary\", time=\"1990-01-01T00:00:00\", tfmt=2)\n)\nprint(comp.render())\ncomp = COMPUTE(\n    times=dict(\n        model_type=\"nonstationary\",\n        tbeg=\"1990-01-01T00:00:00\",\n        tend=\"1990-02-01T00:00:00\",\n        delt=\"PT1H\",\n        tfmt=1,\n        dfmt=\"hr\",\n    ),\n)\nprint(comp.render())\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE(BaseComponent):\n    \"\"\"Start SWAN computation.\n\n    .. code-block:: text\n\n        COMPUTE STATIONARY|NONSTATIONARY\n\n    If the SWAN mode is stationary (see command `MODE`), then only the command\n    `COMPUTE` should be given here.\n\n    If the SWAN mode is nonstationary (see command `MODE`), then the computation can\n    be:\n\n    * stationary (at the specified time: option STATIONARY here).\n    * nonstationary (over the specified period of time.\n\n    To verify input to SWAN (e.g., all input fields such as water depth, wind fields,\n    etc), SWAN can be run without computations (that is: zero iterations by using\n    command `NUM ACCUR MXITST=0`).\n\n    In the case `MODE NONSTATIONARY` several commands COMPUTE can appear, where the\n    wave state at the end of one computation is used as initial state for the next one,\n    unless a command `INIT` appears in between the two COMPUTE commands. This enables\n    the user to make a stationary computation to obtain the initial state for a\n    nonstationary computation and/or to change the computational time step during a\n    computation, to change a boundary condition etc. This also has the advantage of not\n    using a hotfile since, it can be very large in size.\n\n    For small domains, i.e. less than 100 km or 1 deg, a stationary computation is\n    recommended. Otherwise, a nonstationary computation is advised.\n\n    For a nonstationary computation, a time step of at most 10 minutes is advised (when\n    you are choosing a time step larger than 10 minutes, the action density limiter\n    (see command `NUM`) becomes probably a part of the physics).\n\n    Also, the time step should be chosen such that the Courant number is smaller than\n    10 for the fastest (or dominant) wave. Otherwise, a first order upwind scheme is\n    recommended in that case; see command `PROP BSBT`. If you want to run a high\n    resolution model with a very large time step, e.g. 1 hour, you may apply multiple\n    COMPUT STAT commands. For a small time step (&lt;= 10 minutes), no more than 1\n    iteration per time step is recommended (see command `NUM ... NONSTAT mxitns`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import COMPUTE\n        comp = COMPUTE()\n        print(comp.render())\n        comp = COMPUTE(\n            times=dict(model_type=\"stationary\", time=\"1990-01-01T00:00:00\", tfmt=2)\n        )\n        print(comp.render())\n        comp = COMPUTE(\n            times=dict(\n                model_type=\"nonstationary\",\n                tbeg=\"1990-01-01T00:00:00\",\n                tend=\"1990-02-01T00:00:00\",\n                delt=\"PT1H\",\n                tfmt=1,\n                dfmt=\"hr\",\n            ),\n        )\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"compute\", \"COMPUTE\"] = Field(\n        default=\"compute\", description=\"Model type discriminator\"\n    )\n    times: Optional[TIMES_TYPE] = Field(\n        default=None,\n        description=\"Times for the stationary or nonstationary computation\",\n        discriminator=\"model_type\",\n    )\n    i0: Optional[int] = Field(\n        default=None,\n        description=\"Time index of the initial time step\",\n    )\n    i1: Optional[int] = Field(\n        default=None,\n        description=\"Time index of the final time step\",\n    )\n\n    @field_validator(\"times\")\n    @classmethod\n    def times_suffix(cls, times: TIMES_TYPE) -&gt; TIMES_TYPE:\n        if isinstance(times, NONSTATIONARY):\n            times.suffix = \"c\"\n        return times\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"COMPUTE\"\n        if self.times is not None:\n            repr += f\" {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['compute', 'COMPUTE'] = Field(default='compute', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: Optional[TIMES_TYPE] = Field(default=None, description='Times for the stationary or nonstationary computation', discriminator='model_type')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.i0","title":"i0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i0: Optional[int] = Field(default=None, description='Time index of the initial time step')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.i1","title":"i1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i1: Optional[int] = Field(default=None, description='Time index of the final time step')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.times_suffix","title":"times_suffix  <code>classmethod</code>","text":"<pre><code>times_suffix(times: TIMES_TYPE) -&gt; TIMES_TYPE\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"times\")\n@classmethod\ndef times_suffix(cls, times: TIMES_TYPE) -&gt; TIMES_TYPE:\n    if isinstance(times, NONSTATIONARY):\n        times.suffix = \"c\"\n    return times\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"COMPUTE\"\n    if self.times is not None:\n        repr += f\" {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE","title":"HOTFILE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Write intermediate results.</p> <p>.. code-block:: text</p> <pre><code>HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n</code></pre> <p>This command can be used to write the entire wave field at the end of a computation to a so-called hotfile, to be used as initial condition in a subsequent SWAN run (see command <code>INITIAL HOTSTART</code>). This command must be entered immediately after a <code>COMPUTE</code> command.</p> <p>The user may choose the format of the hotfile to be written either as free or unformatted. If the free format is chosen, then this format is identical to the format of the files written by the <code>SPECOUT</code> command (option <code>SPEC2D</code>). This hotfile is therefore an ASCII file which is human readable.</p> <p>An unformatted (or binary) file usually requires less space on your computer than an ASCII file. Moreover, it can be readed by a subsequent SWAN run much faster than an ASCII file. Especially, when the hotfile might become a big file, the choice for unformatted is preferable. Note that your compiler and OS should follow the same ABI (Application Binary Interface) conventions (e.g. word size, endianness), so that unformatted hotfiles may transfer properly between different OS or platforms. This implies that the present and subsequent SWAN runs do not have to be carried out on the same operating system (e.g. Windows, Linux) or on the same computer, provided that distinct ABI conventions have been followed.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE--note","title":"Note","text":"<p>For parallel MPI runs, more than one hotfile will be generated depending on the number of processors (<code>fname-001</code>, <code>fname-002</code>, etc).</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import HOTFILE\nhotfile = HOTFILE(fname=\"hotfile.swn\")\nprint(hotfile.render())\nhotfile = HOTFILE(fname=\"hotfile.dat\", format=\"unformatted\")\nprint(hotfile.render())\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>class HOTFILE(BaseComponent):\n    \"\"\"Write intermediate results.\n\n    .. code-block:: text\n\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n\n    This command can be used to write the entire wave field at the end of a computation\n    to a so-called hotfile, to be used as initial condition in a subsequent SWAN run\n    (see command `INITIAL HOTSTART`). This command must be entered immediately after a\n    `COMPUTE` command.\n\n    The user may choose the format of the hotfile to be written either as free or\n    unformatted. If the free format is chosen, then this format is identical to the\n    format of the files written by the `SPECOUT` command (option `SPEC2D`). This\n    hotfile is therefore an ASCII file which is human readable.\n\n    An unformatted (or binary) file usually requires less space on your computer than\n    an ASCII file. Moreover, it can be readed by a subsequent SWAN run much faster than\n    an ASCII file. Especially, when the hotfile might become a big file, the choice for\n    unformatted is preferable. Note that your compiler and OS should follow the same\n    ABI (Application Binary Interface) conventions (e.g. word size, endianness), so\n    that unformatted hotfiles may transfer properly between different OS or platforms.\n    This implies that the present and subsequent SWAN runs do not have to be carried\n    out on the same operating system (e.g. Windows, Linux) or on the same computer,\n    provided that distinct ABI conventions have been followed.\n\n    Note\n    ----\n    For parallel MPI runs, more than one hotfile will be generated depending on the\n    number of processors (`fname-001`, `fname-002`, etc).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import HOTFILE\n        hotfile = HOTFILE(fname=\"hotfile.swn\")\n        print(hotfile.render())\n        hotfile = HOTFILE(fname=\"hotfile.dat\", format=\"unformatted\")\n        print(hotfile.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotfile\", \"HOTFILE\"] = Field(\n        default=\"hotfile\", description=\"Model type discriminator\"\n    )\n    fname: Path = Field(\n        description=\"Name of the file to which the wave field is written\",\n    )\n    format: Optional[Literal[\"free\", \"unformatted\"]] = Field(\n        default=None,\n        description=(\"Choose between free (SWAN ASCII) or unformatted (binary) format\"),\n    )\n\n    @field_validator(\"fname\")\n    @classmethod\n    def max_length(cls, fname: Path) -&gt; Path:\n        if len(str(fname)) &gt; 36:\n            raise ValueError(\"fname must be less than 36 characters\")\n        return fname\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"HOTFILE fname='{self.fname}'\"\n        if self.format is not None:\n            repr += f\" {self.format.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotfile', 'HOTFILE'] = Field(default='hotfile', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: Path = Field(description='Name of the file to which the wave field is written')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[Literal['free', 'unformatted']] = Field(default=None, description='Choose between free (SWAN ASCII) or unformatted (binary) format')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.max_length","title":"max_length  <code>classmethod</code>","text":"<pre><code>max_length(fname: Path) -&gt; Path\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"fname\")\n@classmethod\ndef max_length(cls, fname: Path) -&gt; Path:\n    if len(str(fname)) &gt; 36:\n        raise ValueError(\"fname must be less than 36 characters\")\n    return fname\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.HOTFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"HOTFILE fname='{self.fname}'\"\n    if self.format is not None:\n        repr += f\" {self.format.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT","title":"COMPUTE_STAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Multiple SWAN stationary computations.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE STATIONARY [time]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\nCOMPUTE STATIONARY [time]\nCOMPUTE STATIONARY [time]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\n.\n.\n</code></pre> <p>This component can be used to define multiple stationary compute commands and write intermediate results as hotfiles between then.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT--note","title":"Note","text":"<p>The field <code>times</code> is optional to allow for the case where the user wants to set times dynamically after instantiating this component.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import STATIONARY, NONSTATIONARY\nfrom rompy_swan.components.lockup import COMPUTE_STAT\ntime = STATIONARY(time=\"1990-01-01T00:00:00\")\ncomp = COMPUTE_STAT(times=time)\nprint(comp.render())\ntimes = NONSTATIONARY(\n    tbeg=\"1990-01-01T00:00:00\",\n    tend=\"1990-01-01T03:00:00\",\n    delt=\"PT1H\",\n)\ncomp = COMPUTE_STAT(times=times)\nprint(comp.render())\nhotfile = dict(fname=\"./hotfile.swn\")\nhottimes=[\"1990-01-01T03:00:00\"]\ncomp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=hottimes)\nprint(comp.render())\ncomp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=[2, -1])\nprint(comp.render())\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE_STAT(BaseComponent):\n    \"\"\"Multiple SWAN stationary computations.\n\n    .. code-block:: text\n\n        COMPUTE STATIONARY [time]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        COMPUTE STATIONARY [time]\n        COMPUTE STATIONARY [time]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        .\n        .\n\n    This component can be used to define multiple stationary compute commands and\n    write intermediate results as hotfiles between then.\n\n    Note\n    ----\n    The field `times` is optional to allow for the case where the user wants to set\n    times dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import STATIONARY, NONSTATIONARY\n        from rompy_swan.components.lockup import COMPUTE_STAT\n        time = STATIONARY(time=\"1990-01-01T00:00:00\")\n        comp = COMPUTE_STAT(times=time)\n        print(comp.render())\n        times = NONSTATIONARY(\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-01-01T03:00:00\",\n            delt=\"PT1H\",\n        )\n        comp = COMPUTE_STAT(times=times)\n        print(comp.render())\n        hotfile = dict(fname=\"./hotfile.swn\")\n        hottimes=[\"1990-01-01T03:00:00\"]\n        comp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=hottimes)\n        print(comp.render())\n        comp = COMPUTE_STAT(times=times, hotfile=hotfile, hottimes=[2, -1])\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stat\", \"STAT\"] = Field(\n        default=\"stat\", description=\"Model type discriminator\"\n    )\n    times: TIMES_TYPE = Field(\n        default_factory=STATIONARY,\n        description=\"Compute times\",\n        discriminator=\"model_type\",\n    )\n    hotfile: Optional[HOTFILE] = Field(\n        default=None,\n        description=\"Write results to restart files\",\n    )\n    hottimes: HOTTIMES_TYPE = Field(\n        default=[],\n        description=(\n            \"Times to write hotfiles, can be a list of datetimes or times indices\"\n        ),\n    )\n    suffix: str = Field(\n        default=\"_%Y%m%dT%H%M%S\",\n        description=(\"Time-template suffix to add to hotfile fname\"),\n    )\n\n    @field_validator(\"hottimes\")\n    @classmethod\n    def timestamp_to_datetime(cls, hottimes: TIMES_TYPE) -&gt; TIMES_TYPE:\n        \"\"\"Ensure pandas.Timestamp entries are coerced into datatime.\"\"\"\n        if hottimes and isinstance(hottimes[0], Timestamp):\n            hottimes = [t.to_pydatetime() for t in hottimes]\n        return hottimes\n\n    @model_validator(mode=\"after\")\n    def hotfile_with_hottimes(self) -&gt; \"COMPUTE_NONSTAT\":\n        if self.hottimes and self.hotfile is None:\n            logger.warning(\"hotfile not specified, hottimes will be ignored\")\n        elif self.hotfile is not None and not self.hottimes:\n            logger.warning(\"hottimes not specified, hotfile will be ignored\")\n        return self\n\n    @property\n    def hotids(self) -&gt; list:\n        \"\"\"List time ids at which to write hotfiles.\"\"\"\n        if self.hottimes and isinstance(self.hottimes[0], datetime):\n            ids = []\n            for t in self.hottimes:\n                try:\n                    ids.append(self.times().index(t))\n                except ValueError as e:\n                    raise ValueError(f\"hottime {t} not in times {self.times}\") from e\n        else:\n            ids = [i if i &gt;= 0 else i + len(self.times) for i in self.hottimes]\n            for i in ids:\n                if i &gt;= len(self.times):\n                    raise ValueError(\n                        f\"Hotfile requested for time {i} but times have \"\n                        f\"only {len(self.times)} values: {self.times} \"\n                    )\n        return ids\n\n    def _hotfile(self, time):\n        \"\"\"Set timestamp to hotfile fname.\"\"\"\n        timestamp = time.strftime(self.suffix)\n        fname = self.hotfile.fname.parent / (\n            f\"{self.hotfile.fname.stem}{timestamp}\" f\"{self.hotfile.fname.suffix}\"\n        )\n        return HOTFILE(fname=fname, format=self.hotfile.format)\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        for ind, time in enumerate(self.times()):\n            repr += [f\"COMPUTE {STATIONARY(time=time, tfmt=self.times.tfmt).render()}\"]\n            if ind in self.hotids and self.hotfile is not None:\n                repr += [f\"{self._hotfile(time).render()}\"]\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stat', 'STAT'] = Field(default='stat', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: TIMES_TYPE = Field(default_factory=STATIONARY, description='Compute times', discriminator='model_type')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotfile","title":"hotfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hotfile: Optional[HOTFILE] = Field(default=None, description='Write results to restart files')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hottimes","title":"hottimes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hottimes: HOTTIMES_TYPE = Field(default=[], description='Times to write hotfiles, can be a list of datetimes or times indices')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: str = Field(default='_%Y%m%dT%H%M%S', description='Time-template suffix to add to hotfile fname')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotids","title":"hotids  <code>property</code>","text":"<pre><code>hotids: list\n</code></pre> <p>List time ids at which to write hotfiles.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.timestamp_to_datetime","title":"timestamp_to_datetime  <code>classmethod</code>","text":"<pre><code>timestamp_to_datetime(hottimes: TIMES_TYPE) -&gt; TIMES_TYPE\n</code></pre> <p>Ensure pandas.Timestamp entries are coerced into datatime.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"hottimes\")\n@classmethod\ndef timestamp_to_datetime(cls, hottimes: TIMES_TYPE) -&gt; TIMES_TYPE:\n    \"\"\"Ensure pandas.Timestamp entries are coerced into datatime.\"\"\"\n    if hottimes and isinstance(hottimes[0], Timestamp):\n        hottimes = [t.to_pydatetime() for t in hottimes]\n    return hottimes\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.hotfile_with_hottimes","title":"hotfile_with_hottimes","text":"<pre><code>hotfile_with_hottimes() -&gt; COMPUTE_NONSTAT\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>@model_validator(mode=\"after\")\ndef hotfile_with_hottimes(self) -&gt; \"COMPUTE_NONSTAT\":\n    if self.hottimes and self.hotfile is None:\n        logger.warning(\"hotfile not specified, hottimes will be ignored\")\n    elif self.hotfile is not None and not self.hottimes:\n        logger.warning(\"hottimes not specified, hotfile will be ignored\")\n    return self\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_STAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    for ind, time in enumerate(self.times()):\n        repr += [f\"COMPUTE {STATIONARY(time=time, tfmt=self.times.tfmt).render()}\"]\n        if ind in self.hotids and self.hotfile is not None:\n            repr += [f\"{self._hotfile(time).render()}\"]\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT","title":"COMPUTE_NONSTAT","text":"<p>               Bases: <code>COMPUTE_STAT</code></p> <p>Multiple SWAN nonstationary computations.</p> <p>.. code-block:: text</p> <pre><code>COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\nCOMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\nHOTFILE 'fname' -&gt;FREE|UNFORMATTED\n.\n.\n</code></pre> <p>This component can be used to define multiple nonstationary compute commands and write intermediate results as hotfiles between then.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT--note","title":"Note","text":"<p>The field <code>times</code> is optional to allow for the case where the user wants to set times dynamically after instantiating this component.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import NONSTATIONARY\nfrom rompy_swan.components.lockup import COMPUTE_NONSTAT\ntimes = NONSTATIONARY(\n    tbeg=\"1990-01-01T00:00:00\",\n    tend=\"1990-02-01T00:00:00\",\n    delt=\"PT1H\",\n    dfmt=\"hr\",\n)\ncomp = COMPUTE_NONSTAT(times=times)\nprint(comp.render())\ncomp = COMPUTE_NONSTAT(\n    times=times,\n    hotfile=dict(fname=\"hotfile.swn\", format=\"free\"),\n    hottimes=[\"1990-02-01T00:00:00\"],\n)\nprint(comp.render())\ncomp = COMPUTE_NONSTAT(\n    times=times,\n    initstat=True,\n    hotfile=dict(fname=\"hotfile\", format=\"free\"),\n    hottimes=[6, 12, 18, -1],\n)\nprint(comp.render())\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>class COMPUTE_NONSTAT(COMPUTE_STAT):\n    \"\"\"Multiple SWAN nonstationary computations.\n\n    .. code-block:: text\n\n        COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        COMPUTE NONSTATIONARY [tbegc] [deltc] SEC|MIN|HR|DAY [tendc]\n        HOTFILE 'fname' -&gt;FREE|UNFORMATTED\n        .\n        .\n\n    This component can be used to define multiple nonstationary compute commands and\n    write intermediate results as hotfiles between then.\n\n    Note\n    ----\n    The field `times` is optional to allow for the case where the user wants to set\n    times dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import NONSTATIONARY\n        from rompy_swan.components.lockup import COMPUTE_NONSTAT\n        times = NONSTATIONARY(\n            tbeg=\"1990-01-01T00:00:00\",\n            tend=\"1990-02-01T00:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        )\n        comp = COMPUTE_NONSTAT(times=times)\n        print(comp.render())\n        comp = COMPUTE_NONSTAT(\n            times=times,\n            hotfile=dict(fname=\"hotfile.swn\", format=\"free\"),\n            hottimes=[\"1990-02-01T00:00:00\"],\n        )\n        print(comp.render())\n        comp = COMPUTE_NONSTAT(\n            times=times,\n            initstat=True,\n            hotfile=dict(fname=\"hotfile\", format=\"free\"),\n            hottimes=[6, 12, 18, -1],\n        )\n        print(comp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nonstat\", \"NONSTAT\"] = Field(\n        default=\"nonstat\", description=\"Model type discriminator\"\n    )\n    times: NONSTATIONARY = Field(\n        default_factory=NONSTATIONARY, description=\"Compute times\"\n    )\n    initstat: bool = Field(\n        default=False,\n        description=(\n            \"Run a STATIONARY computation at the initial time prior to the \"\n            \"NONSTATIONARY computation(s) to prescribe initial conditions\"\n        ),\n    )\n\n    @field_validator(\"times\")\n    @classmethod\n    def times_suffix(cls, times: NONSTATIONARY) -&gt; NONSTATIONARY:\n        times.suffix = \"c\"\n        return times\n\n    def _times(self, tbeg, tend):\n        return NONSTATIONARY(\n            tbeg=tbeg,\n            tend=tend,\n            delt=self.times.delt,\n            tfmt=self.times.tfmt,\n            dfmt=self.times.dfmt,\n            suffix=self.times.suffix,\n        )\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = []\n        ind = -inf\n        tbeg = self.times.tbeg\n        if self.initstat:\n            repr += [f\"COMPUTE {STATIONARY(time=tbeg, tfmt=self.times.tfmt).render()}\"]\n        for ind in self.hotids:\n            tend = self.times()[ind]\n            times = self._times(tbeg, tend)\n            repr += [f\"COMPUTE {times.render()}\"]\n            if self.hotfile is not None:\n                repr += [f\"{self._hotfile(tend).render()}\"]\n            tbeg = tend\n        if ind &lt; len(self.times) - 1:\n            times = self._times(tbeg, self.times.tend)\n            repr += [f\"COMPUTE {times.render()}\"]\n        return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstat', 'NONSTAT'] = Field(default='nonstat', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: NONSTATIONARY = Field(default_factory=NONSTATIONARY, description='Compute times')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.initstat","title":"initstat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initstat: bool = Field(default=False, description='Run a STATIONARY computation at the initial time prior to the NONSTATIONARY computation(s) to prescribe initial conditions')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.times_suffix","title":"times_suffix  <code>classmethod</code>","text":"<pre><code>times_suffix(times: NONSTATIONARY) -&gt; NONSTATIONARY\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>@field_validator(\"times\")\n@classmethod\ndef times_suffix(cls, times: NONSTATIONARY) -&gt; NONSTATIONARY:\n    times.suffix = \"c\"\n    return times\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.COMPUTE_NONSTAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = []\n    ind = -inf\n    tbeg = self.times.tbeg\n    if self.initstat:\n        repr += [f\"COMPUTE {STATIONARY(time=tbeg, tfmt=self.times.tfmt).render()}\"]\n    for ind in self.hotids:\n        tend = self.times()[ind]\n        times = self._times(tbeg, tend)\n        repr += [f\"COMPUTE {times.render()}\"]\n        if self.hotfile is not None:\n            repr += [f\"{self._hotfile(tend).render()}\"]\n        tbeg = tend\n    if ind &lt; len(self.times) - 1:\n        times = self._times(tbeg, self.times.tend)\n        repr += [f\"COMPUTE {times.render()}\"]\n    return repr\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP","title":"STOP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>End of commands.</p> <p>.. code-block:: text</p> <pre><code>STOP\n</code></pre> <p>This required command marks the end of the commands in the command file. Note that the command <code>STOP</code> may be the last command in the input file; any information in the input file beyond this command is ignored.</p>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.lockup import STOP\nstop = STOP()\nprint(stop.render())\n</code></pre> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>class STOP(BaseComponent):\n    \"\"\"End of commands.\n\n    .. code-block:: text\n\n        STOP\n\n    This required command marks the end of the commands in the command file. Note that\n    the command `STOP` may be the last command in the input file; any information in\n    the input file beyond this command is ignored.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.lockup import STOP\n        stop = STOP()\n        print(stop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stop\", \"STOP\"] = Field(\n        default=\"stop\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"STOP\"\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP-attributes","title":"Attributes","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.STOP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stop', 'STOP'] = Field(default='stop', description='Model type discriminator')\n</code></pre>"},{"location":"components/lockup/#rompy_swan.components.lockup.STOP-functions","title":"Functions","text":""},{"location":"components/lockup/#rompy_swan.components.lockup.STOP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/lockup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"STOP\"\n</code></pre>"},{"location":"components/numerics/","title":"Numerics","text":"<p>SWAN numerics commands</p>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP","title":"PROP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Propagation scheme.</p> <p>.. code-block:: text</p> <pre><code>PROP BSTB|GSE\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP--notes","title":"Notes","text":"<ul> <li>The scheme defaults to <code>S&amp;L</code> and <code>SORDUP</code> for nonstationary and stationary   simulations if not specified.</li> <li>All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear   grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a   gradually varying grid otherwise there may be a severe loss of accuracy. If sharp   transitions in the grid cannot be avoided it is safer to use the BSBT scheme.</li> <li>In the computation with unstructured meshes, a lowest order upwind scheme will be   employed. This scheme is very robust but rather diffusive. This may only be   significant for the case when swell waves propagate over relative large distances   (in the order of thousands of kilometers) within the model domain. However and   most fortunately, in such a case this will alleviate the garden-sprinkler effect.</li> <li>Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN   computation conditionally stable. You can either use (i) a smaller time step,   (ii) a lower value of <code>waveage</code>, (iii) better resolution in the directional   space, or (iv) worse resolution in the geographic space, in order of preference,   to make the model stable when necessary.</li> </ul>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import PROP\nprop = PROP()\nprint(prop.render())\nprop = PROP(scheme=dict(model_type=\"bsbt\"))\nprint(prop.render())\nprop = PROP(\n    scheme=dict(\n        model_type=\"gse\",\n        waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n    ),\n)\nprint(prop.render())\n</code></pre> Source code in <code>rompy_swan/components/numerics.py</code> <pre><code>class PROP(BaseComponent):\n    \"\"\"Propagation scheme.\n\n    .. code-block:: text\n\n        PROP BSTB|GSE\n\n    Notes\n    -----\n    * The scheme defaults to `S&amp;L` and `SORDUP` for nonstationary and stationary\n      simulations if not specified.\n    * All schemes (BSBT, SORDUP and S&amp;L) can be used in combination with curvilinear\n      grids. With the higher order schemes (S&amp;L and SORDUP) it is important to use a\n      gradually varying grid otherwise there may be a severe loss of accuracy. If sharp\n      transitions in the grid cannot be avoided it is safer to use the BSBT scheme.\n    * In the computation with unstructured meshes, a lowest order upwind scheme will be\n      employed. This scheme is very robust but rather diffusive. This may only be\n      significant for the case when swell waves propagate over relative large distances\n      (in the order of thousands of kilometers) within the model domain. However and\n      most fortunately, in such a case this will alleviate the garden-sprinkler effect.\n    * Alleviating the garden-sprinkler effect by adding some diffusion makes the SWAN\n      computation conditionally stable. You can either use (i) a smaller time step,\n      (ii) a lower value of `waveage`, (iii) better resolution in the directional\n      space, or (iv) worse resolution in the geographic space, in order of preference,\n      to make the model stable when necessary.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import PROP\n        prop = PROP()\n        print(prop.render())\n        prop = PROP(scheme=dict(model_type=\"bsbt\"))\n        print(prop.render())\n        prop = PROP(\n            scheme=dict(\n                model_type=\"gse\",\n                waveage=dict(delt=\"PT5H\", dfmt=\"hr\"),\n            ),\n        )\n        print(prop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"prop\", \"PROP\"] = Field(\n        default=\"prop\", description=\"Model type discriminator\"\n    )\n    scheme: Optional[PROP_TYPE] = Field(\n        default=None,\n        description=(\n            \"Propagation scheme, by default S&amp;L for nonstationary and SORDUP for \"\n            \"stationary computation.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"PROP\"\n        if self.scheme is not None:\n            repr += f\" {self.scheme.render()}\"\n        return repr\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP-attributes","title":"Attributes","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['prop', 'PROP'] = Field(default='prop', description='Model type discriminator')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.scheme","title":"scheme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scheme: Optional[PROP_TYPE] = Field(default=None, description='Propagation scheme, by default S&amp;L for nonstationary and SORDUP for stationary computation.')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.PROP-functions","title":"Functions","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.PROP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"PROP\"\n    if self.scheme is not None:\n        repr += f\" {self.scheme.render()}\"\n    return repr\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC","title":"NUMERIC","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Numerical properties.</p> <p>.. code-block:: text</p> <pre><code>NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n    ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n    ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.numerics import NUMERIC\nnumeric = NUMERIC()\nprint(numeric.render())\nnumeric = NUMERIC(\n    stop=dict(\n        model_type=\"stopc\",\n        dabs=0.05,\n        drel=0.01,\n        curvat=0.05,\n        npnts=99.5,\n    ),\n    dirimpl=dict(cdd=0.5),\n    sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n    ctheta=dict(cfl=0.9),\n    csigma=dict(cfl=0.9),\n    setup=dict(eps2=1e-4, outp=0, niter=20),\n)\nprint(numeric.render())\n</code></pre> Source code in <code>rompy_swan/components/numerics.py</code> <pre><code>class NUMERIC(BaseComponent):\n    \"\"\"Numerical properties.\n\n    .. code-block:: text\n\n        NUMeric ( STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter] ) &amp;\n            ( DIRimpl [cdd] ) ( SIGIMpl [css] [eps2] [outp] [niter] ) &amp;\n            ( CTheta [cfl] ) ( CSigma [cfl] ) ( SETUP [eps2] [outp] [niter] )\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.numerics import NUMERIC\n        numeric = NUMERIC()\n        print(numeric.render())\n        numeric = NUMERIC(\n            stop=dict(\n                model_type=\"stopc\",\n                dabs=0.05,\n                drel=0.01,\n                curvat=0.05,\n                npnts=99.5,\n            ),\n            dirimpl=dict(cdd=0.5),\n            sigimpl=dict(css=0.5, eps2=1e-4, outp=0, niter=20),\n            ctheta=dict(cfl=0.9),\n            csigma=dict(cfl=0.9),\n            setup=dict(eps2=1e-4, outp=0, niter=20),\n        )\n        print(numeric.render())\n\n    \"\"\"\n\n    model_type: Literal[\"numeric\", \"NUMERIC\"] = Field(\n        default=\"numeric\", description=\"Model type discriminator\"\n    )\n    stop: Optional[Union[STOPC, ACCUR]] = Field(\n        default=None,\n        description=\"Iteration termination criteria\",\n        discriminator=\"model_type\",\n    )\n    dirimpl: Optional[DIRIMPL] = Field(\n        default=None,\n        description=\"Numerical scheme for refraction\",\n    )\n    sigimpl: Optional[SIGIMPL] = Field(\n        default=None,\n        description=\"Frequency shifting accuracy\",\n    )\n    ctheta: Optional[CTHETA] = Field(\n        default=None,\n        description=\"Prevents excessive directional turning\",\n    )\n    csigma: Optional[CSIGMA] = Field(\n        default=None,\n        description=\"Prevents excessive frequency shifting\",\n    )\n    setup: Optional[SETUP] = Field(\n        default=None,\n        description=\"Stop criteria in the computation of wave setup\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NUMERIC\"\n        if self.stop is not None:\n            repr += f\" {self.stop.render()}\"\n        if self.dirimpl is not None:\n            repr += f\" {self.dirimpl.render()}\"\n        if self.sigimpl is not None:\n            repr += f\" {self.sigimpl.render()}\"\n        if self.ctheta is not None:\n            repr += f\" {self.ctheta.render()}\"\n        return repr\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC-attributes","title":"Attributes","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['numeric', 'NUMERIC'] = Field(default='numeric', description='Model type discriminator')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.stop","title":"stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop: Optional[Union[STOPC, ACCUR]] = Field(default=None, description='Iteration termination criteria', discriminator='model_type')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.dirimpl","title":"dirimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirimpl: Optional[DIRIMPL] = Field(default=None, description='Numerical scheme for refraction')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.sigimpl","title":"sigimpl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigimpl: Optional[SIGIMPL] = Field(default=None, description='Frequency shifting accuracy')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.ctheta","title":"ctheta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctheta: Optional[CTHETA] = Field(default=None, description='Prevents excessive directional turning')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.csigma","title":"csigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csigma: Optional[CSIGMA] = Field(default=None, description='Prevents excessive frequency shifting')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.setup","title":"setup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>setup: Optional[SETUP] = Field(default=None, description='Stop criteria in the computation of wave setup')\n</code></pre>"},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC-functions","title":"Functions","text":""},{"location":"components/numerics/#rompy_swan.components.numerics.NUMERIC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NUMERIC\"\n    if self.stop is not None:\n        repr += f\" {self.stop.render()}\"\n    if self.dirimpl is not None:\n        repr += f\" {self.dirimpl.render()}\"\n    if self.sigimpl is not None:\n        repr += f\" {self.sigimpl.render()}\"\n    if self.ctheta is not None:\n        repr += f\" {self.ctheta.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/","title":"Output","text":"<p>SWAN output commands</p>"},{"location":"components/output/#locations","title":"Locations","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation","title":"BaseLocation","text":"<p>               Bases: <code>BaseComponent</code>, <code>ABC</code></p> <p>Base class for SWAN output locations.</p> <p>.. code-block:: text</p> <pre><code>{MODEL_TYPE} sname='sname'\n</code></pre> <p>This is the base class for all locations components. It is not meant to be used directly.</p>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation--note","title":"Note","text":"<p>The name of the set of output locations <code>sname</code> cannot be longer than 8 characters and must not match any SWAN special names such as <code>BOTTGRID</code> (define output over the bottom/current grid) or <code>COMPGRID</code> (define output over the computational grid).</p>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BaseLocation\nloc = BaseLocation(sname=\"outsites\")\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class BaseLocation(BaseComponent, ABC):\n    \"\"\"Base class for SWAN output locations.\n\n    .. code-block:: text\n\n        {MODEL_TYPE} sname='sname'\n\n    This is the base class for all locations components. It is not meant to be used\n    directly.\n\n    Note\n    ----\n    The name of the set of output locations `sname` cannot be longer than 8 characters\n    and must not match any SWAN special names such as `BOTTGRID` (define output over\n    the bottom/current grid) or `COMPGRID` (define output over the computational grid).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BaseLocation\n        loc = BaseLocation(sname=\"outsites\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"locations\", \"LOCATIONS\"] = Field(\n        default=\"locations\",\n        description=\"Model type discriminator\",\n    )\n    sname: str = Field(\n        description=\"Name of the set of output locations defined by this command\",\n        max_length=8,\n    )\n\n    @field_validator(\"sname\")\n    @classmethod\n    def not_special_name(cls, sname: str) -&gt; str:\n        \"\"\"Ensure sname is not defined as one of the special names.\"\"\"\n        for name in SPECIAL_NAMES:\n            if sname.upper().startswith(name):\n                raise ValueError(f\"sname {sname} is a special name and cannot be used\")\n        return sname\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"{self.model_type.upper()} sname='{self.sname}'\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['locations', 'LOCATIONS'] = Field(default='locations', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation.sname","title":"sname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sname: str = Field(description='Name of the set of output locations defined by this command', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BaseLocation.not_special_name","title":"not_special_name  <code>classmethod</code>","text":"<pre><code>not_special_name(sname: str) -&gt; str\n</code></pre> <p>Ensure sname is not defined as one of the special names.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@field_validator(\"sname\")\n@classmethod\ndef not_special_name(cls, sname: str) -&gt; str:\n    \"\"\"Ensure sname is not defined as one of the special names.\"\"\"\n    for name in SPECIAL_NAMES:\n        if sname.upper().startswith(name):\n            raise ValueError(f\"sname {sname} is a special name and cannot be used\")\n    return sname\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseLocation.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"{self.model_type.upper()} sname='{self.sname}'\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME","title":"FRAME","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations on a regular grid.</p> <p>.. code-block:: text</p> <pre><code>FRAME 'sname' [xpfr] [ypfr] [alpfr] [xlenfr] [ylenfr] [mxfr] [myfr]\n</code></pre> <p>With this optional command the user defines output on a rectangular, uniform grid in a regular frame.</p> <p>If the set of output locations is identical to a part of the computational grid, then the user can use the alternative command GROUP.</p>"},{"location":"components/output/#rompy_swan.components.output.FRAME--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.FRAME--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import FRAME\nloc = FRAME(\n    sname=\"outgrid\",\n    grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class FRAME(BaseLocation):\n    \"\"\"Output locations on a regular grid.\n\n    .. code-block:: text\n\n        FRAME 'sname' [xpfr] [ypfr] [alpfr] [xlenfr] [ylenfr] [mxfr] [myfr]\n\n    With this optional command the user defines output on a rectangular, uniform grid\n    in a regular frame.\n\n    If the set of output locations is identical to a part of the computational grid,\n    then the user can use the alternative command GROUP.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import FRAME\n        loc = FRAME(\n            sname=\"outgrid\",\n            grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"frame\", \"FRAME\"] = Field(\n        default=\"frame\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"Frame grid definition\")\n\n    @field_validator(\"grid\")\n    @classmethod\n    def grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n        grid.suffix = \"fr\"\n        return grid\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.grid.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.FRAME.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['frame', 'FRAME'] = Field(default='frame', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='Frame grid definition')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.FRAME.grid_suffix","title":"grid_suffix  <code>classmethod</code>","text":"<pre><code>grid_suffix(grid: GRIDREGULAR) -&gt; GRIDREGULAR\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@field_validator(\"grid\")\n@classmethod\ndef grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n    grid.suffix = \"fr\"\n    return grid\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.FRAME.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.grid.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP","title":"GROUP","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations on subset of a grid.</p> <p>.. code-block:: text</p> <pre><code>GROUP 'sname' SUBGRID [ix1] [ix2] [iy1] [iy2]\n</code></pre> <p>With this optional command the user defines a group of output locations on a rectangular or curvilinear grid that is identical with (part of) the computational grid (rectilinear or curvilinear). Such a group may be convenient for the user to obtain output that is not affected by interpolation errors.</p> <p>The subgrid contains those points (<code>ix</code>,<code>iy</code>) of the computational grid for which: <code>ix1</code> &lt;= <code>ix</code> &lt;= <code>ix2</code> and <code>iy1</code> &lt;= <code>iy</code> &lt;= <code>iy2</code> (The origin of the computational grid is <code>ix=0</code>, <code>iy=0</code>)</p> <p>Limitations: <code>ix1&gt;=0</code>, <code>ix2&lt;=mxc</code>, <code>iy1&gt;=0</code>, <code>iy2&lt;=myc</code> (<code>mxc</code> and <code>myc</code> as defined in the command <code>CGRID</code> which should always precede this command <code>GROUP</code>)</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--note","title":"Note","text":"<p>Cannot be used in 1D-mode or in case of unstructured grids.</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--note_1","title":"Note","text":"<p>Regular and curvilinear grids are supported.</p>"},{"location":"components/output/#rompy_swan.components.output.GROUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import GROUP\nloc = GROUP(sname=\"subgrid\", ix1=20, iy1=0, ix2=50, iy2=100)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class GROUP(BaseLocation):\n    \"\"\"Output locations on subset of a grid.\n\n    .. code-block:: text\n\n        GROUP 'sname' SUBGRID [ix1] [ix2] [iy1] [iy2]\n\n    With this optional command the user defines a group of output locations on a\n    rectangular or curvilinear grid that is identical with (part of) the computational\n    grid (rectilinear or curvilinear). Such a group may be convenient for the user to\n    obtain output that is not affected by interpolation errors.\n\n    The subgrid contains those points (`ix`,`iy`) of the computational grid for which:\n    `ix1` &lt;= `ix` &lt;= `ix2` and `iy1` &lt;= `iy` &lt;= `iy2` (The origin of the computational\n    grid is `ix=0`, `iy=0`)\n\n    Limitations: `ix1&gt;=0`, `ix2&lt;=mxc`, `iy1&gt;=0`, `iy2&lt;=myc` (`mxc` and `myc` as\n    defined in the command `CGRID` which should always precede this command `GROUP`)\n\n    Note\n    ----\n    Cannot be used in 1D-mode or in case of unstructured grids.\n\n    Note\n    ----\n    Regular and curvilinear grids are supported.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import GROUP\n        loc = GROUP(sname=\"subgrid\", ix1=20, iy1=0, ix2=50, iy2=100)\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"group\", \"GROUP\"] = Field(\n        default=\"group\", description=\"Model type discriminator\"\n    )\n    ix1: int = Field(\n        description=\"Lowest index of the computational grid in the ix-direction\",\n        ge=0,\n    )\n    iy1: int = Field(\n        description=\"Lowest index of the computational grid in the iy-direction\",\n        ge=0,\n    )\n    ix2: int = Field(\n        description=\"Highest index of the computational grid in the ix-direction\",\n    )\n    iy2: int = Field(\n        description=\"Highest index of the computational grid in the ix-direction\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()}\"\n        repr += f\" SUBGRID ix1={self.ix1} iy1={self.iy1} ix2={self.ix2} iy2={self.iy2}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.GROUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['group', 'GROUP'] = Field(default='group', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.ix1","title":"ix1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ix1: int = Field(description='Lowest index of the computational grid in the ix-direction', ge=0)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.iy1","title":"iy1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iy1: int = Field(description='Lowest index of the computational grid in the iy-direction', ge=0)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.ix2","title":"ix2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ix2: int = Field(description='Highest index of the computational grid in the ix-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP.iy2","title":"iy2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iy2: int = Field(description='Highest index of the computational grid in the ix-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.GROUP-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.GROUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()}\"\n    repr += f\" SUBGRID ix1={self.ix1} iy1={self.iy1} ix2={self.ix2} iy2={self.iy2}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE","title":"CURVE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations along a curve.</p> <p>.. code-block:: text</p> <pre><code>CURVE 'sname' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user defines output along a curved line. Actually this curve is a broken line, defined by the user with its corner points. The values of the output quantities along the curve are interpolated from the computational grid. This command may be used more than once to define more curves.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note","title":"Note","text":"<p>The following pre-defined curves are available and could be used instead of a CURVE component: 'BOUNDARY' and <code>BOUND_0N</code> where <code>N</code> is boundary part number.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--note_2","title":"Note","text":"<p>Repeat the group <code>&lt; int xp yp</code> &gt; in proper order if there are more corner points on the curve.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import CURVE\nloc = CURVE(\n    sname=\"outcurve\",\n    xp1=172,\n    yp1=-40,\n    npts=[3, 3],\n    xp=[172.0, 174.0],\n    yp=[-38.0, -38.0],\n)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class CURVE(BaseLocation):\n    \"\"\"Output locations along a curve.\n\n    .. code-block:: text\n\n        CURVE 'sname' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n\n    With this optional command the user defines output along a curved line. Actually\n    this curve is a broken line, defined by the user with its corner points. The values\n    of the output quantities along the curve are interpolated from the computational\n    grid. This command may be used more than once to define more curves.\n\n    Note\n    ----\n    The following pre-defined curves are available and could be used instead of a CURVE\n    component: 'BOUNDARY' and `BOUND_0N` where `N` is boundary part number.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Note\n    ----\n    Repeat the group `&lt; int xp yp` &gt; in proper order if there are more corner points\n    on the curve.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import CURVE\n        loc = CURVE(\n            sname=\"outcurve\",\n            xp1=172,\n            yp1=-40,\n            npts=[3, 3],\n            xp=[172.0, 174.0],\n            yp=[-38.0, -38.0],\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curve\", \"CURVE\"] = Field(\n        default=\"curve\", description=\"Model type discriminator\"\n    )\n    xp1: float = Field(\n        description=(\n            \"Problem coordinate of the first point of the curve in the x-direction\"\n        ),\n    )\n    yp1: float = Field(\n        description=(\n            \"Problem coordinate of the first point of the curve in the y-direction\"\n        ),\n    )\n    npts: list[int] = Field(\n        description=(\n            \"The `int` CURVE parameter, SWAN will generate `npts-1` equidistant \"\n            \"locations between two subsequent corner points of the curve \"\n            \"including the two corner points\"\n        ),\n        min_length=1,\n    )\n    xp: list[float] = Field(\n        description=(\n            \"problem coordinates of a corner point of the curve in the x-direction\"\n        ),\n        min_length=1,\n    )\n    yp: list[float] = Field(\n        description=(\n            \"problem coordinates of a corner point of the curve in the y-direction\"\n        ),\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"CURVE\":\n        for key in [\"xp\", \"yp\"]:\n            if len(getattr(self, key)) != len(self.npts):\n                raise ValueError(f\"Size of npts and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} xp1={self.xp1} yp1={self.yp1}\"\n        for npts, xp, yp in zip(self.npts, self.xp, self.yp):\n            repr += f\"\\nint={npts} xp={xp} yp={yp}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.CURVE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curve', 'CURVE'] = Field(default='curve', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.xp1","title":"xp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp1: float = Field(description='Problem coordinate of the first point of the curve in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.yp1","title":"yp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp1: float = Field(description='Problem coordinate of the first point of the curve in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.npts","title":"npts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npts: list[int] = Field(description='The `int` CURVE parameter, SWAN will generate `npts-1` equidistant locations between two subsequent corner points of the curve including the two corner points', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='problem coordinates of a corner point of the curve in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='problem coordinates of a corner point of the curve in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.CURVE.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; CURVE\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"CURVE\":\n    for key in [\"xp\", \"yp\"]:\n        if len(getattr(self, key)) != len(self.npts):\n            raise ValueError(f\"Size of npts and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} xp1={self.xp1} yp1={self.yp1}\"\n    for npts, xp, yp in zip(self.npts, self.xp, self.yp):\n        repr += f\"\\nint={npts} xp={xp} yp={yp}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES","title":"CURVES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Output locations along multiple curves.</p> <p>.. code-block:: text</p> <pre><code>CURVE 'sname1' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\nCURVE 'sname2' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n..\n</code></pre> <p>This component can be used to prescribe and render multiple CURVE components.</p>"},{"location":"components/output/#rompy_swan.components.output.CURVES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import CURVE, CURVES\nloc1 = CURVE(\n    sname=\"c1\", xp1=7, yp1=-40, npts=[3, 3], xp=[7, 9], yp=[-38, -38],\n)\nloc2 = CURVE(\n    sname=\"c2\", xp1=3, yp1=-37, npts=[5, 5], xp=[4, 5], yp=[-37, -36],\n)\nlocs = CURVES(curves=[loc1, loc2])\nprint(locs.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class CURVES(BaseComponent):\n    \"\"\"Output locations along multiple curves.\n\n    .. code-block:: text\n\n        CURVE 'sname1' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n        CURVE 'sname2' [xp1] [yp1] &lt; [int] [xp] [yp] &gt;\n        ..\n\n    This component can be used to prescribe and render multiple CURVE components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import CURVE, CURVES\n        loc1 = CURVE(\n            sname=\"c1\", xp1=7, yp1=-40, npts=[3, 3], xp=[7, 9], yp=[-38, -38],\n        )\n        loc2 = CURVE(\n            sname=\"c2\", xp1=3, yp1=-37, npts=[5, 5], xp=[4, 5], yp=[-37, -36],\n        )\n        locs = CURVES(curves=[loc1, loc2])\n        print(locs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"curves\", \"CURVES\"] = Field(\n        default=\"curves\", description=\"Model type discriminator\"\n    )\n    curves: list[CURVE] = Field(description=\"CURVE components\")\n\n    @property\n    def sname(self) -&gt; list[str]:\n        return [curve.sname for curve in self.curves]\n\n    def cmd(self) -&gt; list[str]:\n        repr = []\n        for curve in self.curves:\n            repr += [curve.cmd()]\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.CURVES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['curves', 'CURVES'] = Field(default='curves', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES.curves","title":"curves  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curves: list[CURVE] = Field(description='CURVE components')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES.sname","title":"sname  <code>property</code>","text":"<pre><code>sname: list[str]\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.CURVES-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.CURVES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list[str]\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; list[str]:\n    repr = []\n    for curve in self.curves:\n        repr += [curve.cmd()]\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY","title":"RAY","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Output locations along a depth contour.</p> <p>.. code-block:: text</p> <pre><code>RAY 'rname' [xp1] [yp1] [xq1] [yq1] &lt; [int] [xp] [yp] [xq] [yq] &gt;\n</code></pre> <p>With this optional command the user provides SWAN with information to determine output locations along the depth contour line(s) defined subsequently in command <code>ISOLINE</code> (see below).</p> <p>These locations are determined by SWAN as the intersections of the depth contour line(s) and the set of straight rays defined in this command RAY. These rays are characterized by a set of master rays defined by their start and end positions (<code>xp</code>,<code>yp</code>) and (<code>xq</code>,<code>yq</code>). Between each pair of sequential master rays thus defined SWAN generates <code>int-1</code> intermediate rays by linear interpolation of the start and end positions.</p> <p>Rays defined by this component have nothing in common with wave rays (e.g. as obtained from conventional refraction computations).</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--note_2","title":"Note","text":"<p>When using rays the input grid for bottom and water level should not be curvilinear.</p>"},{"location":"components/output/#rompy_swan.components.output.RAY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import RAY\nloc = RAY(\n    rname=\"outray\",\n    xp1=171.9,\n    yp1=-40.1,\n    xq1=172.1,\n    yq1=-39.9,\n    npts=[3, 3],\n    xp=[171.9, 173.9],\n    yp=[-38.1, -38.1],\n    xq=[172.1, 174.1],\n    yq=[-37.9, -37.9],\n)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class RAY(BaseComponent):\n    \"\"\"Output locations along a depth contour.\n\n    .. code-block:: text\n\n        RAY 'rname' [xp1] [yp1] [xq1] [yq1] &lt; [int] [xp] [yp] [xq] [yq] &gt;\n\n    With this optional command the user provides SWAN with information to determine\n    output locations along the depth contour line(s) defined subsequently in command\n    `ISOLINE` (see below).\n\n    These locations are determined by SWAN as the intersections of the depth contour\n    line(s) and the set of straight rays defined in this command RAY. These rays are\n    characterized by a set of master rays defined by their start and end positions\n    (`xp`,`yp`) and (`xq`,`yq`). Between each pair of sequential master rays thus\n    defined SWAN generates `int-1` intermediate rays by linear interpolation of the\n    start and end positions.\n\n    Rays defined by this component have nothing in common with wave rays (e.g. as\n    obtained from conventional refraction computations).\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command `COORD`).\n\n    Note\n    ----\n    When using rays the input grid for bottom and water level should not be curvilinear.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import RAY\n        loc = RAY(\n            rname=\"outray\",\n            xp1=171.9,\n            yp1=-40.1,\n            xq1=172.1,\n            yq1=-39.9,\n            npts=[3, 3],\n            xp=[171.9, 173.9],\n            yp=[-38.1, -38.1],\n            xq=[172.1, 174.1],\n            yq=[-37.9, -37.9],\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ray\", \"RAY\"] = Field(\n        default=\"ray\", description=\"Model type discriminator\"\n    )\n    rname: str = Field(\n        description=\"Name of the set of rays defined by this command\",\n        max_length=32,\n    )\n    xp1: float = Field(\n        description=(\n            \"Problem coordinate of the begin point of the first master ray \"\n            \"in the x-direction\"\n        ),\n    )\n    yp1: float = Field(\n        description=(\n            \"Problem coordinate of the begin point of the first master ray \"\n            \"in the y-direction\"\n        ),\n    )\n    xq1: float = Field(\n        description=(\n            \"Problem coordinate of the end point of the first master ray \"\n            \"in the x-direction\"\n        ),\n    )\n    yq1: float = Field(\n        description=(\n            \"Problem coordinate of the end point of the first master ray \"\n            \"in the y-direction\"\n        ),\n    )\n    npts: list[int] = Field(\n        description=(\n            \"The `int` RAY parameter, number of subdivisions between the previous \"\n            \"master ray and the following master ray defined by the following data \"\n            \"(number of subdivisions is one morethan the number of interpolated rays)\"\n        ),\n        min_length=1,\n    )\n    xp: list[float] = Field(\n        description=(\n            \"problem coordinates of the begin of each subsequent master ray in the \"\n            \"x-direction\"\n        ),\n        min_length=1,\n    )\n    yp: list[float] = Field(\n        description=(\n            \"problem coordinates of the begin of each subsequent master ray in the \"\n            \"y-direction\"\n        ),\n        min_length=1,\n    )\n    xq: list[float] = Field(\n        description=(\n            \"problem coordinates of the end of each subsequent master ray in the \"\n            \"x-direction\"\n        ),\n        min_length=1,\n    )\n    yq: list[float] = Field(\n        description=(\n            \"problem coordinates of the end of each subsequent master ray in the \"\n            \"y-direction\"\n        ),\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"CURVE\":\n        for key in [\"xp\", \"yp\", \"xq\", \"yq\"]:\n            if len(getattr(self, key)) != len(self.npts):\n                raise ValueError(f\"Size of npts and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"RAY rname='{self.rname}'\"\n        repr += f\" xp1={self.xp1} yp1={self.yp1} xq1={self.xq1} yq1={self.yq1}\"\n        for npts, xp, yp, xq, yq in zip(self.npts, self.xp, self.yp, self.xq, self.yq):\n            repr += f\"\\nint={npts} xp={xp} yp={yp} xq={xq} yq={yq}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.RAY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ray', 'RAY'] = Field(default='ray', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.rname","title":"rname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rname: str = Field(description='Name of the set of rays defined by this command', max_length=32)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xp1","title":"xp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp1: float = Field(description='Problem coordinate of the begin point of the first master ray in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yp1","title":"yp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp1: float = Field(description='Problem coordinate of the begin point of the first master ray in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xq1","title":"xq1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xq1: float = Field(description='Problem coordinate of the end point of the first master ray in the x-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yq1","title":"yq1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yq1: float = Field(description='Problem coordinate of the end point of the first master ray in the y-direction')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.npts","title":"npts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npts: list[int] = Field(description='The `int` RAY parameter, number of subdivisions between the previous master ray and the following master ray defined by the following data (number of subdivisions is one morethan the number of interpolated rays)', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='problem coordinates of the begin of each subsequent master ray in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='problem coordinates of the begin of each subsequent master ray in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.xq","title":"xq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xq: list[float] = Field(description='problem coordinates of the end of each subsequent master ray in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.yq","title":"yq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yq: list[float] = Field(description='problem coordinates of the end of each subsequent master ray in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.RAY.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; CURVE\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"CURVE\":\n    for key in [\"xp\", \"yp\", \"xq\", \"yq\"]:\n        if len(getattr(self, key)) != len(self.npts):\n            raise ValueError(f\"Size of npts and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.RAY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"RAY rname='{self.rname}'\"\n    repr += f\" xp1={self.xp1} yp1={self.yp1} xq1={self.xq1} yq1={self.yq1}\"\n    for npts, xp, yp, xq, yq in zip(self.npts, self.xp, self.yp, self.xq, self.yq):\n        repr += f\"\\nint={npts} xp={xp} yp={yp} xq={xq} yq={yq}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE","title":"ISOLINE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations along a depth contour.</p> <p>.. code-block:: text</p> <pre><code>ISOLINE 'sname' 'rname' DEPTH|BOTTOM [dep]\n</code></pre> <p>With this optional command the user defines a set of output locations along one depth or bottom level contour line (in combination with command RAY).</p>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import ISOLINE\nloc = ISOLINE(sname=\"outcurve\", rname=\"outray\", dep_type=\"depth\", dep=12.0)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class ISOLINE(BaseLocation):\n    \"\"\"Output locations along a depth contour.\n\n    .. code-block:: text\n\n        ISOLINE 'sname' 'rname' DEPTH|BOTTOM [dep]\n\n    With this optional command the user defines a set of output locations along one\n    depth or bottom level contour line (in combination with command RAY).\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import ISOLINE\n        loc = ISOLINE(sname=\"outcurve\", rname=\"outray\", dep_type=\"depth\", dep=12.0)\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"isoline\", \"ISOLINE\"] = Field(\n        default=\"isoline\", description=\"Model type discriminator\"\n    )\n    rname: str = Field(\n        description=\"Name of the set of rays defined by this command\",\n        max_length=8,\n    )\n    dep: float = Field(\n        description=(\n            \"The depth (in m) of the depth contour line along which output locations \"\n            \"are generated by SWAN.\"\n        ),\n    )\n    dep_type: Optional[Literal[\"depth\", \"bottom\"]] = Field(\n        default=None,\n        description=(\n            \"Define if the depth contour is extracted from the DEPTH output (the \"\n            \"stationary water depth) or from the BOTTOM output (the depth relative \"\n            \"to the datum level with the water level ignored) (SWAN default: DEPTH)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} rname='{self.rname}'\"\n        if self.dep_type is not None:\n            repr += f\" {self.dep_type.upper()}\"\n        repr += f\" dep={self.dep}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.ISOLINE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['isoline', 'ISOLINE'] = Field(default='isoline', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.rname","title":"rname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rname: str = Field(description='Name of the set of rays defined by this command', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.dep","title":"dep  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dep: float = Field(description='The depth (in m) of the depth contour line along which output locations are generated by SWAN.')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE.dep_type","title":"dep_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dep_type: Optional[Literal['depth', 'bottom']] = Field(default=None, description='Define if the depth contour is extracted from the DEPTH output (the stationary water depth) or from the BOTTOM output (the depth relative to the datum level with the water level ignored) (SWAN default: DEPTH)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.ISOLINE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.ISOLINE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} rname='{self.rname}'\"\n    if self.dep_type is not None:\n        repr += f\" {self.dep_type.upper()}\"\n    repr += f\" dep={self.dep}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS","title":"POINTS","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Isolated output locations.</p> <p>.. code-block:: text</p> <pre><code>POINTS 'sname' &lt; [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user defines a set of individual output point locations.</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS--note","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS\nloc = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class POINTS(BaseLocation):\n    \"\"\"Isolated output locations.\n\n    .. code-block:: text\n\n        POINTS 'sname' &lt; [xp] [yp] &gt;\n\n    With this optional command the user defines a set of individual output point\n    locations.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS\n        loc = POINTS(sname=\"outpts\", xp=[172.3, 172.4], yp=[-39, -39])\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"points\", \"POINTS\"] = Field(\n        default=\"points\", description=\"Model type discriminator\"\n    )\n    xp: Optional[list[float]] = Field(\n        description=\"problem coordinates of the points in the x-direction\",\n        min_length=1,\n    )\n    yp: Optional[list[float]] = Field(\n        description=\"problem coordinates of the points in the y-direction\",\n        min_length=1,\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"POINTS\":\n        if len(self.xp) != len(self.yp):\n            raise ValueError(\"xp and yp must be the same size\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()}\"\n        for xp, yp in zip(self.xp, self.yp):\n            repr += f\"\\nxp={xp} yp={yp}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['points', 'POINTS'] = Field(default='points', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: Optional[list[float]] = Field(description='problem coordinates of the points in the x-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: Optional[list[float]] = Field(description='problem coordinates of the points in the y-direction', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; POINTS\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"POINTS\":\n    if len(self.xp) != len(self.yp):\n        raise ValueError(\"xp and yp must be the same size\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()}\"\n    for xp, yp in zip(self.xp, self.yp):\n        repr += f\"\\nxp={xp} yp={yp}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE","title":"POINTS_FILE","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Isolated output locations.</p> <p>.. code-block:: text</p> <pre><code>POINTS 'sname' FILE 'fname'\n</code></pre> <p>With this optional command the user defines a set of individual output point locations from text file. The file should have one point per row with x-coordinates and y-coordinates in the first and second columns respectively.</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE--note","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import POINTS_FILE\nloc = POINTS_FILE(sname=\"outpts\", fname=\"./output_locations.txt\")\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class POINTS_FILE(BaseLocation):\n    \"\"\"Isolated output locations.\n\n    .. code-block:: text\n\n        POINTS 'sname' FILE 'fname'\n\n    With this optional command the user defines a set of individual output point\n    locations from text file. The file should have one point per row with x-coordinates\n    and y-coordinates in the first and second columns respectively.\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import POINTS_FILE\n        loc = POINTS_FILE(sname=\"outpts\", fname=\"./output_locations.txt\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"points_file\", \"POINTS_FILE\"] = Field(\n        default=\"points_file\", description=\"Model type discriminator\"\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the output locations\",\n        max_length=36,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"POINTS sname='{self.sname}' fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['points_file', 'POINTS_FILE'] = Field(default='points_file', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the output locations', max_length=36)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.POINTS_FILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"POINTS sname='{self.sname}' fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID","title":"NGRID","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations for a nested grid.</p> <p>.. code-block:: text</p> <pre><code>NGRID 'sname' [xpn] [ypn] [alpn] [xlenn] [ylenn] [mxn] [myn]\n</code></pre> <p>If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run is required. With this optional command <code>NGRID</code>, the user defines in the present coarse-grid run, a set of output locations along the boundary of the subsequent nested computational grid. The set of output locations thus defined is of the type NGRID.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--note","title":"Note","text":"<p>Command <code>NESTOUT</code> is required after this command <code>NGRID</code> to generate some data for the (subsequent) nested run.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--note_1","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NGRID\nloc = NGRID(\n    sname=\"outnest\",\n    grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n)\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class NGRID(BaseLocation):\n    \"\"\"Output locations for a nested grid.\n\n    .. code-block:: text\n\n        NGRID 'sname' [xpn] [ypn] [alpn] [xlenn] [ylenn] [mxn] [myn]\n\n    If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run\n    is required. With this optional command `NGRID`, the user defines in the present\n    coarse-grid run, a set of output locations along the boundary of the subsequent\n    nested computational grid. The set of output locations thus defined is of the type\n    NGRID.\n\n    Note\n    ----\n    Command `NESTOUT` is required after this command `NGRID` to generate some data for\n    the (subsequent) nested run.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NGRID\n        loc = NGRID(\n            sname=\"outnest\",\n            grid=dict(xp=173, yp=-40, xlen=2, ylen=2, mx=19, my=19),\n        )\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ngrid\", \"NGRID\"] = Field(\n        default=\"ngrid\", description=\"Model type discriminator\"\n    )\n    grid: GRIDREGULAR = Field(description=\"NGRID grid definition\")\n\n    @field_validator(\"grid\")\n    @classmethod\n    def grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n        grid.suffix = \"n\"\n        return grid\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.grid.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ngrid', 'NGRID'] = Field(default='ngrid', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GRIDREGULAR = Field(description='NGRID grid definition')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID.grid_suffix","title":"grid_suffix  <code>classmethod</code>","text":"<pre><code>grid_suffix(grid: GRIDREGULAR) -&gt; GRIDREGULAR\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@field_validator(\"grid\")\n@classmethod\ndef grid_suffix(cls, grid: GRIDREGULAR) -&gt; GRIDREGULAR:\n    grid.suffix = \"n\"\n    return grid\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.grid.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED","title":"NGRID_UNSTRUCTURED","text":"<p>               Bases: <code>BaseLocation</code></p> <p>Output locations for a nested grid.</p> <p>.. code-block:: text</p> <pre><code>NGRID 'sname' UNSTRUCTURED -&gt;TRIANGLE|EASYMESH 'fname'\n</code></pre> <p>If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run is required. With this optional command <code>NGRID</code>, the user defines in the present coarse-grid run, a set of output locations along the boundary of the subsequent nested computational grid. The set of output locations thus defined is of the type NGRID.</p> <p>With this option the user indicates that the subsequent nested grid is unstructured Only grids generated by Triangle and Easymesh are supported by SWAN.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED--note","title":"Note","text":"<p>Command <code>NESTOUT</code> is required after this command <code>NGRID</code> to generate some data for the (subsequent) nested run.</p>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NGRID_UNSTRUCTURED\nloc = NGRID_UNSTRUCTURED(sname=\"outnest\", kind=\"triangle\", fname=\"ngrid.txt\")\nprint(loc.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class NGRID_UNSTRUCTURED(BaseLocation):\n    \"\"\"Output locations for a nested grid.\n\n    .. code-block:: text\n\n        NGRID 'sname' UNSTRUCTURED -&gt;TRIANGLE|EASYMESH 'fname'\n\n    If the user wishes to carry out nested SWAN runs, a separate coarse-grid SWAN run\n    is required. With this optional command `NGRID`, the user defines in the present\n    coarse-grid run, a set of output locations along the boundary of the subsequent\n    nested computational grid. The set of output locations thus defined is of the type\n    NGRID.\n\n    With this option the user indicates that the subsequent nested grid is unstructured\n    Only grids generated by Triangle and Easymesh are supported by SWAN.\n\n    Note\n    ----\n    Command `NESTOUT` is required after this command `NGRID` to generate some data for\n    the (subsequent) nested run.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NGRID_UNSTRUCTURED\n        loc = NGRID_UNSTRUCTURED(sname=\"outnest\", kind=\"triangle\", fname=\"ngrid.txt\")\n        print(loc.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ngrid_unstructured\", \"NGRID_UNSTRUCTURED\"] = Field(\n        default=\"ngrid_unstructured\", description=\"Model type discriminator\"\n    )\n    kind: Optional[Literal[\"triangle\", \"easymesh\"]] = Field(\n        default=\"triangle\",\n        description=(\n            \"Indicate if nested grid is generated by Triangle or Easymesh. The base \"\n            \"name of the grid specified in the `fname` parameter is used internally \"\n            \"by SWAN to define the `.node` and `.ele` files in case of the former or \"\n            \"the `.n` and `.e` files in case of the latter.\"\n        ),\n    )\n    fname: str = Field(\n        description=\"Basename of the required files, i.e. without extension\",\n        max_length=32,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"NGRID sname='{self.sname}' UNSTRUCTURED\"\n        if self.kind is not None:\n            repr += f\" {self.kind.upper()}\"\n        repr += f\" fname='{self.fname}'\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ngrid_unstructured', 'NGRID_UNSTRUCTURED'] = Field(default='ngrid_unstructured', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Optional[Literal['triangle', 'easymesh']] = Field(default='triangle', description='Indicate if nested grid is generated by Triangle or Easymesh. The base name of the grid specified in the `fname` parameter is used internally by SWAN to define the `.node` and `.ele` files in case of the former or the `.n` and `.e` files in case of the latter.')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Basename of the required files, i.e. without extension', max_length=32)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NGRID_UNSTRUCTURED.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"NGRID sname='{self.sname}' UNSTRUCTURED\"\n    if self.kind is not None:\n        repr += f\" {self.kind.upper()}\"\n    repr += f\" fname='{self.fname}'\"\n    return repr\n</code></pre>"},{"location":"components/output/#settings","title":"Settings","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY","title":"QUANTITY","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Define output settings.</p> <p>.. code-block:: text</p> <pre><code>QUANTITY &lt; output &gt; 'short' 'long' [lexp] [hexp] [excv] [power] [ref] &amp;\n    [fswell] [fmin] [fmax] -&gt;PROBLEMCOORD|FRAME\n\nExamples:\n---------\nQUANTITY Xp hexp=100.\nQUANTITY HS TM01 RTMM10 excv=-9.\nQUANTITY HS TM02 FSPR fmin=0.03 fmax=0.5\nQUANTITY Hswell fswell=0.08\nQUANTITY Per short='Tm-1,0' power=0.\nQUANTITY Transp Force Frame\n</code></pre> <p>With this command the user can influence:</p> <ul> <li>The naming of output quantities</li> <li>The accuracy of writing output quantities</li> <li>The definition of some output quantities</li> <li>Reference direction for vectors</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note","title":"Note","text":"<p>The following data are accepted only in combination with some specific quantities:</p> <ul> <li>power</li> <li>ref</li> <li>fswell</li> <li>fmin</li> <li>fmax</li> <li>PROBLEMCOORD</li> <li>FRAME</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note_1","title":"Note","text":"<p>PROBLEMCOORD: Vector components are relative to the x- and y-axes of the problem coordinate system (see command <code>SET</code>):</p> <ul> <li>Directions are counterclockwise relative to the positive x-axis of the problem   coordinate system if Cartesian direction convention is used.</li> <li>Directions are relative to North (clockwise) if Nautical direction convention is   used.</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--note_2","title":"Note","text":"<p>FRAME: If output is requested on sets created by command FRAME or automatically (see command <code>SET</code>) (<code>COMPGRID</code> or <code>BOTTGRID</code>):</p> <ul> <li>Vector components are relative to the x- and y-axes of the frame coordinate   system.</li> <li>Directions are counterclockwise relative to the positive x-axis of the frame   coordinate system if Cartesian direction convention is used.</li> <li>Directions are relative to North (clockwise) if Nautical direction convention   is used.</li> </ul>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import QUANTITY\nquant = QUANTITY(output=[\"xp\"], hexp=100)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\nprint(quant.render())\nquant = QUANTITY(output=[\"hsign\"], fswell=0.08)\nprint(quant.render())\nquant = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\nprint(quant.render())\nquant = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\nprint(quant.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class QUANTITY(BaseComponent):\n    \"\"\"Define output settings.\n\n    .. code-block:: text\n\n        QUANTITY &lt; output &gt; 'short' 'long' [lexp] [hexp] [excv] [power] [ref] &amp;\n            [fswell] [fmin] [fmax] -&gt;PROBLEMCOORD|FRAME\n\n        Examples:\n        ---------\n        QUANTITY Xp hexp=100.\n        QUANTITY HS TM01 RTMM10 excv=-9.\n        QUANTITY HS TM02 FSPR fmin=0.03 fmax=0.5\n        QUANTITY Hswell fswell=0.08\n        QUANTITY Per short='Tm-1,0' power=0.\n        QUANTITY Transp Force Frame\n\n    With this command the user can influence:\n\n    * The naming of output quantities\n    * The accuracy of writing output quantities\n    * The definition of some output quantities\n    * Reference direction for vectors\n\n    Note\n    ----\n    The following data are accepted only in combination with some specific quantities:\n\n    * power\n    * ref\n    * fswell\n    * fmin\n    * fmax\n    * PROBLEMCOORD\n    * FRAME\n\n    Note\n    ----\n    **PROBLEMCOORD**: Vector components are relative to the x- and y-axes of the\n    problem coordinate system (see command `SET`):\n\n    * Directions are counterclockwise relative to the positive x-axis of the problem\n      coordinate system if Cartesian direction convention is used.\n    * Directions are relative to North (clockwise) if Nautical direction convention is\n      used.\n\n    Note\n    ----\n    **FRAME**: If output is requested on sets created by command FRAME or\n    automatically (see command `SET`) (`COMPGRID` or `BOTTGRID`):\n\n    * Vector components are relative to the x- and y-axes of the frame coordinate\n      system.\n    * Directions are counterclockwise relative to the positive x-axis of the frame\n      coordinate system if Cartesian direction convention is used.\n    * Directions are relative to North (clockwise) if Nautical direction convention\n      is used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import QUANTITY\n        quant = QUANTITY(output=[\"xp\"], hexp=100)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\n        print(quant.render())\n        quant = QUANTITY(output=[\"hsign\"], fswell=0.08)\n        print(quant.render())\n        quant = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\n        print(quant.render())\n        quant = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\n        print(quant.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quantity\", \"QUANTITY\"] = Field(\n        default=\"quantity\", description=\"Model type discriminator\"\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to define settings for\",\n        min_length=1,\n    )\n    short: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Short name of the output quantity (e.g. the name in the heading of a \"\n            \"table written by SWAN). If this option is not used, SWAN will use a \"\n            \"realistic name\"\n        ),\n        max_length=16,\n    )\n    long: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Long name of the output quantity (e.g. the name in the heading of a \"\n            \"block output written by SWAN). If this option is not used, SWAN will \"\n            \"use a realistic name\"\n        ),\n        max_length=16,\n    )\n    lexp: Optional[float] = Field(\n        default=None,\n        description=\"Lowest expected value of the output quantity\",\n    )\n    hexp: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Highest expected value of the output quantity; the highest expected \"\n            \"value is used by SWAN to determine the number of decimals in a table \"\n            \"with heading. So the `QUANTITY` command can be used in case the default \"\n            \"number of decimals in a table is unsatisfactory\"\n        ),\n    )\n    excv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"In case there is no valid value (e.g. wave height in a dry point) this \"\n            \"exception value is written in a table or block output\"\n        ),\n    )\n    power: Optional[float] = Field(\n        default=None,\n        description=(\n            \"power `p` appearing in the definition of `PER`, `RPER` and `WLEN`. Note \"\n            \"that the value for `power` given for `PER` affects also the value of \"\n            \"`RPER`; the power for `WLEN` is independent of that of `PER` or `RPER` \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    ref: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Reference time used for the quantity `TSEC`. Default value: starting \"\n            \"time of the first computation, except in cases where this is later than \"\n            \"the time of the earliest input. In these cases, the time of the earliest \"\n            \"input is used\"\n        ),\n    )\n    fswell: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit of frequency range used for computing the quantity HSWELL \"\n            \"(SWAN default: 0.1 Hz)\"\n        ),\n    )\n    noswll: Optional[int] = Field(\n        default=None,\n        description=(\"Number of swells to output for watershed quantities \"),\n    )\n    fmin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Lower limit of frequency range used for computing integral parameters \"\n            \"(SWAN Default: 0.0 Hz)\"\n        ),\n    )\n    fmax: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit of frequency range used for computing integral parameters \"\n            \"(SWAN default: 1000.0 Hz, acts as infinity)\"\n        ),\n    )\n    coord: Optional[Literal[\"problemcoord\", \"frame\"]] = Field(\n        default=None,\n        description=(\n            \"Define if vectors and directions refer to the problem coordinate system \"\n            \"('problemcoord') or sets created by command FRAME ('frame') \"\n            \"(SWAN default: problemcoord)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"QUANTITY\"\n        for output in self.output:\n            repr += f\" {output.upper()}\"\n        if self.short is not None:\n            repr += f\" short='{self.short}'\"\n        if self.long is not None:\n            repr += f\" long='{self.long}'\"\n        if self.lexp is not None:\n            repr += f\" lexp={self.lexp}\"\n        if self.hexp is not None:\n            repr += f\" hexp={self.hexp}\"\n        if self.excv is not None:\n            repr += f\" excv={self.excv}\"\n        if self.power is not None:\n            repr += f\" power={self.power}\"\n        if self.ref is not None:\n            repr += f\" ref='{self.ref}'\"\n        if self.fswell is not None:\n            repr += f\" fswell={self.fswell}\"\n        if self.noswll is not None:\n            repr += f\" noswll={self.noswll}\"\n        if self.fmin is not None:\n            repr += f\" fmin={self.fmin}\"\n        if self.fmax is not None:\n            repr += f\" fmax={self.fmax}\"\n        if self.coord is not None:\n            repr += f\" {self.coord.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quantity', 'QUANTITY'] = Field(default='quantity', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to define settings for', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.short","title":"short  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short: Optional[str] = Field(default=None, description='Short name of the output quantity (e.g. the name in the heading of a table written by SWAN). If this option is not used, SWAN will use a realistic name', max_length=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.long","title":"long  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>long: Optional[str] = Field(default=None, description='Long name of the output quantity (e.g. the name in the heading of a block output written by SWAN). If this option is not used, SWAN will use a realistic name', max_length=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.lexp","title":"lexp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lexp: Optional[float] = Field(default=None, description='Lowest expected value of the output quantity')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.hexp","title":"hexp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hexp: Optional[float] = Field(default=None, description='Highest expected value of the output quantity; the highest expected value is used by SWAN to determine the number of decimals in a table with heading. So the `QUANTITY` command can be used in case the default number of decimals in a table is unsatisfactory')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.excv","title":"excv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>excv: Optional[float] = Field(default=None, description='In case there is no valid value (e.g. wave height in a dry point) this exception value is written in a table or block output')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.power","title":"power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>power: Optional[float] = Field(default=None, description='power `p` appearing in the definition of `PER`, `RPER` and `WLEN`. Note that the value for `power` given for `PER` affects also the value of `RPER`; the power for `WLEN` is independent of that of `PER` or `RPER` (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref: Optional[str] = Field(default=None, description='Reference time used for the quantity `TSEC`. Default value: starting time of the first computation, except in cases where this is later than the time of the earliest input. In these cases, the time of the earliest input is used')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fswell","title":"fswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fswell: Optional[float] = Field(default=None, description='Upper limit of frequency range used for computing the quantity HSWELL (SWAN default: 0.1 Hz)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.noswll","title":"noswll  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>noswll: Optional[int] = Field(default=None, description='Number of swells to output for watershed quantities ')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fmin","title":"fmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmin: Optional[float] = Field(default=None, description='Lower limit of frequency range used for computing integral parameters (SWAN Default: 0.0 Hz)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.fmax","title":"fmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmax: Optional[float] = Field(default=None, description='Upper limit of frequency range used for computing integral parameters (SWAN default: 1000.0 Hz, acts as infinity)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY.coord","title":"coord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coord: Optional[Literal['problemcoord', 'frame']] = Field(default=None, description=\"Define if vectors and directions refer to the problem coordinate system ('problemcoord') or sets created by command FRAME ('frame') (SWAN default: problemcoord)\")\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITY-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"QUANTITY\"\n    for output in self.output:\n        repr += f\" {output.upper()}\"\n    if self.short is not None:\n        repr += f\" short='{self.short}'\"\n    if self.long is not None:\n        repr += f\" long='{self.long}'\"\n    if self.lexp is not None:\n        repr += f\" lexp={self.lexp}\"\n    if self.hexp is not None:\n        repr += f\" hexp={self.hexp}\"\n    if self.excv is not None:\n        repr += f\" excv={self.excv}\"\n    if self.power is not None:\n        repr += f\" power={self.power}\"\n    if self.ref is not None:\n        repr += f\" ref='{self.ref}'\"\n    if self.fswell is not None:\n        repr += f\" fswell={self.fswell}\"\n    if self.noswll is not None:\n        repr += f\" noswll={self.noswll}\"\n    if self.fmin is not None:\n        repr += f\" fmin={self.fmin}\"\n    if self.fmax is not None:\n        repr += f\" fmax={self.fmax}\"\n    if self.coord is not None:\n        repr += f\" {self.coord.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES","title":"QUANTITIES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Define output settings for multiple output.</p> <p>.. code-block:: text</p> <pre><code>QUANTITY &lt; output &gt; ...\nQUANTITY &lt; output &gt; ...\n..\n</code></pre> <p>This component can be used to prescribe and render multiple QUANTITY components.</p>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import QUANTITY, QUANTITIES\nq1 = QUANTITY(output=[\"xp\"], hexp=100)\nq2 = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\nq3 = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\nq4 = QUANTITY(output=[\"hsign\"], fswell=0.08)\nq5 = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\nq6 = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\nquantities = QUANTITIES(quantities=[q1, q2, q3, q4, q5, q6])\nprint(quantities.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class QUANTITIES(BaseComponent):\n    \"\"\"Define output settings for multiple output.\n\n    .. code-block:: text\n\n        QUANTITY &lt; output &gt; ...\n        QUANTITY &lt; output &gt; ...\n        ..\n\n    This component can be used to prescribe and render multiple QUANTITY components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import QUANTITY, QUANTITIES\n        q1 = QUANTITY(output=[\"xp\"], hexp=100)\n        q2 = QUANTITY(output=[\"hsign\", \"tm01\", \"rtmm10\"], excv=-9)\n        q3 = QUANTITY(output=[\"hsign\", \"tm02\", \"fspr\"], fmin=0.03, fmax=0.5)\n        q4 = QUANTITY(output=[\"hsign\"], fswell=0.08)\n        q5 = QUANTITY(output=[\"per\"], short=\"Tm-1,0\", power=0)\n        q6 = QUANTITY(output=[\"transp\", \"force\"], coord=\"frame\")\n        quantities = QUANTITIES(quantities=[q1, q2, q3, q4, q5, q6])\n        print(quantities.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quantities\", \"QUANTITIES\"] = Field(\n        default=\"quantities\", description=\"Model type discriminator\"\n    )\n    quantities: list[QUANTITY] = Field(description=\"QUANTITY components\")\n\n    def cmd(self) -&gt; list:\n        repr = []\n        for quantity in self.quantities:\n            repr += [quantity.cmd()]\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quantities', 'QUANTITIES'] = Field(default='quantities', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.quantities","title":"quantities  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantities: list[QUANTITY] = Field(description='QUANTITY components')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.QUANTITIES-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.QUANTITIES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; list:\n    repr = []\n    for quantity in self.quantities:\n        repr += [quantity.cmd()]\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS","title":"OUTPUT_OPTIONS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Set format of output.</p> <p>.. code-block:: text</p> <pre><code>OUTPUT OPTIons 'comment' (TABLE [field]) (BLOCK [ndec] [len]) (SPEC [ndec])\n</code></pre> <p>This command enables the user to influence the format of block, table and spectral output.</p>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import OUTPUT_OPTIONS\nopts = OUTPUT_OPTIONS(\n    comment=\"!\", field=10, ndec_block=4, len=20, ndec_spec=6,\n)\nprint(opts.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class OUTPUT_OPTIONS(BaseComponent):\n    \"\"\"Set format of output.\n\n    .. code-block:: text\n\n        OUTPUT OPTIons 'comment' (TABLE [field]) (BLOCK [ndec] [len]) (SPEC [ndec])\n\n    This command enables the user to influence the format of block, table and spectral\n    output.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import OUTPUT_OPTIONS\n        opts = OUTPUT_OPTIONS(\n            comment=\"!\", field=10, ndec_block=4, len=20, ndec_spec=6,\n        )\n        print(opts.render())\n\n    \"\"\"\n\n    model_type: Literal[\"block\", \"BLOCK\"] = Field(\n        default=\"block\", description=\"Model type discriminator\"\n    )\n    comment: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Comment character used in comment lines in the output (SWAN default: %)\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    field: Optional[int] = Field(\n        default=None,\n        description=\"Length of one data field in a table (SWAN default: 12)\",\n        ge=8,\n        le=16,\n    )\n    ndec_block: Optional[int] = Field(\n        default=None,\n        description=\"Number of decimals in block output (SWAN default: 4)\",\n        ge=0,\n        le=9,\n    )\n    len: Optional[int] = Field(\n        default=None,\n        description=\"Number of data on one line of block output (SWAN default: 6)\",\n        ge=1,\n        le=9999,\n    )\n    ndec_spec: Optional[int] = Field(\n        default=None,\n        description=\"Number of decimals in spectra output (SWAN default: 4)\",\n        ge=0,\n        le=9,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"OUTPUT OPTIONS\"\n        if self.comment is not None:\n            repr += f\" comment='{self.comment}'\"\n        if self.field is not None:\n            repr += f\" TABLE field={self.field}\"\n        if self.ndec_block is not None or self.len is not None:\n            repr += \" BLOCK\"\n            if self.ndec_block is not None:\n                repr += f\" ndec={self.ndec_block}\"\n            if self.len is not None:\n                repr += f\" len={self.len}\"\n        if self.ndec_spec is not None:\n            repr += f\" SPEC ndec={self.ndec_spec}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['block', 'BLOCK'] = Field(default='block', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: Optional[str] = Field(default=None, description='Comment character used in comment lines in the output (SWAN default: %)', min_length=1, max_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[int] = Field(default=None, description='Length of one data field in a table (SWAN default: 12)', ge=8, le=16)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.ndec_block","title":"ndec_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ndec_block: Optional[int] = Field(default=None, description='Number of decimals in block output (SWAN default: 4)', ge=0, le=9)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.len","title":"len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>len: Optional[int] = Field(default=None, description='Number of data on one line of block output (SWAN default: 6)', ge=1, le=9999)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.ndec_spec","title":"ndec_spec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ndec_spec: Optional[int] = Field(default=None, description='Number of decimals in spectra output (SWAN default: 4)', ge=0, le=9)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.OUTPUT_OPTIONS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"OUTPUT OPTIONS\"\n    if self.comment is not None:\n        repr += f\" comment='{self.comment}'\"\n    if self.field is not None:\n        repr += f\" TABLE field={self.field}\"\n    if self.ndec_block is not None or self.len is not None:\n        repr += \" BLOCK\"\n        if self.ndec_block is not None:\n            repr += f\" ndec={self.ndec_block}\"\n        if self.len is not None:\n            repr += f\" len={self.len}\"\n    if self.ndec_spec is not None:\n        repr += f\" SPEC ndec={self.ndec_spec}\"\n    return repr\n</code></pre>"},{"location":"components/output/#write","title":"Write","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite","title":"BaseWrite","text":"<p>               Bases: <code>BaseComponent</code>, <code>ABC</code></p> <p>Base class for SWAN output writing.</p> <p>.. code-block:: text</p> <pre><code>{MODEL_TYPE} sname='sname'\n</code></pre> <p>This is the base class for all write components. It is not meant to be used directly.</p>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BaseWrite\nwrite = BaseWrite(\n    sname=\"outgrid\",\n    fname=\"./output-grid.nc\",\n    times=dict(\n        tbeg=\"2012-01-01T00:00:00\",\n        delt=\"PT30M\",\n        tfmt=1,\n        dfmt=\"min\",\n        suffix=\"\",\n    )\n)\nprint(write.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class BaseWrite(BaseComponent, ABC):\n    \"\"\"Base class for SWAN output writing.\n\n    .. code-block:: text\n\n        {MODEL_TYPE} sname='sname'\n\n    This is the base class for all write components. It is not meant to be used\n    directly.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BaseWrite\n        write = BaseWrite(\n            sname=\"outgrid\",\n            fname=\"./output-grid.nc\",\n            times=dict(\n                tbeg=\"2012-01-01T00:00:00\",\n                delt=\"PT30M\",\n                tfmt=1,\n                dfmt=\"min\",\n                suffix=\"\",\n            )\n        )\n        print(write.render())\n\n    \"\"\"\n\n    model_type: Literal[\"write\", \"WRITE\"] = Field(\n        default=\"write\",\n        description=\"Model type discriminator\",\n    )\n    sname: str = Field(\n        description=(\n            \"Name of the set of output locations in which the output is to be written\"\n        ),\n        max_length=8,\n    )\n    fname: str = Field(\n        description=(\n            \"Name of the data file where the output is written to The file format is \"\n            \"defined by the file extension, use `.mat` for MATLAB binary (single \"\n            \"precision) or `.nc` for netCDF format. If any other extension is used \"\n            \"the ASCII format is assumed\"\n        ),\n    )\n    times: Optional[TimeRangeOpen] = Field(\n        default=None,\n        description=(\n            \"Time specification if the user requires output at various times. If this \"\n            \"option is not specified data will be written for the last time step of \"\n            \"the computation\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_special_names(self) -&gt; \"BaseWrite\":\n        special_names = (\"COMPGRID\", \"BOTTGRID\")\n        snames = self.sname if isinstance(self.sname, list) else [self.sname]\n        for sname in snames:\n            if sname in special_names and self.model_type.upper() != \"BLOCK\":\n                raise ValueError(f\"Special name {sname} is only supported with BLOCK\")\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_times(self) -&gt; \"BaseWrite\":\n        if self.times is not None:\n            self.times.suffix = self.suffix\n        return self\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['write', 'WRITE'] = Field(default='write', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.sname","title":"sname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sname: str = Field(description='Name of the set of output locations in which the output is to be written', max_length=8)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the data file where the output is written to The file format is defined by the file extension, use `.mat` for MATLAB binary (single precision) or `.nc` for netCDF format. If any other extension is used the ASCII format is assumed')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.times","title":"times  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>times: Optional[TimeRangeOpen] = Field(default=None, description='Time specification if the user requires output at various times. If this option is not specified data will be written for the last time step of the computation')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BaseWrite.validate_special_names","title":"validate_special_names","text":"<pre><code>validate_special_names() -&gt; BaseWrite\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_special_names(self) -&gt; \"BaseWrite\":\n    special_names = (\"COMPGRID\", \"BOTTGRID\")\n    snames = self.sname if isinstance(self.sname, list) else [self.sname]\n    for sname in snames:\n        if sname in special_names and self.model_type.upper() != \"BLOCK\":\n            raise ValueError(f\"Special name {sname} is only supported with BLOCK\")\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.validate_times","title":"validate_times","text":"<pre><code>validate_times() -&gt; BaseWrite\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_times(self) -&gt; \"BaseWrite\":\n    if self.times is not None:\n        self.times.suffix = self.suffix\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BaseWrite.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK","title":"BLOCK","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n    [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that one or more spatial distributions should be written to a file.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note","title":"Note","text":"<p>The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the <code>sname</code> field.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note_1","title":"Note","text":"<p>The text of the header indicates run identification (see command <code>PROJECT</code>), time, frame or group name ('sname'), variable and unit. The number of header lines is 8.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--note_2","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.BLOCK--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import BLOCK\nblock = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\nprint(block.render())\nblock = BLOCK(\n    sname=\"COMPGRID\",\n    header=False,\n    fname=\"./output-grid.nc\",\n    idla=3,\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(\n        tbeg=\"2012-01-01T00:00:00\",\n        delt=\"PT30M\",\n        tfmt=1,\n        dfmt=\"min\",\n        suffix=\"\",\n    )\n)\nprint(block.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class BLOCK(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        BLOCK 'sname' -&gt;HEADER|NOHEADER 'fname' (LAYOUT [idla]) &lt; output &gt; &amp;\n            [unit] (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that one or more spatial\n    distributions should be written to a file.\n\n    Note\n    ----\n    The SWAN special frames 'BOTTGRID' or 'COMPGRID' can be set with the `sname` field.\n\n    Note\n    ----\n    The text of the header indicates run identification (see command `PROJECT`), time,\n    frame or group name ('sname'), variable and unit. The number of header lines is 8.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import BLOCK\n        block = BLOCK(sname=\"outgrid\", fname=\"./depth-frame.nc\", output=[\"depth\"])\n        print(block.render())\n        block = BLOCK(\n            sname=\"COMPGRID\",\n            header=False,\n            fname=\"./output-grid.nc\",\n            idla=3,\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(\n                tbeg=\"2012-01-01T00:00:00\",\n                delt=\"PT30M\",\n                tfmt=1,\n                dfmt=\"min\",\n                suffix=\"\",\n            )\n        )\n        print(block.render())\n\n    \"\"\"\n\n    model_type: Literal[\"block\", \"BLOCK\"] = Field(\n        default=\"block\", description=\"Model type discriminator\"\n    )\n    header: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Indicate if the output should be written to a file with header lines \"\n            \"(SWAN default: True)\"\n        ),\n    )\n    idla: Optional[IDLA] = Field(\n        default=None,\n        description=(\n            \"Prescribe the lay-out of the output to file (supported options here are \"\n            \"1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by \"\n            \"MATLAB, however option 3 is recommended in case of binary MATLAB output \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n    unit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of the output. The program divides computed values \"\n            \"by `unit` before writing to file, so the user should multiply the \"\n            \"written value by `unit` to obtain the proper value. By default, if \"\n            \"HEADER is selected, value is written as a 5 position integer. SWAN takes \"\n            \"`unit` such that the largest number occurring in the block can be \"\n            \"printed. If NOHEADER is selected, values are printed in floating-point \"\n            \"format by default (`unit=1`)\"\n        ),\n    )\n\n    @field_validator(\"idla\")\n    @classmethod\n    def validate_idla(cls, idla: IDLA) -&gt; IDLA:\n        if idla is not None and idla not in (1, 3, 4):\n            raise ValueError(\n                f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n            )\n        return idla\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"blk\"\n\n    @property\n    def _header(self) -&gt; str:\n        \"\"\"Render the header instruction.\"\"\"\n        if self.header:\n            return \"HEADER\"\n        else:\n            return \"NOHEADER\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"BLOCK sname='{self.sname}'\"\n        if self.header is not None:\n            repr += f\" {self._header}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.idla is not None:\n            repr += f\" LAYOUT idla={self.idla}\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.unit is not None:\n            repr += f\"\\nunit={self.unit}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.BLOCK.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['block', 'BLOCK'] = Field(default='block', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: Optional[bool] = Field(default=None, description='Indicate if the output should be written to a file with header lines (SWAN default: True)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[IDLA] = Field(default=None, description='Prescribe the lay-out of the output to file (supported options here are 1, 3, 4). Option 4 is recommended for postprocessing an ASCII file by MATLAB, however option 3 is recommended in case of binary MATLAB output (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: Optional[float] = Field(default=None, description='Controls the scaling of the output. The program divides computed values by `unit` before writing to file, so the user should multiply the written value by `unit` to obtain the proper value. By default, if HEADER is selected, value is written as a 5 position integer. SWAN takes `unit` such that the largest number occurring in the block can be printed. If NOHEADER is selected, values are printed in floating-point format by default (`unit=1`)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.BLOCK.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(idla: IDLA) -&gt; IDLA\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@field_validator(\"idla\")\n@classmethod\ndef validate_idla(cls, idla: IDLA) -&gt; IDLA:\n    if idla is not None and idla not in (1, 3, 4):\n        raise ValueError(\n            f\"Only IDLA options (1, 3, 4) are supported in BLOCK, got {idla}\"\n        )\n    return idla\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.BLOCK.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"BLOCK sname='{self.sname}'\"\n    if self.header is not None:\n        repr += f\" {self._header}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.idla is not None:\n        repr += f\" LAYOUT idla={self.idla}\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.unit is not None:\n        repr += f\"\\nunit={self.unit}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE","title":"TABLE","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write spatial distributions.</p> <p>.. code-block:: text</p> <pre><code>TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n    (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) one or more variables should be written to a file. The keywords <code>HEADER</code> and <code>NOHEADER</code> determine the appearance of the table; the filename determines the destination of the data.</p>"},{"location":"components/output/#rompy_swan.components.output.TABLE--note","title":"Note","text":"<p>HEADER: output is written in fixed format to file with headers giving name of variable and unit per column (numbers too large to be written will be shown as <code>****</code>. The number of header lines is 4.</p> <p>NOHEADER: output is written in floating point format to file and has no headers.</p> <p>INDEXED: output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should give two TABLE commands, one to produce one file with <code>XP</code> and <code>YP</code> as output quantities, the other with <code>HS</code>, <code>RTM01</code> or other output quantities.</p>"},{"location":"components/output/#rompy_swan.components.output.TABLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import TABLE\ntable = TABLE(\n    sname=\"outpts\",\n    format=\"noheader\",\n    fname=\"./output_table.nc\",\n    output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(table.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class TABLE(BaseWrite):\n    \"\"\"Write spatial distributions.\n\n    .. code-block:: text\n\n        TABLE 'sname' -&gt;HEADER|NOHEADER|INDEXED 'fname'  &lt; output &gt; &amp;\n            (OUTPUT [tbegblk] [deltblk]) SEC|MIN|HR|DAY\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) one or\n    more variables should be written to a file. The keywords `HEADER` and `NOHEADER`\n    determine the appearance of the table; the filename determines the destination of\n    the data.\n\n    Note\n    ----\n    **HEADER**:\n    output is written in fixed format to file with headers giving name of variable\n    and unit per column (numbers too large to be written will be shown as `****`.\n    The number of header lines is 4.\n\n    **NOHEADER**:\n    output is written in floating point format to file and has no headers.\n\n    **INDEXED**:\n    output compatible with GIS tools such as ARCVIEW, ARCINFO, etc. The user should\n    give two TABLE commands, one to produce one file with `XP` and `YP` as output\n    quantities, the other with `HS`, `RTM01` or other output quantities.\n\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import TABLE\n        table = TABLE(\n            sname=\"outpts\",\n            format=\"noheader\",\n            fname=\"./output_table.nc\",\n            output=[\"hsign\", \"hswell\", \"dir\", \"tps\", \"tm01\", \"watlev\", \"qp\"],\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(table.render())\n\n    \"\"\"\n\n    model_type: Literal[\"table\", \"TABLE\"] = Field(\n        default=\"table\", description=\"Model type discriminator\"\n    )\n    format: Optional[Literal[\"header\", \"noheader\", \"indexed\"]] = Field(\n        default=None,\n        description=(\n            \"Indicate if the table should be written to a file as a HEADER, NOHEADER \"\n            \"or INDEXED table format (SWAN default: HEADER)\"\n        ),\n    )\n    output: list[BlockOptions] = Field(\n        description=\"The output variables to output to block file\",\n        min_length=1,\n    )\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"tbl\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"TABLE sname='{self.sname}'\"\n        if self.format is not None:\n            repr += f\" {self.format.upper()}\"\n        repr += f\" fname='{self.fname}'\"\n        for output in self.output:\n            if len(self.output) &gt; 1:\n                repr += \"\\n\"\n            else:\n                repr += \" \"\n            repr += f\"{output.upper()}\"\n        if self.times is not None:\n            repr += f\"\\nOUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.TABLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['table', 'TABLE'] = Field(default='table', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[Literal['header', 'noheader', 'indexed']] = Field(default=None, description='Indicate if the table should be written to a file as a HEADER, NOHEADER or INDEXED table format (SWAN default: HEADER)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: list[BlockOptions] = Field(description='The output variables to output to block file', min_length=1)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TABLE-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.TABLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"TABLE sname='{self.sname}'\"\n    if self.format is not None:\n        repr += f\" {self.format.upper()}\"\n    repr += f\" fname='{self.fname}'\"\n    for output in self.output:\n        if len(self.output) &gt; 1:\n            repr += \"\\n\"\n        else:\n            repr += \" \"\n        repr += f\"{output.upper()}\"\n    if self.times is not None:\n        repr += f\"\\nOUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT","title":"SPECOUT","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write to data file the wave spectra.</p> <p>.. code-block:: text</p> <pre><code>SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n    (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n</code></pre> <p>With this optional command the user indicates that for each location of the output location set 'sname' (see commands <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> or <code>GROUP</code>) the 1D or 2D variance / energy (see command <code>SET</code>) density spectrum (either the relative frequency or the absolute frequency spectrum) is to be written to a data file.</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--note","title":"Note","text":"<p>This write command supports the following location types: <code>POINTS</code>, <code>CURVE</code>, <code>FRAME</code> and <code>GROUP</code>.</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--note_1","title":"Note","text":"<p>This output file can be used for defining boundary conditions for subsequent SWAN runs (command <code>BOUNDSPEC</code>).</p>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import SPECOUT\nout = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\nprint(out.render())\nout = SPECOUT(\n    sname=\"outpts\",\n    dim=dict(model_type=\"spec2d\"),\n    freq=dict(model_type=\"rel\"),\n    fname=\"./specout.nc\",\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(out.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class SPECOUT(BaseWrite):\n    \"\"\"Write to data file the wave spectra.\n\n    .. code-block:: text\n\n        SPECOUT 'sname' SPEC1D|-&gt;SPEC2D -&gt;ABS|REL 'fname' &amp;\n            (OUTPUT [tbeg] [delt] SEC|MIN|HR|DAY)\n\n    With this optional command the user indicates that for each location of the output\n    location set 'sname' (see commands `POINTS`, `CURVE`, `FRAME` or `GROUP`) the 1D\n    or 2D variance / energy (see command `SET`) density spectrum (either the relative\n    frequency or the absolute frequency spectrum) is to be written to a data file.\n\n    Note\n    ----\n    This write command supports the following location types: `POINTS`, `CURVE`,\n    `FRAME` and `GROUP`.\n\n    Note\n    ----\n    This output file can be used for defining boundary conditions for subsequent SWAN\n    runs (command `BOUNDSPEC`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import SPECOUT\n        out = SPECOUT(sname=\"outpts\", fname=\"./specout.swn\")\n        print(out.render())\n        out = SPECOUT(\n            sname=\"outpts\",\n            dim=dict(model_type=\"spec2d\"),\n            freq=dict(model_type=\"rel\"),\n            fname=\"./specout.nc\",\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"specout\", \"SPECOUT\"] = Field(\n        default=\"specout\", description=\"Model type discriminator\"\n    )\n    dim: Optional[DIM_TYPE] = Field(default=None)\n    freq: Optional[FREQ_TYPE] = Field(default=None)\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"spc\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"SPECOUT sname='{self.sname}'\"\n        if self.dim is not None:\n            repr += f\" {self.dim.render()}\"\n        if self.freq is not None:\n            repr += f\" {self.freq.render()}\"\n        repr += f\" fname='{self.fname}'\"\n        if self.times is not None:\n            repr += f\" OUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.SPECOUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['specout', 'SPECOUT'] = Field(default='specout', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Optional[DIM_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.freq","title":"freq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freq: Optional[FREQ_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.SPECOUT-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.SPECOUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"SPECOUT sname='{self.sname}'\"\n    if self.dim is not None:\n        repr += f\" {self.dim.render()}\"\n    if self.freq is not None:\n        repr += f\" {self.freq.render()}\"\n    repr += f\" fname='{self.fname}'\"\n    if self.times is not None:\n        repr += f\" OUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT","title":"NESTOUT","text":"<p>               Bases: <code>BaseWrite</code></p> <p>Write to 2D boundary spectra.</p> <p>.. code-block:: text</p> <pre><code>NESTOUT 'sname' 'fname' (OUTPUT [tbegnst] [deltnst] -&gt;SEC|MIN|HR|DAY)\n</code></pre> <p>Write to data file two-dimensional action density spectra (relative frequency) along the boundary of a nested grid (see command NGRID) to be used in a subsequent SWAN run.</p>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT--note","title":"Note","text":"<p>Cannot be used in 1D-mode.</p>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import NESTOUT\nout = NESTOUT(\n    sname=\"outnest\",\n    fname=\"./nestout.swn\",\n    times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n)\nprint(out.render())\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class NESTOUT(BaseWrite):\n    \"\"\"Write to 2D boundary spectra.\n\n    .. code-block:: text\n\n        NESTOUT 'sname' 'fname' (OUTPUT [tbegnst] [deltnst] -&gt;SEC|MIN|HR|DAY)\n\n    Write to data file two-dimensional action density spectra (relative frequency)\n    along the boundary of a nested grid (see command NGRID) to be used in a subsequent\n    SWAN run.\n\n    Note\n    ----\n    Cannot be used in 1D-mode.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import NESTOUT\n        out = NESTOUT(\n            sname=\"outnest\",\n            fname=\"./nestout.swn\",\n            times=dict(tbeg=\"2012-01-01T00:00:00\", delt=\"PT30M\", dfmt=\"min\"),\n        )\n        print(out.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nestout\", \"NESTOUT\"] = Field(\n        default=\"nestout\", description=\"Model type discriminator\"\n    )\n\n    @property\n    def suffix(self) -&gt; str:\n        return \"nst\"\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"NESTOUT sname='{self.sname}' fname='{self.fname}'\"\n        if self.times is not None:\n            repr += f\" OUTPUT {self.times.render()}\"\n        return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.NESTOUT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nestout', 'NESTOUT'] = Field(default='nestout', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT.suffix","title":"suffix  <code>property</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.NESTOUT-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.NESTOUT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"NESTOUT sname='{self.sname}' fname='{self.fname}'\"\n    if self.times is not None:\n        repr += f\" OUTPUT {self.times.render()}\"\n    return repr\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST","title":"TEST","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Write intermediate results.</p> <p>.. code-block:: text</p> <pre><code>TEST [itest] [itrace] POINTS XY|IJ (PAR 'fname') (S1D 'fname') (S2D 'fname')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST--note","title":"Note","text":"<p>The 6 source terms written due to the presence of the keyword S1D or S2D are: wind input, whitecapping, bottom friction, breaking, 3- and 4- wave interactions.</p>"},{"location":"components/output/#rompy_swan.components.output.TEST--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.output import TEST\ntest = TEST(\n    itest=10,\n    points=dict(model_type=\"ij\", i=[0, 0], j=[10, 20]),\n    fname_par=\"integral_parameters.test\",\n    fname_s1d=\"1d_variance_density.test\",\n    fname_s2d=\"2d_variance_density.test\",\n)\nprint(test.render())\nimport numpy as np\ntest = TEST(\n    points=dict(\n        model_type=\"xy\",\n        x=np.linspace(172.5, 174.0, 25),\n        y=25*[-38],\n    ),\n    fname_s2d=\"2d_variance_density.test\",\n)\nprint(test.render())\n</code></pre> <p>TODO: Support <code>k</code> in POINTS IJ.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>class TEST(BaseComponent):\n    \"\"\"Write intermediate results.\n\n    .. code-block:: text\n\n        TEST [itest] [itrace] POINTS XY|IJ (PAR 'fname') (S1D 'fname') (S2D 'fname')\n\n    Note\n    ----\n    The 6 source terms written due to the presence of the keyword S1D or S2D are: wind\n    input, whitecapping, bottom friction, breaking, 3- and 4- wave interactions.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.output import TEST\n        test = TEST(\n            itest=10,\n            points=dict(model_type=\"ij\", i=[0, 0], j=[10, 20]),\n            fname_par=\"integral_parameters.test\",\n            fname_s1d=\"1d_variance_density.test\",\n            fname_s2d=\"2d_variance_density.test\",\n        )\n        print(test.render())\n        import numpy as np\n        test = TEST(\n            points=dict(\n                model_type=\"xy\",\n                x=np.linspace(172.5, 174.0, 25),\n                y=25*[-38],\n            ),\n            fname_s2d=\"2d_variance_density.test\",\n        )\n        print(test.render())\n\n    TODO: Support `k` in POINTS IJ.\n\n    \"\"\"\n\n    model_type: Literal[\"test\", \"TEST\"] = Field(\n        default=\"test\", description=\"Model type discriminator\"\n    )\n    itest: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The level of test output, for values under 100 the amount is usually \"\n            \"reasonable, for values above 200 it can be very large. Values of up to \"\n            \"50 can be interpreted by the user (SWAN default: 1)\"\n        ),\n    )\n    itrace: Optional[int] = Field(\n        default=None,\n        description=(\n            \"SWAN writes a message (name of subroutine) to the PRINT file at the \"\n            \"first `itrace` entries of each subroutine (SWAN default: 0)\"\n        ),\n    )\n    points: Union[XY, IJ] = Field(\n        description=\"Points where detailed print output is produced (max of 50 points)\",\n        discriminator=\"model_type\",\n    )\n    fname_par: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file where the integral parameters are written to\",\n    )\n    fname_par: Optional[str] = Field(\n        default=None,\n        description=\"Name of the file where the integral parameters are written to\",\n    )\n    fname_s1d: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the file where the 1D variance density and 6 source terms are \"\n            \"written to\"\n        ),\n    )\n    fname_s2d: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of the file where the 2D variance density and 6 source terms are \"\n            \"written to\"\n        ),\n    )\n\n    @field_validator(\"points\")\n    @classmethod\n    def validate_points(cls, points: Union[XY, IJ]) -&gt; Union[XY, IJ]:\n        if points.size &gt; 50:\n            raise ValueError(f\"Maximum of 50 points allowed in TEST, got {points.size}\")\n        return points\n\n    @model_validator(mode=\"after\")\n    def at_least_one(self) -&gt; \"TEST\":\n        \"\"\"Warns if no test file is being specified.\"\"\"\n        if all(v is None for v in [self.fname_par, self.fname_s1d, self.fname_s2d]):\n            logger.warning(\n                \"TEST command prescribed with no output files, please ensure at least \"\n                \"one of ()`fname_par`, `fname_s1d` or `fname_s2d`) is specified\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TEST\"\n        if self.itest is not None:\n            repr += f\" itest={self.itest}\"\n        if self.itrace is not None:\n            repr += f\" itrace={self.itrace}\"\n        repr += f\" POINTS {self.points.model_type.upper()}{self.points.render()}\"\n        if self.fname_par is not None:\n            repr += f\"PAR fname='{self.fname_par}' \"\n        if self.fname_s1d is not None:\n            repr += f\"S1D fname='{self.fname_s1d}' \"\n        if self.fname_s2d is not None:\n            repr += f\"S2D fname='{self.fname_s2d}' \"\n        return repr.rstrip()\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST-attributes","title":"Attributes","text":""},{"location":"components/output/#rompy_swan.components.output.TEST.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['test', 'TEST'] = Field(default='test', description='Model type discriminator')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.itest","title":"itest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itest: Optional[int] = Field(default=None, description='The level of test output, for values under 100 the amount is usually reasonable, for values above 200 it can be very large. Values of up to 50 can be interpreted by the user (SWAN default: 1)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.itrace","title":"itrace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itrace: Optional[int] = Field(default=None, description='SWAN writes a message (name of subroutine) to the PRINT file at the first `itrace` entries of each subroutine (SWAN default: 0)')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Union[XY, IJ] = Field(description='Points where detailed print output is produced (max of 50 points)', discriminator='model_type')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_par","title":"fname_par  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_par: Optional[str] = Field(default=None, description='Name of the file where the integral parameters are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_s1d","title":"fname_s1d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_s1d: Optional[str] = Field(default=None, description='Name of the file where the 1D variance density and 6 source terms are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.fname_s2d","title":"fname_s2d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname_s2d: Optional[str] = Field(default=None, description='Name of the file where the 2D variance density and 6 source terms are written to')\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST-functions","title":"Functions","text":""},{"location":"components/output/#rompy_swan.components.output.TEST.validate_points","title":"validate_points  <code>classmethod</code>","text":"<pre><code>validate_points(points: Union[XY, IJ]) -&gt; Union[XY, IJ]\n</code></pre> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@field_validator(\"points\")\n@classmethod\ndef validate_points(cls, points: Union[XY, IJ]) -&gt; Union[XY, IJ]:\n    if points.size &gt; 50:\n        raise ValueError(f\"Maximum of 50 points allowed in TEST, got {points.size}\")\n    return points\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.at_least_one","title":"at_least_one","text":"<pre><code>at_least_one() -&gt; TEST\n</code></pre> <p>Warns if no test file is being specified.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>@model_validator(mode=\"after\")\ndef at_least_one(self) -&gt; \"TEST\":\n    \"\"\"Warns if no test file is being specified.\"\"\"\n    if all(v is None for v in [self.fname_par, self.fname_s1d, self.fname_s2d]):\n        logger.warning(\n            \"TEST command prescribed with no output files, please ensure at least \"\n            \"one of ()`fname_par`, `fname_s1d` or `fname_s2d`) is specified\"\n        )\n    return self\n</code></pre>"},{"location":"components/output/#rompy_swan.components.output.TEST.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TEST\"\n    if self.itest is not None:\n        repr += f\" itest={self.itest}\"\n    if self.itrace is not None:\n        repr += f\" itrace={self.itrace}\"\n    repr += f\" POINTS {self.points.model_type.upper()}{self.points.render()}\"\n    if self.fname_par is not None:\n        repr += f\"PAR fname='{self.fname_par}' \"\n    if self.fname_s1d is not None:\n        repr += f\"S1D fname='{self.fname_s1d}' \"\n    if self.fname_s2d is not None:\n        repr += f\"S2D fname='{self.fname_s2d}' \"\n    return repr.rstrip()\n</code></pre>"},{"location":"components/physics/","title":"Physics","text":"<p>SWAN physics commands</p>"},{"location":"components/physics/#generation","title":"Generation","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1","title":"GEN1","text":"<p>               Bases: <code>BaseComponent</code></p> <p>First generation source terms GEN1.</p> <p>.. code-block:: text</p> <pre><code>GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in first-generation mode (see Scientific/Technical documentation).</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN1\ngen = GEN1()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN1(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class GEN1(BaseComponent):\n    \"\"\"First generation source terms GEN1.\n\n    .. code-block:: text\n\n        GEN1 [cf10] [cf20] [cf30] [cf40] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in first-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN1\n        gen = GEN1()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN1(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen1\", \"GEN1\"] = Field(\n        default=\"gen1\", description=\"Model type discriminator\"\n    )\n    cf10: Optional[float] = Field(\n        default=None,\n        description=\"Controls the linear wave growth (SWAN default: 188.0)\",\n    )\n    cf20: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.59)\",\n    )\n    cf30: Optional[float] = Field(\n        default=None,\n        description=\"Controls the exponential wave growth (SWAN default: 0.12)\",\n    )\n    cf40: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the dissipation rate, i.e., the time decay scale \"\n            \"(SWAN default: 250.0)\"\n        ),\n    )\n    edmlpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum non-dimensionless energy density of the wind sea part of the \"\n            \"spectrum according to Pierson Moskowitz (SWAN default: 0.0036)\"\n        ),\n    )\n    cdrag: Optional[float] = Field(\n        default=None, description=\"Drag coefficient (SWAN default: 0.0012)\"\n    )\n    umin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Minimum wind velocity (relative to current; all wind speeds \"\n            \"are taken at 10 m above sea level) (SWAN default: 1)\"\n        ),\n    )\n    cfpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the Pierson Moskowitz frequency: \"\n            \"`delta_PM = 2pi g / U_10` (SWAN default: 0.13)\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN1\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen1', 'GEN1'] = Field(default='gen1', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf10","title":"cf10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf10: Optional[float] = Field(default=None, description='Controls the linear wave growth (SWAN default: 188.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf20","title":"cf20  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf20: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.59)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf30","title":"cf30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf30: Optional[float] = Field(default=None, description='Controls the exponential wave growth (SWAN default: 0.12)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cf40","title":"cf40  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf40: Optional[float] = Field(default=None, description='Controls the dissipation rate, i.e., the time decay scale (SWAN default: 250.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.edmlpm","title":"edmlpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>edmlpm: Optional[float] = Field(default=None, description='Maximum non-dimensionless energy density of the wind sea part of the spectrum according to Pierson Moskowitz (SWAN default: 0.0036)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cdrag","title":"cdrag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdrag: Optional[float] = Field(default=None, description='Drag coefficient (SWAN default: 0.0012)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.umin","title":"umin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>umin: Optional[float] = Field(default=None, description='Minimum wind velocity (relative to current; all wind speeds are taken at 10 m above sea level) (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cfpm","title":"cfpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfpm: Optional[float] = Field(default=None, description='Coefficient which determines the Pierson Moskowitz frequency: `delta_PM = 2pi g / U_10` (SWAN default: 0.13)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN1-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN1.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN1\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2","title":"GEN2","text":"<p>               Bases: <code>GEN1</code></p> <p>Second generation source terms GEN2.</p> <p>.. code-block:: text</p> <pre><code>GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n</code></pre> <p>With this command the user indicates that SWAN should run in second-generation mode (see Scientific/Technical documentation).</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN2\ngen = GEN2()\nprint(gen.render())\nkwargs = dict(\n    cf10=188.0,\n    cf20=0.59,\n    cf30=0.12,\n    cf40=250.0,\n    cf50=0.0023,\n    cf60=-0.223,\n    edmlpm=0.0036,\n    cdrag=0.0012,\n    umin=1.0,\n    cfpm=0.13\n)\ngen = GEN2(**kwargs)\nprint(gen.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class GEN2(GEN1):\n    \"\"\"Second generation source terms GEN2.\n\n    .. code-block:: text\n\n        GEN2 [cf10] [cf20] [cf30] [cf40] [cf50] [cf60] [edmlpm] [cdrag] [umin] [cfpm]\n\n    With this command the user indicates that SWAN should run in second-generation mode\n    (see Scientific/Technical documentation).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN2\n        gen = GEN2()\n        print(gen.render())\n        kwargs = dict(\n            cf10=188.0,\n            cf20=0.59,\n            cf30=0.12,\n            cf40=250.0,\n            cf50=0.0023,\n            cf60=-0.223,\n            edmlpm=0.0036,\n            cdrag=0.0012,\n            umin=1.0,\n            cfpm=0.13\n        )\n        gen = GEN2(**kwargs)\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen2\", \"GEN2\"] = Field(\n        default=\"gen2\", description=\"Model type discriminator\"\n    )\n    cf50: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: 0.0023)\"\n        ),\n    )\n    cf60: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Ccontrols the spectral energy scale of the limit spectrum \"\n            \"(SWAN default: -0.223\"\n        ),\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = \"GEN2\"\n        if self.cf10 is not None:\n            repr += f\" cf10={self.cf10}\"\n        if self.cf20 is not None:\n            repr += f\" cf20={self.cf20}\"\n        if self.cf30 is not None:\n            repr += f\" cf30={self.cf30}\"\n        if self.cf40 is not None:\n            repr += f\" cf40={self.cf40}\"\n        if self.cf50 is not None:\n            repr += f\" cf50={self.cf50}\"\n        if self.cf60 is not None:\n            repr += f\" cf60={self.cf60}\"\n        if self.edmlpm is not None:\n            repr += f\" edmlpm={self.edmlpm}\"\n        if self.cdrag is not None:\n            repr += f\" cdrag={self.cdrag}\"\n        if self.umin is not None:\n            repr += f\" umin={self.umin}\"\n        if self.cfpm is not None:\n            repr += f\" cfpm={self.cfpm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen2', 'GEN2'] = Field(default='gen2', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cf50","title":"cf50  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf50: Optional[float] = Field(default=None, description='Controls the spectral energy scale of the limit spectrum (SWAN default: 0.0023)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cf60","title":"cf60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cf60: Optional[float] = Field(default=None, description='Ccontrols the spectral energy scale of the limit spectrum (SWAN default: -0.223')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN2-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN2.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = \"GEN2\"\n    if self.cf10 is not None:\n        repr += f\" cf10={self.cf10}\"\n    if self.cf20 is not None:\n        repr += f\" cf20={self.cf20}\"\n    if self.cf30 is not None:\n        repr += f\" cf30={self.cf30}\"\n    if self.cf40 is not None:\n        repr += f\" cf40={self.cf40}\"\n    if self.cf50 is not None:\n        repr += f\" cf50={self.cf50}\"\n    if self.cf60 is not None:\n        repr += f\" cf60={self.cf60}\"\n    if self.edmlpm is not None:\n        repr += f\" edmlpm={self.edmlpm}\"\n    if self.cdrag is not None:\n        repr += f\" cdrag={self.cdrag}\"\n    if self.umin is not None:\n        repr += f\" umin={self.umin}\"\n    if self.cfpm is not None:\n        repr += f\" cfpm={self.cfpm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3","title":"GEN3","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Third generation source terms GEN3.</p> <p>.. code-block:: text</p> <pre><code>GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n</code></pre> <p>With this command the user indicates that SWAN should run in third-generation mode for wind input, quadruplet interactions and whitecapping.</p>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import GEN3\ngen = GEN3(\n    source_terms=dict(\n        model_type=\"westhuysen\",\n        wind_drag=\"wu\",\n        agrow=True,\n    ),\n)\nprint(gen.render())\nfrom rompy_swan.subcomponents.physics import ST6C1\ngen = GEN3(source_terms=ST6C1())\nprint(gen.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class GEN3(BaseComponent):\n    \"\"\"Third generation source terms GEN3.\n\n    .. code-block:: text\n\n        GEN3 JANSSEN|KOMEN|-&gt;WESTHUYSEN|ST6 AGROW [a]\n\n    With this command the user indicates that SWAN should run in third-generation mode\n    for wind input, quadruplet interactions and whitecapping.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import GEN3\n        gen = GEN3(\n            source_terms=dict(\n                model_type=\"westhuysen\",\n                wind_drag=\"wu\",\n                agrow=True,\n            ),\n        )\n        print(gen.render())\n        from rompy_swan.subcomponents.physics import ST6C1\n        gen = GEN3(source_terms=ST6C1())\n        print(gen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gen3\", \"GEN3\"] = Field(\n        default=\"gen3\", description=\"Model type discriminator\"\n    )\n    source_terms: SOURCE_TERMS = Field(\n        default_factory=WESTHUYSEN,\n        description=\"SWAN source terms to be used (SWAN default: WESTHUYSEN)\",\n        discriminator=\"model_type\",\n    )\n\n    def cmd(self):\n        \"\"\"Command line string for this component.\"\"\"\n        repr = f\"GEN3 {self.source_terms.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gen3', 'GEN3'] = Field(default='gen3', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3.source_terms","title":"source_terms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_terms: SOURCE_TERMS = Field(default_factory=WESTHUYSEN, description='SWAN source terms to be used (SWAN default: WESTHUYSEN)', discriminator='model_type')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.GEN3-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.GEN3.cmd","title":"cmd","text":"<pre><code>cmd()\n</code></pre> <p>Command line string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self):\n    \"\"\"Command line string for this component.\"\"\"\n    repr = f\"GEN3 {self.source_terms.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#swell-dissipation","title":"Swell dissipation","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP","title":"NEGATINP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Negative wind input.</p> <p>.. code-block:: text</p> <pre><code>NEGATINP [rdcoef]\n</code></pre> <p>With this optional command the user activates negative wind input. This is intended only for use with non-breaking swell dissipation SSWELL ZIEGER. Parameter <code>rdcoef</code> is a fraction between 0 and 1, representing the strength of negative wind input. As an example, with [rdcoef]=0.04, for a spectral bin that is opposed to the wind direction, the wind input factor W(k, \u03b8) is negative, and its magnitude is 4% of the corresponding value of the spectral bin that is in the opposite direction (i.e. in the wind direction). See Zieger et al. (2015) eq. 11, where a0 is their notation for [rdcoef]. Default [rdcoef]=0.0 and <code>rdcoef=0.04</code> is recommended, though as implied by Zieger et al. (2015), this value is not well-established, so the user is encouraged to experiment with other values.</p>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP--references","title":"References","text":"<p>Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96, pp.2-25.</p>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import NEGATINP\nnegatinp = NEGATINP()\nprint(negatinp.render())\nnegatinp = NEGATINP(rdcoef=0.04)\nprint(negatinp.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class NEGATINP(BaseComponent):\n    \"\"\"Negative wind input.\n\n    .. code-block:: text\n\n        NEGATINP [rdcoef]\n\n    With this optional command the user activates negative wind input. **This is\n    intended only for use with non-breaking swell dissipation SSWELL ZIEGER**.\n    Parameter `rdcoef` is a fraction between 0 and 1, representing the strength of\n    negative wind input. As an example, with [rdcoef]=0.04, for a spectral bin that is\n    opposed to the wind direction, the wind input factor W(k, \u03b8) is negative, and its\n    magnitude is 4% of the corresponding value of the spectral bin that is in the\n    opposite direction (i.e. in the wind direction). See Zieger et al. (2015) eq. 11,\n    where a0 is their notation for [rdcoef]. Default [rdcoef]=0.0 and `rdcoef=0.04` is\n    recommended, though as implied by Zieger et al. (2015), this value is not\n    well-established, so the user is encouraged to experiment with other values.\n\n    References\n    ----------\n    Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based\n    source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96,\n    pp.2-25.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import NEGATINP\n        negatinp = NEGATINP()\n        print(negatinp.render())\n        negatinp = NEGATINP(rdcoef=0.04)\n        print(negatinp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"negatinp\", \"NEGATINP\"] = Field(\n        default=\"negatinp\", description=\"Model type discriminator\"\n    )\n    rdcoef: Optional[float] = Field(\n        default=None,\n        description=\"Coefficient representing the strength of negative wind input\",\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NEGATINP\"\n        if self.rdcoef is not None:\n            repr += f\" rdcoef={self.rdcoef}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['negatinp', 'NEGATINP'] = Field(default='negatinp', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.rdcoef","title":"rdcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rdcoef: Optional[float] = Field(default=None, description='Coefficient representing the strength of negative wind input', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.NEGATINP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NEGATINP\"\n    if self.rdcoef is not None:\n        repr += f\" rdcoef={self.rdcoef}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN","title":"SSWELL_ARDHUIN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Ardhuin et al. (2010).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ARDHUIN [cdsv]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN--references","title":"References","text":"<p>Ardhuin, F., Rogers, E., Babanin, A.V., Filipot, J.F., Magne, R., Roland, A., Van Der Westhuysen, A., Queffeulou, P., Lefevre, J.M., Aouf, L. and Collard, F., 2010. Semiempirical dissipation source functions for ocean waves. Part I: Definition, calibration, and validation. Journal of Physical Oceanography, 40(9), pp.1917-1941.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ARDHUIN\nsswell = SSWELL_ARDHUIN()\nprint(sswell.render())\nsswell = SSWELL_ARDHUIN(cdsv=1.2)\nprint(sswell.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ARDHUIN(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Ardhuin et al. (2010).\n\n    .. code-block:: text\n\n        SSWELL ARDHUIN [cdsv]\n\n    References\n    ----------\n    Ardhuin, F., Rogers, E., Babanin, A.V., Filipot, J.F., Magne, R., Roland, A.,\n    Van Der Westhuysen, A., Queffeulou, P., Lefevre, J.M., Aouf, L. and Collard, F.,\n    2010. Semiempirical dissipation source functions for ocean waves. Part I:\n    Definition, calibration, and validation. Journal of Physical Oceanography, 40(9),\n    pp.1917-1941.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ARDHUIN\n        sswell = SSWELL_ARDHUIN()\n        print(sswell.render())\n        sswell = SSWELL_ARDHUIN(cdsv=1.2)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ardhuin\", \"ARDHUIN\"] = Field(\n        default=\"ardhuin\", description=\"Model type discriminator\"\n    )\n    cdsv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient related to laminar atmospheric boundary layer \"\n            \"(SWAN default: 1.2)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ARDHUIN\"\n        if self.cdsv is not None:\n            repr += f\" cdsv={self.cdsv}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ardhuin', 'ARDHUIN'] = Field(default='ardhuin', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.cdsv","title":"cdsv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdsv: Optional[float] = Field(default=None, description='Coefficient related to laminar atmospheric boundary layer (SWAN default: 1.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ARDHUIN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ARDHUIN\"\n    if self.cdsv is not None:\n        repr += f\" cdsv={self.cdsv}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER","title":"SSWELL_ZIEGER","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Zieger et al. (2015).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ZIEGER [b1]\n</code></pre> <p>Swell dissipation of Young et al. (2013) updated by Zieger et al. (2015). The Zieger option is intended for use with negative wind input via the NEGATINP command. Zieger non-breaking dissipation follows the method used in WAVEWATCH III version 4 and does not include the steepness-dependent swell coefficient introduced in WAVEWATCH III version 5.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER--references","title":"References","text":"<p>Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96, pp.2-25.</p> <p>Young, I.R., Babanin, A.V. and Zieger, S., 2013. The decay rate of ocean swell observed by altimeter. Journal of physical oceanography, 43(11), pp.2322-2333.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ZIEGER\nsswell = SSWELL_ZIEGER()\nprint(sswell.render())\nsswell = SSWELL_ZIEGER(b1=0.00025)\nprint(sswell.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ZIEGER(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Zieger et al. (2015).\n\n    .. code-block:: text\n\n        SSWELL ZIEGER [b1]\n\n    Swell dissipation of Young et al. (2013) updated by Zieger et al. (2015). The\n    Zieger option is intended for use with negative wind input via the NEGATINP\n    command. Zieger non-breaking dissipation follows the method used in WAVEWATCH III\n    version 4 and does not include the steepness-dependent swell coefficient introduced\n    in WAVEWATCH III version 5.\n\n    References\n    ----------\n    Zieger, S., Babanin, A.V., Rogers, W.E. and Young, I.R., 2015. Observation-based\n    source terms in the third-generation wave model WAVEWATCH. Ocean Modelling, 96,\n    pp.2-25.\n\n    Young, I.R., Babanin, A.V. and Zieger, S., 2013. The decay rate of ocean swell\n    observed by altimeter. Journal of physical oceanography, 43(11), pp.2322-2333.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ZIEGER\n        sswell = SSWELL_ZIEGER()\n        print(sswell.render())\n        sswell = SSWELL_ZIEGER(b1=0.00025)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"zieger\", \"ZIEGER\"] = Field(\n        default=\"zieger\", description=\"Model type discriminator\"\n    )\n    b1: Optional[float] = Field(\n        default=None,\n        description=\"Non-dimensional proportionality coefficient \"\n        \"(SWAN default: 0.00025)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ZIEGER\"\n        if self.b1 is not None:\n            repr += f\" b1={self.b1}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['zieger', 'ZIEGER'] = Field(default='zieger', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.b1","title":"b1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b1: Optional[float] = Field(default=None, description='Non-dimensional proportionality coefficient (SWAN default: 0.00025)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ZIEGER.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ZIEGER\"\n    if self.b1 is not None:\n        repr += f\" b1={self.b1}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS","title":"SSWELL_ROGERS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonbreaking dissipation of Rogers et al. (2012).</p> <p>.. code-block:: text</p> <pre><code>SSWELL ROGERS [cdsv] [feswell]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS--references","title":"References","text":"<p>Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and whitecapping dissipation in a model for wind-generated surface waves: Description and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9), pp.1329-1346.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SSWELL_ROGERS\nsswell = SSWELL_ROGERS()\nprint(sswell.render())\nsswell = SSWELL_ROGERS(cdsv=1.2, feswell=0.5)\nprint(sswell.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SSWELL_ROGERS(BaseComponent):\n    \"\"\"Nonbreaking dissipation of Rogers et al. (2012).\n\n    .. code-block:: text\n\n        SSWELL ROGERS [cdsv] [feswell]\n\n    References\n    ----------\n    Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and\n    whitecapping dissipation in a model for wind-generated surface waves: Description\n    and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9),\n    pp.1329-1346.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SSWELL_ROGERS\n        sswell = SSWELL_ROGERS()\n        print(sswell.render())\n        sswell = SSWELL_ROGERS(cdsv=1.2, feswell=0.5)\n        print(sswell.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rogers\", \"ROGERS\"] = Field(\n        default=\"rogers\", description=\"Model type discriminator\"\n    )\n    cdsv: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient related to laminar atmospheric boundary layer \"\n            \"(SWAN default: 1.2)\"\n        ),\n    )\n    feswell: Optional[float] = Field(\n        default=None, description=\"Swell dissipation factor\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SSWELL ROGERS\"\n        if self.cdsv is not None:\n            repr += f\" cdsv={self.cdsv}\"\n        if self.feswell is not None:\n            repr += f\" feswell={self.feswell}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rogers', 'ROGERS'] = Field(default='rogers', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.cdsv","title":"cdsv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdsv: Optional[float] = Field(default=None, description='Coefficient related to laminar atmospheric boundary layer (SWAN default: 1.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.feswell","title":"feswell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>feswell: Optional[float] = Field(default=None, description='Swell dissipation factor')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SSWELL_ROGERS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SSWELL ROGERS\"\n    if self.cdsv is not None:\n        repr += f\" cdsv={self.cdsv}\"\n    if self.feswell is not None:\n        repr += f\" feswell={self.feswell}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#whitecapping","title":"Whitecapping","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN","title":"WCAPPING_KOMEN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Whitecapping according to Komen (1984).</p> <p>.. code-block:: text</p> <pre><code>WCAPPING KOMEN [cds2] [stpm] [powst] [delta] [powk]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--notes","title":"Notes","text":"<p>The SWAN default for <code>delta</code> has been changed since version 40.91A. The setting <code>delta = 1</code> will improve the prediction of the wave energy at low frequencies, and hence the mean wave period. The original default was <code>delta = 0</code>, which corresponds to WAM Cycle 3. See the Scientific/Technical documentation for further details.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--references","title":"References","text":"<p>Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import WCAPPING_KOMEN\nwcapping = WCAPPING_KOMEN()\nprint(wcapping.render())\nwcapping = WCAPPING_KOMEN(cds2=2.36e-5, stpm=3.02e-3, powst=2, delta=1, powk=2)\nprint(wcapping.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class WCAPPING_KOMEN(BaseComponent):\n    \"\"\"Whitecapping according to Komen (1984).\n\n    .. code-block:: text\n\n        WCAPPING KOMEN [cds2] [stpm] [powst] [delta] [powk]\n\n    Notes\n    -----\n    The SWAN default for `delta` has been changed since version 40.91A. The setting\n    `delta = 1` will improve the prediction of the wave energy at low frequencies, and\n    hence the mean wave period. The original default was `delta = 0`, which corresponds\n    to WAM Cycle 3. See the Scientific/Technical documentation for further details.\n\n    References\n    ----------\n    Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully\n    developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import WCAPPING_KOMEN\n        wcapping = WCAPPING_KOMEN()\n        print(wcapping.render())\n        wcapping = WCAPPING_KOMEN(cds2=2.36e-5, stpm=3.02e-3, powst=2, delta=1, powk=2)\n        print(wcapping.render())\n\n    \"\"\"\n\n    model_type: Literal[\"komen\", \"KOMEN\"] = Field(\n        default=\"komen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation ($Cds$) \"\n            \"(SWAN default: 2.36e-5)\"\n        ),\n    )\n    stpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Value of the wave steepness for a Pierson-Moskowitz spectrum \"\n            \"($s^2_{PM}$) (SWAN default: 3.02e-3)\"\n        ),\n    )\n    powst: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power of steepness normalized with the wave steepness \"\n            \"of a Pierson-Moskowitz spectrum (SWAN default: 2)\"\n        ),\n    )\n    delta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the dependency of the whitecapping \"\n            \"on wave number (SWAN default: 1)\"\n        ),\n    )\n    powk: Optional[float] = Field(\n        default=None,\n        description=(\n            \"power of wave number normalized with the mean wave number \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"WCAPPING KOMEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.stpm is not None:\n            repr += f\" stpm={self.stpm}\"\n        if self.powst is not None:\n            repr += f\" powst={self.powst}\"\n        if self.delta is not None:\n            repr += f\" delta={self.delta}\"\n        if self.powk is not None:\n            repr += f\" powk={self.powk}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['komen', 'KOMEN'] = Field(default='komen', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation ($Cds$) (SWAN default: 2.36e-5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.stpm","title":"stpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stpm: Optional[float] = Field(default=None, description='Value of the wave steepness for a Pierson-Moskowitz spectrum ($s^2_{PM}$) (SWAN default: 3.02e-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.powst","title":"powst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>powst: Optional[float] = Field(default=None, description='Power of steepness normalized with the wave steepness of a Pierson-Moskowitz spectrum (SWAN default: 2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: Optional[float] = Field(default=None, description='Coefficient which determines the dependency of the whitecapping on wave number (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.powk","title":"powk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>powk: Optional[float] = Field(default=None, description='power of wave number normalized with the mean wave number (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_KOMEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"WCAPPING KOMEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.stpm is not None:\n        repr += f\" stpm={self.stpm}\"\n    if self.powst is not None:\n        repr += f\" powst={self.powst}\"\n    if self.delta is not None:\n        repr += f\" delta={self.delta}\"\n    if self.powk is not None:\n        repr += f\" powk={self.powk}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB","title":"WCAPPING_AB","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Whitecapping according to Alves and Banner (2003).</p> <p>.. code-block:: text</p> <pre><code>WCAPPING AB [cds2] [br] CURRENT [cds3]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB--references","title":"References","text":"<p>Alves, J.H.G. and Banner, M.L., 2003. Performance of a saturation-based dissipation-rate source term in modeling the fetch-limited evolution of wind waves. Journal of Physical Oceanography, 33(6), pp.1274-1298.</p>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import WCAPPING_AB\nwcapping = WCAPPING_AB()\nprint(wcapping.render())\nwcapping = WCAPPING_AB(cds2=5.0e-5, br=1.75e-3, current=True, cds3=0.8)\nprint(wcapping.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class WCAPPING_AB(BaseComponent):\n    \"\"\"Whitecapping according to Alves and Banner (2003).\n\n    .. code-block:: text\n\n        WCAPPING AB [cds2] [br] CURRENT [cds3]\n\n    References\n    ----------\n    Alves, J.H.G. and Banner, M.L., 2003. Performance of a saturation-based\n    dissipation-rate source term in modeling the fetch-limited evolution of wind waves.\n    Journal of Physical Oceanography, 33(6), pp.1274-1298.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import WCAPPING_AB\n        wcapping = WCAPPING_AB()\n        print(wcapping.render())\n        wcapping = WCAPPING_AB(cds2=5.0e-5, br=1.75e-3, current=True, cds3=0.8)\n        print(wcapping.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ab\", \"AB\"] = Field(\n        default=\"ab\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"proportionality coefficient due to Alves and Banner (2003) \"\n            \"(SWAN default: 5.0e-5)\"\n        ),\n    )\n    br: Optional[float] = Field(\n        default=None, description=\"Threshold saturation level\t(SWAN default: 1.75e-3)\"\n    )\n    current: bool = Field(\n        default=False,\n        description=(\n            \"Indicates that enhanced current-induced dissipation \"\n            \"as proposed by Van der Westhuysen (2012) is to be added\"\n        ),\n    )\n    cds3: Optional[float] = Field(\n        default=None, description=\"Proportionality coefficient (SWAN default: 0.8)\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"WCAPPING AB\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.br is not None:\n            repr += f\" br={self.br}\"\n        if self.current:\n            repr += \" CURRENT\"\n        if self.cds3 is not None:\n            repr += f\" cds3={self.cds3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ab', 'AB'] = Field(default='ab', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='proportionality coefficient due to Alves and Banner (2003) (SWAN default: 5.0e-5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.br","title":"br  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>br: Optional[float] = Field(default=None, description='Threshold saturation level\\t(SWAN default: 1.75e-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.current","title":"current  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current: bool = Field(default=False, description='Indicates that enhanced current-induced dissipation as proposed by Van der Westhuysen (2012) is to be added')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cds3","title":"cds3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds3: Optional[float] = Field(default=None, description='Proportionality coefficient (SWAN default: 0.8)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.WCAPPING_AB.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"WCAPPING AB\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.br is not None:\n        repr += f\" br={self.br}\"\n    if self.current:\n        repr += \" CURRENT\"\n    if self.cds3 is not None:\n        repr += f\" cds3={self.cds3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#quadruplet-interactions","title":"Quadruplet interactions","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL","title":"QUADRUPL","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Nonlinear quadruplet wave interactions.</p> <p>.. code-block:: text</p> <pre><code>QUADRUPL [iquad] [lambda] [cnl4] [Csh1] [Csh2] [Csh3]\n</code></pre> <p>With this option the user can influence the computation of nonlinear quadruplet wave interactions which are usually included in the computations. Can be de-activated with command OFF QUAD. Note that the DIA approximation of the quadruplet interactions is a poor approximation for long-crested waves and frequency resolutions that are deviating much more than 10% (see command CGRID). Note that DIA is usually updated per sweep, either semi-implicit (<code>iquad = 1</code>) or explicit (<code>iquad = 2</code>). However, when ambient current is included, the bounds of the directional sector within a sweep may be different for each frequency bin (particularly the higher frequencies are modified by the current). So there may be some overlap of frequency bins between the sweeps, implying non-conservation of wave energy. To prevent this the user is advised to choose the integration of DIA per iteration instead of per sweep, i.e. <code>iquad = 3</code>. If you want to speed up your computation a bit more, than the choice <code>iquad = 8</code> is a good choice.</p>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import QUADRUPL\nquadrupl = QUADRUPL()\nprint(quadrupl.render())\nkwargs = dict(\n    iquad=3, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833333, csh3=-1.25\n)\nquadrupl = QUADRUPL(**kwargs)\nprint(quadrupl.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class QUADRUPL(BaseComponent):\n    \"\"\"Nonlinear quadruplet wave interactions.\n\n    .. code-block:: text\n\n        QUADRUPL [iquad] [lambda] [cnl4] [Csh1] [Csh2] [Csh3]\n\n    With this option the user can influence the computation of nonlinear quadruplet\n    wave interactions which are usually included in the computations. Can be\n    de-activated with command OFF QUAD. Note that the DIA approximation of the\n    quadruplet interactions is a poor approximation for long-crested waves and\n    frequency resolutions that are deviating much more than 10% (see command CGRID).\n    Note that DIA is usually updated per sweep, either semi-implicit (`iquad = 1`) or\n    explicit (`iquad = 2`). However, when ambient current is included, the bounds of\n    the directional sector within a sweep may be different for each frequency bin\n    (particularly the higher frequencies are modified by the current). So there may be\n    some overlap of frequency bins between the sweeps, implying non-conservation of\n    wave energy. To prevent this the user is advised to choose the integration of DIA\n    per iteration instead of per sweep, i.e. `iquad = 3`. If you want to speed up your\n    computation a bit more, than the choice `iquad = 8` is a good choice.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import QUADRUPL\n        quadrupl = QUADRUPL()\n        print(quadrupl.render())\n        kwargs = dict(\n            iquad=3, lambd=0.25, cnl4=3.0e7, csh1=5.5, csh2=0.833333, csh3=-1.25\n        )\n        quadrupl = QUADRUPL(**kwargs)\n        print(quadrupl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"quadrupl\", \"QUADRUPL\"] = Field(\n        default=\"quadrupl\", description=\"Model type discriminator\"\n    )\n    iquad: Optional[Literal[1, 2, 3, 8, 4, 51, 52, 53]] = Field(\n        default=None,\n        description=(\n            \"Numerical procedures for integrating the quadruplets: 1 = semi-implicit \"\n            \"per sweep, 2 = explicit per sweep, 3 = explicit per iteration, \"\n            \"8 = explicit per iteration, but with a more efficient implementation, \"\n            \"4 = multiple DIA, 51 = XNL (deep water transfer), 52 = XNL (deep water \"\n            \"transfer with WAM depth scaling), 53  XNL (finite depth transfer) (SWAN \"\n            \"default: 2)\"\n        ),\n    )\n    lambd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for quadruplet configuration in case of DIA \"\n            \"(SWAN default: 0.25)\"\n        ),\n    )\n    cnl4: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient for quadruplet interactions in case of DIA \"\n            \"(SWAN default: 3.0e7\"\n        ),\n    )\n    csh1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA (SWAN default: 5.5)\"\n        ),\n    )\n    csh2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA \"\n            \"(SWAN default: 0.833333)\"\n        ),\n    )\n    csh3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for shallow water scaling in case of DIA \"\n            \"(SWAN default: -1.25)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"QUADRUPL\"\n        if self.iquad is not None:\n            repr += f\" iquad={self.iquad}\"\n        if self.lambd is not None:\n            repr += f\" lambda={self.lambd}\"\n        if self.cnl4 is not None:\n            repr += f\" cnl4={self.cnl4}\"\n        if self.csh1 is not None:\n            repr += f\" csh1={self.csh1}\"\n        if self.csh2 is not None:\n            repr += f\" csh2={self.csh2}\"\n        if self.csh3 is not None:\n            repr += f\" csh3={self.csh3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['quadrupl', 'QUADRUPL'] = Field(default='quadrupl', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.iquad","title":"iquad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iquad: Optional[Literal[1, 2, 3, 8, 4, 51, 52, 53]] = Field(default=None, description='Numerical procedures for integrating the quadruplets: 1 = semi-implicit per sweep, 2 = explicit per sweep, 3 = explicit per iteration, 8 = explicit per iteration, but with a more efficient implementation, 4 = multiple DIA, 51 = XNL (deep water transfer), 52 = XNL (deep water transfer with WAM depth scaling), 53  XNL (finite depth transfer) (SWAN default: 2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.lambd","title":"lambd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambd: Optional[float] = Field(default=None, description='Coefficient for quadruplet configuration in case of DIA (SWAN default: 0.25)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.cnl4","title":"cnl4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cnl4: Optional[float] = Field(default=None, description='Proportionality coefficient for quadruplet interactions in case of DIA (SWAN default: 3.0e7')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh1","title":"csh1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh1: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: 5.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh2","title":"csh2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh2: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: 0.833333)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.csh3","title":"csh3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>csh3: Optional[float] = Field(default=None, description='Coefficient for shallow water scaling in case of DIA (SWAN default: -1.25)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.QUADRUPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"QUADRUPL\"\n    if self.iquad is not None:\n        repr += f\" iquad={self.iquad}\"\n    if self.lambd is not None:\n        repr += f\" lambda={self.lambd}\"\n    if self.cnl4 is not None:\n        repr += f\" cnl4={self.cnl4}\"\n    if self.csh1 is not None:\n        repr += f\" csh1={self.csh1}\"\n    if self.csh2 is not None:\n        repr += f\" csh2={self.csh2}\"\n    if self.csh3 is not None:\n        repr += f\" csh3={self.csh3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-breaking","title":"Wave breaking","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT","title":"BREAKING_CONSTANT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Constant wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING CONSTANT [alpha] [gamma]\n</code></pre> <p>Indicates that a constant breaker index is to be used.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_CONSTANT\nbreaking = BREAKING_CONSTANT()\nprint(breaking.render())\nbreaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\nprint(breaking.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class BREAKING_CONSTANT(BaseComponent):\n    \"\"\"Constant wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING CONSTANT [alpha] [gamma]\n\n    Indicates that a constant breaker index is to be used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_CONSTANT\n        breaking = BREAKING_CONSTANT()\n        print(breaking.render())\n        breaking = BREAKING_CONSTANT(alpha=1.0, gamma=0.73)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constant\", \"CONSTANT\"] = Field(\n        default=\"constant\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The breaker index, i.e. the ratio of maximum individual wave height \"\n            \"over depth (SWAN default: 0.73)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING CONSTANT\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma is not None:\n            repr += f\" gamma={self.gamma}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constant', 'CONSTANT'] = Field(default='constant', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.gamma","title":"gamma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma: Optional[float] = Field(default=None, description='The breaker index, i.e. the ratio of maximum individual wave height over depth (SWAN default: 0.73)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_CONSTANT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING CONSTANT\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma is not None:\n        repr += f\" gamma={self.gamma}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD","title":"BREAKING_BKD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Variable wave breaking index.</p> <p>.. code-block:: text</p> <pre><code>BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n</code></pre> <p>Indicates that the breaker index scales with both the bottom slope (<code>beta</code>) and the dimensionless depth (kd).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BREAKING_BKD\nbreaking = BREAKING_BKD()\nprint(breaking.render())\nbreaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\nprint(breaking.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class BREAKING_BKD(BaseComponent):\n    \"\"\"Variable wave breaking index.\n\n    .. code-block:: text\n\n        BREAKING BKD [alpha] [gamma0] [a1] [a2] [a3]\n\n    Indicates that the breaker index scales with both the bottom slope (`beta`)\n    and the dimensionless depth (kd).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BREAKING_BKD\n        breaking = BREAKING_BKD()\n        print(breaking.render())\n        breaking = BREAKING_BKD(alpha=1.0, gamma0=0.54, a1=7.59, a2=-8.06, a3=8.09)\n        print(breaking.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bkd\", \"BKD\"] = Field(\n        default=\"bkd\", description=\"Model type discriminator\"\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient of the rate of dissipation \"\n            \"(SWAN default: 1.0)\"\n        ),\n    )\n    gamma0: Optional[float] = Field(\n        default=None,\n        description=\"The reference $gamma$ for horizontal slopes (SWAN default: 0.54)\",\n    )\n    a1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First tunable coefficient for the breaker index (SWAN default: 7.59)\"\n        ),\n    )\n    a2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second tunable coefficient for the breaker index (SWAN default: -8.06)\"\n        ),\n    )\n    a3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Third tunable coefficient for the breaker index (SWAN default: 8.09)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BREAKING BKD\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.gamma0 is not None:\n            repr += f\" gamma0={self.gamma0}\"\n        if self.a1 is not None:\n            repr += f\" a1={self.a1}\"\n        if self.a2 is not None:\n            repr += f\" a2={self.a2}\"\n        if self.a3 is not None:\n            repr += f\" a3={self.a3}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bkd', 'BKD'] = Field(default='bkd', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='Proportionality coefficient of the rate of dissipation (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.gamma0","title":"gamma0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma0: Optional[float] = Field(default=None, description='The reference $gamma$ for horizontal slopes (SWAN default: 0.54)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a1","title":"a1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1: Optional[float] = Field(default=None, description='First tunable coefficient for the breaker index (SWAN default: 7.59)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a2","title":"a2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2: Optional[float] = Field(default=None, description='Second tunable coefficient for the breaker index (SWAN default: -8.06)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.a3","title":"a3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a3: Optional[float] = Field(default=None, description='Third tunable coefficient for the breaker index (SWAN default: 8.09)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BREAKING_BKD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BREAKING BKD\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.gamma0 is not None:\n        repr += f\" gamma0={self.gamma0}\"\n    if self.a1 is not None:\n        repr += f\" a1={self.a1}\"\n    if self.a2 is not None:\n        repr += f\" a2={self.a2}\"\n    if self.a3 is not None:\n        repr += f\" a3={self.a3}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#bottom-friction","title":"Bottom friction","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP","title":"FRICTION_JONSWAP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Hasselmann et al. (1973) Jonswap friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION JONSWAP CONSTANT [cfjon]\n</code></pre> <p>Indicates that the semi-empirical expression derived from the JONSWAP results for bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated. This option is default.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP--references","title":"References","text":"<p>Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K., Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973. Measurements of wind-wave growth and swell decay during the Joint North Sea Wave Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany, Rep. No. 12, 95 pp.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_JONSWAP\nfriction = FRICTION_JONSWAP()\nprint(friction.render())\nfriction = FRICTION_JONSWAP(cfjon=0.038)\nprint(friction.render())\n</code></pre> <p>TODO: Implement VARIABLE option?</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class FRICTION_JONSWAP(BaseComponent):\n    \"\"\"Hasselmann et al. (1973) Jonswap friction.\n\n    .. code-block:: text\n\n        FRICTION JONSWAP CONSTANT [cfjon]\n\n    Indicates that the semi-empirical expression derived from the JONSWAP results for\n    bottom friction dissipation (Hasselmann et al., 1973, JONSWAP) should be activated.\n    This option is default.\n\n    References\n    ----------\n    Hasselmann, K., Barnett, T.P., Bouws, E., Carlson, H., Cartwright, D.E., Enke, K.,\n    Ewing, J.A., Gienapp, A., Hasselmann, D.E., Kruseman, P. and Meerburg, A., 1973.\n    Measurements of wind-wave growth and swell decay during the Joint North Sea Wave\n    Project (JONSWAP). Deutches Hydrographisches Institut, Hamburg, Germany,\n    Rep. No. 12, 95 pp.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_JONSWAP\n        friction = FRICTION_JONSWAP()\n        print(friction.render())\n        friction = FRICTION_JONSWAP(cfjon=0.038)\n        print(friction.render())\n\n    TODO: Implement VARIABLE option?\n\n    \"\"\"\n\n    model_type: Literal[\"jonswap\", \"JONSWAP\"] = Field(\n        default=\"jonswap\", description=\"Model type discriminator\"\n    )\n    cfjon: Optional[float] = Field(\n        default=None,\n        description=\"Coefficient of the JONSWAP formulation (SWAN default: 0.038)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION JONSWAP CONSTANT\"\n        if self.cfjon is not None:\n            repr += f\" cfjon={self.cfjon}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['jonswap', 'JONSWAP'] = Field(default='jonswap', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.cfjon","title":"cfjon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfjon: Optional[float] = Field(default=None, description='Coefficient of the JONSWAP formulation (SWAN default: 0.038)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_JONSWAP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION JONSWAP CONSTANT\"\n    if self.cfjon is not None:\n        repr += f\" cfjon={self.cfjon}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS","title":"FRICTION_COLLINS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Collins (1972) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION COLLINS [cfw]\n</code></pre> <p>Note that <code>cfw</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>cfw</code> in this command is then not required (it will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS--references","title":"References","text":"<p>Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical Research, 77(15), pp.2693-2707.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_COLLINS\nfriction = FRICTION_COLLINS()\nprint(friction.render())\nfriction = FRICTION_COLLINS(cfw=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class FRICTION_COLLINS(BaseComponent):\n    \"\"\"Collins (1972) friction.\n\n    .. code-block:: text\n\n        FRICTION COLLINS [cfw]\n\n    Note that `cfw` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `cfw` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Collins, J.I., 1972. Prediction of shallow-water spectra. Journal of Geophysical\n    Research, 77(15), pp.2693-2707.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_COLLINS\n        friction = FRICTION_COLLINS()\n        print(friction.render())\n        friction = FRICTION_COLLINS(cfw=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"collins\", \"COLLINS\"] = Field(\n        default=\"collins\", description=\"Model type discriminator\"\n    )\n    cfw: Optional[float] = Field(\n        default=None,\n        description=\"Collins bottom friction coefficient (SWAN default: 0.015)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION COLLINS\"\n        if self.cfw is not None:\n            repr += f\" cfw={self.cfw}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['collins', 'COLLINS'] = Field(default='collins', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.cfw","title":"cfw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfw: Optional[float] = Field(default=None, description='Collins bottom friction coefficient (SWAN default: 0.015)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_COLLINS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION COLLINS\"\n    if self.cfw is not None:\n        repr += f\" cfw={self.cfw}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN","title":"FRICTION_MADSEN","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Madsen et al (1988) friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION MADSEN [kn]\n</code></pre> <p>Note that <code>kn</code> is allowed to vary over the computational region; in that case use the commands INPGRID FRICTION and READINP FRICTION to define and read the friction data. This command FRICTION is still required to define the type of friction expression. The value of <code>kn</code> in this command is then not required (it will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN--references","title":"References","text":"<p>Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).</p> <p>Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_MADSEN\nfriction = FRICTION_MADSEN()\nprint(friction.render())\nfriction = FRICTION_MADSEN(kn=0.038)\nprint(friction.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class FRICTION_MADSEN(BaseComponent):\n    \"\"\"Madsen et al (1988) friction.\n\n    .. code-block:: text\n\n        FRICTION MADSEN [kn]\n\n    Note that `kn` is allowed to vary over the computational region; in that case use\n    the commands INPGRID FRICTION and READINP FRICTION to define and read the friction\n    data. This command FRICTION is still required to define the type of friction\n    expression. The value of `kn` in this command is then not required (it will be\n    ignored).\n\n    References\n    ----------\n    Madsen, O.S., Poon, Y.K. and Graber, H.C., 1988. Spectral wave attenuation by\n    bottom friction: Theory. In Coastal engineering 1988 (pp. 492-504).\n\n    Madsen, O.S. and Rosengaus, M.M., 1988. Spectral wave attenuation by bottom\n    friction: Experiments. In Coastal Engineering 1988 (pp. 849-857).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_MADSEN\n        friction = FRICTION_MADSEN()\n        print(friction.render())\n        friction = FRICTION_MADSEN(kn=0.038)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"madsen\", \"MADSEN\"] = Field(\n        default=\"madsen\", description=\"Model type discriminator\"\n    )\n    kn: Optional[float] = Field(\n        default=None,\n        description=(\n            \"equivalent roughness length scale of the bottom (in m) \"\n            \"(SWAN default: 0.05)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION MADSEN\"\n        if self.kn is not None:\n            repr += f\" kn={self.kn}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['madsen', 'MADSEN'] = Field(default='madsen', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.kn","title":"kn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kn: Optional[float] = Field(default=None, description='equivalent roughness length scale of the bottom (in m) (SWAN default: 0.05)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_MADSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION MADSEN\"\n    if self.kn is not None:\n        repr += f\" kn={self.kn}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES","title":"FRICTION_RIPPLES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Smith et al. (2011) Ripples friction.</p> <p>.. code-block:: text</p> <pre><code>FRICTION RIPPLES [S] [D]\n</code></pre> <p>Indicates that the expression of Smith et al. (2011) should be activated. Here friction depends on the formation of bottom ripples and sediment size.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES--references","title":"References","text":"<p>Smith, G.A., Babanin, A.V., Riedel, P., Young, I.R., Oliver, S. and Hubbert, G., 2011. Introduction of a new friction routine into the SWAN model that evaluates roughness due to bedform and sediment size changes. Coastal Engineering, 58(4), pp.317-326.</p>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import FRICTION_RIPPLES\nfriction = FRICTION_RIPPLES()\nprint(friction.render())\nfriction = FRICTION_RIPPLES(s=2.65, d=0.0001)\nprint(friction.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class FRICTION_RIPPLES(BaseComponent):\n    \"\"\"Smith et al. (2011) Ripples friction.\n\n    .. code-block:: text\n\n        FRICTION RIPPLES [S] [D]\n\n    Indicates that the expression of Smith et al. (2011) should be activated. Here\n    friction depends on the formation of bottom ripples and sediment size.\n\n    References\n    ----------\n    Smith, G.A., Babanin, A.V., Riedel, P., Young, I.R., Oliver, S. and Hubbert, G.,\n    2011. Introduction of a new friction routine into the SWAN model that evaluates\n    roughness due to bedform and sediment size changes. Coastal Engineering, 58(4),\n    pp.317-326.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import FRICTION_RIPPLES\n        friction = FRICTION_RIPPLES()\n        print(friction.render())\n        friction = FRICTION_RIPPLES(s=2.65, d=0.0001)\n        print(friction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ripples\", \"RIPPLES\"] = Field(\n        default=\"ripples\", description=\"Model type discriminator\"\n    )\n    s: Optional[float] = Field(\n        default=None,\n        description=\"The specific gravity of the sediment (SWAN default: 2.65)\",\n    )\n    d: Optional[float] = Field(\n        default=None, description=\"The sediment diameter (in m) (SWAN default: 0.0001)\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"FRICTION RIPPLES\"\n        if self.s is not None:\n            repr += f\" S={self.s}\"\n        if self.d is not None:\n            repr += f\" D={self.d}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ripples', 'RIPPLES'] = Field(default='ripples', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.s","title":"s  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>s: Optional[float] = Field(default=None, description='The specific gravity of the sediment (SWAN default: 2.65)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.d","title":"d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>d: Optional[float] = Field(default=None, description='The sediment diameter (in m) (SWAN default: 0.0001)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.FRICTION_RIPPLES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"FRICTION RIPPLES\"\n    if self.s is not None:\n        repr += f\" S={self.s}\"\n    if self.d is not None:\n        repr += f\" D={self.d}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-triads","title":"Wave triads","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD","title":"TRIAD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave triad interactions.</p> <p>.. code-block:: text</p> <pre><code>TRIAD [itriad] [trfac] [cutfr] [a] [b] [urcrit] [urslim]\n</code></pre> <p>With this command the user can activate the triad wave-wave interactions. If this command is not used, SWAN will not account for triads.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD--note","title":"Note","text":"<p>This is the TRIAD specification in SWAN &lt; 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD\ntriad = TRIAD()\nprint(triad.render())\ntriad = TRIAD(\n    itriad=1,\n    trfac=0.8,\n    cutfr=2.5,\n    a=0.95,\n    b=-0.75,\n    ucrit=0.2,\n    urslim=0.01,\n)\nprint(triad.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class TRIAD(BaseComponent):\n    \"\"\"Wave triad interactions.\n\n    .. code-block:: text\n\n        TRIAD [itriad] [trfac] [cutfr] [a] [b] [urcrit] [urslim]\n\n    With this command the user can activate the triad wave-wave interactions. If this\n    command is not used, SWAN will not account for triads.\n\n    Note\n    ----\n    This is the TRIAD specification in SWAN &lt; 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD\n        triad = TRIAD()\n        print(triad.render())\n        triad = TRIAD(\n            itriad=1,\n            trfac=0.8,\n            cutfr=2.5,\n            a=0.95,\n            b=-0.75,\n            ucrit=0.2,\n            urslim=0.01,\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"triad\", \"TRIAD\"] = Field(\n        default=\"triad\", description=\"Model type discriminator\"\n    )\n    itriad: Optional[Literal[1, 2]] = Field(\n        default=None,\n        description=(\n            \"Approximation method for the triad computation: \\n\\n* 1: the LTA method \"\n            \"of Eldeberky (1996) \\n* 2: the SPB method of Becq-Girard et al. (1999) \"\n            \"(SWAN default: 1)\"\n        ),\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality coefficient (SWAN default: 0.8 in case of LTA method, \"\n            \"0.9 in case of SPB method)\"\n        ),\n    )\n    cutfr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the maximum frequency that is considered in the LTA \"\n            \"computation. The value of `cutfr` is the ratio of this maximum \"\n            \"frequency over the mean frequency (SWAN default: 2.5)\"\n        ),\n    )\n    a: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et \"\n            \"al. (1999). This parameter is associated with broadening of the \"\n            \"resonance condition (SWAN default: 0.95)\"\n        ),\n    )\n    b: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard \"\n            \"et al. (1999). This parameter is associated with broadening of the \"\n            \"resonance condition (SWAN default: -0.75 for 1D, 0.0 for 2D\"\n        ),\n    )\n    ucrit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The critical Ursell number appearing in the expression for the biphase \"\n            \"(SWAN default: 0.2)\"\n        ),\n    )\n    urslim: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The lower threshold for Ursell number, if the actual Ursell number is \"\n            \"below this value triad interactions are be computed (SWAN default: 0.01)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD\"\n        if self.itriad is not None:\n            repr += f\" itriad={self.itriad}\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.cutfr is not None:\n            repr += f\" cutfr={self.cutfr}\"\n        if self.a is not None:\n            repr += f\" a={self.a}\"\n        if self.b is not None:\n            repr += f\" b={self.b}\"\n        if self.ucrit is not None:\n            repr += f\" urcrit={self.ucrit}\"\n        if self.urslim is not None:\n            repr += f\" urslim={self.urslim}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['triad', 'TRIAD'] = Field(default='triad', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.itriad","title":"itriad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>itriad: Optional[Literal[1, 2]] = Field(default=None, description='Approximation method for the triad computation: \\n\\n* 1: the LTA method of Eldeberky (1996) \\n* 2: the SPB method of Becq-Girard et al. (1999) (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Proportionality coefficient (SWAN default: 0.8 in case of LTA method, 0.9 in case of SPB method)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.cutfr","title":"cutfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutfr: Optional[float] = Field(default=None, description='Controls the maximum frequency that is considered in the LTA computation. The value of `cutfr` is the ratio of this maximum frequency over the mean frequency (SWAN default: 2.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: Optional[float] = Field(default=None, description='First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition (SWAN default: 0.95)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: Optional[float] = Field(default=None, description='Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition (SWAN default: -0.75 for 1D, 0.0 for 2D')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.ucrit","title":"ucrit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ucrit: Optional[float] = Field(default=None, description='The critical Ursell number appearing in the expression for the biphase (SWAN default: 0.2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.urslim","title":"urslim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urslim: Optional[float] = Field(default=None, description='The lower threshold for Ursell number, if the actual Ursell number is below this value triad interactions are be computed (SWAN default: 0.01)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD\"\n    if self.itriad is not None:\n        repr += f\" itriad={self.itriad}\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.cutfr is not None:\n        repr += f\" cutfr={self.cutfr}\"\n    if self.a is not None:\n        repr += f\" a={self.a}\"\n    if self.b is not None:\n        repr += f\" b={self.b}\"\n    if self.ucrit is not None:\n        repr += f\" urcrit={self.ucrit}\"\n    if self.urslim is not None:\n        repr += f\" urslim={self.urslim}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA","title":"TRIAD_DCTA","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the DCTA method of Booij et al. (2009).</p> <p>.. code-block:: text</p> <pre><code>TRIAD DCTA [trfac] [p] COLL|NONC BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--references","title":"References","text":"<p>Booij, N., Holthuijsen, L.H. and B\u00e9nit, M.P., 2009. A distributed collinear triad approximation in SWAN. In Proceedings Of Coastal Dynamics 2009: Impacts of Human Activities on Dynamic Coastal Processes (With CD-ROM) (pp. 1-10).</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--note","title":"Note","text":"<p>This is the default method to compute the triad interactions in SWAN &gt;= 41.45, it is not supported in earlier versions of the model.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_DCTA\ntriad = TRIAD_DCTA()\nprint(triad.render())\ntriad = TRIAD_DCTA(\n    trfac=4.4,\n    p=1.3,\n    noncolinear=True,\n    biphase={\"model_type\": \"dewit\", \"lpar\": 0.0},\n)\nprint(triad.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class TRIAD_DCTA(BaseComponent):\n    \"\"\"Triad interactions with the DCTA method of Booij et al. (2009).\n\n    .. code-block:: text\n\n        TRIAD DCTA [trfac] [p] COLL|NONC BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Booij, N., Holthuijsen, L.H. and B\u00e9nit, M.P., 2009. A distributed collinear triad\n    approximation in SWAN. In Proceedings Of Coastal Dynamics 2009: Impacts of Human\n    Activities on Dynamic Coastal Processes (With CD-ROM) (pp. 1-10).\n\n    Note\n    ----\n    This is the default method to compute the triad interactions in SWAN &gt;= 41.45, it\n    is not supported in earlier versions of the model.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_DCTA\n        triad = TRIAD_DCTA()\n        print(triad.render())\n        triad = TRIAD_DCTA(\n            trfac=4.4,\n            p=1.3,\n            noncolinear=True,\n            biphase={\"model_type\": \"dewit\", \"lpar\": 0.0},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dcta\", \"DCTA\"] = Field(\n        default=\"dcta\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to DCTA (SWAN default: 4.4)\"\n        ),\n    )\n    p: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape coefficient to force the high-frequency tail\" \"(SWAN default: 4/3)\"\n        ),\n    )\n    noncolinear: bool = Field(\n        default=False,\n        description=(\n            \"If True, the noncolinear triad interactions \"\n            \"with the DCTA framework are accounted for\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD DCTA\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.p is not None:\n            repr += f\" p={self.p}\"\n        if self.noncolinear:\n            repr += \" NONC\"\n        else:\n            repr += \" COLL\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dcta', 'DCTA'] = Field(default='dcta', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to DCTA (SWAN default: 4.4)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: Optional[float] = Field(default=None, description='Shape coefficient to force the high-frequency tail(SWAN default: 4/3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.noncolinear","title":"noncolinear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>noncolinear: bool = Field(default=False, description='If True, the noncolinear triad interactions with the DCTA framework are accounted for')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_DCTA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD DCTA\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.p is not None:\n        repr += f\" p={self.p}\"\n    if self.noncolinear:\n        repr += \" NONC\"\n    else:\n        repr += \" COLL\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA","title":"TRIAD_LTA","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the LTA method of Eldeberky (1996).</p> <p>.. code-block:: text</p> <pre><code>TRIAD LTA [trfac] [cutfr] BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--references","title":"References","text":"<p>Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for modeling triad interactions in dispersive waves. In Coastal Engineering 1996 (pp. 1088-1101).</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--note","title":"Note","text":"<p>This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_LTA\ntriad = TRIAD_LTA()\nprint(triad.render())\ntriad = TRIAD_LTA(\n    trfac=0.8,\n    cutfr=2.5,\n    biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n)\nprint(triad.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class TRIAD_LTA(BaseComponent):\n    \"\"\"Triad interactions with the LTA method of Eldeberky (1996).\n\n    .. code-block:: text\n\n        TRIAD LTA [trfac] [cutfr] BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for\n    modeling triad interactions in dispersive waves. In Coastal Engineering 1996\n    (pp. 1088-1101).\n\n    Note\n    ----\n    This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_LTA\n        triad = TRIAD_LTA()\n        print(triad.render())\n        triad = TRIAD_LTA(\n            trfac=0.8,\n            cutfr=2.5,\n            biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"lta\", \"LTA\"] = Field(\n        default=\"lta\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to LTA (SWAN default: 0.8)\"\n        ),\n    )\n    cutfr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the maximum frequency that is considered in the LTA \"\n            \"computation. The value of `cutfr` is the ratio of this maximum \"\n            \"frequency over the mean frequency (SWAN default: 2.5)\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD LTA\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.cutfr is not None:\n            repr += f\" cutfr={self.cutfr}\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['lta', 'LTA'] = Field(default='lta', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to LTA (SWAN default: 0.8)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.cutfr","title":"cutfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutfr: Optional[float] = Field(default=None, description='Controls the maximum frequency that is considered in the LTA computation. The value of `cutfr` is the ratio of this maximum frequency over the mean frequency (SWAN default: 2.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_LTA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD LTA\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.cutfr is not None:\n        repr += f\" cutfr={self.cutfr}\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB","title":"TRIAD_SPB","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Triad interactions with the SPB method of Becq-Girard et al. (1999).</p> <p>.. code-block:: text</p> <pre><code>TRIAD SPB [trfac] [a] [b] BIPHHASE ELDEBERKY|DEWIT\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--references","title":"References","text":"<p>Becq-Girard, F., Forget, P. and Benoit, M., 1999. Non-linear propagation of unidirectional wave fields over varying topography. Coastal Engineering, 38(2), pp.91-113.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--note","title":"Note","text":"<p>This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TRIAD_SPB\ntriad = TRIAD_SPB()\nprint(triad.render())\ntriad = TRIAD_SPB(\n    trfac=0.9,\n    a=0.95,\n    b=0.0,\n    biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n)\nprint(triad.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class TRIAD_SPB(BaseComponent):\n    \"\"\"Triad interactions with the SPB method of Becq-Girard et al. (1999).\n\n    .. code-block:: text\n\n        TRIAD SPB [trfac] [a] [b] BIPHHASE ELDEBERKY|DEWIT\n\n    References\n    ----------\n    Becq-Girard, F., Forget, P. and Benoit, M., 1999. Non-linear propagation of\n    unidirectional wave fields over varying topography. Coastal Engineering, 38(2),\n    pp.91-113.\n\n    Note\n    ----\n    This method to compute the triad interactions is only supported in SWAN &gt;= 41.45.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TRIAD_SPB\n        triad = TRIAD_SPB()\n        print(triad.render())\n        triad = TRIAD_SPB(\n            trfac=0.9,\n            a=0.95,\n            b=0.0,\n            biphase={\"model_type\": \"eldeberky\", \"urcrit\": 0.63},\n        )\n        print(triad.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spb\", \"SPB\"] = Field(\n        default=\"spb\", description=\"Model type discriminator\"\n    )\n    trfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scaling factor that controls the intensity of \"\n            \"the triad interaction due to SPB (SWAN default: 0.9)\"\n        ),\n    )\n    a: Optional[float] = Field(\n        default=None,\n        description=(\n            \"First calibration parameter for tuning K in Eq. (5.1) of \"\n            \"Becq-Girard et al. (1999). This parameter is associated with broadening \"\n            \"of the resonance condition. The default value is 0.95 and is calibrated \"\n            \"by means of laboratory experiments (SWAN default: 0.95)\"\n        ),\n    )\n    b: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Second calibration parameter for tuning K in Eq. (5.1) of \"\n            \"Becq-Girard et al. (1999). This parameter is associated with broadening \"\n            \"of the resonance condition. The default value is -0.75 and is calibrated \"\n            \"by means of laboratory experiments. However, it may not be appropriate \"\n            \"for true 2D field cases as it does not scale with the wave field \"\n            \"characteristics. Hence, this parameter is set to zero (SWAN default: 0.0)\"\n        ),\n    )\n    biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(\n        default=None,\n        description=(\n            \"Defines the parameterization of biphase (self-self interaction) \"\n            \"(SWAN default: ELDEBERKY)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TRIAD SPB\"\n        if self.trfac is not None:\n            repr += f\" trfac={self.trfac}\"\n        if self.a is not None:\n            repr += f\" a={self.a}\"\n        if self.b is not None:\n            repr += f\" b={self.b}\"\n        if self.biphase is not None:\n            repr += f\" {self.biphase.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spb', 'SPB'] = Field(default='spb', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.trfac","title":"trfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trfac: Optional[float] = Field(default=None, description='Scaling factor that controls the intensity of the triad interaction due to SPB (SWAN default: 0.9)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: Optional[float] = Field(default=None, description='First calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition. The default value is 0.95 and is calibrated by means of laboratory experiments (SWAN default: 0.95)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: Optional[float] = Field(default=None, description='Second calibration parameter for tuning K in Eq. (5.1) of Becq-Girard et al. (1999). This parameter is associated with broadening of the resonance condition. The default value is -0.75 and is calibrated by means of laboratory experiments. However, it may not be appropriate for true 2D field cases as it does not scale with the wave field characteristics. Hence, this parameter is set to zero (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.biphase","title":"biphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>biphase: Optional[Union[ELDEBERKY, DEWIT]] = Field(default=None, description='Defines the parameterization of biphase (self-self interaction) (SWAN default: ELDEBERKY)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TRIAD_SPB.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TRIAD SPB\"\n    if self.trfac is not None:\n        repr += f\" trfac={self.trfac}\"\n    if self.a is not None:\n        repr += f\" a={self.a}\"\n    if self.b is not None:\n        repr += f\" b={self.b}\"\n    if self.biphase is not None:\n        repr += f\" {self.biphase.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#vegetaion-dumping","title":"Vegetaion dumping","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION","title":"VEGETATION","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Vegetation dumping.</p> <p>.. code-block:: text</p> <pre><code>VEGETATION [iveg] &lt; [height] [diamtr] [nstems] [drag] &gt;\n</code></pre> <p>With this command the user can activate wave damping due to vegetation based on the Dalrymple's formula (1984) as implemented by Suzuki et al. (2011). This damping is uniform over the wave frequencies. An alternative is the frequency-dependent (canopy) dissipation model of Jacobsen et al. (2019). If this command is not used, SWAN will not account for vegetation effects.</p> <p>The vegetation (rigid plants) can be divided over a number of vertical segments and so, the possibility to vary the vegetation vertically is included. Each vertical layer represents some characteristics of the plants. These variables as indicated below can be repeated as many vertical layers to be chosen.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--references","title":"References","text":"<p>Dalrymple, R.A., Kirby, J.T. and Hwang, P.A., 1984. Wave diffraction due to areas of energy dissipation. Journal of waterway, port, coastal, and ocean engineering, 110(1), pp.67-79.</p> <p>Jacobsen, N.G., Bakker, W., Uijttewaal, W.S. and Uittenbogaard, R., 2019. Experimental investigation of the wave-induced motion of and force distribution along a flexible stem. Journal of Fluid Mechanics, 880, pp.1036-1069.</p> <p>Suzuki, T., Zijlema, M., Burger, B., Meijer, M.C. and Narayan, S., 2012. Wave dissipation by vegetation with layer schematization in SWAN. Coastal Engineering, 59(1), pp.64-71.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--notes","title":"Notes","text":"<p>Vertical layering of the vegetation is not yet implemented for the Jacobsen et al. (2019) method.</p>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import VEGETATION\n# Single layer\nvegetation = VEGETATION(\n    height=1.2,\n    diamtr=0.1,\n    drag=0.5,\n    nstems=10,\n)\nprint(vegetation.render())\n# 2 vertical layers\nvegetation = VEGETATION(\n    iveg=1,\n    height=[1.2, 0.8],\n    diamtr=[0.1, 0.1],\n    drag=[0.5, 0.5],\n    nstems=[10, 5],\n)\nprint(vegetation.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class VEGETATION(BaseComponent):\n    \"\"\"Vegetation dumping.\n\n    .. code-block:: text\n\n        VEGETATION [iveg] &lt; [height] [diamtr] [nstems] [drag] &gt;\n\n    With this command the user can activate wave damping due to vegetation based on the\n    Dalrymple's formula (1984) as implemented by Suzuki et al. (2011). This damping is\n    uniform over the wave frequencies. An alternative is the frequency-dependent\n    (canopy) dissipation model of Jacobsen et al. (2019). If this command is not used,\n    SWAN will not account for vegetation effects.\n\n    The vegetation (rigid plants) can be divided over a number of vertical segments and\n    so, the possibility to vary the vegetation vertically is included. Each vertical\n    layer represents some characteristics of the plants. These variables as indicated\n    below can be repeated as many vertical layers to be chosen.\n\n    References\n    ----------\n    Dalrymple, R.A., Kirby, J.T. and Hwang, P.A., 1984. Wave diffraction due to areas\n    of energy dissipation. Journal of waterway, port, coastal, and ocean engineering,\n    110(1), pp.67-79.\n\n    Jacobsen, N.G., Bakker, W., Uijttewaal, W.S. and Uittenbogaard, R., 2019.\n    Experimental investigation of the wave-induced motion of and force distribution\n    along a flexible stem. Journal of Fluid Mechanics, 880, pp.1036-1069.\n\n    Suzuki, T., Zijlema, M., Burger, B., Meijer, M.C. and Narayan, S., 2012. Wave\n    dissipation by vegetation with layer schematization in SWAN. Coastal Engineering,\n    59(1), pp.64-71.\n\n    Notes\n    -----\n    Vertical layering of the vegetation is not yet implemented for the\n    Jacobsen et al. (2019) method.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import VEGETATION\n        # Single layer\n        vegetation = VEGETATION(\n            height=1.2,\n            diamtr=0.1,\n            drag=0.5,\n            nstems=10,\n        )\n        print(vegetation.render())\n        # 2 vertical layers\n        vegetation = VEGETATION(\n            iveg=1,\n            height=[1.2, 0.8],\n            diamtr=[0.1, 0.1],\n            drag=[0.5, 0.5],\n            nstems=[10, 5],\n        )\n        print(vegetation.render())\n\n    \"\"\"\n\n    model_type: Literal[\"vegetation\", \"VEGETATION\"] = Field(\n        default=\"vegetation\", description=\"Model type discriminator\"\n    )\n    iveg: Literal[1, 2] = Field(\n        default=1,\n        description=(\n            \"Indicates the method for the vegetation computation (SWAN default: 1):\\n\"\n            \"\\n* 1: Suzuki et al. (2011)\\n* 2: Jacobsen et al. (2019)\\n\"\n        ),\n    )\n    height: Union[float, list[float]] = Field(\n        description=\"The plant height per layer (in m)\"\n    )\n    diamtr: Union[float, list[float]] = Field(\n        description=\"The diameter of each plant stand per layer (in m)\"\n    )\n    drag: Union[float, list[float]] = Field(\n        description=\"The drag coefficient per layer\"\n    )\n    nstems: Union[int, list[int]] = Field(\n        default=1,\n        description=(\n            \"The number of plant stands per square meter for each layer. Note that \"\n            \"`nstems` is allowed to vary over the computational region to account for \"\n            \"the zonation of vegetation. In that case use the commands \"\n            \"`IMPGRID NPLANTS` and `READINP NPLANTS` to define and read the \"\n            \"vegetation density. The (vertically varying) value of `nstems` in this \"\n            \"command will be multiplied by this horizontally varying plant density \"\n            \"(SWAN default: 1)\"\n        ),\n        validate_default=True,\n    )\n\n    @field_validator(\"height\", \"diamtr\", \"drag\", \"nstems\")\n    @classmethod\n    def number_of_layers(cls, v: Any, info: ValidationInfo) -&gt; Any:\n        if v is None:\n            return v\n        elif not isinstance(v, list):\n            v = [v]\n        sizes = {k: len(v) for k, v in info.data.items() if isinstance(v, list)}\n        if len(set(sizes.values())) &gt; 1:\n            raise ValueError(\n                \"The number of layers must be the same for all variables. \"\n                f\"Got these number of layers: {sizes}\"\n            )\n        return v\n\n    @model_validator(mode=\"after\")\n    def jacomsen_layering_not_implemented(self) -&gt; \"VEGETATION\":\n        if self.iveg == 2 and len(self.nstems) &gt; 1:\n            raise NotImplementedError(\n                \"Vertical layering of the vegetation is not yet implemented for the \"\n                \"Jacobsen et al. (2019) method, please define single layer\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"VEGETATION iveg={self.iveg}\"\n        for h, d, dr, n in zip(self.height, self.diamtr, self.drag, self.nstems):\n            repr += f\" height={h} diamtr={d} nstems={n} drag={dr}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['vegetation', 'VEGETATION'] = Field(default='vegetation', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.iveg","title":"iveg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iveg: Literal[1, 2] = Field(default=1, description='Indicates the method for the vegetation computation (SWAN default: 1):\\n\\n* 1: Suzuki et al. (2011)\\n* 2: Jacobsen et al. (2019)\\n')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height: Union[float, list[float]] = Field(description='The plant height per layer (in m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.diamtr","title":"diamtr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diamtr: Union[float, list[float]] = Field(description='The diameter of each plant stand per layer (in m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.drag","title":"drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drag: Union[float, list[float]] = Field(description='The drag coefficient per layer')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.nstems","title":"nstems  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nstems: Union[int, list[int]] = Field(default=1, description='The number of plant stands per square meter for each layer. Note that `nstems` is allowed to vary over the computational region to account for the zonation of vegetation. In that case use the commands `IMPGRID NPLANTS` and `READINP NPLANTS` to define and read the vegetation density. The (vertically varying) value of `nstems` in this command will be multiplied by this horizontally varying plant density (SWAN default: 1)', validate_default=True)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.number_of_layers","title":"number_of_layers  <code>classmethod</code>","text":"<pre><code>number_of_layers(v: Any, info: ValidationInfo) -&gt; Any\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>@field_validator(\"height\", \"diamtr\", \"drag\", \"nstems\")\n@classmethod\ndef number_of_layers(cls, v: Any, info: ValidationInfo) -&gt; Any:\n    if v is None:\n        return v\n    elif not isinstance(v, list):\n        v = [v]\n    sizes = {k: len(v) for k, v in info.data.items() if isinstance(v, list)}\n    if len(set(sizes.values())) &gt; 1:\n        raise ValueError(\n            \"The number of layers must be the same for all variables. \"\n            f\"Got these number of layers: {sizes}\"\n        )\n    return v\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.jacomsen_layering_not_implemented","title":"jacomsen_layering_not_implemented","text":"<pre><code>jacomsen_layering_not_implemented() -&gt; VEGETATION\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef jacomsen_layering_not_implemented(self) -&gt; \"VEGETATION\":\n    if self.iveg == 2 and len(self.nstems) &gt; 1:\n        raise NotImplementedError(\n            \"Vertical layering of the vegetation is not yet implemented for the \"\n            \"Jacobsen et al. (2019) method, please define single layer\"\n        )\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.VEGETATION.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"VEGETATION iveg={self.iveg}\"\n    for h, d, dr, n in zip(self.height, self.diamtr, self.drag, self.nstems):\n        repr += f\" height={h} diamtr={d} nstems={n} drag={dr}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#mud-dumping","title":"Mud dumping","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD","title":"MUD","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Mud dumping.</p> <p>.. code-block:: text</p> <pre><code>MUD [layer] [rhom] [viscm]\n</code></pre> <p>With this command the user can activate wave damping due to mud based on Ng (2000). If this command or the commands INPGRID MUDLAY and READINP MUDLAY are not used, SWAN will not account for muddy bottom effects.</p>"},{"location":"components/physics/#rompy_swan.components.physics.MUD--references","title":"References","text":"<p>Ng, C., 2000, Water waves over a muddy bed: A two layer Stokes' boundary layer model, Coastal Eng., 40, 221-242.</p>"},{"location":"components/physics/#rompy_swan.components.physics.MUD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import MUD\nmud = MUD()\nprint(mud.render())\nmud = MUD(\n    layer=2.0,\n    rhom=1300,\n    viscm=0.0076,\n)\nprint(mud.render())\n</code></pre> <p>TODO: Validate <code>layer</code> must be prescribed if <code>INPGRID MUDLAY</code> isn't used.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class MUD(BaseComponent):\n    \"\"\"Mud dumping.\n\n    .. code-block:: text\n\n        MUD [layer] [rhom] [viscm]\n\n    With this command the user can activate wave damping due to mud based on Ng (2000).\n    If this command or the commands INPGRID MUDLAY and READINP MUDLAY are not used,\n    SWAN will not account for muddy bottom effects.\n\n    References\n    ----------\n    Ng, C., 2000, Water waves over a muddy bed: A two layer Stokes' boundary layer\n    model, Coastal Eng., 40, 221-242.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import MUD\n        mud = MUD()\n        print(mud.render())\n        mud = MUD(\n            layer=2.0,\n            rhom=1300,\n            viscm=0.0076,\n        )\n        print(mud.render())\n\n    TODO: Validate `layer` must be prescribed if `INPGRID MUDLAY` isn't used.\n\n    \"\"\"\n\n    model_type: Literal[\"mud\", \"MUD\"] = Field(\n        default=\"mud\", description=\"Model type discriminator\"\n    )\n    layer: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The thickness of the mud layer (in m). Note that `layer` is allowed to \"\n            \"vary over the computational region to account for the zonation of muddy \"\n            \"bottom. In that case use the commands `INPGRID MUDLAY` and `READINP \"\n            \"MUDLAY` to define and read the layer thickness of mud. The value of \"\n            \"`layer` in this command is then not required (it will be ignored)\"\n        ),\n    )\n    rhom: Optional[float] = Field(\n        default=None,\n        description=\"The density of the mud layer (in kg/m3) (SWAN default: 1300)\",\n    )\n    viscm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The kinematic viscosity of the mud layer (in m2/s) (SWAN default: 0.0076)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"MUD\"\n        if self.layer is not None:\n            repr += f\" layer={self.layer}\"\n        if self.rhom is not None:\n            repr += f\" rhom={self.rhom}\"\n        if self.viscm is not None:\n            repr += f\" viscm={self.viscm}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['mud', 'MUD'] = Field(default='mud', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.layer","title":"layer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layer: Optional[float] = Field(default=None, description='The thickness of the mud layer (in m). Note that `layer` is allowed to vary over the computational region to account for the zonation of muddy bottom. In that case use the commands `INPGRID MUDLAY` and `READINP MUDLAY` to define and read the layer thickness of mud. The value of `layer` in this command is then not required (it will be ignored)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.rhom","title":"rhom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhom: Optional[float] = Field(default=None, description='The density of the mud layer (in kg/m3) (SWAN default: 1300)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD.viscm","title":"viscm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>viscm: Optional[float] = Field(default=None, description='The kinematic viscosity of the mud layer (in m2/s) (SWAN default: 0.0076)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.MUD-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.MUD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"MUD\"\n    if self.layer is not None:\n        repr += f\" layer={self.layer}\"\n    if self.rhom is not None:\n        repr += f\" rhom={self.rhom}\"\n    if self.viscm is not None:\n        repr += f\" viscm={self.viscm}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#sea-ice-dissipation","title":"Sea ice dissipation","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE","title":"SICE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Sea ice dissipation.</p> <p>.. code-block:: text</p> <pre><code>SICE [aice]\n</code></pre> <p>Using this command, the user activates a sink term to represent the dissipation of wave energy by sea ice. The default method is R19 empirical/parametric: a polynomial based on wave frequency (Rogers, 2019). This polynomial (in 1/m) has seven dimensional coefficients; see Scientific/Technical documentation for details. If this command is not used, SWAN will not account for sea ice effects.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--references","title":"References","text":"<p>Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015. Relating wave attenuation to pancake ice thickness, using field measurements and model results. Geophysical Research Letters, 42(11), pp.4473-4481.</p> <p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science and Technology, 182, p.103198.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--notes","title":"Notes","text":"<p>Iis also necessary to describe the ice, using the <code>ICE</code> command (for uniform and stationary ice) or <code>INPGRID</code>/<code>READINP</code> commands (for variable ice).</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE\nsice = SICE()\nprint(sice.render())\nsice = SICE(aice=0.5)\nprint(sice.render())\n</code></pre> <p>TODO: Verify if the <code>aice</code> parameter should be used with SICE command, it is not shown in the command tree but it is described as an option in the description.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SICE(BaseComponent):\n    \"\"\"Sea ice dissipation.\n\n    .. code-block:: text\n\n        SICE [aice]\n\n    Using this command, the user activates a sink term to represent the dissipation of\n    wave energy by sea ice. The default method is R19 empirical/parametric: a\n    polynomial based on wave frequency (Rogers, 2019). This polynomial (in 1/m) has\n    seven dimensional coefficients; see Scientific/Technical documentation for details.\n    If this command is not used, SWAN will not account for sea ice effects.\n\n    References\n    ----------\n    Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015.\n    Relating wave attenuation to pancake ice thickness, using field measurements and\n    model results. Geophysical Research Letters, 42(11), pp.4473-4481.\n\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of\n    dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of\n    the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave\n    attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science\n    and Technology, 182, p.103198.\n\n    Notes\n    -----\n    Iis also necessary to describe the ice, using the `ICE` command (for uniform and\n    stationary ice) or `INPGRID`/`READINP` commands (for variable ice).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE\n        sice = SICE()\n        print(sice.render())\n        sice = SICE(aice=0.5)\n        print(sice.render())\n\n    TODO: Verify if the `aice` parameter should be used with SICE command, it is not\n    shown in the command tree but it is described as an option in the description.\n\n    \"\"\"\n\n    model_type: Literal[\"sice\", \"SICE\"] = Field(\n        default=\"sice\", description=\"Model type discriminator\"\n    )\n    aice: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Ice concentration as a fraction from 0 to 1. Note that `aice` is allowed \"\n            \"to vary over the computational region to account for the zonation of ice \"\n            \"concentration. In that case use the commands `INPGRID AICE` and `READINP \"\n            \"AICE` to define and read the sea concentration. The value of `aice` in \"\n            \"this command is then not required (it will be ignored)\"\n        ),\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SICE\"\n        if self.aice is not None:\n            repr += f\" aice={self.aice}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['sice', 'SICE'] = Field(default='sice', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE.aice","title":"aice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aice: Optional[float] = Field(default=None, description='Ice concentration as a fraction from 0 to 1. Note that `aice` is allowed to vary over the computational region to account for the zonation of ice concentration. In that case use the commands `INPGRID AICE` and `READINP AICE` to define and read the sea concentration. The value of `aice` in this command is then not required (it will be ignored)', ge=0.0, le=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SICE\"\n    if self.aice is not None:\n        repr += f\" aice={self.aice}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19","title":"SICE_R19","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Rogers et al (2019).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] R19 [c0] [c1] [c2] [c3] [c4] [c5] [c6]\n</code></pre> <p>The default options recover the polynomial of Meylan et al. (2014), calibrated for a case of ice floes, mostly 10 to 25 m in diameter, in the marginal ice zone near Antarctica. Examples for other calibrations can be found in the Scientific/Technical documentation.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19--references","title":"References","text":"<p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p> <p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_R19\nsice = SICE_R19()\nprint(sice.render())\nkwargs = dict(\n    aice=0.5,\n    c0=0.0,\n    c1=0.0,\n    c2=1.06e-3,\n    c3=0.0,\n    c4=0.0,\n    c5=0.0,\n    c6=0.0,\n)\nsice = SICE_R19(**kwargs)\nprint(sice.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SICE_R19(SICE):\n    \"\"\"Sea ice dissipation based on the method of Rogers et al (2019).\n\n    .. code-block:: text\n\n        SICE [aice] R19 [c0] [c1] [c2] [c3] [c4] [c5] [c6]\n\n    The default options recover the polynomial of Meylan et al. (2014), calibrated for\n    a case of ice floes, mostly 10 to 25 m in diameter, in the marginal ice zone near\n    Antarctica. Examples for other calibrations can be found in the\n    Scientific/Technical documentation.\n\n    References\n    ----------\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2018. Frequency distribution of\n    dissipation of energy of ocean waves by sea ice using data from Wave Array 3 of\n    the ONR \u201cSea State\u201d field experiment. Nav. Res. Lab. Memo. Rep, pp.18-9801.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_R19\n        sice = SICE_R19()\n        print(sice.render())\n        kwargs = dict(\n            aice=0.5,\n            c0=0.0,\n            c1=0.0,\n            c2=1.06e-3,\n            c3=0.0,\n            c4=0.0,\n            c5=0.0,\n            c6=0.0,\n        )\n        sice = SICE_R19(**kwargs)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"r19\", \"R19\"] = Field(\n        default=\"r19\", description=\"Model type discriminator\"\n    )\n    c0: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in 1/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s2/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 1.06E-3)\"\n        ),\n    )\n    c3: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s3/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c4: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s4/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 2.3E-2)\"\n        ),\n    )\n    c5: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s5/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n    c6: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Polynomial coefficient (in s6/m) for determining the rate of sea ice \"\n            \"dissipation (SWAN default: 0.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.c0 is not None:\n            repr += f\" c0={self.c0}\"\n        if self.c1 is not None:\n            repr += f\" c1={self.c1}\"\n        if self.c2 is not None:\n            repr += f\" c2={self.c2}\"\n        if self.c3 is not None:\n            repr += f\" c3={self.c3}\"\n        if self.c4 is not None:\n            repr += f\" c4={self.c4}\"\n        if self.c5 is not None:\n            repr += f\" c5={self.c5}\"\n        if self.c6 is not None:\n            repr += f\" c6={self.c6}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['r19', 'R19'] = Field(default='r19', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c0","title":"c0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0: Optional[float] = Field(default=None, description='Polynomial coefficient (in 1/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c1","title":"c1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c1: Optional[float] = Field(default=None, description='Polynomial coefficient (in s/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c2","title":"c2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c2: Optional[float] = Field(default=None, description='Polynomial coefficient (in s2/m) for determining the rate of sea ice dissipation (SWAN default: 1.06E-3)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c3","title":"c3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c3: Optional[float] = Field(default=None, description='Polynomial coefficient (in s3/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c4","title":"c4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c4: Optional[float] = Field(default=None, description='Polynomial coefficient (in s4/m) for determining the rate of sea ice dissipation (SWAN default: 2.3E-2)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c5","title":"c5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c5: Optional[float] = Field(default=None, description='Polynomial coefficient (in s5/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.c6","title":"c6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c6: Optional[float] = Field(default=None, description='Polynomial coefficient (in s6/m) for determining the rate of sea ice dissipation (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R19.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.c0 is not None:\n        repr += f\" c0={self.c0}\"\n    if self.c1 is not None:\n        repr += f\" c1={self.c1}\"\n    if self.c2 is not None:\n        repr += f\" c2={self.c2}\"\n    if self.c3 is not None:\n        repr += f\" c3={self.c3}\"\n    if self.c4 is not None:\n        repr += f\" c4={self.c4}\"\n    if self.c5 is not None:\n        repr += f\" c5={self.c5}\"\n    if self.c6 is not None:\n        repr += f\" c6={self.c6}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15","title":"SICE_D15","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Doble et al. (2015).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] D15 [chf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15--references","title":"References","text":"<p>Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015. Relating wave attenuation to pancake ice thickness, using field measurements and model results. Geophysical Research Letters, 42(11), pp.4473-4481.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_D15\nsice = SICE_D15()\nprint(sice.render())\nsice = SICE_D15(aice=0.2, chf=0.1)\nprint(sice.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SICE_D15(SICE):\n    \"\"\"Sea ice dissipation based on the method of Doble et al. (2015).\n\n    .. code-block:: text\n\n        SICE [aice] D15 [chf]\n\n    References\n    ----------\n    Doble, M.J., De Carolis, G., Meylan, M.H., Bidlot, J.R. and Wadhams, P., 2015.\n    Relating wave attenuation to pancake ice thickness, using field measurements and\n    model results. Geophysical Research Letters, 42(11), pp.4473-4481.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_D15\n        sice = SICE_D15()\n        print(sice.render())\n        sice = SICE_D15(aice=0.2, chf=0.1)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"d15\", \"D15\"] = Field(\n        default=\"d15\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 0.1)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['d15', 'D15'] = Field(default='d15', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 0.1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_D15.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18","title":"SICE_M18","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Meylan et al. (2018).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] M18 [chf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18--references","title":"References","text":"<p>Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research Letters, 41(14), pp.5046-5051.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_M18\nsice = SICE_M18()\nprint(sice.render())\nsice = SICE_M18(aice=0.8, chf=0.059)\nprint(sice.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SICE_M18(SICE):\n    \"\"\"Sea ice dissipation based on the method of Meylan et al. (2018).\n\n    .. code-block:: text\n\n        SICE [aice] M18 [chf]\n\n    References\n    ----------\n    Meylan, M.H., Bennetts, L.G. and Kohout, A.L., 2014. In situ measurements and\n    analysis of ocean waves in the Antarctic marginal ice zone. Geophysical Research\n    Letters, 41(14), pp.5046-5051.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_M18\n        sice = SICE_M18()\n        print(sice.render())\n        sice = SICE_M18(aice=0.8, chf=0.059)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"m18\", \"M18\"] = Field(\n        default=\"m18\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 0.059)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['m18', 'M18'] = Field(default='m18', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 0.059)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_M18.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B","title":"SICE_R21B","text":"<p>               Bases: <code>SICE</code></p> <p>Sea ice dissipation based on the method of Rogers et al. (2021).</p> <p>.. code-block:: text</p> <pre><code>SICE [aice] R21B [chf] [npf]\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B--references","title":"References","text":"<p>Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science and Technology, 182, p.103198.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SICE_R21B\nsice = SICE_R21B()\nprint(sice.render())\nsice = SICE_R21B(aice=0.8, chf=2.9, npf=4.5)\nprint(sice.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SICE_R21B(SICE):\n    \"\"\"Sea ice dissipation based on the method of Rogers et al. (2021).\n\n    .. code-block:: text\n\n        SICE [aice] R21B [chf] [npf]\n\n    References\n    ----------\n    Rogers, W.E., Meylan, M.H. and Kohout, A.L., 2021. Estimates of spectral wave\n    attenuation in Antarctic sea ice, using model/data inversion. Cold Regions Science\n    and Technology, 182, p.103198.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SICE_R21B\n        sice = SICE_R21B()\n        print(sice.render())\n        sice = SICE_R21B(aice=0.8, chf=2.9, npf=4.5)\n        print(sice.render())\n\n    \"\"\"\n\n    model_type: Literal[\"r21b\", \"R21B\"] = Field(\n        default=\"r21b\", description=\"Model type discriminator\"\n    )\n    chf: Optional[float] = Field(\n        default=None,\n        description=\"A simple coefficient of proportionality (SWAN default: 2.9)\",\n    )\n    npf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Controls the degree of dependence on frequency and ice thickness \"\n            \"(SWAN default: 4.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} {self.model_type.upper()}\"\n        if self.chf is not None:\n            repr += f\" chf={self.chf}\"\n        if self.npf is not None:\n            repr += f\" npf={self.npf}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['r21b', 'R21B'] = Field(default='r21b', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.chf","title":"chf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chf: Optional[float] = Field(default=None, description='A simple coefficient of proportionality (SWAN default: 2.9)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.npf","title":"npf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npf: Optional[float] = Field(default=None, description='Controls the degree of dependence on frequency and ice thickness (SWAN default: 4.5)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SICE_R21B.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} {self.model_type.upper()}\"\n    if self.chf is not None:\n        repr += f\" chf={self.chf}\"\n    if self.npf is not None:\n        repr += f\" npf={self.npf}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#turbulent-viscosity","title":"Turbulent viscosity","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE","title":"TURBULENCE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Turbulent viscosity.</p> <p>.. code-block:: text</p> <pre><code>TURBULENCE [ctb] (CURRENT [tbcur])\n</code></pre> <p>With this optional command the user can activate turbulent viscosity. This physical effect is also activated by reading values of the turbulent viscosity using the <code>READGRID TURB</code> command, but then with the default value of <code>ctb</code>. The command <code>READGRID TURB</code> is necessary if this command <code>TURB</code> is used since the value of the viscosity is assumed to vary over space.</p>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import TURBULENCE\nturbulence = TURBULENCE(current=False)\nprint(turbulence.render())\nturbulence = TURBULENCE(ctb=0.01, current=True, tbcur=0.004)\nprint(turbulence.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class TURBULENCE(BaseComponent):\n    \"\"\"Turbulent viscosity.\n\n    .. code-block:: text\n\n        TURBULENCE [ctb] (CURRENT [tbcur])\n\n    With this optional command the user can activate turbulent viscosity. This physical\n    effect is also activated by reading values of the turbulent viscosity using the\n    `READGRID TURB` command, but then with the default value of `ctb`. The command\n    `READGRID TURB` is necessary if this command `TURB` is used since the value of the\n    viscosity is assumed to vary over space.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import TURBULENCE\n        turbulence = TURBULENCE(current=False)\n        print(turbulence.render())\n        turbulence = TURBULENCE(ctb=0.01, current=True, tbcur=0.004)\n        print(turbulence.render())\n\n    \"\"\"\n\n    model_type: Literal[\"turbulence\", \"TURBULENCE\"] = Field(\n        default=\"turbulence\", description=\"Model type discriminator\"\n    )\n    ctb: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The value of the proportionality coefficient appearing in the energy \"\n            \"dissipation term (SWAN default: 0.01)\"\n        ),\n    )\n    current: Optional[bool] = Field(\n        default=True,\n        description=(\n            \"If this keyword is present the turbulent viscosity will be derived from \"\n            \"the product of the depth and the absolute value of the current velocity. \"\n            \"If the command `READGRID TURB` is used, this option is ignored; \"\n            \"the values read from file will prevail\"\n        ),\n    )\n    tbcur: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The factor by which depth x current velocity is multiplied in order to \"\n            \"get the turbulent viscosity (SWAN default: 0.004)\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def tbcur_only_with_current(self) -&gt; \"TURBULENCE\":\n        if not self.current and self.tbcur is not None:\n            raise ValueError(\"`tbcur` can only be defined if `current` is True\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"TURBULENCE\"\n        if self.ctb is not None:\n            repr += f\" ctb={self.ctb}\"\n        if self.current:\n            repr += \" CURRENT\"\n        if self.tbcur is not None:\n            repr += f\" tbcur={self.tbcur}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['turbulence', 'TURBULENCE'] = Field(default='turbulence', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.ctb","title":"ctb  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctb: Optional[float] = Field(default=None, description='The value of the proportionality coefficient appearing in the energy dissipation term (SWAN default: 0.01)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.current","title":"current  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current: Optional[bool] = Field(default=True, description='If this keyword is present the turbulent viscosity will be derived from the product of the depth and the absolute value of the current velocity. If the command `READGRID TURB` is used, this option is ignored; the values read from file will prevail')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.tbcur","title":"tbcur  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbcur: Optional[float] = Field(default=None, description='The factor by which depth x current velocity is multiplied in order to get the turbulent viscosity (SWAN default: 0.004)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.tbcur_only_with_current","title":"tbcur_only_with_current","text":"<pre><code>tbcur_only_with_current() -&gt; TURBULENCE\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef tbcur_only_with_current(self) -&gt; \"TURBULENCE\":\n    if not self.current and self.tbcur is not None:\n        raise ValueError(\"`tbcur` can only be defined if `current` is True\")\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.TURBULENCE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"TURBULENCE\"\n    if self.ctb is not None:\n        repr += f\" ctb={self.ctb}\"\n    if self.current:\n        repr += \" CURRENT\"\n    if self.tbcur is not None:\n        repr += f\" tbcur={self.tbcur}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#bragg-scattering","title":"Bragg scattering","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG","title":"BRAGG","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Bragg scattering.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff]\n</code></pre> <p>Using this optional command, the user activates a source term to represent the scattering of waves due to changes in the small-scale bathymetry based on the theory of Ardhuin and Herbers (2002). If this command is not used, SWAN will not account for Bragg scattering.</p> <p>The underlying process is related to the bed elevation spectrum that describes the random variability of the bathymetry at the scale of the wave length on top of a slowly varying depth. To input this spectrum in the model, two options are available. One option is to read a spectrum from a file. This single bottom spectrum will subsequently be applied in all active grid points. The assumption being made here is that the inputted bottom is gently sloping. Note that the bottom spectrum must be given as a function of the wave number <code>k</code>.</p> <p>Another option is to compute the spectrum by a Fourier transform from <code>x</code> to <code>k</code> of the bed modulations around a computational grid point. First, one must define a square region with a fixed size around the grid point in order to perform the Fourier transform. The size should correspond to a multiple of the wave length at which refraction is resolved (i.e. consistent with the mild slope assumption). Next, the amplitude modulation of the small-scale bathymetry is obtained by substracting a slowly varying bed level from the inputted high-resolution bathymetric data within this square region. Here, the smooth bed level is achieved using a bilinear fit. During the computation, however, SWAN employs the gently sloping bed as the mean of the original bathymetry within the given square around each computational grid point. Finally, the corresponding bottom spectrum is computed with an FFT.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG--notes","title":"Notes","text":"<p>The Bragg scattering source term to the action balance equation gives rise to a fairly stiff equation. The best remedy is to run SWAN in the nonstationary mode with a relatively small time step or in the stationary mode with some under relaxation (see command <code>NUM STAT [alfa]</code>).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG\nbragg = BRAGG(nreg=200)\nprint(bragg.render())\nbragg = BRAGG(ibrag=1, nreg=200, cutoff=5.0)\nprint(bragg.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class BRAGG(BaseComponent):\n    \"\"\"Bragg scattering.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff]\n\n    Using this optional command, the user activates a source term to represent the\n    scattering of waves due to changes in the small-scale bathymetry based on the\n    theory of Ardhuin and Herbers (2002). If this command is not used, SWAN will not\n    account for Bragg scattering.\n\n    The underlying process is related to the bed elevation spectrum that describes the\n    random variability of the bathymetry at the scale of the wave length on top of a\n    slowly varying depth. To input this spectrum in the model, two options are\n    available. One option is to read a spectrum from a file. This single bottom\n    spectrum will subsequently be applied in all active grid points. The assumption\n    being made here is that the inputted bottom is gently sloping. Note that the bottom\n    spectrum must be given as a function of the wave number `k`.\n\n    Another option is to compute the spectrum by a Fourier transform from `x` to `k` of\n    the bed modulations around a computational grid point. First, one must define a\n    square region with a fixed size around the grid point in order to perform the\n    Fourier transform. The size should correspond to a multiple of the wave length at\n    which refraction is resolved (i.e. consistent with the mild slope assumption).\n    Next, the amplitude modulation of the small-scale bathymetry is obtained by\n    substracting a slowly varying bed level from the inputted high-resolution\n    bathymetric data within this square region. Here, the smooth bed level is achieved\n    using a bilinear fit. During the computation, however, SWAN employs the gently\n    sloping bed as the mean of the original bathymetry within the given square around\n    each computational grid point. Finally, the corresponding bottom spectrum is\n    computed with an FFT.\n\n    Notes\n    -----\n    The Bragg scattering source term to the action balance equation gives rise to a\n    fairly stiff equation. The best remedy is to run SWAN in the nonstationary mode\n    with a relatively small time step or in the stationary mode with some under\n    relaxation (see command `NUM STAT [alfa]`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG\n        bragg = BRAGG(nreg=200)\n        print(bragg.render())\n        bragg = BRAGG(ibrag=1, nreg=200, cutoff=5.0)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bragg\", \"BRAGG\"] = Field(\n        default=\"bragg\", description=\"Model type discriminator\"\n    )\n    ibrag: Optional[Literal[1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Indicates the computation of Bragg scattering term:\\n\\n* 1: source term \"\n            \"is calculated per sweep and bottom spectrum is interpolated at the \"\n            \"difference wave number a priori (thus requiring storage)\\n* 2: source \"\n            \"term is calculated per sweep and bottom spectrum is interpolated at the \"\n            \"difference wave number per sweep (no storage)\\n* 3: source term is \"\n            \"calculated per iteration and bottom spectrum is interpolated at the \"\n            \"difference wave number per iteration (no storage)\\n\\n(SWAN default: 1)\"\n        ),\n    )\n    nreg: int = Field(\n        description=(\n            \"Size of square region around computational grid point (centered) for \"\n            \"computing the mean depth and, if desired, the bed elevation spectrum. It \"\n            \"is expressed in terms of the number of grid points (per direction) \"\n            \"of the inputted bottom grid\"\n        ),\n    )\n    cutoff: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Cutoff to the ratio between surface and bottom wave numbers. Note: see\"\n            \"the Scientific/Technical documentation for details (SWAN default: 5.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"BRAGG\"\n        if self.ibrag is not None:\n            repr += f\" ibrag={self.ibrag}\"\n        if self.nreg is not None:\n            repr += f\" nreg={self.nreg}\"\n        if self.cutoff is not None:\n            repr += f\" cutoff={self.cutoff}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bragg', 'BRAGG'] = Field(default='bragg', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.ibrag","title":"ibrag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ibrag: Optional[Literal[1, 2, 3]] = Field(default=None, description='Indicates the computation of Bragg scattering term:\\n\\n* 1: source term is calculated per sweep and bottom spectrum is interpolated at the difference wave number a priori (thus requiring storage)\\n* 2: source term is calculated per sweep and bottom spectrum is interpolated at the difference wave number per sweep (no storage)\\n* 3: source term is calculated per iteration and bottom spectrum is interpolated at the difference wave number per iteration (no storage)\\n\\n(SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.nreg","title":"nreg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nreg: int = Field(description='Size of square region around computational grid point (centered) for computing the mean depth and, if desired, the bed elevation spectrum. It is expressed in terms of the number of grid points (per direction) of the inputted bottom grid')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutoff: Optional[float] = Field(default=None, description='Cutoff to the ratio between surface and bottom wave numbers. Note: seethe Scientific/Technical documentation for details (SWAN default: 5.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"BRAGG\"\n    if self.ibrag is not None:\n        repr += f\" ibrag={self.ibrag}\"\n    if self.nreg is not None:\n        repr += f\" nreg={self.nreg}\"\n    if self.cutoff is not None:\n        repr += f\" cutoff={self.cutoff}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT","title":"BRAGG_FT","text":"<p>               Bases: <code>BRAGG</code></p> <p>Bragg scattering with bottom spectrum computed from FFT.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff] FT\n</code></pre> <p>If this keyword is present the bottom spectrum will be computed in each active grid point using a Fast Fourier Transform (FFT).</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT--notes","title":"Notes","text":"<p>The depth in each computational grid point is computed as the average of the inputted (high-resolution) bed levels within the square region.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG_FT\nbragg = BRAGG_FT(nreg=350)\nprint(bragg.render())\nbragg = BRAGG_FT(ibrag=2, nreg=350, cutoff=5.0)\nprint(bragg.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class BRAGG_FT(BRAGG):\n    \"\"\"Bragg scattering with bottom spectrum computed from FFT.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff] FT\n\n    If this keyword is present the bottom spectrum will be computed in each active\n    grid point using a Fast Fourier Transform (FFT).\n\n    Notes\n    -----\n    The depth in each computational grid point is computed as the average of the\n    inputted (high-resolution) bed levels within the square region.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG_FT\n        bragg = BRAGG_FT(nreg=350)\n        print(bragg.render())\n        bragg = BRAGG_FT(ibrag=2, nreg=350, cutoff=5.0)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ft\", \"FT\"] = Field(\n        default=\"ft\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"{super().cmd()} FT\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ft', 'FT'] = Field(default='ft', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"{super().cmd()} FT\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE","title":"BRAGG_FILE","text":"<p>               Bases: <code>BRAGG</code></p> <p>Bragg scattering with bottom spectrum from file.</p> <p>.. code-block:: text</p> <pre><code>BRAGG [ibrag] [nreg] [cutoff] FILE 'fname' [idla] [mkx] [mky] [dkx] [dky]\n</code></pre> <p>The bed elevation spectrum <code>FB(kx, ky)</code> is read from a file.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE--notes","title":"Notes","text":"<p>This spectrum is taken to be uniform over the entire computational domain.</p>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import BRAGG_FILE\nbragg = BRAGG_FILE(fname=\"bottom_spectrum.txt\", nreg=500, mkx=99, dkx=0.1)\nprint(bragg.render())\nkwargs = dict(\n    ibrag=3,\n    nreg=500,\n    cutoff=5.0,\n    fname=\"bottom_spectrum.txt\",\n    mkx=99,\n    mky=149,\n    dkx=0.1,\n    dky=0.1,\n)\nbragg = BRAGG_FILE(**kwargs)\nprint(bragg.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class BRAGG_FILE(BRAGG):\n    \"\"\"Bragg scattering with bottom spectrum from file.\n\n    .. code-block:: text\n\n        BRAGG [ibrag] [nreg] [cutoff] FILE 'fname' [idla] [mkx] [mky] [dkx] [dky]\n\n    The bed elevation spectrum `FB(kx, ky)` is read from a file.\n\n    Notes\n    -----\n    This spectrum is taken to be uniform over the entire computational domain.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import BRAGG_FILE\n        bragg = BRAGG_FILE(fname=\"bottom_spectrum.txt\", nreg=500, mkx=99, dkx=0.1)\n        print(bragg.render())\n        kwargs = dict(\n            ibrag=3,\n            nreg=500,\n            cutoff=5.0,\n            fname=\"bottom_spectrum.txt\",\n            mkx=99,\n            mky=149,\n            dkx=0.1,\n            dky=0.1,\n        )\n        bragg = BRAGG_FILE(**kwargs)\n        print(bragg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"file\", \"FILE\"] = Field(\n        default=\"file\", description=\"Model type discriminator\"\n    )\n    fname: str = Field(\n        description=\"Name of file containing the bottom spectrum\",\n        max_length=36,\n    )\n    idla: Optional[IDLA] = Field(\n        default=None,\n        description=(\"Order in which the values should be given in the input files\"),\n    )\n    mkx: int = Field(\n        description=(\n            \"Number of cells in x-direction of the wave number grid related to bottom \"\n            \"spectrum (this is one less than the number of points in this direction)\"\n        ),\n    )\n    mky: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Number of cells in y-direction of the wave number grid related to bottom \"\n            \"spectrum (this is one less than the number of points in this direction)\"\n            \"(SWAN default: `mky = mkx`)\"\n        ),\n    )\n    dkx: float = Field(\n        description=(\n            \"Mesh size in x-direction of the wave number grid related to bottom \"\n            \"spectrum (1/m)\"\n        ),\n    )\n    dky: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Mesh size in y-direction of the wave number grid related to bottom \"\n            \"spectrum (1/m) (SWAN default: `dky = dkx`)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"{super().cmd()} FILE fname='{self.fname}'\"\n        if self.idla is not None:\n            repr += f\" idla={self.idla.value}\"\n        repr += f\" mkx={self.mkx}\"\n        if self.mky is not None:\n            repr += f\" mky={self.mky}\"\n        repr += f\" dkx={self.dkx}\"\n        if self.dky is not None:\n            repr += f\" dky={self.dky}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['file', 'FILE'] = Field(default='file', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of file containing the bottom spectrum', max_length=36)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[IDLA] = Field(default=None, description='Order in which the values should be given in the input files')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.mkx","title":"mkx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mkx: int = Field(description='Number of cells in x-direction of the wave number grid related to bottom spectrum (this is one less than the number of points in this direction)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.mky","title":"mky  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mky: Optional[int] = Field(default=None, description='Number of cells in y-direction of the wave number grid related to bottom spectrum (this is one less than the number of points in this direction)(SWAN default: `mky = mkx`)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.dkx","title":"dkx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dkx: float = Field(description='Mesh size in x-direction of the wave number grid related to bottom spectrum (1/m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.dky","title":"dky  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dky: Optional[float] = Field(default=None, description='Mesh size in y-direction of the wave number grid related to bottom spectrum (1/m) (SWAN default: `dky = dkx`)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.BRAGG_FILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"{super().cmd()} FILE fname='{self.fname}'\"\n    if self.idla is not None:\n        repr += f\" idla={self.idla.value}\"\n    repr += f\" mkx={self.mkx}\"\n    if self.mky is not None:\n        repr += f\" mky={self.mky}\"\n    repr += f\" dkx={self.dkx}\"\n    if self.dky is not None:\n        repr += f\" dky={self.dky}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#limiter","title":"Limiter","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER","title":"LIMITER","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Physics limiter.</p> <p>.. code-block:: text</p> <pre><code>LIMITER [ursell] [qb]\n</code></pre> <p>With this command the user can de-activate permanently the quadruplets when the actual Ursell number exceeds <code>ursell</code>. Moreover, as soon as the actual fraction of breaking waves exceeds <code>qb</code> then the action limiter will not be used in case of decreasing action density.</p>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import LIMITER\nlimiter = LIMITER()\nprint(limiter.render())\nlimiter = LIMITER(ursell=10.0, qb=1.0)\nprint(limiter.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class LIMITER(BaseComponent):\n    \"\"\"Physics limiter.\n\n    .. code-block:: text\n\n        LIMITER [ursell] [qb]\n\n    With this command the user can de-activate permanently the quadruplets when\n    the actual Ursell number exceeds `ursell`. Moreover, as soon as the actual\n    fraction of breaking waves exceeds `qb` then the action limiter will not be\n    used in case of decreasing action density.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import LIMITER\n        limiter = LIMITER()\n        print(limiter.render())\n        limiter = LIMITER(ursell=10.0, qb=1.0)\n        print(limiter.render())\n\n    \"\"\"\n\n    model_type: Literal[\"limiter\", \"LIMITER\"] = Field(\n        default=\"limiter\", description=\"Model type discriminator\"\n    )\n    ursell: Optional[float] = Field(\n        default=None,\n        description=(\"The upper threshold for Ursell number (SWAN default: 10.0)\"),\n    )\n    qb: Optional[float] = Field(\n        default=None,\n        description=\"The threshold for fraction of breaking waves (SWAN default: 1.0)\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"LIMITER\"\n        if self.ursell is not None:\n            repr += f\" ursell={self.ursell}\"\n        if self.qb is not None:\n            repr += f\" qb={self.qb}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['limiter', 'LIMITER'] = Field(default='limiter', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.ursell","title":"ursell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ursell: Optional[float] = Field(default=None, description='The upper threshold for Ursell number (SWAN default: 10.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.qb","title":"qb  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qb: Optional[float] = Field(default=None, description='The threshold for fraction of breaking waves (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.LIMITER-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.LIMITER.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"LIMITER\"\n    if self.ursell is not None:\n        repr += f\" ursell={self.ursell}\"\n    if self.qb is not None:\n        repr += f\" qb={self.qb}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#obstacle","title":"Obstacle","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE","title":"OBSTACLE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Subgrid obstacle.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE -&gt;TRANSM|TRANS1D|TRANS2D|GODA|DANGREMOND REFL [reflc] -&gt;RSPEC|RDIFF &amp;\n    (FREEBOARD [hgt] [gammat] [gammar] QUAY) LINE &lt; [xp] [yp] &gt;\n</code></pre> <p>With this optional command the user provides the characteristics of a (line of) sub-grid obstacle(s) through which waves are transmitted or against which waves are reflected (possibly both at the same time). The obstacle is sub-grid in the sense that it is narrow compared to the spatial meshes; its length should be at least one mesh length.</p> <p>The location of the obstacle is defined by a sequence of corner points of a line. The obstacles interrupt the propagation of the waves from one grid point to the next wherever this obstacle line is located between two neighbouring grid points (of the computational grid; the resolution of the obstacle is therefore equal to the computational grid spacing). This implies that an obstacle to be effective must be located such that it crosses at least one grid line. This is always the case when an obstacle is larger than one mesh length.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE--notes","title":"Notes","text":"<ul> <li>The advise is to define obstacles with the least amount of points possible.</li> <li>SWAN checks if the criterion <code>reflc^2 + trcoef^2 LE 1</code> is fulfilled.</li> </ul>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLE\nobs = OBSTACLE(\n    transmission=dict(model_type=\"transm\", trcoef=0.5),\n    reflection=dict(reflc=0.5),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class OBSTACLE(BaseComponent):\n    \"\"\"Subgrid obstacle.\n\n    .. code-block:: text\n\n        OBSTACLE -&gt;TRANSM|TRANS1D|TRANS2D|GODA|DANGREMOND REFL [reflc] -&gt;RSPEC|RDIFF &amp;\n            (FREEBOARD [hgt] [gammat] [gammar] QUAY) LINE &lt; [xp] [yp] &gt;\n\n    With this optional command the user provides the characteristics of a (line\n    of) sub-grid obstacle(s) through which waves are transmitted or against which\n    waves are reflected (possibly both at the same time). The obstacle is sub-grid\n    in the sense that it is narrow compared to the spatial meshes; its length should\n    be at least one mesh length.\n\n    The location of the obstacle is defined by a sequence of corner points of a line.\n    The obstacles interrupt the propagation of the waves from one grid point to the\n    next wherever this obstacle line is located between two neighbouring grid points\n    (of the computational grid; the resolution of the obstacle is therefore equal to\n    the computational grid spacing). This implies that an obstacle to be effective must\n    be located such that it crosses at least one grid line. This is always the case\n    when an obstacle is larger than one mesh length.\n\n    Notes\n    -----\n\n    * The advise is to define obstacles with the least amount of points possible.\n    * SWAN checks if the criterion `reflc^2 + trcoef^2 LE 1` is fulfilled.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLE\n        obs = OBSTACLE(\n            transmission=dict(model_type=\"transm\", trcoef=0.5),\n            reflection=dict(reflc=0.5),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"obstacle\", \"OBSTACLE\"] = Field(\n        default=\"obstacle\", description=\"Model type discriminator\"\n    )\n    transmission: Optional[TRANSMISSION_TYPE] = Field(default=None)\n    reflection: Optional[REFL] = Field(default=None, description=\"Wave reflection\")\n    reflection_type: Optional[REFLECTION_TYPE] = Field(default=None)\n    freeboard: Optional[FREEBOARD] = Field(default=None, description=\"Freeboard\")\n    line: LINE = Field(default=None, description=\"Line of obstacle\")\n\n    @model_validator(mode=\"after\")\n    def hgt_consistent(self) -&gt; \"OBSTACLE\":\n        \"\"\"Warns if `hgt` has different values in DAM and FREEBOARD specifications.\"\"\"\n        if self.transmission is not None and self.freeboard is not None:\n            is_dam = self.transmission.model_type.upper() in [\"GODA\", \"DANGREMOND\"]\n            if is_dam and self.freeboard.hgt != self.transmission.hgt:\n                logger.warning(\"hgt in FREEBOARD and DAM specifications are not equal\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"OBSTACLE\"\n        if self.transmission is not None:\n            repr += f\" {self.transmission.render()}\"\n        if self.reflection:\n            repr += f\" {self.reflection.render()}\"\n        if self.reflection_type is not None:\n            repr += f\" {self.reflection_type.render()}\"\n        if self.freeboard is not None:\n            repr += f\" {self.freeboard.render()}\"\n        repr += f\" {self.line.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['obstacle', 'OBSTACLE'] = Field(default='obstacle', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.transmission","title":"transmission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transmission: Optional[TRANSMISSION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: Optional[REFL] = Field(default=None, description='Wave reflection')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.reflection_type","title":"reflection_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection_type: Optional[REFLECTION_TYPE] = Field(default=None)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.freeboard","title":"freeboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freeboard: Optional[FREEBOARD] = Field(default=None, description='Freeboard')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.line","title":"line  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line: LINE = Field(default=None, description='Line of obstacle')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.hgt_consistent","title":"hgt_consistent","text":"<pre><code>hgt_consistent() -&gt; OBSTACLE\n</code></pre> <p>Warns if <code>hgt</code> has different values in DAM and FREEBOARD specifications.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef hgt_consistent(self) -&gt; \"OBSTACLE\":\n    \"\"\"Warns if `hgt` has different values in DAM and FREEBOARD specifications.\"\"\"\n    if self.transmission is not None and self.freeboard is not None:\n        is_dam = self.transmission.model_type.upper() in [\"GODA\", \"DANGREMOND\"]\n        if is_dam and self.freeboard.hgt != self.transmission.hgt:\n            logger.warning(\"hgt in FREEBOARD and DAM specifications are not equal\")\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"OBSTACLE\"\n    if self.transmission is not None:\n        repr += f\" {self.transmission.render()}\"\n    if self.reflection:\n        repr += f\" {self.reflection.render()}\"\n    if self.reflection_type is not None:\n        repr += f\" {self.reflection_type.render()}\"\n    if self.freeboard is not None:\n        repr += f\" {self.freeboard.render()}\"\n    repr += f\" {self.line.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG","title":"OBSTACLE_FIG","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Obstacle for free infragravity radiation.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE FIG [alpha1] [hss] [tss] (REFL [reflc]) LINE &lt;[xp] [yp]&gt;\n</code></pre> <p>With this optional command the user specifies the obstacles along which the free infra-gravity (FIG) energy is radiated. By placing the obstacles close to the shorelines SWAN will include the FIG source term along the coastlines according to the parametrization of Ardhuin et al. (2014).</p> <p>The location of the obstacle is defined by a sequence of corner points of a line. For an obstacle line to be effective its length is at least one mesh size large. It is recommended to place the obstacles at the inner area of the computational grid, not at or through the boundaries. In particular, each obstacle line must be bordered by wet points on both sides.</p> <p>In addition, the orientation of the obstacle line determines from which side of the obstacle the FIG wave energy is radiated away. If the begin point of the line is below or left of the end point, that is, pointing upwards/to the right, then FIG energy is radiated from the west/north side of the line. If the begin point is above or right of the end point (pointing downwards/to the left), then FIG energy is radiated away from the east/south side of the obstacle line.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--references","title":"References","text":"<p>Ardhuin, F., Rawat, A. and Aucan, J., 2014. A numerical model for free infragravity waves: Definition and validation at regional and global scales. Ocean Modelling, 77, pp.20-32.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--notes","title":"Notes","text":"<p>Either <code>hss</code> or <code>tss</code> or both are allowed to vary over the computational domain. In that case use the commands <code>INPGRID HSS</code> and <code>READINP HSS</code> and/or the commands <code>INPGRID TSS</code> and <code>READINP TSS</code> to define and read the sea-swell wave height/period It is permissible to have constant sea-swell height and non-constant sea-swell period, or vice versa. The command <code>OBST FIG</code> is still required to define the obstacles. The values of <code>hss</code> and/or <code>tss</code> in this command are then not required (they will be ignored).</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLE_FIG\nobs = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\nobs = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    reflection=dict(reflc=0.5),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nprint(obs.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class OBSTACLE_FIG(BaseComponent):\n    \"\"\"Obstacle for free infragravity radiation.\n\n    .. code-block:: text\n\n        OBSTACLE FIG [alpha1] [hss] [tss] (REFL [reflc]) LINE &lt;[xp] [yp]&gt;\n\n    With this optional command the user specifies the obstacles along which the\n    free infra-gravity (FIG) energy is radiated. By placing the obstacles close to\n    the shorelines SWAN will include the FIG source term along the coastlines\n    according to the parametrization of Ardhuin et al. (2014).\n\n    The location of the obstacle is defined by a sequence of corner points of a line.\n    For an obstacle line to be effective its length is at least one mesh size large. It\n    is recommended to place the obstacles at the inner area of the computational grid,\n    not at or through the boundaries. In particular, each obstacle line must be\n    bordered by wet points on both sides.\n\n    In addition, the orientation of the obstacle line determines from which side of the\n    obstacle the FIG wave energy is radiated away. If the begin point of the line is\n    below or left of the end point, that is, pointing upwards/to the right, then FIG\n    energy is radiated from the west/north side of the line. If the begin point is\n    above or right of the end point (pointing downwards/to the left), then FIG energy\n    is radiated away from the east/south side of the obstacle line.\n\n    References\n    ----------\n    Ardhuin, F., Rawat, A. and Aucan, J., 2014. A numerical model for free\n    infragravity waves: Definition and validation at regional and global scales.\n    Ocean Modelling, 77, pp.20-32.\n\n    Notes\n    -----\n    Either `hss` or `tss` or both are allowed to vary over the computational domain.\n    In that case use the commands `INPGRID HSS` and `READINP HSS` and/or the commands\n    `INPGRID TSS` and `READINP TSS` to define and read the sea-swell wave height/period\n    It is permissible to have constant sea-swell height and non-constant sea-swell\n    period, or vice versa. The command `OBST FIG` is still required to define the\n    obstacles. The values of `hss` and/or `tss` in this command are then not required\n    (they will be ignored).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLE_FIG\n        obs = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n        obs = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            reflection=dict(reflc=0.5),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        print(obs.render())\n\n    \"\"\"\n\n    model_type: Literal[\"fig\", \"FIG\"] = Field(\n        default=\"fig\", description=\"Model type discriminator\"\n    )\n    alpha1: float = Field(\n        description=(\n            \"Calibration parameter (in 1/s) for determining the rate of radiating FIG \"\n            \"energy from the shorelines, values in Table 1 of Ardhuin et al. (2014) \"\n            \"are between 4e-4 and 8.1e-4\"\n        ),\n    )\n    hss: float = Field(\n        description=\"The sea-swell significant wave height (in m)\",\n        ge=0.0,\n    )\n    tss: float = Field(\n        description=\"The sea-swell mean wave period (in s)\",\n        ge=0.0,\n    )\n    reflection: Optional[REFL] = Field(default=None, description=\"Wave reflection\")\n    line: LINE = Field(description=\"Line of obstacle\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = f\"OBSTACLE FIG alpha1={self.alpha1} hss={self.hss} tss={self.tss}\"\n        if self.reflection:\n            repr += f\" {self.reflection.render()}\"\n        repr += f\" {self.line.render()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['fig', 'FIG'] = Field(default='fig', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.alpha1","title":"alpha1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha1: float = Field(description='Calibration parameter (in 1/s) for determining the rate of radiating FIG energy from the shorelines, values in Table 1 of Ardhuin et al. (2014) are between 4e-4 and 8.1e-4')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.hss","title":"hss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hss: float = Field(description='The sea-swell significant wave height (in m)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.tss","title":"tss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tss: float = Field(description='The sea-swell mean wave period (in s)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: Optional[REFL] = Field(default=None, description='Wave reflection')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.line","title":"line  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line: LINE = Field(description='Line of obstacle')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLE_FIG.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = f\"OBSTACLE FIG alpha1={self.alpha1} hss={self.hss} tss={self.tss}\"\n    if self.reflection:\n        repr += f\" {self.reflection.render()}\"\n    repr += f\" {self.line.render()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES","title":"OBSTACLES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>List of swan obstacles.</p> <p>.. code-block:: text</p> <pre><code>OBSTACLE ... LINE &lt; [xp] [yp] &gt;\nOBSTACLE ... LINE &lt; [xp] [yp] &gt;\n.\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of obstacle components.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OBSTACLES, OBSTACLE, OBSTACLE_FIG\nobst1 = dict(\n    model_type=\"obstacle\",\n    reflection=dict(reflc=1.0),\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nobst2 = OBSTACLE(\n    transmission=dict(model_type=\"transm\"),\n    line=dict(xp=[174.3, 174.3], yp=[-39.1, -39.2]),\n)\nobst3 = OBSTACLE_FIG(\n    alpha1=5e-4,\n    hss=2.5,\n    tss=10.3,\n    line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n)\nobstacles = OBSTACLES(obstacles=[obst1, obst2, obst3])\nfor obst in obstacles.render():\n    print(obst)\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class OBSTACLES(BaseComponent):\n    \"\"\"List of swan obstacles.\n\n    .. code-block:: text\n\n        OBSTACLE ... LINE &lt; [xp] [yp] &gt;\n        OBSTACLE ... LINE &lt; [xp] [yp] &gt;\n        .\n\n    This group component is a convenience to allow defining and rendering\n    a list of obstacle components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OBSTACLES, OBSTACLE, OBSTACLE_FIG\n        obst1 = dict(\n            model_type=\"obstacle\",\n            reflection=dict(reflc=1.0),\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        obst2 = OBSTACLE(\n            transmission=dict(model_type=\"transm\"),\n            line=dict(xp=[174.3, 174.3], yp=[-39.1, -39.2]),\n        )\n        obst3 = OBSTACLE_FIG(\n            alpha1=5e-4,\n            hss=2.5,\n            tss=10.3,\n            line=dict(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1]),\n        )\n        obstacles = OBSTACLES(obstacles=[obst1, obst2, obst3])\n        for obst in obstacles.render():\n            print(obst)\n\n    \"\"\"\n\n    model_type: Literal[\"obstacles\", \"OBSTACLES\"] = Field(\n        default=\"obstacles\", description=\"Model type discriminator\"\n    )\n    obstacles: list[OBSTACLES_TYPE] = Field(description=\"List of obstacles\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        repr = []\n        for obstacle in self.obstacles:\n            repr += [obstacle.cmd()]\n        return repr\n\n    def render(self) -&gt; str:\n        \"\"\"Override base class to allow rendering list of components.\"\"\"\n        cmds = []\n        for cmd in self.cmd():\n            cmds.append(super().render(cmd))\n        return cmds\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['obstacles', 'OBSTACLES'] = Field(default='obstacles', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.obstacles","title":"obstacles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacles: list[OBSTACLES_TYPE] = Field(description='List of obstacles')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    repr = []\n    for obstacle in self.obstacles:\n        repr += [obstacle.cmd()]\n    return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OBSTACLES.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Override base class to allow rendering list of components.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Override base class to allow rendering list of components.\"\"\"\n    cmds = []\n    for cmd in self.cmd():\n        cmds.append(super().render(cmd))\n    return cmds\n</code></pre>"},{"location":"components/physics/#wave-setup","title":"Wave setup","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP","title":"SETUP","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave setup.</p> <p>.. code-block:: text</p> <pre><code>SETUP [supcor]\n</code></pre> <p>If this command is given, the wave-induced set-up is computed and accounted for in the wave computations (during the computation it is added to the depth that is obtained from the <code>READ BOTTOM</code> and <code>READ WLEVEL</code> commands). This approximation in SWAN can only be applied to open coast (unlimited supply of water from outside the domain, e.g. nearshore coasts) in contrast to closed basin, e.g. lakes and estuaries, where this option should not be used. Note that set-up is not computed correctly with spherical coordinates.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP--notes","title":"Notes","text":"<ul> <li>The SETUP command cannot be used in case of unstructured grids.</li> <li>Set-up is not supported in case of parallel runs using either MPI or OpenMP.</li> </ul>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import SETUP\nsetup = SETUP()\nprint(setup.render())\nsetup = SETUP(supcor=0.5)\nprint(setup.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SETUP(BaseComponent):\n    \"\"\"Wave setup.\n\n    .. code-block:: text\n\n        SETUP [supcor]\n\n    If this command is given, the wave-induced set-up is computed and accounted for in\n    the wave computations (during the computation it is added to the depth that is\n    obtained from the `READ BOTTOM` and `READ WLEVEL` commands). This approximation in\n    SWAN can only be applied to open coast (unlimited supply of water from outside the\n    domain, e.g. nearshore coasts) in contrast to closed basin, e.g. lakes and\n    estuaries, where this option should not be used. Note that set-up is not computed\n    correctly with spherical coordinates.\n\n    Notes\n    -----\n\n    * The SETUP command cannot be used in case of unstructured grids.\n    * Set-up is not supported in case of parallel runs using either MPI or OpenMP.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import SETUP\n        setup = SETUP()\n        print(setup.render())\n        setup = SETUP(supcor=0.5)\n        print(setup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"setup\", \"SETUP\"] = Field(\n        default=\"setup\", description=\"Model type discriminator\"\n    )\n    supcor: Optional[float] = Field(\n        default=None,\n        description=(\n            \"By default the wave-induced set-up is computed with a constant added \"\n            \"such that the set-up is zero in the deepest point in the computational \"\n            \"grid. The user can modify this constant by the value of `supcor`. The \"\n            \"user can thus impose a set-up in any one point (and only one) in the \"\n            \"computational grid by first running SWAN, then reading the set-up in \"\n            \"that point and adding or subtracting the required value of `supcor` \"\n            \"(in m; positive if the set-up has to rise) (SWAN default: 0.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SETUP\"\n        if self.supcor is not None:\n            repr += f\" supcor={self.supcor}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['setup', 'SETUP'] = Field(default='setup', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP.supcor","title":"supcor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supcor: Optional[float] = Field(default=None, description='By default the wave-induced set-up is computed with a constant added such that the set-up is zero in the deepest point in the computational grid. The user can modify this constant by the value of `supcor`. The user can thus impose a set-up in any one point (and only one) in the computational grid by first running SWAN, then reading the set-up in that point and adding or subtracting the required value of `supcor` (in m; positive if the set-up has to rise) (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SETUP-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SETUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SETUP\"\n    if self.supcor is not None:\n        repr += f\" supcor={self.supcor}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#wave-diffraction","title":"Wave diffraction","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION","title":"DIFFRACTION","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Wave diffraction.</p> <p>.. code-block:: text</p> <pre><code>DIFFRACTION [idiffr] [smpar] [smnum] [cgmod]\n</code></pre> <p>If this optional command is given, the diffraction is included in the wave computation. But the diffraction approximation in SWAN does not properly handle diffraction in harbours or in front of reflecting obstacles (see Scientific/Technical documentation). Behind breakwaters with a down-wave beach, the SWAN results seem reasonable. The spatial resolution near (the tip of) the diffraction obstacle should be 1/5 to 1/10 of the dominant wave length.</p>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION--notes","title":"Notes","text":"<p>Without extra measures, the diffraction computations with SWAN often converge poorly or not at all. Two measures can be taken:</p> <ol> <li> <p>(RECOMMENDED) The user can request under-relaxation. See command <code>NUMERIC</code> parameter <code>alpha</code> and Scientific/Technical documentation (Eq. (3.31)). Very limited experience suggests <code>alpha = 0.01</code>.</p> </li> <li> <p>Alternatively, the user can request smoothing of the wave field for the computation of the diffraction parameter (the wave field remains intact for all other computations and output). This is done with a repeated convolution filtering.</p> </li> </ol>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION--examples","title":"Examples","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import DIFFRACTION\ndiffraction = DIFFRACTION()\nprint(diffraction.render())\ndiffraction = DIFFRACTION(idiffr=True, smpar=0.0, smnum=1.0)\nprint(diffraction.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class DIFFRACTION(BaseComponent):\n    \"\"\"Wave diffraction.\n\n    .. code-block:: text\n\n        DIFFRACTION [idiffr] [smpar] [smnum] [cgmod]\n\n    If this optional command is given, the diffraction is included in the wave\n    computation. But the diffraction approximation in SWAN does not properly handle\n    diffraction in harbours or in front of reflecting obstacles (see\n    Scientific/Technical documentation). Behind breakwaters with a down-wave beach, the\n    SWAN results seem reasonable. The spatial resolution near (the tip of) the\n    diffraction obstacle should be 1/5 to 1/10 of the dominant wave length.\n\n    Notes\n    -----\n    Without extra measures, the diffraction computations with SWAN often converge\n    poorly or not at all. Two measures can be taken:\n\n    1. (RECOMMENDED) The user can request under-relaxation. See command `NUMERIC`\n    parameter `alpha` and Scientific/Technical documentation (Eq. (3.31)). Very limited\n    experience suggests `alpha = 0.01`.\n\n    2. Alternatively, the user can request smoothing of the wave field for the\n    computation of the diffraction parameter (the wave field remains intact for all\n    other computations and output). This is done with a repeated convolution filtering.\n\n    Examples\n    --------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import DIFFRACTION\n        diffraction = DIFFRACTION()\n        print(diffraction.render())\n        diffraction = DIFFRACTION(idiffr=True, smpar=0.0, smnum=1.0)\n        print(diffraction.render())\n\n    \"\"\"\n\n    model_type: Literal[\"diffraction\", \"DIFFRACTION\"] = Field(\n        default=\"diffraction\", description=\"Model type discriminator\"\n    )\n    idiffr: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Indicates the use of diffraction. If `idiffr=0` then no diffraction is \"\n            \"taken into account (SWAN default: 1)\"\n        ),\n    )\n    smpar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Smoothing parameter for the calculation of \u2207 \u00b7 \u221aEtot. During every \"\n            \"smoothing step all grid points exchange `smpar` times the energy with \"\n            \"their neighbours. Note that `smpar` is parameter a in the above text \"\n            \"(SWAN default: 0.0)\"\n        ),\n    )\n    smnum: Optional[int] = Field(\n        default=None,\n        description=\"Number of smoothing steps relative to `smpar` (SWAN default: 0)\",\n    )\n    cgmod: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Adaption of propagation velocities in geographic space due to \"\n            \"diffraction. If `cgmod=0` then no adaption (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"DIFFRACTION\"\n        if self.idiffr is not None:\n            repr += f\" idiffr={int(self.idiffr)}\"\n        if self.smpar is not None:\n            repr += f\" smpar={self.smpar}\"\n        if self.smnum is not None:\n            repr += f\" smnum={self.smnum}\"\n        if self.cgmod is not None:\n            repr += f\" cgmod={self.cgmod}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['diffraction', 'DIFFRACTION'] = Field(default='diffraction', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.idiffr","title":"idiffr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idiffr: Optional[bool] = Field(default=None, description='Indicates the use of diffraction. If `idiffr=0` then no diffraction is taken into account (SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.smpar","title":"smpar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smpar: Optional[float] = Field(default=None, description='Smoothing parameter for the calculation of \u2207 \u00b7 \u221aEtot. During every smoothing step all grid points exchange `smpar` times the energy with their neighbours. Note that `smpar` is parameter a in the above text (SWAN default: 0.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.smnum","title":"smnum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smnum: Optional[int] = Field(default=None, description='Number of smoothing steps relative to `smpar` (SWAN default: 0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.cgmod","title":"cgmod  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cgmod: Optional[float] = Field(default=None, description='Adaption of propagation velocities in geographic space due to diffraction. If `cgmod=0` then no adaption (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.DIFFRACTION.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"DIFFRACTION\"\n    if self.idiffr is not None:\n        repr += f\" idiffr={int(self.idiffr)}\"\n    if self.smpar is not None:\n        repr += f\" smpar={self.smpar}\"\n    if self.smnum is not None:\n        repr += f\" smnum={self.smnum}\"\n    if self.cgmod is not None:\n        repr += f\" cgmod={self.cgmod}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#surfbeat","title":"Surfbeat","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT","title":"SURFBEAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Surfbeat.</p> <p>.. code-block:: text</p> <pre><code>SURFBEAT [df] [nmax] [emin] UNIFORM/LOGARITHMIC\n</code></pre> <p>Using this optional command, the user activates the Infragravity Energy Module (IEM) of Reniers and Zijlema (2022). Besides the energy balance equation for a sea-swell wave field, another energy balance is included to account for the transfer of sea-swell energy to the bound infragravity (BIG) wave. This infragravity energy balance also involves a nonlinear transfer, expressed by the biphase, through the phase coupling between the radiation stress forcing and the BIG wave. For the prediction of the biphase for obliquely incident waves, an evolution equation is provided under the assumption that the bottom slopes are mild and alongshore uniform.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT--references","title":"References","text":"<p>Reniers, A. and Zijlema, M., 2022. Swan surfbeat-1d. Coastal Engineering, 172, p.104068.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import SURFBEAT\nsurfbeat = SURFBEAT()\nprint(surfbeat.render())\nsurfbeat = SURFBEAT(df=0.01, nmax=50000, emin=0.05, spacing=\"logarithmic\")\nprint(surfbeat.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SURFBEAT(BaseComponent):\n    \"\"\"Surfbeat.\n\n    .. code-block:: text\n\n        SURFBEAT [df] [nmax] [emin] UNIFORM/LOGARITHMIC\n\n    Using this optional command, the user activates the Infragravity Energy Module\n    (IEM) of Reniers and Zijlema (2022). Besides the energy balance equation for a\n    sea-swell wave field, another energy balance is included to account for the\n    transfer of sea-swell energy to the bound infragravity (BIG) wave. This\n    infragravity energy balance also involves a nonlinear transfer, expressed by the\n    biphase, through the phase coupling between the radiation stress forcing and the\n    BIG wave. For the prediction of the biphase for obliquely incident waves, an\n    evolution equation is provided under the assumption that the bottom slopes are mild\n    and alongshore uniform.\n\n    References\n    ----------\n    Reniers, A. and Zijlema, M., 2022. Swan surfbeat-1d. Coastal Engineering, 172,\n    p.104068.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import SURFBEAT\n        surfbeat = SURFBEAT()\n        print(surfbeat.render())\n        surfbeat = SURFBEAT(df=0.01, nmax=50000, emin=0.05, spacing=\"logarithmic\")\n        print(surfbeat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"surfbeat\", \"SURFBEAT\"] = Field(\n        default=\"surfbeat\", description=\"Model type discriminator\"\n    )\n    df: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The constant size of BIG frequency bin (in Hz) (SWAN default: 0.01)\"\n        ),\n        ge=0.0,\n    )\n    nmax: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of short-wave pairs for creating bichromatic wave \"\n            \"groups (SWAN default: 50000)\"\n        ),\n        ge=0,\n    )\n    emin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The energy threshold in fraction of energy spectrum peak. With this \"\n            \"threshold one takes into account those short wave components to create \"\n            \"bichromatic wave groups while their energy levels are larger than \"\n            \"`emin x E_max` with `E_max` the peak of the spectrum (SWAN default: 0.05)\"\n        ),\n    )\n    spacing: Optional[Literal[\"uniform\", \"logarithmic\"]] = Field(\n        default=None,\n        description=(\n            \"Define if frequencies for reflected ig waves are uniformly or \"\n            \"logarithmically distributed\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SURFBEAT\"\n        if self.df is not None:\n            repr += f\" df={self.df}\"\n        if self.nmax is not None:\n            repr += f\" nmax={self.nmax}\"\n        if self.emin is not None:\n            repr += f\" emin={self.emin}\"\n        if self.spacing is not None:\n            repr += f\" {self.spacing.upper()}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['surfbeat', 'SURFBEAT'] = Field(default='surfbeat', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.df","title":"df  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>df: Optional[float] = Field(default=None, description='The constant size of BIG frequency bin (in Hz) (SWAN default: 0.01)', ge=0.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.nmax","title":"nmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nmax: Optional[int] = Field(default=None, description='The maximum number of short-wave pairs for creating bichromatic wave groups (SWAN default: 50000)', ge=0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.emin","title":"emin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>emin: Optional[float] = Field(default=None, description='The energy threshold in fraction of energy spectrum peak. With this threshold one takes into account those short wave components to create bichromatic wave groups while their energy levels are larger than `emin x E_max` with `E_max` the peak of the spectrum (SWAN default: 0.05)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spacing: Optional[Literal['uniform', 'logarithmic']] = Field(default=None, description='Define if frequencies for reflected ig waves are uniformly or logarithmically distributed')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SURFBEAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SURFBEAT\"\n    if self.df is not None:\n        repr += f\" df={self.df}\"\n    if self.nmax is not None:\n        repr += f\" nmax={self.nmax}\"\n    if self.emin is not None:\n        repr += f\" emin={self.emin}\"\n    if self.spacing is not None:\n        repr += f\" {self.spacing.upper()}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#scattering","title":"Scattering","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT","title":"SCAT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Scattering.</p> <p>.. code-block:: text</p> <pre><code>SCAT [iqcm] (GRID [rfac]) (TRUNC [alpha] [qmax])\n</code></pre> <p>Using this optional command, the user activates a source term that allows for the generation and propagation of cross correlations between scattered waves due to variations in the bathymetry and mean currents. Such variations are rapid compared to the distancebetween the crossing waves (at the scale of 100-1000 m) and is particularly relevant for cases involving narrowband waves (swells) in coastal regions with shallow water and ambient currents. In turn, the immediate spatial effects of coherent scattering, interference, refraction and diffraction can cause large-scale changes in the wave parameters.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--references","title":"References","text":"<p>Smit, P.B. and Janssen, T.T., 2013. The evolution of inhomogeneous wave statistics through a variable medium. Journal of Physical Oceanography, 43(8), pp.1741-1758.</p> <p>Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of inhomogeneous ocean waves. Ocean Modelling, 96, pp.26-35.</p> <p>Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of coherent wave fields over variable depth. Journal of Physical Oceanography, 45(4), pp.1139-1154.</p> <p>Akrish, G., Smit, P., Zijlema, M. and Reniers, A., 2020. Modelling statistical wave interferences over shear currents. Journal of Fluid Mechanics, 891, p.A2.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--notes","title":"Notes","text":"<p>Implemented in SWAN 41.41.</p> <p>If both <code>alpha</code> and <code>qmax</code> options are provided to truncate the infinite convolution sum their mimimum is considered as the final limit on the sum.</p>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import SCAT\nscat = SCAT()\nprint(scat.render())\nscat = SCAT(iqcm=2, rfac=1.0, alpha=1.0)\nprint(scat.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class SCAT(BaseComponent):\n    \"\"\"Scattering.\n\n    .. code-block:: text\n\n        SCAT [iqcm] (GRID [rfac]) (TRUNC [alpha] [qmax])\n\n    Using this optional command, the user activates a source term that allows for the\n    generation and propagation of cross correlations between scattered waves due to\n    variations in the bathymetry and mean currents. Such variations are rapid compared\n    to the distancebetween the crossing waves (at the scale of 100-1000 m) and is\n    particularly relevant for cases involving narrowband waves (swells) in coastal\n    regions with shallow water and ambient currents. In turn, the immediate spatial\n    effects of coherent scattering, interference, refraction and diffraction can cause\n    large-scale changes in the wave parameters.\n\n    References\n    ----------\n    Smit, P.B. and Janssen, T.T., 2013. The evolution of inhomogeneous wave statistics\n    through a variable medium. Journal of Physical Oceanography, 43(8), pp.1741-1758.\n\n    Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of\n    inhomogeneous ocean waves. Ocean Modelling, 96, pp.26-35.\n\n    Smit, P.B., Janssen, T.T. and Herbers, T.H.C., 2015. Stochastic modeling of\n    coherent wave fields over variable depth. Journal of Physical Oceanography, 45(4),\n    pp.1139-1154.\n\n    Akrish, G., Smit, P., Zijlema, M. and Reniers, A., 2020. Modelling statistical wave\n    interferences over shear currents. Journal of Fluid Mechanics, 891, p.A2.\n\n    Notes\n    -----\n    Implemented in SWAN 41.41.\n\n    If both `alpha` and `qmax` options are provided to truncate the infinite\n    convolution sum their mimimum is considered as the final limit on the sum.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import SCAT\n        scat = SCAT()\n        print(scat.render())\n        scat = SCAT(iqcm=2, rfac=1.0, alpha=1.0)\n        print(scat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"scat\", \"SCAT\"] = Field(\n        default=\"scat\", description=\"Model type discriminator\"\n    )\n    iqcm: Optional[Literal[0, 1, 2]] = Field(\n        default=None,\n        description=(\n            \"Indicates the modelling and computation of QC scattering:\\n\\n* 0: no \"\n            \"scattering\\n* 1: scattering due to non-uniform bathymetry and currents \"\n            \"(the latter only if applicable; see command `INPGRID CURRENT`)\\n* 2: \"\n            \"wave-current interaction under the assumption of a slowly varying \"\n            \"bathymetry\\n\\n(SWAN default: 1)\"\n        ),\n    )\n    rfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The resolution factor through which the incident spectral width is\"\n            \"multiplied (SWAN default: 1.0)\"\n        ),\n        ge=1.0,\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The coefficient by which the mean wave number is multiplied to set the\"\n            \"limit on the convolution sum (SWAN default: 1.0)\"\n        ),\n    )\n    qmax: Optional[float] = Field(\n        default=None, description=\"The maximum scattering wave number (in 1/m)\"\n    )\n\n    @model_validator(mode=\"after\")\n    def warn_if_qmax_and_alpha(self) -&gt; \"SCAT\":\n        if self.qmax is not None and self.alpha is not None:\n            logger.warning(\n                \"Both `alpha` and `qmax` options are provided to truncate the \"\n                \"infinite convolution sum. Their mimimum is considered in SWAN as the \"\n                \"final limit on the sum\"\n            )\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SCAT\"\n        if self.iqcm is not None:\n            repr += f\" iqcm={self.iqcm}\"\n        if self.rfac is not None:\n            repr += f\" GRID rfac={self.rfac}\"\n        if self.alpha is not None or self.qmax is not None:\n            repr += \" TRUNC\"\n            if self.alpha is not None:\n                repr += f\" alpha={self.alpha}\"\n            if self.qmax is not None:\n                repr += f\" qmax={self.qmax}\"\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['scat', 'SCAT'] = Field(default='scat', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.iqcm","title":"iqcm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iqcm: Optional[Literal[0, 1, 2]] = Field(default=None, description='Indicates the modelling and computation of QC scattering:\\n\\n* 0: no scattering\\n* 1: scattering due to non-uniform bathymetry and currents (the latter only if applicable; see command `INPGRID CURRENT`)\\n* 2: wave-current interaction under the assumption of a slowly varying bathymetry\\n\\n(SWAN default: 1)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.rfac","title":"rfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rfac: Optional[float] = Field(default=None, description='The resolution factor through which the incident spectral width ismultiplied (SWAN default: 1.0)', ge=1.0)\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description='The coefficient by which the mean wave number is multiplied to set thelimit on the convolution sum (SWAN default: 1.0)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.qmax","title":"qmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qmax: Optional[float] = Field(default=None, description='The maximum scattering wave number (in 1/m)')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.SCAT.warn_if_qmax_and_alpha","title":"warn_if_qmax_and_alpha","text":"<pre><code>warn_if_qmax_and_alpha() -&gt; SCAT\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef warn_if_qmax_and_alpha(self) -&gt; \"SCAT\":\n    if self.qmax is not None and self.alpha is not None:\n        logger.warning(\n            \"Both `alpha` and `qmax` options are provided to truncate the \"\n            \"infinite convolution sum. Their mimimum is considered in SWAN as the \"\n            \"final limit on the sum\"\n        )\n    return self\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.SCAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SCAT\"\n    if self.iqcm is not None:\n        repr += f\" iqcm={self.iqcm}\"\n    if self.rfac is not None:\n        repr += f\" GRID rfac={self.rfac}\"\n    if self.alpha is not None or self.qmax is not None:\n        repr += \" TRUNC\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.qmax is not None:\n            repr += f\" qmax={self.qmax}\"\n    return repr\n</code></pre>"},{"location":"components/physics/#off","title":"Off","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF","title":"OFF","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Deactivate physics commands.</p> <p>.. code-block:: text</p> <pre><code>OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n</code></pre> <p>This command deactivates physics commands. The command can be used to switch off the computation of a certain physics component without having to remove the command from the input file. This is useful for testing purposes.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OFF--examples","title":"Examples:","text":"<p>.. ipython:: python</p> <pre><code>from rompy_swan.components.physics import OFF\noff = OFF(physics=\"windgrowth\")\nprint(off.render())\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class OFF(BaseComponent):\n    \"\"\"Deactivate physics commands.\n\n    .. code-block:: text\n\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n\n    This command deactivates physics commands. The command can be used to switch off\n    the computation of a certain physics component without having to remove the command\n    from the input file. This is useful for testing purposes.\n\n    Examples:\n    ---------\n\n    .. ipython:: python\n\n        from rompy_swan.components.physics import OFF\n        off = OFF(physics=\"windgrowth\")\n        print(off.render())\n\n    \"\"\"\n\n    model_type: Literal[\"off\", \"OFF\"] = Field(\n        default=\"off\", description=\"Model type discriminator\"\n    )\n    physics: PhysicsOff = Field(description=\"Physics command to be switched off\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return f\"OFF {self.physics.value.upper()}\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['off', 'OFF'] = Field(default='off', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF.physics","title":"physics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>physics: PhysicsOff = Field(description='Physics command to be switched off')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFF-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFF.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return f\"OFF {self.physics.value.upper()}\"\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS","title":"OFFS","text":"<p>               Bases: <code>BaseComponent</code></p> <p>Deactivate multiple physics commands.</p> <p>.. code-block:: text</p> <pre><code>OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\nOFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n.\n</code></pre> <p>This group component is a convenience to allow defining and rendering a list of <code>OFF</code> components.</p>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.physics import OFFS\noff1 = dict(physics=\"windgrowth\")\noff2 = dict(physics=\"wcapping\")\noffs = OFFS(offs=[off1, off2])\nfor off in offs.render():\n    print(off)\n</code></pre> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>class OFFS(BaseComponent):\n    \"\"\"Deactivate multiple physics commands.\n\n    .. code-block:: text\n\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n        OFF WINDGROWTH|QUADRUPL|WCAPPING|BREAKING|REFRAC|FSHIFT|BNDCHK\n        .\n\n    This group component is a convenience to allow defining and rendering\n    a list of `OFF` components.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.physics import OFFS\n        off1 = dict(physics=\"windgrowth\")\n        off2 = dict(physics=\"wcapping\")\n        offs = OFFS(offs=[off1, off2])\n        for off in offs.render():\n            print(off)\n\n    \"\"\"\n\n    model_type: Literal[\"offs\", \"OFFS\"] = Field(\n        default=\"offs\", description=\"Model type discriminator\"\n    )\n    offs: list[OFF] = Field(description=\"Physics commands to deactivate\")\n\n    def cmd(self) -&gt; list:\n        \"\"\"Command file strings for this component.\"\"\"\n        repr = []\n        for off in self.offs:\n            repr += [off.cmd()]\n        return repr\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS-attributes","title":"Attributes","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFFS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['offs', 'OFFS'] = Field(default='offs', description='Model type discriminator')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS.offs","title":"offs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offs: list[OFF] = Field(description='Physics commands to deactivate')\n</code></pre>"},{"location":"components/physics/#rompy_swan.components.physics.OFFS-functions","title":"Functions","text":""},{"location":"components/physics/#rompy_swan.components.physics.OFFS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; list\n</code></pre> <p>Command file strings for this component.</p> Source code in <code>rompy_swan/components/physics.py</code> <pre><code>def cmd(self) -&gt; list:\n    \"\"\"Command file strings for this component.\"\"\"\n    repr = []\n    for off in self.offs:\n        repr += [off.cmd()]\n    return repr\n</code></pre>"},{"location":"components/startup/","title":"Startup","text":"<p>SWAN startup commands</p>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT","title":"PROJECT","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Project.</p> <p>.. code-block:: text</p> <pre><code>PROJECT 'name' 'nr' 'title' 'title2 'title3'\n</code></pre> <p>With this required command the user defines a number of strings to identify the SWAN run (project name e.g., an engineering project) in the print and plot file.</p>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import PROJECT\nproj = PROJECT(nr=\"01\")\nprint(proj.render())\nproj = PROJECT(\n    name=\"waus\",\n    nr=\"001\",\n    title1=\"Western Australia\",\n    title2=\"Perth Nest\"\n)\nprint(proj.render())\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>class PROJECT(BaseComponent):\n    \"\"\"SWAN Project.\n\n    .. code-block:: text\n\n        PROJECT 'name' 'nr' 'title' 'title2 'title3'\n\n    With this required command the user defines a number of strings to identify the\n    SWAN run (project name e.g., an engineering project) in the print and plot file.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import PROJECT\n        proj = PROJECT(nr=\"01\")\n        print(proj.render())\n        proj = PROJECT(\n            name=\"waus\",\n            nr=\"001\",\n            title1=\"Western Australia\",\n            title2=\"Perth Nest\"\n        )\n        print(proj.render())\n\n    \"\"\"\n\n    model_type: Literal[\"project\", \"PROJECT\"] = Field(\n        default=\"project\",\n        description=\"Model type discriminator\",\n    )\n    name: Optional[str] = Field(\n        default=None,\n        description=\"Is the name of the project, at most 16 characters long\",\n        max_length=16,\n    )\n    nr: str = Field(\n        description=(\n            \"Is the run identification (to be provided as a character string; e.g. \"\n            \"the run number) to distinguish this run among other runs for the same \"\n            \"project; it is at most 4 characters long. It is the only required \"\n            \"information in this command.\"\n        ),\n        max_length=4,\n    )\n    title1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A string of at most 72 characters provided by the user to appear in the \"\n            \"output of the program for the user's convenience (SWAN default: blanks)\"\n        ),\n        max_length=72,\n    )\n    title2: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n    title3: Optional[str] = Field(\n        default=None, description=\"Same as 'title1'\", max_length=72\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"PROJECT\"\n        if self.name is not None:\n            repr += f\" name='{self.name}'\"\n        repr += f\" nr='{self.nr}'\"\n        if self.title1 is not None:\n            repr += f\" title1='{self.title1}'\"\n        if self.title2 is not None:\n            repr += f\" title2='{self.title2}'\"\n        if self.title3 is not None:\n            repr += f\" title3='{self.title3}'\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['project', 'PROJECT'] = Field(default='project', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Is the name of the project, at most 16 characters long', max_length=16)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.nr","title":"nr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nr: str = Field(description='Is the run identification (to be provided as a character string; e.g. the run number) to distinguish this run among other runs for the same project; it is at most 4 characters long. It is the only required information in this command.', max_length=4)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title1","title":"title1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title1: Optional[str] = Field(default=None, description=\"A string of at most 72 characters provided by the user to appear in the output of the program for the user's convenience (SWAN default: blanks)\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title2","title":"title2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title2: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.title3","title":"title3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title3: Optional[str] = Field(default=None, description=\"Same as 'title1'\", max_length=72)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.PROJECT-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.PROJECT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"PROJECT\"\n    if self.name is not None:\n        repr += f\" name='{self.name}'\"\n    repr += f\" nr='{self.nr}'\"\n    if self.title1 is not None:\n        repr += f\" title1='{self.title1}'\"\n    if self.title2 is not None:\n        repr += f\" title2='{self.title2}'\"\n    if self.title3 is not None:\n        repr += f\" title3='{self.title3}'\"\n    return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET","title":"SET","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN setting commands.</p> <p>.. code-block:: text</p> <pre><code>SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n    [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n</code></pre> <p>With this optional command the user assigns values to various general parameters.</p>"},{"location":"components/startup/#rompy_swan.components.startup.SET--notes","title":"Notes","text":"<p>The error level <code>maxerr</code> is coded as follows:</p> <ul> <li>1: warnings</li> <li>2: errors (possibly automatically repaired or repairable by SWAN)</li> <li>3: severe errors</li> </ul> <p>Default values for <code>pwtail</code> depend on formulations of physics:</p> <ul> <li>command GEN1: <code>pwtail = 5</code></li> <li>command GEN2: <code>pwtail = 5</code></li> <li>command GEN3 KOMEN: <code>pwtail = 4</code></li> <li>command GEN3 WESTH: <code>pwtail = 4</code></li> <li>command GEN3 JANSSEN: <code>pwtail = 5</code></li> </ul>"},{"location":"components/startup/#rompy_swan.components.startup.SET--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SET\nset = SET(level=0.5, direction_convention=\"nautical\")\nprint(set.render())\nset = SET(\n    level=-1.0,\n    nor=90,\n    depmin=0.01,\n    maxerr=3,\n    grav=9.81,\n    rho=1025,\n    cdcap=2.5e-3,\n    inrhog=0,\n    hsrerr=0.1,\n    direction_convention=\"nautical\",\n)\nprint(set.render())\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>class SET(BaseComponent):\n    \"\"\"SWAN setting commands.\n\n    .. code-block:: text\n\n        SET [level] [nor] [depmin] [maxmes] [maxerr] [grav] [rho] [cdcap] &amp;\n            [inrhog] [hsrerr] NAUTICAL|-&gt;CARTESIAN [pwtail] [froudmax] [icewind]\n\n    With this optional command the user assigns values to various general parameters.\n\n    Notes\n    -----\n    The error level `maxerr` is coded as follows:\n\n    * 1: warnings\n    * 2: errors (possibly automatically repaired or repairable by SWAN)\n    * 3: severe errors\n\n    Default values for `pwtail` depend on formulations of physics:\n\n    * command GEN1: `pwtail = 5`\n    * command GEN2: `pwtail = 5`\n    * command GEN3 KOMEN: `pwtail = 4`\n    * command GEN3 WESTH: `pwtail = 4`\n    * command GEN3 JANSSEN: `pwtail = 5`\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SET\n        set = SET(level=0.5, direction_convention=\"nautical\")\n        print(set.render())\n        set = SET(\n            level=-1.0,\n            nor=90,\n            depmin=0.01,\n            maxerr=3,\n            grav=9.81,\n            rho=1025,\n            cdcap=2.5e-3,\n            inrhog=0,\n            hsrerr=0.1,\n            direction_convention=\"nautical\",\n        )\n        print(set.render())\n\n    \"\"\"\n\n    model_type: Literal[\"set\", \"SET\"] = Field(\n        default=\"set\", description=\"Model type discriminator\"\n    )\n    level: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Increase in water level that is constant in space and time can be given \"\n            \"with this option, `level` is the value of this increase (in m). For a \"\n            \"variable water level reference is made to the commands \"\n            \"INPGRID and READINP (SWAN default: 0)\"\n        ),\n        examples=[0],\n    )\n    nor: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Direction of North with respect to the x-axis (measured \"\n            \"counterclockwise); default `nor = 90`, i.e. x-axis of the problem \"\n            \"coordinate system points East. When spherical coordinates are used \"\n            \"(see command COORD) the value of `nor` may not be modified\"\n        ),\n        ge=-360.0,\n        le=360.0,\n    )\n    depmin: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Threshold depth (in m). In the computation any positive depth smaller \"\n            \"than `depmin` is made equal to `depmin` (SWAN default: 0.05)\"\n        ),\n        ge=0.0,\n    )\n    maxmes: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of error messages during the computation at which the \"\n            \"computation is terminated. During the computational process messages are \"\n            \"written to the print file (SWAN default: 200)\"\n        ),\n        ge=0,\n    )\n    maxerr: Optional[Literal[1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"During pre-processing SWAN checks input data. Depending on the severity \"\n            \"of the errors encountered during this pre-processing, SWAN does not \"\n            \"start computations. The user can influence the error level above which \"\n            \"SWAN will  not start computations (at the level indicated the \"\n            \"computations will continue) (SWAN default: 1)\"\n        ),\n    )\n    grav: Optional[float] = Field(\n        default=None,\n        description=\"The gravitational acceleration (in m/s2) (SWAN default: 9.81)\",\n        ge=0.0,\n    )\n    rho: Optional[float] = Field(\n        default=None,\n        description=\"The water density (in kg/m3) (SWAN default: 1025)\",\n        ge=0.0,\n    )\n    cdcap: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The maximum value for the wind drag coefficient. A value of 99999 means\"\n            \"no cutting off the drag coefficient. A suggestion for this parameter is \"\n            \"`cdcap = 2.5x 10-3` (SWAN default: 99999) \"\n        ),\n        ge=0.0,\n    )\n    inrhog: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"To indicate whether the user requires output based on variance or based \"\n            \"on true energy (see Section 2.5). `inrhog` = 0: output based on variance, \"\n            \"`inrhog` = 1: output based on true energy (SWAN default: 0)\"\n        ),\n    )\n    hsrerr: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The relative difference between the user imposed significant wave height \"\n            \"and the significant wave height computed by SWAN (anywhere along the \"\n            \"computational grid boundary) above which a warning will be given. This \"\n            \"relative difference is the difference normalized with the user provided \"\n            \"significant wave height. This warning will be given for each boundary \"\n            \"grid point where the problem occurs (with its x- and y-index number of \"\n            \"the computational grid). The cause of the difference is explained in \"\n            \"Section 2.6.3. To suppress these warnings (in particular for \"\n            \"nonstationary computations), set `hsrerr` at a very high value or use \"\n            \"command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)\"\n        ),\n        ge=0.0,\n    )\n    direction_convention: Literal[\"nautical\", \"cartesian\"] = Field(\n        description=(\n            \"Direction convention: `nautical` indicates that the Nautical convention \"\n            \"for wind and wave direction (SWAN input and output) will be used, \"\n            \"`cartesian` indicates that the Cartesian convention for wind and wave \"\n            \"direction will be used. For definition, see Section 2.5 or Appendix A \"\n            \"(SWAN default: `cartesian`)\"\n        ),\n    )\n    pwtail: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Power of high frequency tail; defines the shape of the spectral tail \"\n            \"above the highest prognostic frequency `fhigh` (see command CGRID). \"\n            \"The energy density is assumed to be proportional to frequency to the \"\n            \"power `pwtail`. If the user wishes to use another value, then this SET \"\n            \"command should be located in the command file after GEN1, GEN2 or GEN3 \"\n            \"command (these will override the SET command with respect to `pwtail`)\"\n        ),\n        ge=0,\n    )\n    froudmax: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the \"\n            \"water depth). The currents taken from a circulation model may mismatch \"\n            \"with given water depth `d` in the sense that the Froude number becomes \"\n            \"larger than 1. For this, the current velocities will be maximized by \"\n            \"Froude number times `sqrt(gh)` (SWAN default: 0.8)\"\n        ),\n        ge=0.0,\n    )\n    icewind: Optional[Literal[0, 1]] = Field(\n        default=None,\n        description=(\n            \"Controls the scaling of wind input by open water fraction. Default value \"\n            \"of zero corresponds to the case where wind input is scaled by the open \"\n            \"water fraction. If `icewind = 1` then sea ice does not affect wind input \"\n            \"directly. (Though there is still indirect effect via the sea ice sink \"\n            \"term; see command SICE) (SWAN default: 0)\"\n        ),\n    )\n\n    @field_validator(\"pwtail\")\n    @classmethod\n    def pwtail_after_gen(cls, v):\n        if v is not None:\n            logger.warning(\"pwtail only has effect if set after GEN command\")\n        return v\n\n    def cmd(self) -&gt; str:\n        repr = \"SET\"\n        if self.level is not None:\n            repr += f\" level={self.level}\"\n        if self.nor is not None:\n            repr += f\" nor={self.nor}\"\n        if self.depmin is not None:\n            repr += f\" depmin={self.depmin}\"\n        if self.maxmes is not None:\n            repr += f\" maxmes={self.maxmes}\"\n        if self.maxerr is not None:\n            repr += f\" maxerr={self.maxerr}\"\n        if self.grav is not None:\n            repr += f\" grav={self.grav}\"\n        if self.rho is not None:\n            repr += f\" rho={self.rho}\"\n        if self.cdcap is not None:\n            repr += f\" cdcap={self.cdcap}\"\n        if self.inrhog is not None:\n            repr += f\" inrhog={self.inrhog}\"\n        if self.hsrerr is not None:\n            repr += f\" hsrerr={self.hsrerr}\"\n        if self.direction_convention is not None:\n            repr += f\" {self.direction_convention.upper()}\"\n        if self.pwtail is not None:\n            repr += f\" pwtail={self.pwtail}\"\n        if self.froudmax is not None:\n            repr += f\" froudmax={self.froudmax}\"\n        if self.icewind is not None:\n            repr += f\" icewind={self.icewind}\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.SET.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['set', 'SET'] = Field(default='set', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: Optional[float] = Field(default=None, description='Increase in water level that is constant in space and time can be given with this option, `level` is the value of this increase (in m). For a variable water level reference is made to the commands INPGRID and READINP (SWAN default: 0)', examples=[0])\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.nor","title":"nor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nor: Optional[float] = Field(default=None, description='Direction of North with respect to the x-axis (measured counterclockwise); default `nor = 90`, i.e. x-axis of the problem coordinate system points East. When spherical coordinates are used (see command COORD) the value of `nor` may not be modified', ge=-360.0, le=360.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.depmin","title":"depmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depmin: Optional[float] = Field(default=None, description='Threshold depth (in m). In the computation any positive depth smaller than `depmin` is made equal to `depmin` (SWAN default: 0.05)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.maxmes","title":"maxmes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxmes: Optional[int] = Field(default=None, description='Maximum number of error messages during the computation at which the computation is terminated. During the computational process messages are written to the print file (SWAN default: 200)', ge=0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.maxerr","title":"maxerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxerr: Optional[Literal[1, 2, 3]] = Field(default=None, description='During pre-processing SWAN checks input data. Depending on the severity of the errors encountered during this pre-processing, SWAN does not start computations. The user can influence the error level above which SWAN will  not start computations (at the level indicated the computations will continue) (SWAN default: 1)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.grav","title":"grav  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grav: Optional[float] = Field(default=None, description='The gravitational acceleration (in m/s2) (SWAN default: 9.81)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.rho","title":"rho  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rho: Optional[float] = Field(default=None, description='The water density (in kg/m3) (SWAN default: 1025)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.cdcap","title":"cdcap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdcap: Optional[float] = Field(default=None, description='The maximum value for the wind drag coefficient. A value of 99999 meansno cutting off the drag coefficient. A suggestion for this parameter is `cdcap = 2.5x 10-3` (SWAN default: 99999) ', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.inrhog","title":"inrhog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inrhog: Optional[Literal[0, 1]] = Field(default=None, description='To indicate whether the user requires output based on variance or based on true energy (see Section 2.5). `inrhog` = 0: output based on variance, `inrhog` = 1: output based on true energy (SWAN default: 0)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.hsrerr","title":"hsrerr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hsrerr: Optional[float] = Field(default=None, description='The relative difference between the user imposed significant wave height and the significant wave height computed by SWAN (anywhere along the computational grid boundary) above which a warning will be given. This relative difference is the difference normalized with the user provided significant wave height. This warning will be given for each boundary grid point where the problem occurs (with its x- and y-index number of the computational grid). The cause of the difference is explained in Section 2.6.3. To suppress these warnings (in particular for nonstationary computations), set `hsrerr` at a very high value or use command OFF BNDCHK (SWAN default: 0.10) (ONLY MEANT FOR STRUCTURED GRIDS)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.direction_convention","title":"direction_convention  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction_convention: Literal['nautical', 'cartesian'] = Field(description='Direction convention: `nautical` indicates that the Nautical convention for wind and wave direction (SWAN input and output) will be used, `cartesian` indicates that the Cartesian convention for wind and wave direction will be used. For definition, see Section 2.5 or Appendix A (SWAN default: `cartesian`)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.pwtail","title":"pwtail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pwtail: Optional[int] = Field(default=None, description='Power of high frequency tail; defines the shape of the spectral tail above the highest prognostic frequency `fhigh` (see command CGRID). The energy density is assumed to be proportional to frequency to the power `pwtail`. If the user wishes to use another value, then this SET command should be located in the command file after GEN1, GEN2 or GEN3 command (these will override the SET command with respect to `pwtail`)', ge=0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.froudmax","title":"froudmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>froudmax: Optional[float] = Field(default=None, description='Is the maximum Froude number (`U/\u221agd` with `U` the current and `d` the water depth). The currents taken from a circulation model may mismatch with given water depth `d` in the sense that the Froude number becomes larger than 1. For this, the current velocities will be maximized by Froude number times `sqrt(gh)` (SWAN default: 0.8)', ge=0.0)\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.icewind","title":"icewind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icewind: Optional[Literal[0, 1]] = Field(default=None, description='Controls the scaling of wind input by open water fraction. Default value of zero corresponds to the case where wind input is scaled by the open water fraction. If `icewind = 1` then sea ice does not affect wind input directly. (Though there is still indirect effect via the sea ice sink term; see command SICE) (SWAN default: 0)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.SET.pwtail_after_gen","title":"pwtail_after_gen  <code>classmethod</code>","text":"<pre><code>pwtail_after_gen(v)\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>@field_validator(\"pwtail\")\n@classmethod\ndef pwtail_after_gen(cls, v):\n    if v is not None:\n        logger.warning(\"pwtail only has effect if set after GEN command\")\n    return v\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.SET.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"SET\"\n    if self.level is not None:\n        repr += f\" level={self.level}\"\n    if self.nor is not None:\n        repr += f\" nor={self.nor}\"\n    if self.depmin is not None:\n        repr += f\" depmin={self.depmin}\"\n    if self.maxmes is not None:\n        repr += f\" maxmes={self.maxmes}\"\n    if self.maxerr is not None:\n        repr += f\" maxerr={self.maxerr}\"\n    if self.grav is not None:\n        repr += f\" grav={self.grav}\"\n    if self.rho is not None:\n        repr += f\" rho={self.rho}\"\n    if self.cdcap is not None:\n        repr += f\" cdcap={self.cdcap}\"\n    if self.inrhog is not None:\n        repr += f\" inrhog={self.inrhog}\"\n    if self.hsrerr is not None:\n        repr += f\" hsrerr={self.hsrerr}\"\n    if self.direction_convention is not None:\n        repr += f\" {self.direction_convention.upper()}\"\n    if self.pwtail is not None:\n        repr += f\" pwtail={self.pwtail}\"\n    if self.froudmax is not None:\n        repr += f\" froudmax={self.froudmax}\"\n    if self.icewind is not None:\n        repr += f\" icewind={self.icewind}\"\n    return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE","title":"MODE","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Mode.</p> <p>.. code-block:: text</p> <pre><code>MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n</code></pre> <p>With this optional command the user indicates that the run will be either stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional (2D-mode). Nonstationary means either (see command COMPUTE):</p> <ul> <li>(a) one nonstationary computations or</li> <li>(b) a sequence of stationary computations or</li> <li>(c) a mix of (a) and (b)</li> </ul>"},{"location":"components/startup/#rompy_swan.components.startup.MODE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import MODE\nmode = MODE()\nprint(mode.render())\nmode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\nprint(mode.render())\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>class MODE(BaseComponent):\n    \"\"\"SWAN Mode.\n\n    .. code-block:: text\n\n        MODE -&gt;STATIONARY|NONSTATIONARY -&gt;TWODIMENSIONAL|ONEDIMENSIONAL\n\n    With this optional command the user indicates that the run will be either\n    stationary or nonstationary and one-dimensional (1D-mode) or two-dimensional\n    (2D-mode). Nonstationary means either (see command COMPUTE):\n\n    * (a) one nonstationary computations or\n    * (b) a sequence of stationary computations or\n    * (c) a mix of (a) and (b)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import MODE\n        mode = MODE()\n        print(mode.render())\n        mode = MODE(kind=\"nonstationary\", dim=\"twodimensional\")\n        print(mode.render())\n\n    \"\"\"\n\n    model_type: Literal[\"mode\", \"MODE\"] = Field(\n        default=\"mode\", description=\"Model type discriminator.\"\n    )\n    kind: Literal[\"stationary\", \"nonstationary\"] = Field(\n        default=\"stationary\",\n        description=\"Indicates if run will be stationary or nonstationary\",\n    )\n    dim: Literal[\"onedimensional\", \"twodimensional\"] = Field(\n        default=\"twodimensional\",\n        description=(\n            \"Indicates that the run will be either one-dimensional (1D-mode) or \"\n            \"two-dimensional (2D-mode)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.MODE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['mode', 'MODE'] = Field(default='mode', description='Model type discriminator.')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Literal['stationary', 'nonstationary'] = Field(default='stationary', description='Indicates if run will be stationary or nonstationary')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: Literal['onedimensional', 'twodimensional'] = Field(default='twodimensional', description='Indicates that the run will be either one-dimensional (1D-mode) or two-dimensional (2D-mode)')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.MODE-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.MODE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"MODE {self.kind.upper()} {self.dim.upper()}\"\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES","title":"COORDINATES","text":"<p>               Bases: <code>BaseComponent</code></p> <p>SWAN Coordinates.</p> <p>.. code-block:: text</p> <pre><code>COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n</code></pre> <p>Command to choose between Cartesian and spherical coordinates (see Section 2.5). A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.</p>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import COORDINATES\ncoords = COORDINATES()\nprint(coords.render())\ncoords = COORDINATES(\n    kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n    reapeating=True,\n)\nprint(coords.render())\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>class COORDINATES(BaseComponent):\n    \"\"\"SWAN Coordinates.\n\n    .. code-block:: text\n\n        COORDINATES -&gt;CARTESIAN|SPHERICAL REPEATING\n\n    Command to choose between Cartesian and spherical coordinates (see Section 2.5).\n    A nested SWAN run must use the same coordinate system as the coarse grid SWAN run.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import COORDINATES\n        coords = COORDINATES()\n        print(coords.render())\n        coords = COORDINATES(\n            kind=dict(model_type=\"spherical\", projection=\"ccm\"),\n            reapeating=True,\n        )\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"coordinates\", \"COORDINATES\"] = Field(\n        default=\"coordinates\",\n        description=\"Model type discriminator\",\n    )\n    kind: CARTESIAN | SPHERICAL = Field(\n        default_factory=CARTESIAN,\n        description=\"Coordinates kind\",\n    )\n    reapeating: bool = Field(\n        default=False,\n        description=(\n            \"This option is only for academic cases. It means that wave energy \"\n            \"leaving at one end of the domain (in computational x-direction) enter at \"\n            \"the other side; it is as if the wave field repeats itself in x-direction \"\n            \"with the length of the domain in x-direction. This option cannot be used \"\n            \"in combination with computation of set-up (see command SETUP). This \"\n            \"option is available only with regular grids\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"COORDINATES {self.kind.render()}\"\n        if self.reapeating:\n            repr += \" REPEATING\"\n        return repr\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES-attributes","title":"Attributes","text":""},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['coordinates', 'COORDINATES'] = Field(default='coordinates', description='Model type discriminator')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: CARTESIAN | SPHERICAL = Field(default_factory=CARTESIAN, description='Coordinates kind')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.reapeating","title":"reapeating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reapeating: bool = Field(default=False, description='This option is only for academic cases. It means that wave energy leaving at one end of the domain (in computational x-direction) enter at the other side; it is as if the wave field repeats itself in x-direction with the length of the domain in x-direction. This option cannot be used in combination with computation of set-up (see command SETUP). This option is available only with regular grids')\n</code></pre>"},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES-functions","title":"Functions","text":""},{"location":"components/startup/#rompy_swan.components.startup.COORDINATES.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/components/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"COORDINATES {self.kind.render()}\"\n    if self.reapeating:\n        repr += \" REPEATING\"\n    return repr\n</code></pre>"},{"location":"reference/config/","title":"Config","text":""},{"location":"reference/config/#rompy_swan.config","title":"config","text":"<p>SWAN Configuration Module</p> <p>This module provides configuration classes for the SWAN model within the ROMPY framework.</p>"},{"location":"reference/config/#rompy_swan.config-attributes","title":"Attributes","text":""},{"location":"reference/config/#rompy_swan.config.HERE","title":"HERE  <code>module-attribute</code>","text":"<pre><code>HERE = parent\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.DEFAULT_TEMPLATE","title":"DEFAULT_TEMPLATE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_TEMPLATE = str(parent / 'templates' / 'swan')\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.STARTUP_TYPE","title":"STARTUP_TYPE  <code>module-attribute</code>","text":"<pre><code>STARTUP_TYPE = Annotated[STARTUP, Field(description='Startup components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.INITIAL_TYPE","title":"INITIAL_TYPE  <code>module-attribute</code>","text":"<pre><code>INITIAL_TYPE = Annotated[INITIAL, Field(description='Initial component')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.PHYSICS_TYPE","title":"PHYSICS_TYPE  <code>module-attribute</code>","text":"<pre><code>PHYSICS_TYPE = Annotated[PHYSICS, Field(description='Physics components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.PROP_TYPE","title":"PROP_TYPE  <code>module-attribute</code>","text":"<pre><code>PROP_TYPE = Annotated[PROP, Field(description='Propagation components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.NUMERIC_TYPE","title":"NUMERIC_TYPE  <code>module-attribute</code>","text":"<pre><code>NUMERIC_TYPE = Annotated[NUMERIC, Field(description='Numerics components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.OUTPUT_TYPE","title":"OUTPUT_TYPE  <code>module-attribute</code>","text":"<pre><code>OUTPUT_TYPE = Annotated[OUTPUT, Field(description='Output components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.LOCKUP_TYPE","title":"LOCKUP_TYPE  <code>module-attribute</code>","text":"<pre><code>LOCKUP_TYPE = Annotated[LOCKUP, Field(description='Output components')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.CGRID_TYPES","title":"CGRID_TYPES  <code>module-attribute</code>","text":"<pre><code>CGRID_TYPES = Annotated[Union[REGULAR, CURVILINEAR, UNSTRUCTURED], Field(description='Cgrid component', discriminator='model_type')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.INPGRID_TYPES","title":"INPGRID_TYPES  <code>module-attribute</code>","text":"<pre><code>INPGRID_TYPES = Annotated[Union[INPGRIDS, DataInterface], Field(description='Input grid components', discriminator='model_type')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.BOUNDARY_TYPES","title":"BOUNDARY_TYPES  <code>module-attribute</code>","text":"<pre><code>BOUNDARY_TYPES = Annotated[Union[BOUNDSPEC, BOUNDNEST1, BOUNDNEST2, BOUNDNEST3, BoundaryInterface], Field(description='Boundary component', discriminator='model_type')]\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config-classes","title":"Classes","text":""},{"location":"reference/config/#rompy_swan.config.SwanConfig","title":"SwanConfig","text":"<p>               Bases: <code>BaseConfig</code></p> <p>SWAN config class.</p> <p>TODO: Combine boundary and inpgrid into a single input type.</p>"},{"location":"reference/config/#rompy_swan.config.SwanConfig--note","title":"Note","text":"<p>The <code>cgrid</code> is the only required field since it is used to define the swan grid object which is passed to other components.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>class SwanConfig(BaseConfig):\n    \"\"\"SWAN config class.\n\n    TODO: Combine boundary and inpgrid into a single input type.\n\n    Note\n    ----\n    The `cgrid` is the only required field since it is used to define the swan grid\n    object which is passed to other components.\n\n    \"\"\"\n\n    model_type: Literal[\"swan\", \"SWAN\"] = Field(\n        default=\"swan\",\n        description=\"Model type discriminator\",\n    )\n    template: str = Field(\n        default=DEFAULT_TEMPLATE,\n        description=\"The template for SWAN.\",\n    )\n    cgrid: CGRID_TYPES\n    startup: Optional[STARTUP_TYPE] = Field(default=None)\n    inpgrid: Optional[INPGRID_TYPES] = Field(default=None)\n    boundary: Optional[BOUNDARY_TYPES] = Field(default=None)\n    initial: Optional[INITIAL_TYPE] = Field(default=None)\n    physics: Optional[PHYSICS_TYPE] = Field(default=None)\n    prop: Optional[PROP_TYPE] = Field(default=None)\n    numeric: Optional[NUMERIC_TYPE] = Field(default=None)\n    output: Optional[OUTPUT_TYPE] = Field(default=None)\n    lockup: Optional[LOCKUP_TYPE] = Field(default=None)\n\n    @model_validator(mode=\"after\")\n    def no_nor_if_spherical(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure SET nor is not prescribed when using spherical coordinates.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def no_repeating_if_setup(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure COORD repeating not set when using set-up.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def alp_is_zero_if_spherical(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure alp is zero when using spherical coordinates.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def cgrid_contain_inpgrids(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure all inpgrids are inside the cgrid area.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def layer_defined_if_no_mud_inpgrid(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure layer is set in MUD command if not defined with INPGRID MUD.\"\"\"\n        return self\n\n    model_validator(mode=\"after\")\n\n    def transm_msc_mdc(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure the number of transmission coefficients match msc and mdc.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def locations_2d(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure Location components not used in 1D mode.\"\"\"\n        # FRAME, GROUP, RAY, ISOLINE and NGRID not in 1D\n        # BLOCK and NESTOUT not in 1D\n        # GROUP not in unstructured\n        return self\n\n    @model_validator(mode=\"after\")\n    def group_within_cgrid(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure group indices are contained in computational grid.\"\"\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def not_curvilinear_if_ray(self) -&gt; \"SwanConfig\":\n        \"\"\"Ensure bottom and water level grids are not curvilinear for RAY.\"\"\"\n        return self\n\n    @property\n    def grid(self):\n        \"\"\"Define a SwanGrid from the cgrid field.\"\"\"\n        return SwanGrid.from_component(self.cgrid.grid)\n\n    def _format_value(self, obj):\n        \"\"\"Custom formatter for SwanConfig values.\n\n        This method provides special formatting for specific types used in\n        SwanConfig such as grid, boundary, and output components.\n\n        Args:\n            obj: The object to format\n\n        Returns:\n            A formatted string or None to use default formatting\n        \"\"\"\n        # Import specific types if needed\n        from rompy.logging import LoggingConfig\n        from rompy_swan.grid import SwanGrid\n\n        # Get ASCII mode setting from LoggingConfig\n        logging_config = LoggingConfig()\n        USE_ASCII_ONLY = logging_config.use_ascii\n\n        # Format SwanConfig (self-formatting)\n        if isinstance(obj, SwanConfig):\n            header, footer, bullet = get_formatted_header_footer(\n                title=\"SWAN COMPONENTS CONFIGURATION\", use_ascii=USE_ASCII_ONLY\n            )\n\n            lines = [header]\n\n            # Add computational grid info if available\n            if hasattr(obj, \"cgrid\") and obj.cgrid:\n                grid_name = type(obj.cgrid).__name__\n                lines.append(f\"  {bullet} Computational Grid: {grid_name}\")\n                # Try to add grid details\n                if hasattr(obj.cgrid, \"grid\"):\n                    grid = obj.cgrid.grid\n                    if hasattr(grid, \"mx\") and hasattr(grid, \"my\"):\n                        lines.append(f\"      Resolution: {grid.mx}x{grid.my} cells\")\n                    if hasattr(grid, \"xp\") and hasattr(grid, \"yp\"):\n                        lines.append(f\"      Origin: ({grid.xp}, {grid.yp})\")\n                    if hasattr(grid, \"alp\"):\n                        lines.append(f\"      Rotation: {grid.alp}\u00b0\")\n                    if hasattr(grid, \"xlen\") and hasattr(grid, \"ylen\"):\n                        lines.append(f\"      Size: {grid.xlen}x{grid.ylen}\")\n\n            # List all non-None components\n            components = {\n                \"Startup\": obj.startup,\n                \"Input Grid\": obj.inpgrid,\n                \"Boundary\": obj.boundary,\n                \"Initial\": obj.initial,\n                \"Physics\": obj.physics,\n                \"Propagation\": obj.prop,\n                \"Numerics\": obj.numeric,\n                \"Output\": obj.output,\n                \"Lock-up\": obj.lockup,\n            }\n\n            for name, component in components.items():\n                if component is not None:\n                    if name == \"Input Grid\" and isinstance(component, list):\n                        lines.append(f\"  {bullet} {name}: {len(component)} grid(s)\")\n                        for i, ingrid in enumerate(component):\n                            lines.append(f\"      Grid {i+1}: {type(ingrid).__name__}\")\n                            # Try to add more details for each input grid\n                            var_name = getattr(ingrid, \"var\", \"unknown\")\n                            lines.append(f\"          Variable: {var_name}\")\n                    else:\n                        lines.append(f\"  {bullet} {name}: {type(component).__name__}\")\n                        # Add details for physics if available\n                        if name == \"Physics\" and hasattr(component, \"gen\"):\n                            gen_type = type(component.gen).__name__\n                            lines.append(f\"      Generation: {gen_type}\")\n                            if hasattr(component, \"breaking\"):\n                                break_type = type(component.breaking).__name__\n                                lines.append(f\"      Breaking: {break_type}\")\n                            if hasattr(component, \"friction\"):\n                                fric_type = type(component.friction).__name__\n                                lines.append(f\"      Friction: {fric_type}\")\n                        # Add details for output if available\n                        if name == \"Output\" and hasattr(component, \"quantity\"):\n                            if hasattr(component.quantity, \"quantities\"):\n                                qtys = component.quantity.quantities\n                                qty_count = len(qtys) if isinstance(qtys, list) else 1\n                                lines.append(\n                                    f\"      Quantities: {qty_count} output group(s)\"\n                                )\n                            if hasattr(component, \"block\"):\n                                lines.append(\"      Block output: Yes\")\n                            if hasattr(component, \"specout\"):\n                                lines.append(\"      Spectral output: Yes\")\n\n            # Add template info if available\n            if hasattr(obj, \"template\"):\n                template_path = obj.template\n                if len(template_path) &gt; 50:  # Truncate long paths\n                    template_path = \"...\" + template_path[-47:]\n                lines.append(f\"\\n  {bullet} Template: {template_path}\")\n\n            lines.append(footer)\n            return \"\\n\".join(lines)\n\n        # Format SwanGrid with relevant grid details\n        if (\n            hasattr(obj, \"grid\")\n            and hasattr(obj, \"cgrid\")\n            and hasattr(obj.cgrid, \"grid\")\n        ):\n            grid = obj.cgrid.grid\n\n            header, footer, _ = get_formatted_header_footer(\n                title=\"COMPUTATIONAL GRID\", use_ascii=USE_ASCII_ONLY\n            )\n\n            return (\n                f\"{header}\\n\"\n                f\"  Type:       {getattr(grid, 'grid_type', 'REG')}\\n\"\n                f\"  Resolution: {getattr(grid, 'mx', 0)}x{getattr(grid, 'my', 0)} cells\\n\"\n                f\"  Origin:     ({getattr(grid, 'xp', 0.0)}, {getattr(grid, 'yp', 0.0)})\\n\"\n                f\"  Rotation:   {getattr(grid, 'alp', 0.0)}\u00b0\\n\"\n                f\"  Size:       {getattr(grid, 'xlen', 0.0)}x{getattr(grid, 'ylen', 0.0)}\\n\"\n                f\"{footer}\"\n            )\n\n        # Format CGRID component directly\n        from rompy_swan.components.cgrid import REGULAR\n\n        if isinstance(obj, REGULAR):\n            grid = obj.grid\n\n            header, footer, bullet = get_formatted_header_footer(\n                title=\"GRID CONFIGURATION\", use_ascii=USE_ASCII_ONLY\n            )\n\n            lines = [header]\n            lines.append(f\"  {bullet} Type:       {getattr(grid, 'grid_type', 'REG')}\")\n            lines.append(\n                f\"  {bullet} Resolution: {getattr(grid, 'mx', 0)}x{getattr(grid, 'my', 0)} cells\"\n            )\n            lines.append(\n                f\"  {bullet} Origin:     ({getattr(grid, 'xp', 0.0)}, {getattr(grid, 'yp', 0.0)})\"\n            )\n            lines.append(f\"  {bullet} Rotation:   {getattr(grid, 'alp', 0.0)}\u00b0\")\n            lines.append(\n                f\"  {bullet} Size:       {getattr(grid, 'xlen', 0.0)}x{getattr(grid, 'ylen', 0.0)}\"\n            )\n\n            # Add spectrum details if available\n            if hasattr(obj, \"spectrum\"):\n                spectrum = obj.spectrum\n                lines.append(\"\")\n                lines.append(f\"  {bullet} Spectrum:\")\n                if hasattr(spectrum, \"mdc\"):\n                    lines.append(f\"      Direction bins: {spectrum.mdc}\")\n                if hasattr(spectrum, \"flow\") and hasattr(spectrum, \"fhigh\"):\n                    lines.append(\n                        f\"      Frequency range: {spectrum.flow} - {spectrum.fhigh} Hz\"\n                    )\n\n            lines.append(footer)\n            return \"\\n\".join(lines)\n\n        # Format grid directly\n\n        if isinstance(obj, SwanGrid):\n            header, footer, _ = get_formatted_header_footer(\n                title=\"SWAN GRID\", use_ascii=USE_ASCII_ONLY\n            )\n\n            # Try to get values with fallback to None\n            mx = getattr(obj, \"mx\", None)\n            my = getattr(obj, \"my\", None)\n            xp = getattr(obj, \"xp\", None)\n            yp = getattr(obj, \"yp\", None)\n            alp = getattr(obj, \"alp\", None)\n\n            lines = [header]\n            if mx and my:\n                lines.append(f\"  Resolution: {mx}x{my} cells\")\n            if xp and yp:\n                lines.append(f\"  Origin:     ({xp}, {yp})\")\n            if alp is not None:\n                lines.append(f\"  Rotation:   {alp}\u00b0\")\n            lines.append(footer)\n            return \"\\n\".join(lines)\n\n        # Format boundary components\n        if hasattr(obj, \"boundary\") and obj.boundary is not None:\n            count = 1\n            if hasattr(obj.boundary, \"boundaries\"):\n                count = len(obj.boundary.boundaries)\n\n            header, footer, _ = get_formatted_header_footer(\n                title=\"BOUNDARY CONDITIONS\", use_ascii=USE_ASCII_ONLY\n            )\n\n            boundary_type = getattr(obj.boundary, \"type\", \"spectral\")\n            return (\n                f\"{header}\\n\"\n                f\"  Type:     {boundary_type}\\n\"\n                f\"  Segments: {count}\\n\"\n                f\"{footer}\"\n            )\n\n        # Format output components\n        if hasattr(obj, \"output\") and obj.output is not None:\n            locations = []\n            if hasattr(obj.output, \"locations\"):\n                locations = obj.output.locations\n\n            header, footer, bullet = get_formatted_header_footer(\n                title=\"OUTPUT CONFIGURATION\", use_ascii=USE_ASCII_ONLY\n            )\n\n            lines = [header]\n            lines.append(f\"  {bullet} Locations: {len(locations)}\")\n\n            if hasattr(obj.output, \"format\"):\n                output_format = getattr(obj.output, \"format\", \"default\")\n                lines.append(f\"  {bullet} Format:    {output_format}\")\n\n            if hasattr(obj.output, \"variables\"):\n                variables = getattr(obj.output, \"variables\", [])\n                if variables:\n                    lines.append(\n                        f\"  {bullet} Variables: {', '.join(variables) if len(variables) &lt; 5 else f'{len(variables)} variables'}\"\n                    )\n\n            # Add detailed output info if available\n            if hasattr(obj.output, \"quantity\"):\n                lines.append(f\"  {bullet} Output quantities configuration available\")\n\n            if hasattr(obj.output, \"block\"):\n                lines.append(f\"  {bullet} Block output configuration available\")\n\n            if hasattr(obj.output, \"specout\"):\n                lines.append(f\"  {bullet} Spectral output configuration available\")\n\n            lines.append(footer)\n            return \"\\n\".join(lines)\n\n        # Format output component directly\n        if hasattr(obj, \"model_type\") and getattr(obj, \"model_type\") == \"output\":\n            header, footer, bullet = get_formatted_header_footer(\n                title=\"OUTPUT CONFIGURATION\", use_ascii=USE_ASCII_ONLY\n            )\n\n            lines = [header]\n\n            # Points output\n            if hasattr(obj, \"points\"):\n                points = obj.points\n                sname = getattr(points, \"sname\", \"unknown\")\n                xp = getattr(points, \"xp\", [])\n                yp = getattr(points, \"yp\", [])\n                if isinstance(xp, list) and isinstance(yp, list):\n                    num_points = min(len(xp), len(yp))\n                else:\n                    num_points = 1\n\n                lines.append(f\"  {bullet} Output Points: {num_points}\")\n                lines.append(f\"      Name: {sname}\")\n\n            # Output quantities\n            if hasattr(obj, \"quantity\"):\n                qty = obj.quantity\n                if hasattr(qty, \"quantities\") and isinstance(qty.quantities, list):\n                    lines.append(\n                        f\"  {bullet} Output Quantities: {len(qty.quantities)} groups\"\n                    )\n                    for i, group in enumerate(qty.quantities):\n                        if hasattr(group, \"output\") and len(group.output) &gt; 0:\n                            outputs = group.output\n                            if len(outputs) &lt; 5:\n                                lines.append(f\"      Group {i+1}: {', '.join(outputs)}\")\n                            else:\n                                lines.append(\n                                    f\"      Group {i+1}: {len(outputs)} variables\"\n                                )\n\n            # Table output\n            if hasattr(obj, \"table\"):\n                table = obj.table\n                sname = getattr(table, \"sname\", \"unknown\")\n                fname = getattr(table, \"fname\", \"unknown\")\n                lines.append(f\"  {bullet} Table Output:\")\n                lines.append(f\"      Name: {sname}\")\n                lines.append(f\"      File: {fname}\")\n                if hasattr(table, \"output\"):\n                    outputs = table.output\n                    if len(outputs) &lt; 5:\n                        lines.append(f\"      Variables: {', '.join(outputs)}\")\n                    else:\n                        lines.append(f\"      Variables: {len(outputs)} variables\")\n\n            # Block output\n            if hasattr(obj, \"block\"):\n                block = obj.block\n                sname = getattr(block, \"sname\", \"unknown\")\n                fname = getattr(block, \"fname\", \"unknown\")\n                lines.append(f\"  {bullet} Block Output:\")\n                lines.append(f\"      Name: {sname}\")\n                lines.append(f\"      File: {fname}\")\n                if hasattr(block, \"output\"):\n                    outputs = block.output\n                    if len(outputs) &lt; 5:\n                        lines.append(f\"      Variables: {', '.join(outputs)}\")\n                    else:\n                        lines.append(f\"      Variables: {len(outputs)} variables\")\n\n            # Spectral output\n            return None\n\n        # Use the new formatting framework\n        from rompy.formatting import format_value\n\n        return format_value(obj)\n\n    def __call__(self, runtime) -&gt; str:\n        # Use the new LoggingConfig for logging settings\n        from rompy.logging import LoggingConfig\n\n        logging_config = LoggingConfig()\n        SIMPLE_LOGS = logging_config.format == \"simple\"\n\n        # Use the log_box utility function\n        from rompy.formatting import log_box\n\n        log_box(title=\"PROCESSING SWAN CONFIGURATION\", logger=logger)\n\n        period = runtime.period\n        staging_dir = runtime.staging_dir\n\n        # Log configuration components\n        logger.info(\"Configuration components:\")\n        if self.cgrid:\n            if SIMPLE_LOGS:\n                logger.info(f\"CGRID: {type(self.cgrid).__name__}\")\n            else:\n                logger.info(f\"  - CGRID: {type(self.cgrid).__name__}\")\n            # Log grid details using _format_value\n            grid_str = self._format_value(self.cgrid)\n            if grid_str:\n                for line in grid_str.split(\"\\n\"):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"{line}\")\n                    else:\n                        logger.info(f\"    {line}\")\n        if self.startup:\n            if SIMPLE_LOGS:\n                logger.info(f\"Startup: {type(self.startup).__name__}\")\n            else:\n                logger.info(f\"  - Startup: {type(self.startup).__name__}\")\n            # Log startup details using _format_value\n            startup_str = self._format_value(self.startup)\n            if startup_str:\n                for line in startup_str.split(\"\\n\"):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"{line}\")\n                    else:\n                        logger.info(f\"    {line}\")\n        if self.inpgrid:\n            if isinstance(self.inpgrid, list):\n                if SIMPLE_LOGS:\n                    logger.info(f\"Input Grids: {len(self.inpgrid)} grid(s)\")\n                else:\n                    logger.info(f\"  - Input Grids: {len(self.inpgrid)} grid(s)\")\n                # Log details for each input grid\n                for i, inpgrid in enumerate(self.inpgrid):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"Input Grid {i+1}: {type(inpgrid).__name__}\")\n                    else:\n                        logger.info(f\"    Input Grid {i+1}: {type(inpgrid).__name__}\")\n                    inpgrid_str = self._format_value(inpgrid)\n                    if inpgrid_str:\n                        for line in inpgrid_str.split(\"\\n\"):\n                            if SIMPLE_LOGS:\n                                logger.info(f\"  {line}\")\n                            else:\n                                logger.info(f\"      {line}\")\n            else:\n                if SIMPLE_LOGS:\n                    logger.info(f\"Input Grid: {type(self.inpgrid).__name__}\")\n                else:\n                    logger.info(f\"  - Input Grid: {type(self.inpgrid).__name__}\")\n                # Log input grid details using _format_value\n                inpgrid_str = self._format_value(self.inpgrid)\n                if inpgrid_str:\n                    for line in inpgrid_str.split(\"\\n\"):\n                        if SIMPLE_LOGS:\n                            logger.info(f\"  {line}\")\n                        else:\n                            logger.info(f\"    {line}\")\n        if self.boundary:\n            if SIMPLE_LOGS:\n                logger.info(f\"Boundary: {type(self.boundary).__name__}\")\n            else:\n                logger.info(f\"  - Boundary: {type(self.boundary).__name__}\")\n            # Log boundary details using _format_value\n            boundary_str = self._format_value(self.boundary)\n            if boundary_str:\n                for line in boundary_str.split(\"\\n\"):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"{line}\")\n                    else:\n                        logger.info(f\"    {line}\")\n        if self.physics:\n            if SIMPLE_LOGS:\n                logger.info(f\"Physics: {type(self.physics).__name__}\")\n            else:\n                logger.info(f\"  - Physics: {type(self.physics).__name__}\")\n            # Log physics details using _format_value\n            physics_str = self._format_value(self.physics)\n            if physics_str:\n                for line in physics_str.split(\"\\n\"):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"{line}\")\n                    else:\n                        logger.info(f\"    {line}\")\n        if self.output:\n            if SIMPLE_LOGS:\n                logger.info(f\"Output: {type(self.output).__name__}\")\n            else:\n                logger.info(f\"  - Output: {type(self.output).__name__}\")\n            # Log output details using _format_value\n            output_str = self._format_value(self.output)\n            if output_str:\n                for line in output_str.split(\"\\n\"):\n                    if SIMPLE_LOGS:\n                        logger.info(f\"{line}\")\n                    else:\n                        logger.info(f\"    {line}\")\n\n        # Interface the runtime with components that require times\n        if self.output:\n\n            logger.debug(\"Configuring output interface with period\")\n            self.output = OutputInterface(group=self.output, period=period).group\n        if self.lockup:\n\n            logger.debug(\"Configuring lockup interface with period\")\n            self.lockup = LockupInterface(group=self.lockup, period=period).group\n\n        # Render each group component before passing to template\n        logger.info(\"Rendering SWAN configuration components\")\n        logger.debug(\"Rendering CGRID configuration\")\n        ret = {\"cgrid\": self.cgrid.render()}\n        if self.startup:\n            logger.debug(\"Rendering startup configuration\")\n            ret[\"startup\"] = self.startup.render()\n        if self.initial:\n            logger.debug(\"Rendering initial configuration\")\n            ret[\"initial\"] = self.initial.render()\n        if self.physics:\n            logger.debug(\"Rendering physics configuration\")\n            ret[\"physics\"] = self.physics.render()\n        if self.prop:\n            logger.debug(\"Rendering propagation configuration\")\n            ret[\"prop\"] = self.prop.render()\n        if self.numeric:\n            logger.debug(\"Rendering numeric configuration\")\n            ret[\"numeric\"] = self.numeric.render()\n        if self.output:\n            logger.debug(\"Rendering output configuration\")\n            ret[\"output\"] = self.output.render()\n        if self.lockup:\n            logger.debug(\"Rendering lockup configuration\")\n            ret[\"lockup\"] = self.lockup.render()\n\n        # inpgrid / boundary may use the Interface api so we need passing the args\n        if self.inpgrid and isinstance(self.inpgrid, DataInterface):\n            logger.debug(\"Rendering inpgrid configuration with data interface\")\n            ret[\"inpgrid\"] = self.inpgrid.render(staging_dir, self.grid, period)\n        elif self.inpgrid:\n            logger.debug(\"Rendering inpgrid configuration\")\n            ret[\"inpgrid\"] = self.inpgrid.render()\n        if self.boundary and isinstance(self.boundary, BoundaryInterface):\n            logger.debug(\"Rendering boundary configuration with boundary interface\")\n            ret[\"boundary\"] = self.boundary.render(staging_dir, self.grid, period)\n        elif self.boundary:\n            logger.debug(\"Rendering boundary configuration\")\n            ret[\"boundary\"] = self.boundary.render()\n\n        # Use formatting utilities imported at the top of the file\n\n        # Use the log_box utility function\n        from rompy.formatting import log_box\n\n        log_box(title=\"SWAN CONFIGURATION RENDERING COMPLETE\", logger=logger)\n\n        return ret\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig-attributes","title":"Attributes","text":""},{"location":"reference/config/#rompy_swan.config.SwanConfig.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['swan', 'SWAN'] = Field(default='swan', description='Model type discriminator')\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: str = Field(default=DEFAULT_TEMPLATE, description='The template for SWAN.')\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.cgrid","title":"cgrid  <code>instance-attribute</code>","text":"<pre><code>cgrid: CGRID_TYPES\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.startup","title":"startup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>startup: Optional[STARTUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.inpgrid","title":"inpgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inpgrid: Optional[INPGRID_TYPES] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.boundary","title":"boundary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>boundary: Optional[BOUNDARY_TYPES] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial: Optional[INITIAL_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.physics","title":"physics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>physics: Optional[PHYSICS_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.prop","title":"prop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prop: Optional[PROP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.numeric","title":"numeric  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>numeric: Optional[NUMERIC_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Optional[OUTPUT_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.lockup","title":"lockup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lockup: Optional[LOCKUP_TYPE] = Field(default=None)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.grid","title":"grid  <code>property</code>","text":"<pre><code>grid\n</code></pre> <p>Define a SwanGrid from the cgrid field.</p>"},{"location":"reference/config/#rompy_swan.config.SwanConfig-functions","title":"Functions","text":""},{"location":"reference/config/#rompy_swan.config.SwanConfig.no_nor_if_spherical","title":"no_nor_if_spherical","text":"<pre><code>no_nor_if_spherical() -&gt; SwanConfig\n</code></pre> <p>Ensure SET nor is not prescribed when using spherical coordinates.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef no_nor_if_spherical(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure SET nor is not prescribed when using spherical coordinates.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.no_repeating_if_setup","title":"no_repeating_if_setup","text":"<pre><code>no_repeating_if_setup() -&gt; SwanConfig\n</code></pre> <p>Ensure COORD repeating not set when using set-up.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef no_repeating_if_setup(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure COORD repeating not set when using set-up.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.alp_is_zero_if_spherical","title":"alp_is_zero_if_spherical","text":"<pre><code>alp_is_zero_if_spherical() -&gt; SwanConfig\n</code></pre> <p>Ensure alp is zero when using spherical coordinates.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef alp_is_zero_if_spherical(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure alp is zero when using spherical coordinates.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.cgrid_contain_inpgrids","title":"cgrid_contain_inpgrids","text":"<pre><code>cgrid_contain_inpgrids() -&gt; SwanConfig\n</code></pre> <p>Ensure all inpgrids are inside the cgrid area.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef cgrid_contain_inpgrids(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure all inpgrids are inside the cgrid area.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.layer_defined_if_no_mud_inpgrid","title":"layer_defined_if_no_mud_inpgrid","text":"<pre><code>layer_defined_if_no_mud_inpgrid() -&gt; SwanConfig\n</code></pre> <p>Ensure layer is set in MUD command if not defined with INPGRID MUD.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef layer_defined_if_no_mud_inpgrid(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure layer is set in MUD command if not defined with INPGRID MUD.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.transm_msc_mdc","title":"transm_msc_mdc","text":"<pre><code>transm_msc_mdc() -&gt; SwanConfig\n</code></pre> <p>Ensure the number of transmission coefficients match msc and mdc.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>def transm_msc_mdc(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure the number of transmission coefficients match msc and mdc.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.locations_2d","title":"locations_2d","text":"<pre><code>locations_2d() -&gt; SwanConfig\n</code></pre> <p>Ensure Location components not used in 1D mode.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef locations_2d(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure Location components not used in 1D mode.\"\"\"\n    # FRAME, GROUP, RAY, ISOLINE and NGRID not in 1D\n    # BLOCK and NESTOUT not in 1D\n    # GROUP not in unstructured\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.group_within_cgrid","title":"group_within_cgrid","text":"<pre><code>group_within_cgrid() -&gt; SwanConfig\n</code></pre> <p>Ensure group indices are contained in computational grid.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef group_within_cgrid(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure group indices are contained in computational grid.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfig.not_curvilinear_if_ray","title":"not_curvilinear_if_ray","text":"<pre><code>not_curvilinear_if_ray() -&gt; SwanConfig\n</code></pre> <p>Ensure bottom and water level grids are not curvilinear for RAY.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef not_curvilinear_if_ray(self) -&gt; \"SwanConfig\":\n    \"\"\"Ensure bottom and water level grids are not curvilinear for RAY.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfigComponents","title":"SwanConfigComponents","text":"<p>               Bases: <code>SwanConfig</code></p> <p>Deprecated: Use SwanConfig instead.</p> <p>This class is deprecated and will be removed in a future version. Please use SwanConfig instead of SwanConfigComponents.</p> Source code in <code>rompy_swan/config.py</code> <pre><code>class SwanConfigComponents(SwanConfig):\n    \"\"\"Deprecated: Use SwanConfig instead.\n\n    This class is deprecated and will be removed in a future version.\n    Please use SwanConfig instead of SwanConfigComponents.\n    \"\"\"\n\n    model_type: Literal[\"swanconfig\", \"SWANCONFIG\"] = Field(\n        default=\"swanconfig\",\n        description=\"Model type discriminator\",\n    )\n\n    def __init__(self, **kwargs):\n        warnings.warn(\n            \"SwanConfigComponents is deprecated and will be removed in a future version. \"\n            \"Please use SwanConfig instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/config/#rompy_swan.config.SwanConfigComponents-attributes","title":"Attributes","text":""},{"location":"reference/config/#rompy_swan.config.SwanConfigComponents.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['swanconfig', 'SWANCONFIG'] = Field(default='swanconfig', description='Model type discriminator')\n</code></pre>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#rompy_swan.types","title":"types","text":"<p>SWAN Types</p> <p>This module contains type definitions and enumerations used throughout the SWAN model implementation, including grid types, boundary conditions, and physics options.</p>"},{"location":"reference/types/#rompy_swan.types-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/types/#rompy_swan.types-classes","title":"Classes","text":""},{"location":"reference/types/#rompy_swan.types.IDLA","title":"IDLA","text":"<p>               Bases: <code>IntEnum</code></p> <p>Order of values in the input files.</p>"},{"location":"reference/types/#rompy_swan.types.IDLA--attributes","title":"Attributes","text":"<p>ONE: 1     SWAN reads the map from left to right starting in the upper-left-hand corner of     the map. A new line in the map should start on a new line in the file. TWO: 2     As <code>1</code> but a new line in the map need not start on a new line in the file. THREE: 3     SWAN reads the map from left to right starting in the lower-left-hand corner of     the map. A new line in the map should start on a new line in the file. FOUR: 4     As <code>3</code> but a new line in the map need not start on a new line in the file. FIVE: 5     SWAN reads the map from top to bottom starting in the lower-left-hand corner of     the map. A new column in the map should start on a new line in the file. SIX: 6     As <code>5</code> but a new column in the map need not start on a new line in the file.</p>"},{"location":"reference/types/#rompy_swan.types.IDLA--notes","title":"Notes","text":"<p>It is assumed that the x-axis of the grid is pointing to the right and the y-axis upwards.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class IDLA(IntEnum):\n    \"\"\"Order of values in the input files.\n\n    Attributes\n    ----------\n    ONE: 1\n        SWAN reads the map from left to right starting in the upper-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    TWO: 2\n        As `1` but a new line in the map need not start on a new line in the file.\n    THREE: 3\n        SWAN reads the map from left to right starting in the lower-left-hand corner of\n        the map. A new line in the map should start on a new line in the file.\n    FOUR: 4\n        As `3` but a new line in the map need not start on a new line in the file.\n    FIVE: 5\n        SWAN reads the map from top to bottom starting in the lower-left-hand corner of\n        the map. A new column in the map should start on a new line in the file.\n    SIX: 6\n        As `5` but a new column in the map need not start on a new line in the file.\n\n    Notes\n    -----\n    It is assumed that the x-axis of the grid is pointing to the right and the y-axis\n    upwards.\n\n    \"\"\"\n\n    ONE = 1\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.IDLA.ONE","title":"ONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ONE = 1\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA.TWO","title":"TWO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TWO = 2\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA.THREE","title":"THREE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THREE = 3\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA.FOUR","title":"FOUR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOUR = 4\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA.FIVE","title":"FIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIVE = 5\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.IDLA.SIX","title":"SIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIX = 6\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions","title":"GridOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the input grid type.</p>"},{"location":"reference/types/#rompy_swan.types.GridOptions--attributes","title":"Attributes","text":"<p>BOTTOM: \"bottom\"     Bottom level grid. WLEVEL: \"wlevel\"     Water level grid. CURRENT: \"current\"     Current field grid. VX: \"vx\"     Current field x-component grid. VY: \"vy\"     Current field y-component grid. WIND: \"wind\"     Wind velocity grid. WX: \"wx\"     Wind velocity x-component grid. WY: \"wy\"     Wind velocity y-component grid. FRICTION: \"friction\"     Bottom friction grid. NPLANTS: \"nplants\"     Horizontally varying vegetation density grid. TURBVISC: \"turbvisc\"     Horizontally varying turbulent viscosity grid. MUDLAYER: \"mudlayer\"     Horizontally varying mud layer thickness grid. AICE: \"aice\"     Areal ice fraction grid, a number between 0 and 1. HICE: \"hice\"     Ice thickness grid. HSS: \"hss\"     Sea-swell significant wave height grid. TSS: \"tss\"     Sea-swell mean wave period.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class GridOptions(str, Enum):\n    \"\"\"Valid options for the input grid type.\n\n    Attributes\n    ----------\n    BOTTOM: \"bottom\"\n        Bottom level grid.\n    WLEVEL: \"wlevel\"\n        Water level grid.\n    CURRENT: \"current\"\n        Current field grid.\n    VX: \"vx\"\n        Current field x-component grid.\n    VY: \"vy\"\n        Current field y-component grid.\n    WIND: \"wind\"\n        Wind velocity grid.\n    WX: \"wx\"\n        Wind velocity x-component grid.\n    WY: \"wy\"\n        Wind velocity y-component grid.\n    FRICTION: \"friction\"\n        Bottom friction grid.\n    NPLANTS: \"nplants\"\n        Horizontally varying vegetation density grid.\n    TURBVISC: \"turbvisc\"\n        Horizontally varying turbulent viscosity grid.\n    MUDLAYER: \"mudlayer\"\n        Horizontally varying mud layer thickness grid.\n    AICE: \"aice\"\n        Areal ice fraction grid, a number between 0 and 1.\n    HICE: \"hice\"\n        Ice thickness grid.\n    HSS: \"hss\"\n        Sea-swell significant wave height grid.\n    TSS: \"tss\"\n        Sea-swell mean wave period.\n\n    \"\"\"\n\n    BOTTOM = \"bottom\"\n    WLEVEL = \"wlevel\"\n    CURRENT = \"current\"\n    VX = \"vx\"\n    VY = \"vy\"\n    WIND = \"wind\"\n    WX = \"wx\"\n    WY = \"wy\"\n    FRICTION = \"friction\"\n    NPLANTS = \"nplants\"\n    TURBVISC = \"turbvisc\"\n    MUDLAYER = \"mudlayer\"\n    AICE = \"aice\"\n    HICE = \"hice\"\n    HSS = \"hss\"\n    TSS = \"tss\"\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.GridOptions.BOTTOM","title":"BOTTOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTTOM = 'bottom'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.WLEVEL","title":"WLEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLEVEL = 'wlevel'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.CURRENT","title":"CURRENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT = 'current'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.VX","title":"VX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VX = 'vx'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.VY","title":"VY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VY = 'vy'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.WX","title":"WX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WX = 'wx'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.WY","title":"WY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WY = 'wy'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.FRICTION","title":"FRICTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRICTION = 'friction'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.TURBVISC","title":"TURBVISC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TURBVISC = 'turbvisc'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.MUDLAYER","title":"MUDLAYER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUDLAYER = 'mudlayer'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.HICE","title":"HICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HICE = 'hice'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.HSS","title":"HSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSS = 'hss'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.GridOptions.TSS","title":"TSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSS = 'tss'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions","title":"BoundShapeOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions--attributes","title":"Attributes","text":"<p>JONSWAP: \"jonswap\"     JONSWAP spectrum. PM: \"pm\"     Pierson-Moskowitz spectrum. GAUSS: \"gauss\"     Gaussian spectrum. BIN: \"bin\"     Energy at a single bin spectrum. TMA: \"tma\"     TMA spectrum.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class BoundShapeOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    JONSWAP: \"jonswap\"\n        JONSWAP spectrum.\n    PM: \"pm\"\n        Pierson-Moskowitz spectrum.\n    GAUSS: \"gauss\"\n        Gaussian spectrum.\n    BIN: \"bin\"\n        Energy at a single bin spectrum.\n    TMA: \"tma\"\n        TMA spectrum.\n\n    \"\"\"\n\n    JONSWAP = \"jonswap\"\n    PM = \"pm\"\n    GAUSS = \"gauss\"\n    BIN = \"bin\"\n    TMA = \"tma\"\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions.JONSWAP","title":"JONSWAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JONSWAP = 'jonswap'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions.PM","title":"PM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PM = 'pm'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions.GAUSS","title":"GAUSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAUSS = 'gauss'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions.BIN","title":"BIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIN = 'bin'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BoundShapeOptions.TMA","title":"TMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMA = 'tma'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions","title":"SideOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for the boundary shape type.</p>"},{"location":"reference/types/#rompy_swan.types.SideOptions--attributes","title":"Attributes","text":"<p>NORTH: \"north\"     North side. NW: \"nw\"     North-west side. WEST: \"west\"     West side. SW: \"sw\"     South-west side. SOUTH: \"south\"     South side. SE: \"se\"     South-east side. EAST: \"east\"     East side. NE: \"ne\"     North-east side.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class SideOptions(str, Enum):\n    \"\"\"Valid options for the boundary shape type.\n\n    Attributes\n    ----------\n    NORTH: \"north\"\n        North side.\n    NW: \"nw\"\n        North-west side.\n    WEST: \"west\"\n        West side.\n    SW: \"sw\"\n        South-west side.\n    SOUTH: \"south\"\n        South side.\n    SE: \"se\"\n        South-east side.\n    EAST: \"east\"\n        East side.\n    NE: \"ne\"\n        North-east side.\n\n    \"\"\"\n\n    NORTH = \"north\"\n    NW = \"nw\"\n    WEST = \"west\"\n    SW = \"sw\"\n    SOUTH = \"south\"\n    SE = \"se\"\n    EAST = \"east\"\n    NE = \"ne\"\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.SideOptions.NORTH","title":"NORTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NORTH = 'north'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.NW","title":"NW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NW = 'nw'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.WEST","title":"WEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEST = 'west'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.SW","title":"SW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SW = 'sw'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.SOUTH","title":"SOUTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOUTH = 'south'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.SE","title":"SE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SE = 'se'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.EAST","title":"EAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EAST = 'east'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.SideOptions.NE","title":"NE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NE = 'ne'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff","title":"PhysicsOff","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Physics commands to be switched off.</p>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff--attributes","title":"Attributes","text":"<p>WINDGROWTH : str = \"windgrowth\"     Switches off wind growth (in commands GEN1, GEN2, GEN3). QUADRUPL : str = \"quadrupl\"     Switches off quadruplet wave interactions (in command GEN3). WCAPPING : str = \"wcapping\"     Switches off whitecapping (in command GEN3). BREAKING : str = \"breaking\"     Switches off wave breaking dissipation. REFRAC : str = \"refrac\"     Switches off wave refraction (action transport in theta space). FSHIFT : str = \"fshift\"     Switches off frequency shifting (action transport in sigma space). BNDCHK : str = \"bndchk\"     Switches off the checking of the delta imposed and computed Hs at the boundary.</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class PhysicsOff(str, Enum):\n    \"\"\"Physics commands to be switched off.\n\n    Attributes\n    ----------\n    WINDGROWTH : str = \"windgrowth\"\n        Switches off wind growth (in commands GEN1, GEN2, GEN3).\n    QUADRUPL : str = \"quadrupl\"\n        Switches off quadruplet wave interactions (in command GEN3).\n    WCAPPING : str = \"wcapping\"\n        Switches off whitecapping (in command GEN3).\n    BREAKING : str = \"breaking\"\n        Switches off wave breaking dissipation.\n    REFRAC : str = \"refrac\"\n        Switches off wave refraction (action transport in theta space).\n    FSHIFT : str = \"fshift\"\n        Switches off frequency shifting (action transport in sigma space).\n    BNDCHK : str = \"bndchk\"\n        Switches off the checking of the delta imposed and computed Hs at the boundary.\n\n    \"\"\"\n\n    WINDGROWTH = \"windgrowth\"\n    QUADRUPL = \"quadrupl\"\n    WCAPPING = \"wcapping\"\n    BREAKING = \"breaking\"\n    REFRAC = \"refrac\"\n    FSHIFT = \"fshift\"\n    BNDCHK = \"bndchk\"\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.PhysicsOff.WINDGROWTH","title":"WINDGROWTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDGROWTH = 'windgrowth'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.QUADRUPL","title":"QUADRUPL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUADRUPL = 'quadrupl'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.WCAPPING","title":"WCAPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WCAPPING = 'wcapping'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.BREAKING","title":"BREAKING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BREAKING = 'breaking'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.REFRAC","title":"REFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REFRAC = 'refrac'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.FSHIFT","title":"FSHIFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSHIFT = 'fshift'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.PhysicsOff.BNDCHK","title":"BNDCHK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BNDCHK = 'bndchk'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions","title":"BlockOptions","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid options for block output parameters.</p>"},{"location":"reference/types/#rompy_swan.types.BlockOptions--attributes","title":"Attributes","text":"<p>HSIGN: \"hsign\"     Significant wave height (in m). HSWELL: \"hswell\"     Swell wave height (in m). DIR: \"dir\"     Mean wave direction (in degrees). DPM: \"dpm\"     Mean wave direction at the peak frequency (in degrees). PDIR: \"pdir\"     Peak wave direction (in degrees). TDIR: \"tdir\"     Direction of energy transport (in degrees). TM01: \"tm01\"     Mean absolute wave period (in s). RTM01: \"rtm01\"     Mean relative wave period (in s). RTP: \"rtp\"     Peak period of the (relative frequency) variance density spectrum (in s). TPS: \"tps\"     Smoothed peak period (in s). PER: \"per\"     Mean absolute wave period (in s). RPER: \"rper\"     Mean relative wave period (in s). TMM10: \"tmm10\"     Mean absolute wave period (in s). RTMM10: \"rtmm10\"     Mean relative wave period (in s). TM02: \"tm02\"     Mean absolute zero-crossing period (in s). FSPR: \"fspr\"     The normalised width of the frequency spectrum. DSPR: \"dspr\"     Directional spreading of the waves (in degrees). QP: \"qp\"     Peakedness of the wave spectrum (dimensionless). DEPTH: \"depth\"     Water depth (in m). WATLEV: \"watlev\"     Water level (in m). BOTLEV: \"botlev\"     Bottom level (in m). VEL: \"vel\"     Current velocity (vector; in m/s). FRCOEF: \"frcoef\"     Friction coefficient (equal to <code>cfw</code> or <code>kn</code> in command <code>FRICTION</code>). WIND: \"wind\"     Wind velocity (vector; in m/s). AICE: \"aice\"     Ice concentration (as a fraction from 0 to 1). PROPAGAT: \"propagat\"     Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s). PROPXY: \"propxy\"     Energy propagation in geographic space; sum of x- and y-direction     (in W/m2 or m2/s). PROPTHETA: \"proptheta\"     Energy propagation in theta space (in W/m2 or m2/s). PROPSIGMA: \"propsigma\"     Energy propagation in sigma space (in W/m2 or m2/s). GENERAT: \"generat\"     Total energy generation (in W/m2 or m2/s). GENWIND: \"genwind\"     Energy generation due to wind (in W/m2 or m2/s). REDIST: \"redist\"     Total energy redistribution (in W/m2 or m2/s). REDQUAD: \"redquad\"     Energy redistribution due to quadruplets (in W/m2 or m2/s). REDTRIAD: \"redtriad\"     Energy redistribution due to triads (in W/m2 or m2/s). DISSIP: \"dissip\"     Total energy dissipation (in W/m2 or m2/s). DISBOT: \"disbot\"     Energy dissipation due to bottom friction (in W/m2 or m2/s). DISSURF: \"dissurf\"     Energy dissipation due to surf breaking (in W/m2 or m2/s). DISWCAP: \"diswcap\"     Energy dissipation due to whitecapping (in W/m2 or m2/s). DISSWELL: \"disswell\"     Energy dissipation due to swell dissipation (in W/m2 or m2/s). DISVEG: \"disveg\"     Energy dissipation due to vegetation (in W/m2 or m2/s). DISMUD: \"dismud\"     Energy dissipation due to mud (in W/m2 or m2/s). DISICE: \"disice\"     Energy dissipation due to sea ice (in W/m2 or m2/s). RADSTR: \"radstr\"     Energy transfer between waves and currents due to radiation stress     (in W/m2 or m2/s). QB: \"qb\"     Fraction of breaking waves due to depth-induced breaking. TRANSP: \"transp\"     Transport of energy (vector; in W/m2 or m2/s). FORCE: \"force\"     Wave-induced force per unit surface area (vector; in N/m2). UBOT: \"ubot\"     The rms-value of the maxima of the orbital velocity near the bottom (in m/s). URMS: \"urms\"     The rms-value of the orbital velocity near the bottom (in m/s). TMBOT: \"tmbot\"     The bottom wave period (in s). WLENGTH: \"wlength\"     Average wave length (in m). LWAVP: \"lwavp\"     Peak wave length (in m). STEEPNESS: \"steepness\"     Average wave steepness (dimensionless). BFI: \"bfi\"     Benjamin-Feir index (dimensionless). NPLANTS: \"nplants\"     Number of plants per square meter. DHSIGN: \"dhsign\"     Difference in significant wave height from the last two iterations (in m). DRTM01: \"drtm01\"     Difference in average wave period (RTM01) from the last two iterations (in s). LEAK: \"leak\"     Numerical loss of energy equal to <code>cthetaE(omega,theta)</code> across boundaries. TIME: \"time\"     Full date-time string as part of line used in TABLE only. TSEC: \"tsec\"     Time in seconds with respect to a reference time (see command QUANTITY). XP: \"xp\"     The x-coordinate in the problem coordinate system of the output location. YP: \"yp\"     The y-coordinate in the problem coordinate system of the output location. DIST: \"dist\"     If output has been requested along a curve then the distance along the curve     can be obtained with the command TABLE. DIST is the distance along the curve     measured from teh first point on the curve to the output location on the curve     in meters (also in the case of spherical coordinates). SETUP: \"setup\"     Set-up due to waves (in m). PTHSIGN: \"pthsign\"     Watershed partitions of the significant wave height (in m). PTRTP: \"ptrtp\"     Watershed partitions of the relative peak period (in s). PTWLEN: \"ptwlen\"     Watershed partitions of the average wave length (in m). PTDIR: \"ptdir\"     Watershed partitions of the peak wave direction (in degrees). PTDSPR: \"ptdspr\"     Watershed partitions of the directional spreading (in degrees). PTWFRAC: \"ptwfrac\"     Watershed partitions of the wind fraction (dimensionless). PTSTEEPNE: \"ptsteepne\"     Watershed partition of the wave steepness (dimensionless). PARTITION: \"partition\"     The raw spectral partition for wave system tracking post-processing.</p>"},{"location":"reference/types/#rompy_swan.types.BlockOptions--note","title":"Note","text":"<p>Energy given in W/m2 or m2/s depending on command SET.</p>"},{"location":"reference/types/#rompy_swan.types.BlockOptions--note_1","title":"Note","text":"<p>UBOT and URMS required command <code>FRICTION</code> to be used. If friction is ignored in the computation, then one should use the command <code>FRICTION</code> with the value of the friction set to zero (e.g., <code>FRICTION COLLINS 0</code>).</p> Source code in <code>rompy_swan/types.py</code> <pre><code>class BlockOptions(str, Enum):\n    \"\"\"Valid options for block output parameters.\n\n    Attributes\n    ----------\n    HSIGN: \"hsign\"\n        Significant wave height (in m).\n    HSWELL: \"hswell\"\n        Swell wave height (in m).\n    DIR: \"dir\"\n        Mean wave direction (in degrees).\n    DPM: \"dpm\"\n        Mean wave direction at the peak frequency (in degrees).\n    PDIR: \"pdir\"\n        Peak wave direction (in degrees).\n    TDIR: \"tdir\"\n        Direction of energy transport (in degrees).\n    TM01: \"tm01\"\n        Mean absolute wave period (in s).\n    RTM01: \"rtm01\"\n        Mean relative wave period (in s).\n    RTP: \"rtp\"\n        Peak period of the (relative frequency) variance density spectrum (in s).\n    TPS: \"tps\"\n        Smoothed peak period (in s).\n    PER: \"per\"\n        Mean absolute wave period (in s).\n    RPER: \"rper\"\n        Mean relative wave period (in s).\n    TMM10: \"tmm10\"\n        Mean absolute wave period (in s).\n    RTMM10: \"rtmm10\"\n        Mean relative wave period (in s).\n    TM02: \"tm02\"\n        Mean absolute zero-crossing period (in s).\n    FSPR: \"fspr\"\n        The normalised width of the frequency spectrum.\n    DSPR: \"dspr\"\n        Directional spreading of the waves (in degrees).\n    QP: \"qp\"\n        Peakedness of the wave spectrum (dimensionless).\n    DEPTH: \"depth\"\n        Water depth (in m).\n    WATLEV: \"watlev\"\n        Water level (in m).\n    BOTLEV: \"botlev\"\n        Bottom level (in m).\n    VEL: \"vel\"\n        Current velocity (vector; in m/s).\n    FRCOEF: \"frcoef\"\n        Friction coefficient (equal to `cfw` or `kn` in command `FRICTION`).\n    WIND: \"wind\"\n        Wind velocity (vector; in m/s).\n    AICE: \"aice\"\n        Ice concentration (as a fraction from 0 to 1).\n    PROPAGAT: \"propagat\"\n        Sum of PROPXY, PROPTHETA and PROPSIGMA (in W/m2 or m2/s).\n    PROPXY: \"propxy\"\n        Energy propagation in geographic space; sum of x- and y-direction\n        (in W/m2 or m2/s).\n    PROPTHETA: \"proptheta\"\n        Energy propagation in theta space (in W/m2 or m2/s).\n    PROPSIGMA: \"propsigma\"\n        Energy propagation in sigma space (in W/m2 or m2/s).\n    GENERAT: \"generat\"\n        Total energy generation (in W/m2 or m2/s).\n    GENWIND: \"genwind\"\n        Energy generation due to wind (in W/m2 or m2/s).\n    REDIST: \"redist\"\n        Total energy redistribution (in W/m2 or m2/s).\n    REDQUAD: \"redquad\"\n        Energy redistribution due to quadruplets (in W/m2 or m2/s).\n    REDTRIAD: \"redtriad\"\n        Energy redistribution due to triads (in W/m2 or m2/s).\n    DISSIP: \"dissip\"\n        Total energy dissipation (in W/m2 or m2/s).\n    DISBOT: \"disbot\"\n        Energy dissipation due to bottom friction (in W/m2 or m2/s).\n    DISSURF: \"dissurf\"\n        Energy dissipation due to surf breaking (in W/m2 or m2/s).\n    DISWCAP: \"diswcap\"\n        Energy dissipation due to whitecapping (in W/m2 or m2/s).\n    DISSWELL: \"disswell\"\n        Energy dissipation due to swell dissipation (in W/m2 or m2/s).\n    DISVEG: \"disveg\"\n        Energy dissipation due to vegetation (in W/m2 or m2/s).\n    DISMUD: \"dismud\"\n        Energy dissipation due to mud (in W/m2 or m2/s).\n    DISICE: \"disice\"\n        Energy dissipation due to sea ice (in W/m2 or m2/s).\n    RADSTR: \"radstr\"\n        Energy transfer between waves and currents due to radiation stress\n        (in W/m2 or m2/s).\n    QB: \"qb\"\n        Fraction of breaking waves due to depth-induced breaking.\n    TRANSP: \"transp\"\n        Transport of energy (vector; in W/m2 or m2/s).\n    FORCE: \"force\"\n        Wave-induced force per unit surface area (vector; in N/m2).\n    UBOT: \"ubot\"\n        The rms-value of the maxima of the orbital velocity near the bottom (in m/s).\n    URMS: \"urms\"\n        The rms-value of the orbital velocity near the bottom (in m/s).\n    TMBOT: \"tmbot\"\n        The bottom wave period (in s).\n    WLENGTH: \"wlength\"\n        Average wave length (in m).\n    LWAVP: \"lwavp\"\n        Peak wave length (in m).\n    STEEPNESS: \"steepness\"\n        Average wave steepness (dimensionless).\n    BFI: \"bfi\"\n        Benjamin-Feir index (dimensionless).\n    NPLANTS: \"nplants\"\n        Number of plants per square meter.\n    DHSIGN: \"dhsign\"\n        Difference in significant wave height from the last two iterations (in m).\n    DRTM01: \"drtm01\"\n        Difference in average wave period (RTM01) from the last two iterations (in s).\n    LEAK: \"leak\"\n        Numerical loss of energy equal to `cthetaE(omega,theta)` across boundaries.\n    TIME: \"time\"\n        Full date-time string as part of line used in TABLE only.\n    TSEC: \"tsec\"\n        Time in seconds with respect to a reference time (see command QUANTITY).\n    XP: \"xp\"\n        The x-coordinate in the problem coordinate system of the output location.\n    YP: \"yp\"\n        The y-coordinate in the problem coordinate system of the output location.\n    DIST: \"dist\"\n        If output has been requested along a curve then the distance along the curve\n        can be obtained with the command TABLE. DIST is the distance along the curve\n        measured from teh first point on the curve to the output location on the curve\n        in meters (also in the case of spherical coordinates).\n    SETUP: \"setup\"\n        Set-up due to waves (in m).\n    PTHSIGN: \"pthsign\"\n        Watershed partitions of the significant wave height (in m).\n    PTRTP: \"ptrtp\"\n        Watershed partitions of the relative peak period (in s).\n    PTWLEN: \"ptwlen\"\n        Watershed partitions of the average wave length (in m).\n    PTDIR: \"ptdir\"\n        Watershed partitions of the peak wave direction (in degrees).\n    PTDSPR: \"ptdspr\"\n        Watershed partitions of the directional spreading (in degrees).\n    PTWFRAC: \"ptwfrac\"\n        Watershed partitions of the wind fraction (dimensionless).\n    PTSTEEPNE: \"ptsteepne\"\n        Watershed partition of the wave steepness (dimensionless).\n    PARTITION: \"partition\"\n        The raw spectral partition for wave system tracking post-processing.\n\n    Note\n    ----\n    Energy given in W/m2 or m2/s depending on command SET.\n\n    Note\n    ----\n    UBOT and URMS required command `FRICTION` to be used. If friction is ignored in the\n    computation, then one should use the command `FRICTION` with the value of the\n    friction set to zero (e.g., `FRICTION COLLINS 0`).\n\n    \"\"\"\n\n    HSIGN = \"hsign\"\n    HSWELL = \"hswell\"\n    DIR = \"dir\"\n    DPM = \"dpm\"\n    PDIR = \"pdir\"\n    TDIR = \"tdir\"\n    TM01 = \"tm01\"\n    RTM01 = \"rtm01\"\n    RTP = \"rtp\"\n    TPS = \"tps\"\n    PER = \"per\"\n    RPER = \"rper\"\n    TMM10 = \"tmm10\"\n    RTMM10 = \"rtmm10\"\n    TM02 = \"tm02\"\n    FSPR = \"fspr\"\n    DSPR = \"dspr\"\n    QP = \"qp\"\n    DEPTH = \"depth\"\n    WATLEV = \"watlev\"\n    BOTLEV = \"botlev\"\n    VEL = \"vel\"\n    FRCOEF = \"frcoef\"\n    WIND = \"wind\"\n    AICE = \"aice\"\n    PROPAGAT = \"propagat\"\n    PROPXY = \"propxy\"\n    PROPTHETA = \"proptheta\"\n    PROPSIGMA = \"propsigma\"\n    GENERAT = \"generat\"\n    GENWIND = \"genwind\"\n    REDIST = \"redist\"\n    REDQUAD = \"redquad\"\n    REDTRIAD = \"redtriad\"\n    DISSIP = \"dissip\"\n    DISBOT = \"disbot\"\n    DISSURF = \"dissurf\"\n    DISWCAP = \"diswcap\"\n    DISSWELL = \"disswell\"\n    DISVEG = \"disveg\"\n    DISMUD = \"dismud\"\n    DISICE = \"disice\"\n    RADSTR = \"radstr\"\n    QB = \"qb\"\n    TRANSP = \"transp\"\n    FORCE = \"force\"\n    UBOT = \"ubot\"\n    URMS = \"urms\"\n    TMBOT = \"tmbot\"\n    WLENGTH = \"wlength\"\n    LWAVP = \"lwavp\"\n    STEEPNESS = \"steepness\"\n    BFI = \"bfi\"\n    NPLANTS = \"nplants\"\n    DHSIGN = \"dhsign\"\n    DRTM01 = \"drtm01\"\n    LEAK = \"leak\"\n    TIME = \"time\"\n    TSEC = \"tsec\"\n    XP = \"xp\"\n    YP = \"yp\"\n    DIST = \"dist\"\n    SETUP = \"setup\"\n    PTHSIGN = \"pthsign\"\n    PTRTP = \"ptrtp\"\n    PTWLEN = \"ptwlen\"\n    PTDIR = \"ptdir\"\n    PTDSPR = \"ptdspr\"\n    PTWFRAC = \"ptwfrac\"\n    PTSTEEPNE = \"ptsteepne\"\n    PARTITION = \"partition\"\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions-attributes","title":"Attributes","text":""},{"location":"reference/types/#rompy_swan.types.BlockOptions.HSIGN","title":"HSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSIGN = 'hsign'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.HSWELL","title":"HSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HSWELL = 'hswell'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DIR","title":"DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIR = 'dir'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DPM","title":"DPM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DPM = 'dpm'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PDIR","title":"PDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PDIR = 'pdir'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TDIR","title":"TDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TDIR = 'tdir'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TM01","title":"TM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM01 = 'tm01'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.RTM01","title":"RTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTM01 = 'rtm01'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.RTP","title":"RTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTP = 'rtp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TPS","title":"TPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TPS = 'tps'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PER","title":"PER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PER = 'per'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.RPER","title":"RPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RPER = 'rper'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TMM10","title":"TMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMM10 = 'tmm10'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.RTMM10","title":"RTMM10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RTMM10 = 'rtmm10'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TM02","title":"TM02  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TM02 = 'tm02'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.FSPR","title":"FSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FSPR = 'fspr'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DSPR","title":"DSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DSPR = 'dspr'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.QP","title":"QP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QP = 'qp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DEPTH","title":"DEPTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEPTH = 'depth'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.WATLEV","title":"WATLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WATLEV = 'watlev'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.BOTLEV","title":"BOTLEV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTLEV = 'botlev'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.VEL","title":"VEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VEL = 'vel'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.FRCOEF","title":"FRCOEF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRCOEF = 'frcoef'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.WIND","title":"WIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIND = 'wind'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.AICE","title":"AICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AICE = 'aice'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PROPAGAT","title":"PROPAGAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPAGAT = 'propagat'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PROPXY","title":"PROPXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPXY = 'propxy'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PROPTHETA","title":"PROPTHETA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPTHETA = 'proptheta'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PROPSIGMA","title":"PROPSIGMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPSIGMA = 'propsigma'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.GENERAT","title":"GENERAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAT = 'generat'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.GENWIND","title":"GENWIND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENWIND = 'genwind'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.REDIST","title":"REDIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDIST = 'redist'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.REDQUAD","title":"REDQUAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDQUAD = 'redquad'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.REDTRIAD","title":"REDTRIAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDTRIAD = 'redtriad'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISSIP","title":"DISSIP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSIP = 'dissip'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISBOT","title":"DISBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISBOT = 'disbot'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISSURF","title":"DISSURF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSURF = 'dissurf'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISWCAP","title":"DISWCAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISWCAP = 'diswcap'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISSWELL","title":"DISSWELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISSWELL = 'disswell'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISVEG","title":"DISVEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISVEG = 'disveg'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISMUD","title":"DISMUD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISMUD = 'dismud'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DISICE","title":"DISICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISICE = 'disice'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.RADSTR","title":"RADSTR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RADSTR = 'radstr'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.QB","title":"QB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QB = 'qb'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TRANSP","title":"TRANSP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSP = 'transp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.FORCE","title":"FORCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCE = 'force'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.UBOT","title":"UBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UBOT = 'ubot'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.URMS","title":"URMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>URMS = 'urms'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TMBOT","title":"TMBOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TMBOT = 'tmbot'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.WLENGTH","title":"WLENGTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WLENGTH = 'wlength'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.LWAVP","title":"LWAVP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LWAVP = 'lwavp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.STEEPNESS","title":"STEEPNESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STEEPNESS = 'steepness'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.BFI","title":"BFI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BFI = 'bfi'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.NPLANTS","title":"NPLANTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NPLANTS = 'nplants'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DHSIGN","title":"DHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DHSIGN = 'dhsign'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DRTM01","title":"DRTM01  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRTM01 = 'drtm01'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.LEAK","title":"LEAK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LEAK = 'leak'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TIME","title":"TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME = 'time'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.TSEC","title":"TSEC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSEC = 'tsec'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.XP","title":"XP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XP = 'xp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.YP","title":"YP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YP = 'yp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.DIST","title":"DIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIST = 'dist'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.SETUP","title":"SETUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SETUP = 'setup'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTHSIGN","title":"PTHSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTHSIGN = 'pthsign'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTRTP","title":"PTRTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTRTP = 'ptrtp'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTWLEN","title":"PTWLEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWLEN = 'ptwlen'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTDIR","title":"PTDIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDIR = 'ptdir'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTDSPR","title":"PTDSPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTDSPR = 'ptdspr'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTWFRAC","title":"PTWFRAC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTWFRAC = 'ptwfrac'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PTSTEEPNE","title":"PTSTEEPNE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PTSTEEPNE = 'ptsteepne'\n</code></pre>"},{"location":"reference/types/#rompy_swan.types.BlockOptions.PARTITION","title":"PARTITION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTITION = 'partition'\n</code></pre>"},{"location":"subcomponents/base/","title":"Base","text":"<p>Sub-commands to support the output components</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY","title":"XY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Points in problem coordinates.</p> <p>.. code-block:: text</p> <pre><code>&lt; [x] [y] &gt;\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY--note","title":"Note","text":"<p>Coordinates should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.base import XY\npoints = XY(\n    x=[172, 172, 172, 172.5, 173],\n    y=[-41, -40.5, -40, -40, -40],\n    fmt=\"0.2f\",\n)\nprint(points.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>class XY(BaseSubComponent):\n    \"\"\"Points in problem coordinates.\n\n    .. code-block:: text\n\n        &lt; [x] [y] &gt;\n\n    Note\n    ----\n    Coordinates should be given in m when Cartesian coordinates are used or degrees\n    when Spherical coordinates are used (see command `COORD`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.base import XY\n        points = XY(\n            x=[172, 172, 172, 172.5, 173],\n            y=[-41, -40.5, -40, -40, -40],\n            fmt=\"0.2f\",\n        )\n        print(points.render())\n\n    \"\"\"\n\n    model_type: Literal[\"xy\", \"XY\"] = Field(\n        default=\"xy\",\n        description=\"Model type discriminator\",\n    )\n    x: list[float] = Field(description=\"Problem x-coordinate values\")\n    y: list[float] = Field(description=\"Problem y-coordinate values\")\n    fmt: str = Field(\n        default=\"0.8f\",\n        description=\"The format to render floats values\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_size(self) -&gt; \"XY\":\n        if len(self.x) != len(self.y):\n            raise ValueError(\"x and y must be the same size\")\n        return self\n\n    @property\n    def size(self):\n        return len(self.x)\n\n    def cmd(self) -&gt; str:\n        repr = \"\"\n        for x, y in zip(self.x, self.y):\n            repr += f\"\\n{x:{self.fmt}} {y:{self.fmt}}\"\n        return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY-attributes","title":"Attributes","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['xy', 'XY'] = Field(default='xy', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: list[float] = Field(description='Problem x-coordinate values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: list[float] = Field(description='Problem y-coordinate values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.fmt","title":"fmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmt: str = Field(default='0.8f', description='The format to render floats values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY-functions","title":"Functions","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.validate_size","title":"validate_size","text":"<pre><code>validate_size() -&gt; XY\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_size(self) -&gt; \"XY\":\n    if len(self.x) != len(self.y):\n        raise ValueError(\"x and y must be the same size\")\n    return self\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.XY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"\"\n    for x, y in zip(self.x, self.y):\n        repr += f\"\\n{x:{self.fmt}} {y:{self.fmt}}\"\n    return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ","title":"IJ","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Points in grid indices coordinates.</p> <p>.. code-block:: text</p> <pre><code>&lt; [x] [y] &gt;\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ--note","title":"Note","text":"<p>Coordinates should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command <code>COORD</code>).</p>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.base import IJ\npoints = IJ(i=[0, 0, 5], j=[0, 19, 19])\nprint(points.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>class IJ(BaseSubComponent):\n    \"\"\"Points in grid indices coordinates.\n\n    .. code-block:: text\n\n        &lt; [x] [y] &gt;\n\n    Note\n    ----\n    Coordinates should be given in m when Cartesian coordinates are used or degrees\n    when Spherical coordinates are used (see command `COORD`).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.base import IJ\n        points = IJ(i=[0, 0, 5], j=[0, 19, 19])\n        print(points.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ij\", \"IJ\"] = Field(\n        default=\"ij\",\n        description=\"Model type discriminator\",\n    )\n    i: list[int] = Field(description=\"i-index values\")\n    j: list[int] = Field(description=\"j-index values\")\n\n    @model_validator(mode=\"after\")\n    def validate_size(self) -&gt; \"IJ\":\n        if len(self.i) != len(self.j):\n            raise ValueError(\"i and j must be the same size\")\n        return self\n\n    @property\n    def size(self):\n        return len(self.i)\n\n    def cmd(self) -&gt; str:\n        repr = \"\"\n        for i, j in zip(self.i, self.j):\n            repr += f\"\\ni={i} j={j}\"\n        return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ-attributes","title":"Attributes","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ij', 'IJ'] = Field(default='ij', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.i","title":"i  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i: list[int] = Field(description='i-index values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.j","title":"j  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>j: list[int] = Field(description='j-index values')\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ-functions","title":"Functions","text":""},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.validate_size","title":"validate_size","text":"<pre><code>validate_size() -&gt; IJ\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_size(self) -&gt; \"IJ\":\n    if len(self.i) != len(self.j):\n        raise ValueError(\"i and j must be the same size\")\n    return self\n</code></pre>"},{"location":"subcomponents/base/#rompy_swan.subcomponents.base.IJ.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/base.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"\"\n    for i, j in zip(self.i, self.j):\n        repr += f\"\\ni={i} j={j}\"\n    return repr + \"\\n\"\n</code></pre>"},{"location":"subcomponents/boundary/","title":"Boundary and initial conditions","text":"<p>Sub-commands to support the boundary and initial conditions components</p>"},{"location":"subcomponents/boundary/#boundary","title":"Boundary","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE","title":"SIDE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Boundary over one side of computational domain.</p> <p>.. code-block:: text</p> <pre><code>SIDE NORTH|NW|WEST|SW|SOUTH|SE|E|NE CCW|CLOCKWISE\n</code></pre> <p>The boundary is one full side of the computational grid (in 1D cases either of the two ends of the 1D-grid).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE--note","title":"Note","text":"<p>Should not be used in case of CURVILINEAR grids.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import SIDE\nside = SIDE(side=\"west\", direction=\"ccw\")\nprint(side.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class SIDE(BaseSubComponent):\n    \"\"\"Boundary over one side of computational domain.\n\n    .. code-block:: text\n\n        SIDE NORTH|NW|WEST|SW|SOUTH|SE|E|NE CCW|CLOCKWISE\n\n    The boundary is one full side of the computational grid (in 1D cases either of the\n    two ends of the 1D-grid).\n\n    Note\n    ----\n    Should not be used in case of CURVILINEAR grids.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import SIDE\n        side = SIDE(side=\"west\", direction=\"ccw\")\n        print(side.render())\n\n    \"\"\"\n\n    model_type: Literal[\"side\", \"SIDE\"] = Field(\n        default=\"side\",\n        description=\"Model type discriminator\",\n    )\n    side: Literal[\"north\", \"nw\", \"west\", \"sw\", \"south\", \"se\", \"east\", \"ne\"] = Field(\n        description=\"The side of the grid to apply the boundary to\",\n    )\n    direction: Literal[\"ccw\", \"clockwise\"] = Field(\n        default=\"ccw\",\n        description=\"The direction to apply the boundary in\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = f\"SIDE {self.side.upper()} {self.direction.upper()} \"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['side', 'SIDE'] = Field(default='side', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: Literal['north', 'nw', 'west', 'sw', 'south', 'se', 'east', 'ne'] = Field(description='The side of the grid to apply the boundary to')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.direction","title":"direction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction: Literal['ccw', 'clockwise'] = Field(default='ccw', description='The direction to apply the boundary in')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SIDE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"SIDE {self.side.upper()} {self.direction.upper()} \"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT","title":"SEGMENT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Boundary over a segment defined from points.</p> <p>.. code-block:: text</p> <pre><code>SEGMENT XY &lt; [x] [y] &gt;\nSEGMENT IJ &lt; [i] [j] &gt;\n</code></pre> <p>The segment is defined either by means of a series of points in terms of problem coordinates (<code>XY</code>) or by means of a series of points in terms of grid indices (<code>IJ</code>). The points do not have to include all or coincide with actual grid points.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import SEGMENT\nseg = SEGMENT(\n    points=dict(\n        model_type=\"xy\",\n        x=[172, 172, 172, 172.5, 173],\n        y=[-41, -40.5, -40, -40, -40],\n        fmt=\"0.2f\",\n    ),\n)\nprint(seg.render())\nseg = SEGMENT(\n    points=dict(\n        model_type=\"ij\",\n        i=[0, 0, 5],\n        j=[0, 19, 19],\n    ),\n)\nprint(seg.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class SEGMENT(BaseSubComponent):\n    \"\"\"Boundary over a segment defined from points.\n\n    .. code-block:: text\n\n        SEGMENT XY &lt; [x] [y] &gt;\n        SEGMENT IJ &lt; [i] [j] &gt;\n\n    The segment is defined either by means of a series of points in terms of problem\n    coordinates (`XY`) or by means of a series of points in terms of grid indices\n    (`IJ`). The points do not have to include all or coincide with actual grid points.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import SEGMENT\n        seg = SEGMENT(\n            points=dict(\n                model_type=\"xy\",\n                x=[172, 172, 172, 172.5, 173],\n                y=[-41, -40.5, -40, -40, -40],\n                fmt=\"0.2f\",\n            ),\n        )\n        print(seg.render())\n        seg = SEGMENT(\n            points=dict(\n                model_type=\"ij\",\n                i=[0, 0, 5],\n                j=[0, 19, 19],\n            ),\n        )\n        print(seg.render())\n\n    \"\"\"\n\n    model_type: Literal[\"segment\", \"SEGMENT\"] = Field(\n        default=\"segment\",\n        description=\"Model type discriminator\",\n    )\n    points: Union[XY, IJ] = Field(\n        description=\"Points to define the segment\",\n        discriminator=\"model_type\",\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"SEGMENT {self.points.model_type.upper()} {self.points.render()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['segment', 'SEGMENT'] = Field(default='segment', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Union[XY, IJ] = Field(description='Points to define the segment', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.SEGMENT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"SEGMENT {self.points.model_type.upper()} {self.points.render()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR","title":"PAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spectral parameters.</p> <p>.. code-block:: text</p> <pre><code>PAR [hs] [per] [dir] [dd]\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import PAR\npar = PAR(hs=1.5, per=8.1, dir=225)\nprint(par.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class PAR(BaseSubComponent):\n    \"\"\"Spectral parameters.\n\n    .. code-block:: text\n\n        PAR [hs] [per] [dir] [dd]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import PAR\n        par = PAR(hs=1.5, per=8.1, dir=225)\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"par\"] = Field(\n        default=\"par\",\n        description=\"Model type discriminator\",\n    )\n    hs: float = Field(\n        description=\"The significant wave height (m)\",\n        gt=0.0,\n    )\n    per: float = Field(\n        description=(\n            \"The characteristic period (s) of the energy spectrum (relative \"\n            \"frequency; which is equal to absolute frequency in the absence of \"\n            \"currents); `per` is the value of the peak period if option PEAK is \"\n            \"chosen in command BOUND SHAPE or `per` is the value of the mean period, \"\n            \"if option MEAN was chosen in command BOUND SHAPE.\"\n        ),\n        gt=0.0,\n    )\n    dir: float = Field(\n        description=(\n            \"The peak wave direction thetapeak (degree), constant over frequencies\"\n        ),\n        ge=-360.0,\n        le=360.0,\n    )\n    dd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient of directional spreading; a `cos^m(\u03b8)` distribution is \"\n            \"assumed. `dd` is interpreted as the directional standard deviation in \"\n            \"degrees, if the option DEGREES is chosen in the command BOUND SHAPE \"\n            \"(SWAN default: 30). `dd` is interpreted as the power `m`, if the option \"\n            \"POWER is chosen in the command BOUND SHAPE (SWAN default: 2)\"\n        ),\n        ge=0.0,\n        le=360.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"PAR hs={self.hs} per={self.per} dir={self.dir}\"\n        if self.dd is not None:\n            repr += f\" dd={self.dd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['par'] = Field(default='par', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.hs","title":"hs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hs: float = Field(description='The significant wave height (m)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.per","title":"per  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per: float = Field(description='The characteristic period (s) of the energy spectrum (relative frequency; which is equal to absolute frequency in the absence of currents); `per` is the value of the peak period if option PEAK is chosen in command BOUND SHAPE or `per` is the value of the mean period, if option MEAN was chosen in command BOUND SHAPE.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: float = Field(description='The peak wave direction thetapeak (degree), constant over frequencies', ge=-360.0, le=360.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.dd","title":"dd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dd: Optional[float] = Field(default=None, description='Coefficient of directional spreading; a `cos^m(\u03b8)` distribution is assumed. `dd` is interpreted as the directional standard deviation in degrees, if the option DEGREES is chosen in the command BOUND SHAPE (SWAN default: 30). `dd` is interpreted as the power `m`, if the option POWER is chosen in the command BOUND SHAPE (SWAN default: 2)', ge=0.0, le=360.0)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.PAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"PAR hs={self.hs} per={self.per} dir={self.dir}\"\n    if self.dd is not None:\n        repr += f\" dd={self.dd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR","title":"CONSTANTPAR","text":"<p>               Bases: <code>PAR</code></p> <p>Constant spectral parameters.</p> <p>.. code-block:: text</p> <pre><code>CONSTANT PAR [hs] [per] [dir] ([dd])\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import CONSTANTPAR\npar = CONSTANTPAR(hs=1.5, per=8.1, dir=225)\nprint(par.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class CONSTANTPAR(PAR):\n    \"\"\"Constant spectral parameters.\n\n    .. code-block:: text\n\n        CONSTANT PAR [hs] [per] [dir] ([dd])\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import CONSTANTPAR\n        par = CONSTANTPAR(hs=1.5, per=8.1, dir=225)\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constantpar\", \"CONSTANTPAR\"] = Field(\n        default=\"constantpar\",\n        description=\"Model type discriminator\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"CONSTANT {super().cmd()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constantpar', 'CONSTANTPAR'] = Field(default='constantpar', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTPAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"CONSTANT {super().cmd()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR","title":"VARIABLEPAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Variable spectral parameter.</p> <p>.. code-block:: text</p> <pre><code>VARIABLE PAR &lt; [len] [hs] [per] [dir] [dd] &gt;\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import VARIABLEPAR\npar = VARIABLEPAR(\n    hs=[1.5, 1.4, 1.1],\n    per=[8.1, 8.0, 8.1],\n    dir=[225, 226, 228],\n    dd=[25, 22, 23],\n    len=[0, 0.5, 1.0],\n)\nprint(par.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class VARIABLEPAR(BaseSubComponent):\n    \"\"\"Variable spectral parameter.\n\n    .. code-block:: text\n\n        VARIABLE PAR &lt; [len] [hs] [per] [dir] [dd] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import VARIABLEPAR\n        par = VARIABLEPAR(\n            hs=[1.5, 1.4, 1.1],\n            per=[8.1, 8.0, 8.1],\n            dir=[225, 226, 228],\n            dd=[25, 22, 23],\n            len=[0, 0.5, 1.0],\n        )\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"variablepar\", \"VARIABLEPAR\"] = Field(\n        default=\"variablepar\",\n        description=\"Model type discriminator\",\n    )\n    hs: list[Annotated[float, Field(ge=0.0)]] = Field(\n        description=\"The significant wave height (m)\",\n    )\n    per: list[Annotated[float, Field(ge=0.0)]] = Field(\n        description=(\n            \"The characteristic period (s) of the energy spectrum (relative \"\n            \"frequency; which is equal to absolute frequency in the absence of \"\n            \"currents); `per` is the value of the peak period if option PEAK is \"\n            \"chosen in command BOUND SHAPE or `per` is the value of the mean period, \"\n            \"if option MEAN was chosen in command BOUND SHAPE\"\n        ),\n    )\n    dir: list[Annotated[float, Field(ge=-360.0, le=360.0)]] = Field(\n        description=(\n            \"The peak wave direction thetapeak (degrees), constant over frequencies\"\n        ),\n    )\n    dd: list[Annotated[float, Field(ge=0.0, le=360.0)]] = Field(\n        description=(\n            \"Coefficient of directional spreading; a $cos^m(\u03b8)$ distribution is \"\n            \"assumed. `dd` is interpreted as the directional standard deviation in \"\n            \"degrees, if the option DEGREES is chosen in the command BOUND SHAPE \"\n            \"(SWAN default: 30). `dd` is interpreted as the power `m`, if the option \"\n            \"POWER is chosen in the command BOUND SHAPE (SWAN default: 2)\"\n        ),\n    )\n    dist: list[Annotated[float, Field(ge=0)]] = Field(\n        alias=\"len\",\n        description=(\n            \"Is the distance from the first point of the side or segment to the point \"\n            \"along the side or segment for which the incident wave spectrum is \"\n            \"prescribed. Note: these points do no have to coincide with grid points of \"\n            \"the computational grid. `len` is the distance in m or degrees in the case \"\n            \"of spherical coordinates, not in grid steps. The values of `len` should \"\n            \"be given in ascending order. The length along a SIDE is measured in \"\n            \"clockwise or counterclockwise direction, depending on the options CCW or \"\n            \"CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT \"\n            \"the length is measured from the indicated begin point of the segment\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"VARIABLEPAR\":\n        for key in [\"hs\", \"per\", \"dir\", \"dd\"]:\n            if len(getattr(self, key)) != len(self.dist):\n                raise ValueError(f\"Size of dist and {key} must be the same\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = \"VARIABLE PAR\"\n        for dist, hs, per, dir, dd in zip(\n            self.dist, self.hs, self.per, self.dir, self.dd\n        ):\n            repr += f\" &amp;\\n\\tlen={dist} hs={hs} per={per} dir={dir} dd={dd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['variablepar', 'VARIABLEPAR'] = Field(default='variablepar', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.hs","title":"hs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hs: list[Annotated[float, Field(ge=0.0)]] = Field(description='The significant wave height (m)')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.per","title":"per  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per: list[Annotated[float, Field(ge=0.0)]] = Field(description='The characteristic period (s) of the energy spectrum (relative frequency; which is equal to absolute frequency in the absence of currents); `per` is the value of the peak period if option PEAK is chosen in command BOUND SHAPE or `per` is the value of the mean period, if option MEAN was chosen in command BOUND SHAPE')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir: list[Annotated[float, Field(ge=-360.0, le=360.0)]] = Field(description='The peak wave direction thetapeak (degrees), constant over frequencies')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dd","title":"dd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dd: list[Annotated[float, Field(ge=0.0, le=360.0)]] = Field(description='Coefficient of directional spreading; a $cos^m(\u03b8)$ distribution is assumed. `dd` is interpreted as the directional standard deviation in degrees, if the option DEGREES is chosen in the command BOUND SHAPE (SWAN default: 30). `dd` is interpreted as the power `m`, if the option POWER is chosen in the command BOUND SHAPE (SWAN default: 2)')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.dist","title":"dist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist: list[Annotated[float, Field(ge=0)]] = Field(alias='len', description='Is the distance from the first point of the side or segment to the point along the side or segment for which the incident wave spectrum is prescribed. Note: these points do no have to coincide with grid points of the computational grid. `len` is the distance in m or degrees in the case of spherical coordinates, not in grid steps. The values of `len` should be given in ascending order. The length along a SIDE is measured in clockwise or counterclockwise direction, depending on the options CCW or CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT the length is measured from the indicated begin point of the segment')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; VARIABLEPAR\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"VARIABLEPAR\":\n    for key in [\"hs\", \"per\", \"dir\", \"dd\"]:\n        if len(getattr(self, key)) != len(self.dist):\n            raise ValueError(f\"Size of dist and {key} must be the same\")\n    return self\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEPAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = \"VARIABLE PAR\"\n    for dist, hs, per, dir, dd in zip(\n        self.dist, self.hs, self.per, self.dir, self.dd\n    ):\n        repr += f\" &amp;\\n\\tlen={dist} hs={hs} per={per} dir={dir} dd={dd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE","title":"CONSTANTFILE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Constant file specification.</p> <p>.. code-block:: text</p> <pre><code>CONSTANT FILE 'fname' [seq]\n</code></pre> <p>There are three types of files:</p> <ul> <li>TPAR files containing nonstationary wave parameters</li> <li>files containing stationary or nonstationary 1D spectra   (usually from measurements)</li> <li>files containing stationary or nonstationary 2D spectra   (from other computer programs or other SWAN runs)</li> </ul> <p>A TPAR file is for only one location; it has the string TPAR on the first line of the file and a number of lines which each contain 5 numbers, i.e.: Time (ISO-notation), Hs, Period (average or peak period depending on the choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian, depending on command SET), Directional spread (in degrees or as power of cos depending on the choice given in command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE--note","title":"Note","text":"<p>Example of a TPAR file:</p> <p>.. code-block:: text</p> <pre><code>TPAR\n19920516.130000 4.2 12. -110. 22.\n19920516.180000 4.2 12. -110. 22.\n19920517.000000 1.2 8. -110. 22.\n19920517.120000 1.4 8.5 -80. 26\n19920517.200000 0.9 6.5 -95. 28\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import CONSTANTFILE\npar = CONSTANTFILE(fname=\"tpar.txt\")\nprint(par.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class CONSTANTFILE(BaseSubComponent):\n    \"\"\"Constant file specification.\n\n    .. code-block:: text\n\n        CONSTANT FILE 'fname' [seq]\n\n    There are three types of files:\n\n    - TPAR files containing nonstationary wave parameters\n    - files containing stationary or nonstationary 1D spectra\n      (usually from measurements)\n    - files containing stationary or nonstationary 2D spectra\n      (from other computer programs or other SWAN runs)\n\n    A TPAR file is for only one location; it has the string TPAR on the first\n    line of the file and a number of lines which each contain 5 numbers, i.e.:\n    Time (ISO-notation), Hs, Period (average or peak period depending on the\n    choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian,\n    depending on command SET), Directional spread (in degrees or as power of cos\n    depending on the choice given in command BOUND SHAPE).\n\n    Note\n    ----\n    Example of a TPAR file:\n\n    .. code-block:: text\n\n        TPAR\n        19920516.130000 4.2 12. -110. 22.\n        19920516.180000 4.2 12. -110. 22.\n        19920517.000000 1.2 8. -110. 22.\n        19920517.120000 1.4 8.5 -80. 26\n        19920517.200000 0.9 6.5 -95. 28\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import CONSTANTFILE\n        par = CONSTANTFILE(fname=\"tpar.txt\")\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"constantfile\", \"CONSTANTFILE\"] = Field(\n        default=\"constantfile\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the boundary condition.\",\n        max_length=36,\n    )\n    seq: Optional[int] = Field(\n        default=None,\n        description=(\n            \"sequence number of geographic location in the file (see Appendix D); \"\n            \"useful for files which contain spectra for more than one location. \"\n            \"Note: a TPAR file always contains only one location so in this case \"\n            \"`seq` must always be 1\"\n        ),\n        ge=1,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"CONSTANT FILE fname='{self.fname}'\"\n        if self.seq is not None:\n            repr += f\" seq={self.seq}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['constantfile', 'CONSTANTFILE'] = Field(default='constantfile', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the boundary condition.', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.seq","title":"seq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seq: Optional[int] = Field(default=None, description='sequence number of geographic location in the file (see Appendix D); useful for files which contain spectra for more than one location. Note: a TPAR file always contains only one location so in this case `seq` must always be 1', ge=1)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.CONSTANTFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"CONSTANT FILE fname='{self.fname}'\"\n    if self.seq is not None:\n        repr += f\" seq={self.seq}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE","title":"VARIABLEFILE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Variable file specification.</p> <p>.. code-block:: text</p> <pre><code>VARIABLE FILE &lt; [len] 'fname' [seq] &gt;\n</code></pre> <p>There are three types of files:</p> <ul> <li>TPAR files containing nonstationary wave parameters</li> <li>files containing stationary or nonstationary 1D spectra   (usually from measurements)</li> <li>files containing stationary or nonstationary 2D spectra   (from other computer programs or other SWAN runs)</li> </ul> <p>A TPAR file is for only one location; it has the string TPAR on the first line of the file and a number of lines which each contain 5 numbers, i.e.: Time (ISO-notation), Hs, Period (average or peak period depending on the choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian, depending on command SET), Directional spread (in degrees or as power of cos depending on the choice given in command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE--note","title":"Note","text":"<p>Example of a TPAR file:</p> <p>.. code-block:: text</p> <pre><code>TPAR\n19920516.130000 4.2 12. -110. 22.\n19920516.180000 4.2 12. -110. 22.\n19920517.000000 1.2 8. -110. 22.\n19920517.120000 1.4 8.5 -80. 26\n19920517.200000 0.9 6.5 -95. 28\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import VARIABLEFILE\npar = VARIABLEFILE(\n    fname=[\"tpar1.txt\", \"tpar2.txt\", \"tpar3.txt\"],\n    len=[0.0, 0.5, 1.0],\n)\nprint(par.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class VARIABLEFILE(BaseSubComponent):\n    \"\"\"Variable file specification.\n\n    .. code-block:: text\n\n        VARIABLE FILE &lt; [len] 'fname' [seq] &gt;\n\n    There are three types of files:\n\n    - TPAR files containing nonstationary wave parameters\n    - files containing stationary or nonstationary 1D spectra\n      (usually from measurements)\n    - files containing stationary or nonstationary 2D spectra\n      (from other computer programs or other SWAN runs)\n\n    A TPAR file is for only one location; it has the string TPAR on the first\n    line of the file and a number of lines which each contain 5 numbers, i.e.:\n    Time (ISO-notation), Hs, Period (average or peak period depending on the\n    choice given in command BOUND SHAPE), Peak Direction (Nautical or Cartesian,\n    depending on command SET), Directional spread (in degrees or as power of cos\n    depending on the choice given in command BOUND SHAPE).\n\n    Note\n    ----\n    Example of a TPAR file:\n\n    .. code-block:: text\n\n        TPAR\n        19920516.130000 4.2 12. -110. 22.\n        19920516.180000 4.2 12. -110. 22.\n        19920517.000000 1.2 8. -110. 22.\n        19920517.120000 1.4 8.5 -80. 26\n        19920517.200000 0.9 6.5 -95. 28\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import VARIABLEFILE\n        par = VARIABLEFILE(\n            fname=[\"tpar1.txt\", \"tpar2.txt\", \"tpar3.txt\"],\n            len=[0.0, 0.5, 1.0],\n        )\n        print(par.render())\n\n    \"\"\"\n\n    model_type: Literal[\"variablefile\", \"VARIABLEFILE\"] = Field(\n        default=\"variablefile\",\n        description=\"Model type discriminator\",\n    )\n    fname: list[Annotated[str, Field(max_length=36)]] = Field(\n        description=\"Names of the files containing the boundary condition\",\n    )\n    seq: Optional[list[Annotated[int, Field(ge=1)]]] = Field(\n        default=None,\n        description=(\n            \"sequence number of geographic location in the file (see Appendix D); \"\n            \"useful for files which contain spectra for more than one location. \"\n            \"Note: a TPAR file always contains only one location so in this case \"\n            \"[seq] must always be 1.\"\n        ),\n    )\n    dist: list[Annotated[float, Field(ge=0)]] = Field(\n        alias=\"len\",\n        description=(\n            \"Is the distance from the first point of the side or segment to the point \"\n            \"along the side or segment for which the incident wave spectrum is \"\n            \"prescribed. Note: these points do no have to coincide with grid points \"\n            \"of the computational grid. [len] is the distance in m or degrees in the \"\n            \"case of spherical coordinates, not in grid steps. The values of `len` \"\n            \"should be given in ascending order. The length along a SIDE is measured \"\n            \"in clockwise or counterclockwise direction, depending on the options CCW \"\n            \"or CLOCKWISE (see above). The option CCW is default. In case of a \"\n            \"SEGMENT the length is measured from the indicated begin point of the \"\n            \"segment.\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_equal_size(self) -&gt; \"VARIABLEFILE\":\n        for key in [\"fname\", \"seq\"]:\n            attr = getattr(self, key)\n            if attr is not None and len(attr) != len(self.dist):\n                raise ValueError(f\"Size of dist and {key} must be the same\")\n        if self.seq is None:\n            self.seq = [1] * len(self.dist)\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = \"VARIABLE FILE\"\n        for dist, fname, seq in zip(self.dist, self.fname, self.seq):\n            repr += f\" &amp;\\n\\tlen={dist} fname='{fname}' seq={seq}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['variablefile', 'VARIABLEFILE'] = Field(default='variablefile', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: list[Annotated[str, Field(max_length=36)]] = Field(description='Names of the files containing the boundary condition')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.seq","title":"seq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seq: Optional[list[Annotated[int, Field(ge=1)]]] = Field(default=None, description='sequence number of geographic location in the file (see Appendix D); useful for files which contain spectra for more than one location. Note: a TPAR file always contains only one location so in this case [seq] must always be 1.')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.dist","title":"dist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist: list[Annotated[float, Field(ge=0)]] = Field(alias='len', description='Is the distance from the first point of the side or segment to the point along the side or segment for which the incident wave spectrum is prescribed. Note: these points do no have to coincide with grid points of the computational grid. [len] is the distance in m or degrees in the case of spherical coordinates, not in grid steps. The values of `len` should be given in ascending order. The length along a SIDE is measured in clockwise or counterclockwise direction, depending on the options CCW or CLOCKWISE (see above). The option CCW is default. In case of a SEGMENT the length is measured from the indicated begin point of the segment.')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.ensure_equal_size","title":"ensure_equal_size","text":"<pre><code>ensure_equal_size() -&gt; VARIABLEFILE\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_equal_size(self) -&gt; \"VARIABLEFILE\":\n    for key in [\"fname\", \"seq\"]:\n        attr = getattr(self, key)\n        if attr is not None and len(attr) != len(self.dist):\n            raise ValueError(f\"Size of dist and {key} must be the same\")\n    if self.seq is None:\n        self.seq = [1] * len(self.dist)\n    return self\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.VARIABLEFILE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = \"VARIABLE FILE\"\n    for dist, fname, seq in zip(self.dist, self.fname, self.seq):\n        repr += f\" &amp;\\n\\tlen={dist} fname='{fname}' seq={seq}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/boundary/#initial-conditions","title":"Initial conditions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT","title":"DEFAULT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Default initial conditions.</p> <p>.. code-block:: text</p> <pre><code>DEFAULT\n</code></pre> <p>The initial spectra are computed from the local wind velocities, using the deep-water growth curve of Kahma and Calkoen (1992), cut off at values of significant wave height and peak frequency from Pierson and Moskowitz (1964). The average (over the model area) spatial step size is used as fetch with local wind. The shape of the spectrum is default JONSWAP with a cos2-directional distribution (options are available: see command BOUND SHAPE).</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import DEFAULT\ninit = DEFAULT()\nprint(init.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class DEFAULT(BaseSubComponent):\n    \"\"\"Default initial conditions.\n\n    .. code-block:: text\n\n        DEFAULT\n\n    The initial spectra are computed from the local wind velocities, using the\n    deep-water growth curve of Kahma and Calkoen (1992), cut off at values of\n    significant wave height and peak frequency from Pierson and Moskowitz (1964).\n    The average (over the model area) spatial step size is used as fetch with local\n    wind. The shape of the spectrum is default JONSWAP with a cos2-directional\n    distribution (options are available: see command BOUND SHAPE).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import DEFAULT\n        init = DEFAULT()\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"default\", \"DEFAULT\"] = Field(\n        default=\"default\",\n        description=\"Model type discriminator\",\n    )\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.DEFAULT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['default', 'DEFAULT'] = Field(default='default', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO","title":"ZERO","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Zero initial conditions.</p> <p>.. code-block:: text</p> <pre><code>ZERO\n</code></pre> <p>The initial spectral densities are all 0; note that if waves are generated in the model only by wind, waves can become non-zero only by the presence of the \u201dA\u201d term in the growth model; see the keyword AGROW in command GEN3.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import ZERO\ninit = ZERO()\nprint(init.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class ZERO(BaseSubComponent):\n    \"\"\"Zero initial conditions.\n\n    .. code-block:: text\n\n        ZERO\n\n    The initial spectral densities are all 0; note that if waves are generated in the\n    model only by wind, waves can become non-zero only by the presence of the\n    \u201dA\u201d term in the growth model; see the keyword AGROW in command GEN3.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import ZERO\n        init = ZERO()\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"zero\", \"ZERO\"] = Field(\n        default=\"zero\",\n        description=\"Model type discriminator\",\n    )\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.ZERO.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['zero', 'ZERO'] = Field(default='zero', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE","title":"HOTSINGLE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Hotstart single initial conditions.</p> <p>.. code-block:: text</p> <pre><code>HOTSTART SINGLE fname='fname' FREE|UNFORMATTED\n</code></pre> <p>Initial wave field is read from file; this file was generated in a previous SWAN run by means of the HOTFILE command. If the previous run was nonstationary, the time found on the file will be assumed to be the initial time of computation. It can also be used for stationary computation as first guess. The computational grid (both in geographical space and in spectral space) must be identical to the one in the run in which the initial wave field was computed</p> <p>Input will be read from a single (concatenated) hotfile. In the case of a previous parallel MPI run, the concatenated hotfile can be created from a set of multiple hotfiles using the program hcat.exe, see Implementation Manual.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import HOTSINGLE\ninit = HOTSINGLE(fname=\"hotstart.swn\", format=\"free\")\nprint(init.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class HOTSINGLE(BaseSubComponent):\n    \"\"\"Hotstart single initial conditions.\n\n    .. code-block:: text\n\n        HOTSTART SINGLE fname='fname' FREE|UNFORMATTED\n\n    Initial wave field is read from file; this file was generated in a previous SWAN\n    run by means of the HOTFILE command. If the previous run was nonstationary,\n    the time found on the file will be assumed to be the initial time of computation. It\n    can also be used for stationary computation as first guess. The computational grid\n    (both in geographical space and in spectral space) must be identical to the one in\n    the run in which the initial wave field was computed\n\n    Input will be read from a single (concatenated) hotfile. In the case of a previous\n    parallel MPI run, the concatenated hotfile can be created from a set of multiple\n    hotfiles using the program hcat.exe, see Implementation Manual.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import HOTSINGLE\n        init = HOTSINGLE(fname=\"hotstart.swn\", format=\"free\")\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotsingle\", \"HOTSINGLE\"] = Field(\n        default=\"hotsingle\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the initial wave field\",\n        max_length=36,\n    )\n    format: Literal[\"free\", \"unformatted\"] = Field(\n        default=\"free\",\n        description=(\n            \"Format of the file containing the initial wave field. \"\n            \"FREE: free format, UNFORMATTED: binary format\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"HOTSTART SINGLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotsingle', 'HOTSINGLE'] = Field(default='hotsingle', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the initial wave field', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['free', 'unformatted'] = Field(default='free', description='Format of the file containing the initial wave field. FREE: free format, UNFORMATTED: binary format')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTSINGLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"HOTSTART SINGLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE","title":"HOTMULTIPLE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Hotstart multiple initial conditions.</p> <p>.. code-block:: text</p> <pre><code>HOTSTART MULTIPLE fname='fname' FREE|UNFORMATTED\n</code></pre> <p>Initial wave field is read from file; this file was generated in a previous SWAN run by means of the HOTFILE command. If the previous run was nonstationary, the time found on the file will be assumed to be the initial time of computation. It can also be used for stationary computation as first guess. The computational grid (both in geographical space and in spectral space) must be identical to the one in the run in which the initial wave field was computed</p> <p>Input will be read from multiple hotfiles obtained from a previous parallel MPI run. The number of files equals the number of processors. Hence, for the present run the same number of processors must be chosen.</p>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.boundary import HOTMULTIPLE\ninit = HOTMULTIPLE(fname=\"hotstart.swn\", format=\"free\")\nprint(init.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>class HOTMULTIPLE(BaseSubComponent):\n    \"\"\"Hotstart multiple initial conditions.\n\n    .. code-block:: text\n\n        HOTSTART MULTIPLE fname='fname' FREE|UNFORMATTED\n\n    Initial wave field is read from file; this file was generated in a previous SWAN\n    run by means of the HOTFILE command. If the previous run was nonstationary,\n    the time found on the file will be assumed to be the initial time of computation. It\n    can also be used for stationary computation as first guess. The computational grid\n    (both in geographical space and in spectral space) must be identical to the one in\n    the run in which the initial wave field was computed\n\n    Input will be read from multiple hotfiles obtained from a previous parallel MPI run.\n    The number of files equals the number of processors. Hence, for the present run the\n    same number of processors must be chosen.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.boundary import HOTMULTIPLE\n        init = HOTMULTIPLE(fname=\"hotstart.swn\", format=\"free\")\n        print(init.render())\n\n    \"\"\"\n\n    model_type: Literal[\"hotmultiple\", \"HOTMULTIPLE\"] = Field(\n        default=\"hotmultiple\",\n        description=\"Model type discriminator\",\n    )\n    fname: str = Field(\n        description=\"Name of the file containing the initial wave field\",\n        max_length=36,\n    )\n    format: Literal[\"free\", \"unformatted\"] = Field(\n        default=\"free\",\n        description=(\n            \"Format of the file containing the initial wave field. \"\n            \"FREE: free format, UNFORMATTED: binary format\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"HOTSTART MULTIPLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE-attributes","title":"Attributes","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['hotmultiple', 'HOTMULTIPLE'] = Field(default='hotmultiple', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the file containing the initial wave field', max_length=36)\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Literal['free', 'unformatted'] = Field(default='free', description='Format of the file containing the initial wave field. FREE: free format, UNFORMATTED: binary format')\n</code></pre>"},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE-functions","title":"Functions","text":""},{"location":"subcomponents/boundary/#rompy_swan.subcomponents.boundary.HOTMULTIPLE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/boundary.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"HOTSTART MULTIPLE fname='{self.fname}' {self.format.upper()}\"\n</code></pre>"},{"location":"subcomponents/cgrid/","title":"Computational grid","text":"<p>Sub-commands to support the computational grid components</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN","title":"CARTESIAN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Cartesian coordinates.</p> <p>.. code-block:: text</p> <pre><code>CARTESIAN\n</code></pre> <p>All locations and distances are in m. Coordinates are given with respect to x- and y-axes chosen by the user in the various commands.</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import CARTESIAN\ncoords = CARTESIAN()\nprint(coords.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>class CARTESIAN(BaseSubComponent):\n    \"\"\"Cartesian coordinates.\n\n    .. code-block:: text\n\n        CARTESIAN\n\n    All locations and distances are in m. Coordinates are given with respect\n    to x- and y-axes chosen by the user in the various commands.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import CARTESIAN\n        coords = CARTESIAN()\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"cartesian\", \"CARTESIAN\"] = Field(\n        default=\"cartesian\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN-attributes","title":"Attributes","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.CARTESIAN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['cartesian', 'CARTESIAN'] = Field(default='cartesian', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL","title":"SPHERICAL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spherical coordinates.</p> <p>.. code-block:: text</p> <pre><code>SPHERICAL [-&gt;CCM|QC]\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL--notes","title":"Notes","text":"<p>projection options:</p> <ul> <li>CCM: central conformal Mercator. The horizontal and vertical scales are   uniform in terms of cm/degree over the area shown. In the centre of the scale   is identical to that of the conventional Mercator projection (but only at   that centre). The area in the projection centre is therefore exactly conformal.</li> <li>QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical   scales are equal to one another in terms of cm/degree.</li> </ul> <p>All coordinates of locations and geographical grid sizes are given in degrees;<code>x</code> is longitude with <code>x = 0</code> being the Greenwich meridian and <code>x &gt; 0</code> is East of this meridian; <code>y</code> is latitude with <code>y &gt; 0</code> being the Northern hemisphere. Input and output grids have to be oriented with their x-axis to the East; mesh sizes are in degrees. All other distances are in meters.</p> <p>Note that spherical coordinates can also be used for relatively small areas, say 10 or 20 km horizontal dimension. This may be useful if one obtains the boundary conditions by nesting in an oceanic model which is naturally formulated in spherical coordinates. Note that in case of spherical coordinates regular grids must always be oriented E-W, N-S, i.e. <code>alpc=0</code>, <code>alpinp=0</code>, <code>alpfr=0</code> (see commands CGRID, INPUT GRID and FRAME, respectively).</p>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SPHERICAL\ncoords = SPHERICAL()\nprint(coords.render())\ncoords = SPHERICAL(projection=\"qc\")\nprint(coords.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>class SPHERICAL(BaseSubComponent):\n    \"\"\"Spherical coordinates.\n\n    .. code-block:: text\n\n        SPHERICAL [-&gt;CCM|QC]\n\n    Notes\n    -----\n\n    projection options:\n\n    * CCM: central conformal Mercator. The horizontal and vertical scales are\n      uniform in terms of cm/degree over the area shown. In the centre of the scale\n      is identical to that of the conventional Mercator projection (but only at\n      that centre). The area in the projection centre is therefore exactly conformal.\n    * QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical\n      scales are equal to one another in terms of cm/degree.\n\n    All coordinates of locations and geographical grid sizes are given in degrees;`x`\n    is longitude with `x = 0` being the Greenwich meridian and `x &gt; 0` is East of this\n    meridian; `y` is latitude with `y &gt; 0` being the Northern hemisphere. Input and\n    output grids have to be oriented with their x-axis to the East; mesh sizes are in\n    degrees. All other distances are in meters.\n\n    Note that spherical coordinates can also be used for relatively small areas, say 10\n    or 20 km horizontal dimension. This may be useful if one obtains the boundary\n    conditions by nesting in an oceanic model which is naturally formulated in\n    spherical coordinates. Note that in case of spherical coordinates regular grids\n    must always be oriented E-W, N-S, i.e. `alpc=0`, `alpinp=0`, `alpfr=0`\n    (see commands CGRID, INPUT GRID and FRAME, respectively).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SPHERICAL\n        coords = SPHERICAL()\n        print(coords.render())\n        coords = SPHERICAL(projection=\"qc\")\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spherical\", \"SPHERICAL\"] = Field(\n        default=\"spherical\", description=\"Model type discriminator\"\n    )\n    projection: Literal[\"ccm\", \"qc\"] = Field(\n        default=\"ccm\",\n        description=(\n            \"Defines the projection method in case of spherical coordinates, `ccm` \"\n            \"Central Conformal Mercator, `qc` means Quasi-cartesian\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        if self.projection is not None:\n            repr += f\" {self.projection.upper()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL-attributes","title":"Attributes","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spherical', 'SPHERICAL'] = Field(default='spherical', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.projection","title":"projection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projection: Literal['ccm', 'qc'] = Field(default='ccm', description='Defines the projection method in case of spherical coordinates, `ccm` Central Conformal Mercator, `qc` means Quasi-cartesian')\n</code></pre>"},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL-functions","title":"Functions","text":""},{"location":"subcomponents/cgrid/#rompy_swan.subcomponents.startup.SPHERICAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    if self.projection is not None:\n        repr += f\" {self.projection.upper()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/","title":"Numerics","text":"<p>Sub-commands to support the numerics components</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT","title":"BSBT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>BSBT first order propagation scheme.</p> <p>.. code-block:: text</p> <pre><code>BSTB\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import BSBT\nscheme = BSBT()\nprint(scheme.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class BSBT(BaseSubComponent):\n    \"\"\"BSBT first order propagation scheme.\n\n    .. code-block:: text\n\n        BSTB\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import BSBT\n        scheme = BSBT()\n        print(scheme.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bsbt\", \"BSBT\"] = Field(\n        default=\"bsbt\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        return \"BSBT\"\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bsbt', 'BSBT'] = Field(default='bsbt', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.BSBT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    return \"BSBT\"\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE","title":"GSE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Garden-sprinkler effect.</p> <p>.. code-block:: text</p> <pre><code>GSE [waveage] Sec|MIn|HR|DAy\n</code></pre> <p>Garden-sprinkler effect is to be counteracted in the S&amp;L propagation scheme (default for nonstationary regular grid computations) or in the propagation scheme for unstructured grids by adding a diffusion term to the basic equation. This may affect the numerical stability of SWAN.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import GSE\nscheme = GSE(waveage=dict(delt=86400, dfmt=\"day\"))\nprint(scheme.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class GSE(BaseSubComponent):\n    \"\"\"Garden-sprinkler effect.\n\n    .. code-block:: text\n\n        GSE [waveage] Sec|MIn|HR|DAy\n\n    Garden-sprinkler effect is to be counteracted in the S&amp;L propagation scheme\n    (default for nonstationary regular grid computations) or in the propagation\n    scheme for unstructured grids by adding a diffusion term to the basic equation.\n    This may affect the numerical stability of SWAN.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import GSE\n        scheme = GSE(waveage=dict(delt=86400, dfmt=\"day\"))\n        print(scheme.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gse\", \"GSE\"] = Field(\n        default=\"gse\", description=\"Model type discriminator\"\n    )\n    waveage: Optional[Delt] = Field(\n        default=None,\n        description=(\n            \"The time interval used to determine the diffusion which counteracts the \"\n            \"so-called garden-sprinkler effect. The default value of `waveage` is \"\n            \"zero, i.e. no added diffusion. The value of `waveage` should correspond \"\n            \"to the travel time of the waves over the computational region.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"GSE\"\n        if self.waveage is not None:\n            repr += f\" waveage={self.waveage.render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gse', 'GSE'] = Field(default='gse', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.waveage","title":"waveage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>waveage: Optional[Delt] = Field(default=None, description='The time interval used to determine the diffusion which counteracts the so-called garden-sprinkler effect. The default value of `waveage` is zero, i.e. no added diffusion. The value of `waveage` should correspond to the travel time of the waves over the computational region.')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.GSE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"GSE\"\n    if self.waveage is not None:\n        repr += f\" waveage={self.waveage.render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT","title":"STAT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Computation parameters in stationary computation.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class STAT(BaseSubComponent):\n    \"\"\"Computation parameters in stationary computation.\"\"\"\n\n    model_type: Literal[\"stat\", \"STAT\"] = Field(\n        default=\"stat\", description=\"Model type discriminator\"\n    )\n    mxitst: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of iterations for stationary computations. The \"\n            \"computation stops when this number is exceeded (SWAN default:  50)\"\n        ),\n    )\n    alfa: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Proportionality constant used in the frequency-dependent under-\"\n            \"relaxation technique. Based on experiences, a suggestion for this \"\n            \"parameter is `alfa = 0.01`. In case of diffraction computations, the use \"\n            \"of this parameter is recommended (SWAN default: 0.00)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"STATIONARY\"\n        if self.mxitst is not None:\n            repr += f\" mxitst={self.mxitst}\"\n        if self.alfa is not None:\n            repr += f\" alfa={self.alfa}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stat', 'STAT'] = Field(default='stat', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.mxitst","title":"mxitst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxitst: Optional[int] = Field(default=None, description='The maximum number of iterations for stationary computations. The computation stops when this number is exceeded (SWAN default:  50)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.alfa","title":"alfa  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alfa: Optional[float] = Field(default=None, description='Proportionality constant used in the frequency-dependent under-relaxation technique. Based on experiences, a suggestion for this parameter is `alfa = 0.01`. In case of diffraction computations, the use of this parameter is recommended (SWAN default: 0.00)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"STATIONARY\"\n    if self.mxitst is not None:\n        repr += f\" mxitst={self.mxitst}\"\n    if self.alfa is not None:\n        repr += f\" alfa={self.alfa}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT","title":"NONSTAT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Computation parameters in nonstationary computation.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class NONSTAT(BaseSubComponent):\n    \"\"\"Computation parameters in nonstationary computation.\"\"\"\n\n    model_type: Literal[\"nonstat\", \"NONSTAT\"] = Field(\n        default=\"nonstat\", description=\"Model type discriminator\"\n    )\n    mxitns: Optional[int] = Field(\n        default=None,\n        description=(\n            \"The maximum number of iterations per time step for nonstationary \"\n            \"computations. The computation moves to the next time step when this \"\n            \"number is exceeded (SWAN default: `mxitns = 1`\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"NONSTATIONARY\"\n        if self.mxitns is not None:\n            repr += f\" mxitns={self.mxitns}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstat', 'NONSTAT'] = Field(default='nonstat', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.mxitns","title":"mxitns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mxitns: Optional[int] = Field(default=None, description='The maximum number of iterations per time step for nonstationary computations. The computation moves to the next time step when this number is exceeded (SWAN default: `mxitns = 1`')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.NONSTAT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"NONSTATIONARY\"\n    if self.mxitns is not None:\n        repr += f\" mxitns={self.mxitns}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC","title":"STOPC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stopping criteria of  Zijlema and Van der Westhuysen (2005).</p> <p>.. code-block:: text</p> <pre><code>STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter]\n</code></pre> <p>With this option the user can influence the criterion for terminating the iterative procedure in the SWAN computations (both stationary and nonstationary). The criterion makes use of the second derivative, or curvature, of the iteration curve of the significant wave height. As the solution of a simulation approaches full convergence, the curvature of the iteration curve will tend to zero. SWAN stops the process if the relative change in Hs from one iteration to the next is less than <code>drel</code> and the curvature of the iteration curve of Hs normalized with Hs is less than <code>curvat</code> or the absolute change in Hs from one iteration to the next is less than <code>dabs</code>. Both conditions need to be fulfilled in more than fraction <code>npnts</code> percent of all wet grid points.</p> <p>With respect to the QC modelling, another stopping criteria will be employed. Namely, SWAN stops the iteration process if the absolute change in Hs from one iterate to another is less than <code>dabs</code> * Hinc, where Hinc is the representative incident wave height, or the relative change in Hs from one to the next iteration is less than <code>drel</code>. These criteria must be fulfilled in more than <code>npnts</code> percent of all active, well-defined points.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC--references","title":"References","text":"<ul> <li>Zijlema, M. and Van der Westhuysen, A. (2005). On convergence behaviour and   numerical accuracy in stationary SWAN simulations of nearshore wind wave spectra,   Coastal Engineering, 52(3), p. 337-256.</li> </ul>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import STOPC\nstop = STOPC()\nprint(stop.render())\nstop = STOPC(\n    dabs=0.005,\n    drel=0.01,\n    curvat=0.005,\n    npnts=99.5,\n    mode=dict(model_type=\"nonstat\", mxitns=1),\n    limiter=0.1,\n)\nprint(stop.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class STOPC(BaseSubComponent):\n    \"\"\"Stopping criteria of  Zijlema and Van der Westhuysen (2005).\n\n    .. code-block:: text\n\n        STOPC [dabs] [drel] [curvat] [npnts] -&gt;STAT|NONSTAT [limiter]\n\n    With this option the user can influence the criterion for terminating the iterative\n    procedure in the SWAN computations (both stationary and nonstationary). The\n    criterion makes use of the second derivative, or curvature, of the iteration curve\n    of the significant wave height. As the solution of a simulation approaches full\n    convergence, the curvature of the iteration curve will tend to zero. SWAN stops the\n    process if the relative change in Hs from one iteration to the next is less than\n    `drel` and the curvature of the iteration curve of Hs normalized with Hs is less\n    than `curvat` or the absolute change in Hs from one iteration to the next is less\n    than `dabs`. Both conditions need to be fulfilled in more than fraction `npnts`\n    percent of all wet grid points.\n\n    With respect to the QC modelling, another stopping criteria will be employed.\n    Namely, SWAN stops the iteration process if the absolute change in Hs from one\n    iterate to another is less than `dabs` * Hinc, where Hinc is the representative\n    incident wave height, or the relative change in Hs from one to the next iteration\n    is less than `drel`. These criteria must be fulfilled in more than `npnts`\n    percent of all active, well-defined points.\n\n    References\n    ----------\n    - Zijlema, M. and Van der Westhuysen, A. (2005). On convergence behaviour and\n      numerical accuracy in stationary SWAN simulations of nearshore wind wave spectra,\n      Coastal Engineering, 52(3), p. 337-256.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import STOPC\n        stop = STOPC()\n        print(stop.render())\n        stop = STOPC(\n            dabs=0.005,\n            drel=0.01,\n            curvat=0.005,\n            npnts=99.5,\n            mode=dict(model_type=\"nonstat\", mxitns=1),\n            limiter=0.1,\n        )\n        print(stop.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stopc\", \"STOPC\"] = Field(\n        default=\"stopc\", description=\"Model type discriminator\"\n    )\n    dabs: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum absolute change in Hs from one iteration to the next \"\n            \"(SWAN default: 0.005 [m] or 0.05 [-] in case of QC model)\"\n        ),\n    )\n    drel: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum relative change in Hs from one iteration to the next \"\n            \"(SWAN default: 0.01 [-])\"\n        ),\n    )\n    curvat: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum curvature of the iteration curve of Hs normalised with Hs \"\n            \"(SWAN default: 0.005 [-] (not used in the QC model))\"\n        ),\n    )\n    npnts: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Percentage of points in the computational grid above which the stopping \"\n            \"criteria needs to be satisfied (SWAN default: 99.5 [-])\"\n        ),\n    )\n    mode: Optional[Union[STAT, NONSTAT]] = Field(\n        default=None,\n        description=\"Termination criteria for stationary or nonstationary runs\",\n        discriminator=\"model_type\",\n    )\n    limiter: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Determines the maximum change per iteration of the energy density per \"\n            \"spectral-bin given in terms of a fraction of the omni-directional \"\n            \"Phillips level (SWAN default: 0.1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"STOPC\"\n        if self.dabs is not None:\n            repr += f\" dabs={self.dabs}\"\n        if self.drel is not None:\n            repr += f\" drel={self.drel}\"\n        if self.curvat is not None:\n            repr += f\" curvat={self.curvat}\"\n        if self.npnts is not None:\n            repr += f\" npnts={self.npnts}\"\n        if self.mode is not None:\n            repr += f\" {self.mode.render()}\"\n        if self.limiter is not None:\n            repr += f\" limiter={self.limiter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stopc', 'STOPC'] = Field(default='stopc', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.dabs","title":"dabs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dabs: Optional[float] = Field(default=None, description='Maximum absolute change in Hs from one iteration to the next (SWAN default: 0.005 [m] or 0.05 [-] in case of QC model)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.drel","title":"drel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drel: Optional[float] = Field(default=None, description='Maximum relative change in Hs from one iteration to the next (SWAN default: 0.01 [-])')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.curvat","title":"curvat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curvat: Optional[float] = Field(default=None, description='Maximum curvature of the iteration curve of Hs normalised with Hs (SWAN default: 0.005 [-] (not used in the QC model))')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.npnts","title":"npnts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npnts: Optional[float] = Field(default=None, description='Percentage of points in the computational grid above which the stopping criteria needs to be satisfied (SWAN default: 99.5 [-])')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[Union[STAT, NONSTAT]] = Field(default=None, description='Termination criteria for stationary or nonstationary runs', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[float] = Field(default=None, description='Determines the maximum change per iteration of the energy density per spectral-bin given in terms of a fraction of the omni-directional Phillips level (SWAN default: 0.1)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.STOPC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"STOPC\"\n    if self.dabs is not None:\n        repr += f\" dabs={self.dabs}\"\n    if self.drel is not None:\n        repr += f\" drel={self.drel}\"\n    if self.curvat is not None:\n        repr += f\" curvat={self.curvat}\"\n    if self.npnts is not None:\n        repr += f\" npnts={self.npnts}\"\n    if self.mode is not None:\n        repr += f\" {self.mode.render()}\"\n    if self.limiter is not None:\n        repr += f\" limiter={self.limiter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR","title":"ACCUR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stop the iterative procedure.</p> <p>.. code-block:: text</p> <pre><code>ACCUR [drel] [dhoval] [dtoval] [npnts] -&gt;STAT|NONSTAT [limiter]\n</code></pre> <p>With this option the user can influence the criterion for terminating the iterative procedure in the SWAN computations (both stationary and non-stationary modes). SWAN stops the iterations if (a), (b) and (c) are all satisfied:</p> <p>a) The change in the local significant wave height Hs from one iteration to the    next is less than (1) fraction <code>drel</code> of that height or (2) fraction <code>dhoval</code>    of the average Hs over all grid points.</p> <p>b) The change in the local mean wave period Tm01 from one iteration to the next is    less than (1) fraction <code>drel</code> of that period or (2) fraction <code>dtoval</code> of the    average mean wave period over all wet grid points.</p> <p>c) Conditions (a) and (b) are fulfilled in more than fraction <code>npnts%</code> of all wet    grid points.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR--note","title":"Note","text":"<p>This command has become obsolete in SWAN 41.01. The command STOPC should be used.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import ACCUR\naccur = ACCUR()\nprint(accur.render())\naccur = ACCUR(\n    drel=0.01,\n    dhoval=0.02,\n    dtoval=0.02,\n    npnts=98.0,\n    mode=dict(model_type=\"nonstat\", mxitns=1),\n    limiter=0.1,\n)\nprint(accur.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class ACCUR(BaseSubComponent):\n    \"\"\"Stop the iterative procedure.\n\n    .. code-block:: text\n\n        ACCUR [drel] [dhoval] [dtoval] [npnts] -&gt;STAT|NONSTAT [limiter]\n\n    With this option the user can influence the criterion for terminating the iterative\n    procedure in the SWAN computations (both stationary and non-stationary modes).\n    SWAN stops the iterations if (a), (b) and (c) are all satisfied:\n\n    a) The change in the local significant wave height Hs from one iteration to the\n       next is less than (1) fraction `drel` of that height or (2) fraction `dhoval`\n       of the average Hs over all grid points.\n\n    b) The change in the local mean wave period Tm01 from one iteration to the next is\n       less than (1) fraction `drel` of that period or (2) fraction `dtoval` of the\n       average mean wave period over all wet grid points.\n\n    c) Conditions (a) and (b) are fulfilled in more than fraction `npnts%` of all wet\n       grid points.\n\n    Note\n    ----\n    This command has become obsolete in SWAN 41.01. The command STOPC should be used.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import ACCUR\n        accur = ACCUR()\n        print(accur.render())\n        accur = ACCUR(\n            drel=0.01,\n            dhoval=0.02,\n            dtoval=0.02,\n            npnts=98.0,\n            mode=dict(model_type=\"nonstat\", mxitns=1),\n            limiter=0.1,\n        )\n        print(accur.render())\n\n    \"\"\"\n\n    model_type: Literal[\"accur\", \"ACCUR\"] = Field(\n        default=\"accur\", description=\"Model type discriminator\"\n    )\n    drel: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Maximum relative change in Hs or Tm01 from one iteration to the next \"\n            \"(SWAN default: 0.02)\"\n        ),\n    )\n    dhoval: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Fraction of the average Hs over all wet grid points below which the \"\n            \"the stopping criteria needs to be satisfied (SWAN default: 0.02)\"\n        ),\n    )\n    dtoval: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Fraction of the average Tm01 over all wet grid points below which the \"\n            \"the stopping criteria needs to be satisfied (SWAN default: 0.02)\"\n        ),\n    )\n    npnts: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Percentage of points in the computational grid above which the stopping \"\n            \"criteria needs to be satisfied (SWAN default: 98)\"\n        ),\n    )\n    mode: Optional[Union[STAT, NONSTAT]] = Field(\n        default=None,\n        description=\"Termination criteria for stationary or nonstationary runs\",\n        discriminator=\"model_type\",\n    )\n    limiter: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Determines the maximum change per iteration of the energy density per \"\n            \"spectral-bin given in terms of a fraction of the omni-directional \"\n            \"Phillips level (SWAN default: 0.1)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"ACCUR\"\n        if self.drel is not None:\n            repr += f\" drel={self.drel}\"\n        if self.dhoval is not None:\n            repr += f\" dhoval={self.dhoval}\"\n        if self.dtoval is not None:\n            repr += f\" dtoval={self.dtoval}\"\n        if self.npnts is not None:\n            repr += f\" npnts={self.npnts}\"\n        if self.mode is not None:\n            repr += f\" {self.mode.render()}\"\n        if self.limiter is not None:\n            repr += f\" limiter={self.limiter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['accur', 'ACCUR'] = Field(default='accur', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.drel","title":"drel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drel: Optional[float] = Field(default=None, description='Maximum relative change in Hs or Tm01 from one iteration to the next (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.dhoval","title":"dhoval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhoval: Optional[float] = Field(default=None, description='Fraction of the average Hs over all wet grid points below which the the stopping criteria needs to be satisfied (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.dtoval","title":"dtoval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtoval: Optional[float] = Field(default=None, description='Fraction of the average Tm01 over all wet grid points below which the the stopping criteria needs to be satisfied (SWAN default: 0.02)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.npnts","title":"npnts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>npnts: Optional[float] = Field(default=None, description='Percentage of points in the computational grid above which the stopping criteria needs to be satisfied (SWAN default: 98)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[Union[STAT, NONSTAT]] = Field(default=None, description='Termination criteria for stationary or nonstationary runs', discriminator='model_type')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.limiter","title":"limiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limiter: Optional[float] = Field(default=None, description='Determines the maximum change per iteration of the energy density per spectral-bin given in terms of a fraction of the omni-directional Phillips level (SWAN default: 0.1)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.ACCUR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"ACCUR\"\n    if self.drel is not None:\n        repr += f\" drel={self.drel}\"\n    if self.dhoval is not None:\n        repr += f\" dhoval={self.dhoval}\"\n    if self.dtoval is not None:\n        repr += f\" dtoval={self.dtoval}\"\n    if self.npnts is not None:\n        repr += f\" npnts={self.npnts}\"\n    if self.mode is not None:\n        repr += f\" {self.mode.render()}\"\n    if self.limiter is not None:\n        repr += f\" limiter={self.limiter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL","title":"DIRIMPL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Numerical scheme for refraction.</p> <p>.. code-block:: text</p> <pre><code>DIRIMPL [cdd]\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import DIRIMPL\ndirimpl = DIRIMPL()\nprint(dirimpl.render())\ndirimpl = DIRIMPL(cdd=0.5)\nprint(dirimpl.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class DIRIMPL(BaseSubComponent):\n    \"\"\"Numerical scheme for refraction.\n\n    .. code-block:: text\n\n        DIRIMPL [cdd]\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import DIRIMPL\n        dirimpl = DIRIMPL()\n        print(dirimpl.render())\n        dirimpl = DIRIMPL(cdd=0.5)\n        print(dirimpl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dirimpl\", \"DIRIMPL\"] = Field(\n        default=\"dirimpl\", description=\"Model type discriminator\"\n    )\n    cdd: Optional[float] = Field(\n        default=None,\n        description=(\n            \"A value of `cdd=0` corresponds to a central scheme and has the largest \"\n            \"accuracy (diffusion \u2248 0) but the computation may more easily generate\"\n            \"spurious fluctuations. A value of `cdd=1` corresponds to a first order\"\n            \"upwind scheme and it is more diffusive and therefore preferable if \"\n            \"(strong) gradients in depth or current are present (SWAN default: 0.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"DIRIMPL\"\n        if self.cdd is not None:\n            repr += f\" cdd={self.cdd}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dirimpl', 'DIRIMPL'] = Field(default='dirimpl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.cdd","title":"cdd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdd: Optional[float] = Field(default=None, description='A value of `cdd=0` corresponds to a central scheme and has the largest accuracy (diffusion \u2248 0) but the computation may more easily generatespurious fluctuations. A value of `cdd=1` corresponds to a first orderupwind scheme and it is more diffusive and therefore preferable if (strong) gradients in depth or current are present (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.DIRIMPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"DIRIMPL\"\n    if self.cdd is not None:\n        repr += f\" cdd={self.cdd}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL","title":"SIGIMPL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency shifting accuracy.</p> <p>.. code-block:: text</p> <pre><code>SIGIMpl [cfl] [eps2] [outp] [niter]\n</code></pre> <p>Controls the accuracy of computing the frequency shifting and the stopping criterion and amount of output for the SIP solver (used in the computations in the presence of currents or time varying depth)</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import SIGIMPL\nsigimpl = SIGIMPL()\nprint(sigimpl.render())\nsigimpl = SIGIMPL(css=0.5, eps2=1e-4, outp=0, niter=20)\nprint(sigimpl.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class SIGIMPL(BaseSubComponent):\n    \"\"\"Frequency shifting accuracy.\n\n    .. code-block:: text\n\n        SIGIMpl [cfl] [eps2] [outp] [niter]\n\n    Controls the accuracy of computing the frequency shifting and the stopping\n    criterion and amount of output for the SIP solver (used in the computations in the\n    presence of currents or time varying depth)\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import SIGIMPL\n        sigimpl = SIGIMPL()\n        print(sigimpl.render())\n        sigimpl = SIGIMPL(css=0.5, eps2=1e-4, outp=0, niter=20)\n        print(sigimpl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"sigimpl\", \"SIGIMPL\"] = Field(\n        default=\"sigimpl\", description=\"Model type discriminator\"\n    )\n    css: Optional[float] = Field(\n        default=None,\n        description=(\n            \"A value of `css=0` corresponds to a central scheme and has the largest \"\n            \"accuracy (diffusion \u2248 0) but the computation may more easily generate \"\n            \"spurious fluctuations. A value of `css=1` corresponds to a first order \"\n            \"upwind scheme and it is more diffusive and therefore preferable if \"\n            \"(strong) gradients in depth or current are present (SWAN default: 0.5)\"\n        ),\n    )\n    eps2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Relative stopping criterion to terminate the linear solver (SIP or SOR). \"\n            \"(SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)\"\n        ),\n    )\n    outp: Optional[Literal[0, 1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional \"\n            \"information about the iteration process is written to the PRINT file \"\n            \"\\n* 2 = gives a maximal amount of output concerning the iteration \"\n            \"process\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)\"\n        ),\n    )\n    niter: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of iterations for the linear solver (SWAN default: 20 in \"\n            \"case of SIP and 1000 in case of SOR)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SIGIMPL\"\n        if self.css is not None:\n            repr += f\" css={self.css}\"\n        if self.eps2 is not None:\n            repr += f\" eps2={self.eps2}\"\n        if self.outp is not None:\n            repr += f\" outp={self.outp}\"\n        if self.niter is not None:\n            repr += f\" niter={self.niter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['sigimpl', 'SIGIMPL'] = Field(default='sigimpl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[float] = Field(default=None, description='A value of `css=0` corresponds to a central scheme and has the largest accuracy (diffusion \u2248 0) but the computation may more easily generate spurious fluctuations. A value of `css=1` corresponds to a first order upwind scheme and it is more diffusive and therefore preferable if (strong) gradients in depth or current are present (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.eps2","title":"eps2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps2: Optional[float] = Field(default=None, description='Relative stopping criterion to terminate the linear solver (SIP or SOR). (SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.outp","title":"outp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outp: Optional[Literal[0, 1, 2, 3]] = Field(default=None, description='Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional information about the iteration process is written to the PRINT file \\n* 2 = gives a maximal amount of output concerning the iteration process\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.niter","title":"niter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>niter: Optional[int] = Field(default=None, description='Maximum number of iterations for the linear solver (SWAN default: 20 in case of SIP and 1000 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SIGIMPL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SIGIMPL\"\n    if self.css is not None:\n        repr += f\" css={self.css}\"\n    if self.eps2 is not None:\n        repr += f\" eps2={self.eps2}\"\n    if self.outp is not None:\n        repr += f\" outp={self.outp}\"\n    if self.niter is not None:\n        repr += f\" niter={self.niter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA","title":"CTHETA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Prevents excessive directional turning.</p> <p>.. code-block:: text</p> <pre><code>CTheta [cfl]\n</code></pre> <p>This option prevents an excessive directional turning at a single grid point or vertex due to a very coarse bathymetry or current locally. This option limits the directional turning rate c\u03b8 based on the CFL restriction. (See Eq. 3.41 of Scientific/Technical documentation). See also the final remark in Section 2.6.3. Note that if this command is not specified, then the limiter is not activated.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import CTHETA\nctheta = CTHETA()\nprint(ctheta.render())\nctheta = CTHETA(cfl=0.9)\nprint(ctheta.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class CTHETA(BaseSubComponent):\n    \"\"\"Prevents excessive directional turning.\n\n    .. code-block:: text\n\n        CTheta [cfl]\n\n    This option prevents an excessive directional turning at a single grid point or\n    vertex due to a very coarse bathymetry or current locally. This option limits the\n    directional turning rate c\u03b8 based on the CFL restriction. (See Eq. 3.41 of\n    Scientific/Technical documentation). See also the final remark in Section 2.6.3.\n    Note that if this command is not specified, then the limiter is not activated.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import CTHETA\n        ctheta = CTHETA()\n        print(ctheta.render())\n        ctheta = CTHETA(cfl=0.9)\n        print(ctheta.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ctheta\", \"CTHETA\"] = Field(\n        default=\"ctheta\", description=\"Model type discriminator\"\n    )\n    cfl: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit for the CFL restriction for ctheta. A suggestion for this \"\n            \"parameter is `cfl = 0.9` (SWAN default: 0.9 when CTHETA is activated)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"CTHETA\"\n        if self.cfl is not None:\n            repr += f\" cfl={self.cfl}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ctheta', 'CTHETA'] = Field(default='ctheta', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.cfl","title":"cfl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfl: Optional[float] = Field(default=None, description='Upper limit for the CFL restriction for ctheta. A suggestion for this parameter is `cfl = 0.9` (SWAN default: 0.9 when CTHETA is activated)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CTHETA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"CTHETA\"\n    if self.cfl is not None:\n        repr += f\" cfl={self.cfl}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA","title":"CSIGMA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Prevents excessive directional turning.</p> <p>.. code-block:: text</p> <pre><code>CSigma [cfl]\n</code></pre> <p>This option prevents an excessive frequency shifting at a single grid point or vertex due to a very coarse bathymetry or current locally. This option limits the frequency shifting rate csigma based on the CFL restriction. See also the final remark in Section 2.6.3. Note that if this command is not specified, then the limiter is not activated.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import CSIGMA\ncsigma = CSIGMA()\nprint(csigma.render())\ncsigma = CSIGMA(cfl=0.9)\nprint(csigma.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class CSIGMA(BaseSubComponent):\n    \"\"\"Prevents excessive directional turning.\n\n    .. code-block:: text\n\n        CSigma [cfl]\n\n    This option prevents an excessive frequency shifting at a single grid point or\n    vertex due to a very coarse bathymetry or current locally. This option limits the\n    frequency shifting rate csigma based on the CFL restriction. See also the final\n    remark in Section 2.6.3. Note that if this command is not specified, then the\n    limiter is not activated.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import CSIGMA\n        csigma = CSIGMA()\n        print(csigma.render())\n        csigma = CSIGMA(cfl=0.9)\n        print(csigma.render())\n\n    \"\"\"\n\n    model_type: Literal[\"ctheta\", \"CTHETA\"] = Field(\n        default=\"ctheta\", description=\"Model type discriminator\"\n    )\n    cfl: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Upper limit for the CFL restriction for csigma. A suggestion for this \"\n            \"parameter is `cfl = 0.9` (SWAN default: 0.9 when CSIGMA is activated)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"CSIGMA\"\n        if self.cfl is not None:\n            repr += f\" cfl={self.cfl}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ctheta', 'CTHETA'] = Field(default='ctheta', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.cfl","title":"cfl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfl: Optional[float] = Field(default=None, description='Upper limit for the CFL restriction for csigma. A suggestion for this parameter is `cfl = 0.9` (SWAN default: 0.9 when CSIGMA is activated)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.CSIGMA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"CSIGMA\"\n    if self.cfl is not None:\n        repr += f\" cfl={self.cfl}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP","title":"SETUP","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stop criteria in the computation of wave setup.</p> <p>.. code-block:: text</p> <pre><code>SETUP [eps2] [outp] [niter]\n</code></pre> <p>Controls the stopping criterion and amount of output for the SOR solver in the computation of the wave-induced set-up.</p>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.numerics import SETUP\nsetup = SETUP()\nprint(setup.render())\nsetup = SETUP(eps2=1e-4, outp=0, niter=20)\nprint(setup.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>class SETUP(BaseSubComponent):\n    \"\"\"Stop criteria in the computation of wave setup.\n\n    .. code-block:: text\n\n        SETUP [eps2] [outp] [niter]\n\n    Controls the stopping criterion and amount of output for the SOR solver in the\n    computation of the wave-induced set-up.\n\n    Examples\n    --------\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.numerics import SETUP\n        setup = SETUP()\n        print(setup.render())\n        setup = SETUP(eps2=1e-4, outp=0, niter=20)\n        print(setup.render())\n\n    \"\"\"\n\n    model_type: Literal[\"setup\", \"SETUP\"] = Field(\n        default=\"setup\", description=\"Model type discriminator\"\n    )\n    eps2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Relative stopping criterion to terminate the linear solver (SIP or SOR). \"\n            \"(SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)\"\n        ),\n    )\n    outp: Optional[Literal[0, 1, 2, 3]] = Field(\n        default=None,\n        description=(\n            \"Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional \"\n            \"information about the iteration process is written to the PRINT file \"\n            \"\\n* 2 = gives a maximal amount of output concerning the iteration process \"\n            \"\\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)\"\n        ),\n    )\n    niter: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Maximum number of iterations for the linear solver (SWAN default: 20 in \"\n            \"case of SIP and 1000 in case of SOR)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this component.\"\"\"\n        repr = \"SETUP\"\n        if self.eps2 is not None:\n            repr += f\" eps2={self.eps2}\"\n        if self.outp is not None:\n            repr += f\" outp={self.outp}\"\n        if self.niter is not None:\n            repr += f\" niter={self.niter}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP-attributes","title":"Attributes","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['setup', 'SETUP'] = Field(default='setup', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.eps2","title":"eps2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eps2: Optional[float] = Field(default=None, description='Relative stopping criterion to terminate the linear solver (SIP or SOR). (SWAN default: 1.e-4 in case of SIP and 1.e-6 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.outp","title":"outp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outp: Optional[Literal[0, 1, 2, 3]] = Field(default=None, description='Output for the iterative solver:\\n\\n* 0 = no output\\n* 1 = additional information about the iteration process is written to the PRINT file \\n* 2 = gives a maximal amount of output concerning the iteration process \\n* 3 = summary of the iteration process\\n\\n(SWAN default: 0)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.niter","title":"niter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>niter: Optional[int] = Field(default=None, description='Maximum number of iterations for the linear solver (SWAN default: 20 in case of SIP and 1000 in case of SOR)')\n</code></pre>"},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP-functions","title":"Functions","text":""},{"location":"subcomponents/numerics/#rompy_swan.subcomponents.numerics.SETUP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this component.</p> Source code in <code>rompy_swan/subcomponents/numerics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this component.\"\"\"\n    repr = \"SETUP\"\n    if self.eps2 is not None:\n        repr += f\" eps2={self.eps2}\"\n    if self.outp is not None:\n        repr += f\" outp={self.outp}\"\n    if self.niter is not None:\n        repr += f\" niter={self.niter}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/output/","title":"Output","text":"<p>Sub-commands to support the output components</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D","title":"SPEC1D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency 1D spectra.</p> <p>.. code-block:: text</p> <pre><code>SPEC1D\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import SPEC1D\nspec = SPEC1D()\nprint(spec.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>class SPEC1D(BaseSubComponent):\n    \"\"\"Frequency 1D spectra.\n\n    .. code-block:: text\n\n        SPEC1D\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import SPEC1D\n        spec = SPEC1D()\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spec1d\", \"SPEC1D\"] = Field(\n        default=\"spec1d\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spec1d', 'SPEC1D'] = Field(default='spec1d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC1D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D","title":"SPEC2D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency-direction 2D spectra.</p> <p>.. code-block:: text</p> <pre><code>SPEC2D\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import SPEC2D\nspec = SPEC2D()\nprint(spec.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>class SPEC2D(BaseSubComponent):\n    \"\"\"Frequency-direction 2D spectra.\n\n    .. code-block:: text\n\n        SPEC2D\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import SPEC2D\n        spec = SPEC2D()\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spec2d\", \"SPEC2D\"] = Field(\n        default=\"spec2d\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spec2d', 'SPEC2D'] = Field(default='spec2d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.SPEC2D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"SPEC2D\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS","title":"ABS","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Absolute frequency spectra.</p> <p>.. code-block:: text</p> <pre><code>ABS\n</code></pre> <p>Spectra are computed as a function of absolute frequency, i.e., the frequency as measured in a fixed point.</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import ABS\nfreq = ABS()\nprint(freq.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>class ABS(BaseSubComponent):\n    \"\"\"Absolute frequency spectra.\n\n    .. code-block:: text\n\n        ABS\n\n    Spectra are computed as a function of absolute frequency, i.e., the frequency as\n    measured in a fixed point.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import ABS\n        freq = ABS()\n        print(freq.render())\n\n    \"\"\"\n\n    model_type: Literal[\"abs\", \"ABS\"] = Field(\n        default=\"abs\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"ABS\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['abs', 'ABS'] = Field(default='abs', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.ABS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"ABS\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL","title":"REL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Relative frequency spectra.</p> <p>.. code-block:: text</p> <pre><code>REL\n</code></pre> <p>Spectra are computed as a function of relative frequency, i.e., the frequency as measured when moving with current.</p>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.output import REL\nfreq = REL()\nprint(freq.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>class REL(BaseSubComponent):\n    \"\"\"Relative frequency spectra.\n\n    .. code-block:: text\n\n        REL\n\n    Spectra are computed as a function of relative frequency, i.e., the frequency as\n    measured when moving with current.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.output import REL\n        freq = REL()\n        print(freq.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rel\", \"REL\"] = Field(\n        default=\"rel\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"REL\"\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL-attributes","title":"Attributes","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rel', 'REL'] = Field(default='rel', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL-functions","title":"Functions","text":""},{"location":"subcomponents/output/#rompy_swan.subcomponents.output.REL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/output.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"REL\"\n</code></pre>"},{"location":"subcomponents/physics/","title":"Physics","text":"<p>Sub-commands to support the physics components</p>"},{"location":"subcomponents/physics/#source-terms","title":"Source terms","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN","title":"JANSSEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Janssen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>JANSSEN [cds1] [delta] (AGROW [a])\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN--references","title":"References","text":"<p>Janssen, P.A., 1989. Wave-induced stress and the drag of air flow over sea waves. Journal of Physical Oceanography, 19(6), pp.745-754.</p> <p>Janssen, P.A.E.M., Lionello, P. and Zambresky, L., 1989. On the interaction of wind and waves. Philosophical transactions of the royal society of London. Series A, Mathematical and Physical Sciences, 329(1604), pp.289-301.</p> <p>Janssen, P.A., 1991. Quasi-linear theory of wind-wave generation applied to wave forecasting. Journal of physical oceanography, 21(11), pp.1631-1642.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import JANSSEN\njanssen = JANSSEN()\nprint(janssen.render())\njanssen = JANSSEN(cds1=4.5, delta=0.5, agrow=True)\nprint(janssen.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class JANSSEN(SourceTerms):\n    \"\"\"Janssen source terms subcomponent.\n\n    .. code-block:: text\n\n        JANSSEN [cds1] [delta] (AGROW [a])\n\n    References\n    ----------\n    Janssen, P.A., 1989. Wave-induced stress and the drag of air flow over sea waves.\n    Journal of Physical Oceanography, 19(6), pp.745-754.\n\n    Janssen, P.A.E.M., Lionello, P. and Zambresky, L., 1989. On the interaction of wind\n    and waves. Philosophical transactions of the royal society of London. Series A,\n    Mathematical and Physical Sciences, 329(1604), pp.289-301.\n\n    Janssen, P.A., 1991. Quasi-linear theory of wind-wave generation applied to wave\n    forecasting. Journal of physical oceanography, 21(11), pp.1631-1642.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import JANSSEN\n        janssen = JANSSEN()\n        print(janssen.render())\n        janssen = JANSSEN(cds1=4.5, delta=0.5, agrow=True)\n        print(janssen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"janssen\", \"JANSSEN\"] = Field(\n        default=\"janssen\", description=\"Model type discriminator\"\n    )\n    cds1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation \"\n            \"($Cds / s^4_{PM}$) (SWAN default: 4.5)\"\n        ),\n    )\n    delta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient which determines the dependency of the whitecapping on wave \"\n            \"number (mix with Komen et al. formulation) (SWAN default: 0.5)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"JANSSEN\"\n        if self.cds1 is not None:\n            repr += f\" cds1={self.cds1}\"\n        if self.delta is not None:\n            repr += f\" delta={self.delta}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['janssen', 'JANSSEN'] = Field(default='janssen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.cds1","title":"cds1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds1: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation ($Cds / s^4_{PM}$) (SWAN default: 4.5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: Optional[float] = Field(default=None, description='Coefficient which determines the dependency of the whitecapping on wave number (mix with Komen et al. formulation) (SWAN default: 0.5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.JANSSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"JANSSEN\"\n    if self.cds1 is not None:\n        repr += f\" cds1={self.cds1}\"\n    if self.delta is not None:\n        repr += f\" delta={self.delta}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN","title":"KOMEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Komen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>KOMEN [cds2] [stpm] (AGROW [a])\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN--references","title":"References","text":"<p>Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import KOMEN\nkomen = KOMEN()\nprint(komen.render())\nkomen = KOMEN(cds2=2.36e-5, stpm=3.02e-3, agrow=True, a=0.0015)\nprint(komen.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class KOMEN(SourceTerms):\n    \"\"\"Komen source terms subcomponent.\n\n    .. code-block:: text\n\n        KOMEN [cds2] [stpm] (AGROW [a])\n\n    References\n    ----------\n    Komen, G.J., Hasselmann, S. and Hasselmann, K., 1984. On the existence of a fully\n    developed wind-sea spectrum. Journal of physical oceanography, 14(8), pp.1271-1285.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import KOMEN\n        komen = KOMEN()\n        print(komen.render())\n        komen = KOMEN(cds2=2.36e-5, stpm=3.02e-3, agrow=True, a=0.0015)\n        print(komen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"komen\", \"KOMEN\"] = Field(\n        default=\"komen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Coefficient for determining the rate of whitecapping dissipation \"\n            \"(`Cds`) (SWAN default: 2.36e-5)\"\n        ),\n    )\n    stpm: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Value of the wave steepness for a Pierson-Moskowitz spectrum \"\n            \"(`s^2_PM`) (SWAN default: 3.02e-3)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"KOMEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.stpm is not None:\n            repr += f\" stpm={self.stpm}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['komen', 'KOMEN'] = Field(default='komen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='Coefficient for determining the rate of whitecapping dissipation (`Cds`) (SWAN default: 2.36e-5)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.stpm","title":"stpm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stpm: Optional[float] = Field(default=None, description='Value of the wave steepness for a Pierson-Moskowitz spectrum (`s^2_PM`) (SWAN default: 3.02e-3)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.KOMEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"KOMEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.stpm is not None:\n        repr += f\" stpm={self.stpm}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN","title":"WESTHUYSEN","text":"<p>               Bases: <code>SourceTerms</code></p> <p>Westhuysen source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>WESTHUYSEN [cds2] [br] (AGROW [a])\n</code></pre> <p>Nonlinear saturation-based whitecapping combined with wind input of Yan (1987).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--notes","title":"Notes","text":"<p>The two arguments are specified in the Appendix C of the User manual but not in the command description for WESTH in Section 4.5.4. They are also options in the WCAPPING command. It is not entirely clear if they should/could be specified here.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--references","title":"References","text":"<p>van der Westhuysen, A.J., Zijlema, M. and Battjes, J.A., 2007. Nonlinear saturation-based whitecapping dissipation in SWAN for deep and shallow water. Coastal Engineering, 54(2), pp.151-170.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import WESTHUYSEN\nwesthuysen = WESTHUYSEN()\nprint(westhuysen.render())\nwesthuysen = WESTHUYSEN(cds2=5.0e-5, br=1.75e-3)\nprint(westhuysen.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class WESTHUYSEN(SourceTerms):\n    \"\"\"Westhuysen source terms subcomponent.\n\n    .. code-block:: text\n\n        WESTHUYSEN [cds2] [br] (AGROW [a])\n\n    Nonlinear saturation-based whitecapping combined with wind input of Yan (1987).\n\n    Notes\n    -----\n    The two arguments are specified in the Appendix C of the User manual but not in the\n    command description for WESTH in Section 4.5.4. They are also options in the\n    WCAPPING command. It is not entirely clear if they should/could be specified here.\n\n    References\n    ----------\n    van der Westhuysen, A.J., Zijlema, M. and Battjes, J.A., 2007. Nonlinear\n    saturation-based whitecapping dissipation in SWAN for deep and shallow water.\n    Coastal Engineering, 54(2), pp.151-170.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import WESTHUYSEN\n        westhuysen = WESTHUYSEN()\n        print(westhuysen.render())\n        westhuysen = WESTHUYSEN(cds2=5.0e-5, br=1.75e-3)\n        print(westhuysen.render())\n\n    \"\"\"\n\n    model_type: Literal[\"westhuysen\", \"WESTHUYSEN\"] = Field(\n        default=\"westhuysen\", description=\"Model type discriminator\"\n    )\n    cds2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"proportionality coefficient due to Alves and Banner (2003) \"\n            \"(SWAN default: 5.0e-5).\"\n        ),\n    )\n    br: Optional[float] = Field(\n        default=None, description=\"Threshold saturation level\t(SWAN default: 1.75e-3)\"\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"WESTHUYSEN\"\n        if self.cds2 is not None:\n            repr += f\" cds2={self.cds2}\"\n        if self.br is not None:\n            repr += f\" br={self.br}\"\n        repr += f\" DRAG {self.wind_drag.upper()}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['westhuysen', 'WESTHUYSEN'] = Field(default='westhuysen', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.cds2","title":"cds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cds2: Optional[float] = Field(default=None, description='proportionality coefficient due to Alves and Banner (2003) (SWAN default: 5.0e-5).')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.br","title":"br  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>br: Optional[float] = Field(default=None, description='Threshold saturation level\\t(SWAN default: 1.75e-3)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.WESTHUYSEN.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"WESTHUYSEN\"\n    if self.cds2 is not None:\n        repr += f\" cds2={self.cds2}\"\n    if self.br is not None:\n        repr += f\" br={self.br}\"\n    repr += f\" DRAG {self.wind_drag.upper()}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6","title":"ST6","text":"<p>               Bases: <code>SourceTerms</code></p> <p>St6 source terms subcomponent.</p> <p>.. code-block:: text</p> <pre><code>ST6 [a1sds] [a2sds] [p1sds] [p2sds] UP|DOWN HWANG|FAN|ECMWF VECTAU|SCATAU &amp;\n    TRUE10|U10PROXY [windscaling] DEBIAS [cdfac] (AGROW [a])\n</code></pre> <p>wind input and whitecapping from Rogers et al. (2012) (RBW12).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--notes","title":"Notes","text":"<p>The two arguments are specified in the Appendix C of the User manual but not in the command description for WESTH in Section 4.5.4. They are also options in the WCAPPING command. It is not entirely clear if they should/could be specified here.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--references","title":"References","text":"<p>Fan, Y., Lin, S.J., Held, I.M., Yu, Z. and Tolman, H.L., 2012. Global ocean surface wave simulation using a coupled atmosphere\u2013wave model. Journal of Climate, 25(18), pp.6233-6252.</p> <p>Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and whitecapping dissipation in a model for wind-generated surface waves: Description and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9), pp.1329-1346.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6\nst6 = ST6(a1sds=4.7e-7, a2sds=6.6e-6)\nprint(st6.render())\nkwargs = dict(\n    a1sds=2.8e-6,\n    a2sds=3.5e-5,\n    normalization=\"up\",\n    wind_drag=\"hwang\",\n    tau=\"vectau\",\n    u10=\"u10proxy\",\n    windscaling=32.0,\n    cdfac=0.89,\n    agrow=True,\n    a=0.0015,\n)\nst6 = ST6(**kwargs)\nprint(st6.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6(SourceTerms):\n    \"\"\"St6 source terms subcomponent.\n\n    .. code-block:: text\n\n        ST6 [a1sds] [a2sds] [p1sds] [p2sds] UP|DOWN HWANG|FAN|ECMWF VECTAU|SCATAU &amp;\n            TRUE10|U10PROXY [windscaling] DEBIAS [cdfac] (AGROW [a])\n\n    wind input and whitecapping from Rogers et al. (2012) (RBW12).\n\n    Notes\n    -----\n    The two arguments are specified in the Appendix C of the User manual but not in the\n    command description for WESTH in Section 4.5.4. They are also options in the\n    WCAPPING command. It is not entirely clear if they should/could be specified here.\n\n    References\n    ----------\n    Fan, Y., Lin, S.J., Held, I.M., Yu, Z. and Tolman, H.L., 2012. Global ocean surface\n    wave simulation using a coupled atmosphere\u2013wave model. Journal of Climate, 25(18),\n    pp.6233-6252.\n\n    Rogers, W.E., Babanin, A.V. and Wang, D.W., 2012. Observation-consistent input and\n    whitecapping dissipation in a model for wind-generated surface waves: Description\n    and simple calculations. Journal of Atmospheric and Oceanic Technology, 29(9),\n    pp.1329-1346.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6\n        st6 = ST6(a1sds=4.7e-7, a2sds=6.6e-6)\n        print(st6.render())\n        kwargs = dict(\n            a1sds=2.8e-6,\n            a2sds=3.5e-5,\n            normalization=\"up\",\n            wind_drag=\"hwang\",\n            tau=\"vectau\",\n            u10=\"u10proxy\",\n            windscaling=32.0,\n            cdfac=0.89,\n            agrow=True,\n            a=0.0015,\n        )\n        st6 = ST6(**kwargs)\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6\"] = Field(\n        default=\"st6\", description=\"Model type discriminator\"\n    )\n    a1sds: float = Field(\n        description=\"Coefficient related to local dissipation term T1 (a1 in RBW12)\"\n    )\n    a2sds: float = Field(\n        description=\"Coefficient related to local dissipation term T2 (a2 in RBW12)\"\n    )\n    p1sds: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power coefficient controlling strength of dissipation term T1 \"\n            \"(L in RBW12, SWAN default: 4)\"\n        ),\n    )\n    p2sds: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Power coefficient controlling strength of dissipation term T2 \"\n            \"(M in RBW12, SWAN default: 4)\"\n        ),\n    )\n    normalization: Literal[\"up\", \"down\"] = Field(\n        default=\"up\",\n        description=(\n            \"Selection of normalization of exceedance level by ET(f) (`up`) or E(f) \"\n            \"(`down`) as in RBW12 (right column, page 1333), `up` is default and \"\n            \"strongly recommended\"\n        ),\n    )\n    wind_drag: Literal[\"hwang\", \"fan\", \"ecmwf\"] = Field(\n        default=\"hwang\",\n        description=(\n            \"Wind drag formula, `hwang` is the default and is unchanged from RBW12, \"\n            \"`fan` is from Fan et al. (2012), `ecmwf` follows WAM Cycle 4 methodology\"\n        ),\n    )\n    tau: Literal[\"vectau\", \"scatau\"] = Field(\n        default=\"vectau\",\n        description=(\n            \"Use vector (vectau) or scalar (scatau) calculation for the wind strerss \"\n            \"(Eq. 12 in RBW12), `vectau` is the default and strongly recommended\"\n        ),\n    )\n    u10: Literal[\"u10proxy\", \"true10\"] = Field(\n        default=\"u10proxy\",\n        description=\"Wind velocity definition\",\n    )\n    windscaling: Optional[float] = Field(\n        default=32.0,\n        description=\"Factor to scale U10 with U* when using U10PROXY\",\n    )\n    cdfac: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Counter bias in the input wind fields by providing a multiplier \"\n            \"on the drag coefficient\"\n        ),\n        gt=0.0,\n    )\n\n    @model_validator(mode=\"after\")\n    def debias_only_with_hwang(self) -&gt; \"ST6\":\n        if self.cdfac is not None and self.wind_drag != \"hwang\":\n            raise ValueError(\n                f\"Debias is only supported with hwang wind drag, not {self.wind_drag}\"\n            )\n        return self\n\n    @property\n    def u10_cmd(self) -&gt; str:\n        if self.u10 == \"true10\":\n            return \"TRUE10\"\n        else:\n            return f\"U10PROXY windscaling={self.windscaling}\"\n\n    def cmd(self) -&gt; str:\n        repr = f\"ST6 a1sds={self.a1sds} a2sds={self.a2sds}\"\n        if self.p1sds is not None:\n            repr += f\" p1sds={self.p1sds}\"\n        if self.p2sds is not None:\n            repr += f\" p2sds={self.p2sds}\"\n        repr += f\" {self.normalization.upper()}\"\n        repr += f\" {self.wind_drag.upper()}\"\n        repr += f\" {self.tau.upper()}\"\n        repr += f\" {self.u10_cmd}\"\n        if self.cdfac is not None:\n            repr += f\" DEBIAS cdfac={self.cdfac}\"\n        if self.agrow:\n            repr += \" AGROW\"\n        if self.a is not None and self.agrow:\n            repr += f\" a={self.a}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6'] = Field(default='st6', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: float = Field(description='Coefficient related to local dissipation term T1 (a1 in RBW12)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: float = Field(description='Coefficient related to local dissipation term T2 (a2 in RBW12)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.p1sds","title":"p1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p1sds: Optional[float] = Field(default=None, description='Power coefficient controlling strength of dissipation term T1 (L in RBW12, SWAN default: 4)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.p2sds","title":"p2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p2sds: Optional[float] = Field(default=None, description='Power coefficient controlling strength of dissipation term T2 (M in RBW12, SWAN default: 4)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.normalization","title":"normalization  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normalization: Literal['up', 'down'] = Field(default='up', description='Selection of normalization of exceedance level by ET(f) (`up`) or E(f) (`down`) as in RBW12 (right column, page 1333), `up` is default and strongly recommended')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.wind_drag","title":"wind_drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wind_drag: Literal['hwang', 'fan', 'ecmwf'] = Field(default='hwang', description='Wind drag formula, `hwang` is the default and is unchanged from RBW12, `fan` is from Fan et al. (2012), `ecmwf` follows WAM Cycle 4 methodology')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.tau","title":"tau  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tau: Literal['vectau', 'scatau'] = Field(default='vectau', description='Use vector (vectau) or scalar (scatau) calculation for the wind strerss (Eq. 12 in RBW12), `vectau` is the default and strongly recommended')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.u10","title":"u10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>u10: Literal['u10proxy', 'true10'] = Field(default='u10proxy', description='Wind velocity definition')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Optional[float] = Field(default=32.0, description='Factor to scale U10 with U* when using U10PROXY')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Optional[float] = Field(default=None, description='Counter bias in the input wind fields by providing a multiplier on the drag coefficient', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.u10_cmd","title":"u10_cmd  <code>property</code>","text":"<pre><code>u10_cmd: str\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.debias_only_with_hwang","title":"debias_only_with_hwang","text":"<pre><code>debias_only_with_hwang() -&gt; ST6\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef debias_only_with_hwang(self) -&gt; \"ST6\":\n    if self.cdfac is not None and self.wind_drag != \"hwang\":\n        raise ValueError(\n            f\"Debias is only supported with hwang wind drag, not {self.wind_drag}\"\n        )\n    return self\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"ST6 a1sds={self.a1sds} a2sds={self.a2sds}\"\n    if self.p1sds is not None:\n        repr += f\" p1sds={self.p1sds}\"\n    if self.p2sds is not None:\n        repr += f\" p2sds={self.p2sds}\"\n    repr += f\" {self.normalization.upper()}\"\n    repr += f\" {self.wind_drag.upper()}\"\n    repr += f\" {self.tau.upper()}\"\n    repr += f\" {self.u10_cmd}\"\n    if self.cdfac is not None:\n        repr += f\" DEBIAS cdfac={self.cdfac}\"\n    if self.agrow:\n        repr += \" AGROW\"\n    if self.a is not None and self.agrow:\n        repr += f\" a={self.a}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#st6-presets","title":"ST6 presets","text":"<p>Combinations of calibrated coefficients for ST6 are defined in the SWAN Manual. The following presets are available:</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1","title":"ST6C1","text":"<p>               Bases: <code>ST6</code></p> <p>First ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C1\nst6 = ST6C1()\nprint(st6.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C1(ST6):\n    \"\"\"First ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C1\n        st6 = ST6C1()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c1\"] = Field(default=\"st6c1\")\n    a1sds: Literal[4.7e-7] = Field(default=4.7e-7)\n    a2sds: Literal[6.6e-6] = Field(default=6.6e-6)\n    p1sds: Literal[4.0] = Field(default=4.0)\n    p2sds: Literal[4.0] = Field(default=4.0)\n    windscaling: Literal[28.0] = Field(default=28.0)\n    agrow: Literal[True] = Field(default=True)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c1'] = Field(default='st6c1')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[4.7e-07] = Field(default=4.7e-07)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[6.6e-06] = Field(default=6.6e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.p1sds","title":"p1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p1sds: Literal[4.0] = Field(default=4.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.p2sds","title":"p2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p2sds: Literal[4.0] = Field(default=4.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[28.0] = Field(default=28.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C1.agrow","title":"agrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>agrow: Literal[True] = Field(default=True)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2","title":"ST6C2","text":"<p>               Bases: <code>ST6C1</code></p> <p>Second ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP FAN VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C2\nst6 = ST6C2()\nprint(st6.render())\n</code></pre> <p>TODO: Ensure validator is reused here so fan and debias are not used together.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C2(ST6C1):\n    \"\"\"Second ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP FAN VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C2\n        st6 = ST6C2()\n        print(st6.render())\n\n    TODO: Ensure validator is reused here so fan and debias are not used together.\n\n    \"\"\"\n\n    model_type: Literal[\"st6c2\"] = Field(default=\"st6c2\")\n    wind_drag: Literal[\"fan\"] = Field(default=\"fan\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c2'] = Field(default='st6c2')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C2.wind_drag","title":"wind_drag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wind_drag: Literal['fan'] = Field(default='fan')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3","title":"ST6C3","text":"<p>               Bases: <code>ST6C1</code></p> <p>Third ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C3\nst6 = ST6C3()\nprint(st6.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C3(ST6C1):\n    \"\"\"Third ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C3\n        st6 = ST6C3()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c3\"] = Field(default=\"st6c3\")\n    a1sds: Literal[2.8e-6] = Field(default=2.8e-6)\n    a2sds: Literal[3.5e-5] = Field(default=3.5e-5)\n    windscaling: Literal[32.0] = Field(default=32.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c3'] = Field(default='st6c3')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[2.8e-06] = Field(default=2.8e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[3.5e-05] = Field(default=3.5e-05)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C3.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[32.0] = Field(default=32.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4","title":"ST6C4","text":"<p>               Bases: <code>ST6C3</code></p> <p>Fourth ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 DEBIAS 0.89 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C4\nst6 = ST6C4()\nprint(st6.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C4(ST6C3):\n    \"\"\"Fourth ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 2.8e-6 3.5e-5 4.0 4.0 UP HWANG VECTAU U10PROXY 32.0 DEBIAS 0.89 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C4\n        st6 = ST6C4()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c4\"] = Field(default=\"st6c4\")\n    cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c4'] = Field(default='st6c4')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C4.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5","title":"ST6C5","text":"<p>               Bases: <code>ST6C1</code></p> <p>Fifth ST6 calibration in the SWAN user manual.</p> <p>.. code-block:: text</p> <pre><code>ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ST6C5\nst6 = ST6C5()\nprint(st6.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ST6C5(ST6C1):\n    \"\"\"Fifth ST6 calibration in the SWAN user manual.\n\n    .. code-block:: text\n\n        ST6 4.7e-7 6.6e-6 4.0 4.0 UP HWANG VECTAU U10PROXY 28.0 AGROW\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ST6C5\n        st6 = ST6C5()\n        print(st6.render())\n\n    \"\"\"\n\n    model_type: Literal[\"st6c5\"] = Field(default=\"st6c5\")\n    cdfac: Literal[0.89] = Field(default=0.89)\n    a1sds: Literal[6.5e-6] = Field(default=6.5e-6)\n    a2sds: Literal[8.5e-5] = Field(default=8.5e-5)\n    windscaling: Literal[35.0] = Field(default=35.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['st6c5'] = Field(default='st6c5')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.cdfac","title":"cdfac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdfac: Literal[0.89] = Field(default=0.89)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.a1sds","title":"a1sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a1sds: Literal[6.5e-06] = Field(default=6.5e-06)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.a2sds","title":"a2sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a2sds: Literal[8.5e-05] = Field(default=8.5e-05)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ST6C5.windscaling","title":"windscaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>windscaling: Literal[35.0] = Field(default=35.0)\n</code></pre>"},{"location":"subcomponents/physics/#biphase","title":"Biphase","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY","title":"ELDEBERKY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Biphase of Eldeberky (1999).</p> <p>.. code-block:: text</p> <pre><code>BIPHASE ELDEBERKY [urcrit]\n</code></pre> <p>Biphase parameterisation as a funtion of the Ursell number of Eldeberky (1999).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY--references","title":"References","text":"<p>Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for modeling triad interactions in dispersive waves. In Coastal Engineering 1996 (pp. 1088-1101).</p> <p>Eldeberky, Y. and Madsen, P.A., 1999. Deterministic and stochastic evolution equations for fully dispersive and weakly nonlinear waves. Coastal Engineering, 38(1), pp.1-24.</p> <p>Doering, J.C. and Bowen, A.J., 1995. Parametrization of orbital velocity asymmetries of shoaling and breaking waves using bispectral analysis. Coastal engineering, 26(1-2), pp.15-33.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import ELDEBERKY\nbiphase = ELDEBERKY()\nprint(biphase.render())\nbiphase = ELDEBERKY(urcrit=0.63)\nprint(biphase.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class ELDEBERKY(BaseSubComponent):\n    \"\"\"Biphase of Eldeberky (1999).\n\n    .. code-block:: text\n\n        BIPHASE ELDEBERKY [urcrit]\n\n    Biphase parameterisation as a funtion of the Ursell number of Eldeberky (1999).\n\n    References\n    ----------\n    Eldeberky, Y., Polnikov, V. and Battjes, J.A., 1996. A statistical approach for\n    modeling triad interactions in dispersive waves. In Coastal Engineering 1996\n    (pp. 1088-1101).\n\n    Eldeberky, Y. and Madsen, P.A., 1999. Deterministic and stochastic evolution\n    equations for fully dispersive and weakly nonlinear waves. Coastal Engineering,\n    38(1), pp.1-24.\n\n    Doering, J.C. and Bowen, A.J., 1995. Parametrization of orbital velocity\n    asymmetries of shoaling and breaking waves using bispectral analysis. Coastal\n    engineering, 26(1-2), pp.15-33.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import ELDEBERKY\n        biphase = ELDEBERKY()\n        print(biphase.render())\n        biphase = ELDEBERKY(urcrit=0.63)\n        print(biphase.render())\n\n    \"\"\"\n\n    model_type: Literal[\"eldeberky\"] = Field(\n        default=\"eldeberky\", description=\"Model type discriminator\"\n    )\n    urcrit: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The critical Ursell number appearing in the parametrization. Note: the \"\n            \"value of `urcrit` is setted by Eldeberky (1996) at 0.2 based on a \"\n            \"laboratory experiment, whereas Doering and Bowen (1995) employed the \"\n            \"value of 0.63 based on the field experiment data (SWAN default: 0.63)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"BIPHASE ELDEBERKY\"\n        if self.urcrit is not None:\n            repr += f\" urcrit={self.urcrit}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['eldeberky'] = Field(default='eldeberky', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.urcrit","title":"urcrit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urcrit: Optional[float] = Field(default=None, description='The critical Ursell number appearing in the parametrization. Note: the value of `urcrit` is setted by Eldeberky (1996) at 0.2 based on a laboratory experiment, whereas Doering and Bowen (1995) employed the value of 0.63 based on the field experiment data (SWAN default: 0.63)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.ELDEBERKY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"BIPHASE ELDEBERKY\"\n    if self.urcrit is not None:\n        repr += f\" urcrit={self.urcrit}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT","title":"DEWIT","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Biphase of De Wit (2022).</p> <p>.. code-block:: text</p> <pre><code>BIPHASE DEWIT [lpar]\n</code></pre> <p>Biphase parameterization based on bed slope and peak period of De Wit (2022).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT--references","title":"References","text":"<p>De Wit, F.P., 2022. Wave shape prediction in complex coastal systems (Doctoral dissertation, PhD. thesis. Delft University of Technology. https://repository. tudelft. nl/islandora/object/uuid% 3A0fb850a4-4294-4181-9d74-857de21265c2).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import DEWIT\nbiphase = DEWIT()\nprint(biphase.render())\nbiphase = DEWIT(lpar=0.0)\nprint(biphase.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class DEWIT(BaseSubComponent):\n    \"\"\"Biphase of De Wit (2022).\n\n    .. code-block:: text\n\n        BIPHASE DEWIT [lpar]\n\n    Biphase parameterization based on bed slope and peak period of De Wit (2022).\n\n    References\n    ----------\n    De Wit, F.P., 2022. Wave shape prediction in complex coastal systems (Doctoral\n    dissertation, PhD. thesis. Delft University of Technology. https://repository.\n    tudelft. nl/islandora/object/uuid% 3A0fb850a4-4294-4181-9d74-857de21265c2).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import DEWIT\n        biphase = DEWIT()\n        print(biphase.render())\n        biphase = DEWIT(lpar=0.0)\n        print(biphase.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dewit\"] = Field(\n        default=\"dewit\", description=\"Model type discriminator\"\n    )\n    lpar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scales spatial averaging of the De Wit's biphase in terms of a multiple \"\n            \"of peak wave length of the incident wave field. Note: `lpar` = 0` means \"\n            \"no averaging (SWAN default: 0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        repr = \"BIPHASE DEWIT\"\n        if self.lpar is not None:\n            repr += f\" lpar={self.lpar}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dewit'] = Field(default='dewit', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.lpar","title":"lpar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lpar: Optional[float] = Field(default=None, description=\"Scales spatial averaging of the De Wit's biphase in terms of a multiple of peak wave length of the incident wave field. Note: `lpar` = 0` means no averaging (SWAN default: 0)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DEWIT.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = \"BIPHASE DEWIT\"\n    if self.lpar is not None:\n        repr += f\" lpar={self.lpar}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#transmission-and-reflection","title":"Transmission and reflection","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM","title":"TRANSM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Constant transmission coefficient.</p> <p>.. code-block:: text</p> <pre><code>TRANSM [trcoef]\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANSM\ntransm = TRANSM()\nprint(transm.render())\ntransm = TRANSM(trcoef=0.5)\nprint(transm.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANSM(BaseSubComponent):\n    \"\"\"Constant transmission coefficient.\n\n    .. code-block:: text\n\n        TRANSM [trcoef]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANSM\n        transm = TRANSM()\n        print(transm.render())\n        transm = TRANSM(trcoef=0.5)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"transm\", \"TRANSM\"] = Field(\n        default=\"transm\", description=\"Model type discriminator\"\n    )\n    trcoef: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Constant transmission coefficient (ratio of transmitted over incoming \"\n            \"significant wave height) (SWAN default: 0.0) (no transmission = complete \"\n            \"blockage)\"\n        ),\n        ge=0.0,\n        le=1.0,\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"TRANSM\"\n        if self.trcoef is not None:\n            repr += f\" trcoef={self.trcoef}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['transm', 'TRANSM'] = Field(default='transm', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: Optional[float] = Field(default=None, description='Constant transmission coefficient (ratio of transmitted over incoming significant wave height) (SWAN default: 0.0) (no transmission = complete blockage)', ge=0.0, le=1.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANSM.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"TRANSM\"\n    if self.trcoef is not None:\n        repr += f\" trcoef={self.trcoef}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D","title":"TRANS1D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency dependent transmission.</p> <p>.. code-block:: text</p> <pre><code>TRANS1D &lt; [trcoef] &gt;\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANS1D\ntransm = TRANS1D(trcoef=[0.0, 0.0, 0.2, 0.5, 0.2, 0.0, 0.0])\nprint(transm.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANS1D(BaseSubComponent):\n    \"\"\"Frequency dependent transmission.\n\n    .. code-block:: text\n\n        TRANS1D &lt; [trcoef] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANS1D\n        transm = TRANS1D(trcoef=[0.0, 0.0, 0.2, 0.5, 0.2, 0.0, 0.0])\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"trans1d\", \"TRANS1D\"] = Field(\n        default=\"trans1d\", description=\"Model type discriminator\"\n    )\n    trcoef: list[Annotated[float, Field(ge=0.0, le=1.0)]] = Field(\n        description=(\n            \"Transmission coefficient (ratio of transmitted over incoming significant \"\n            \"wave height) per frequency. The number of these transmission values must \"\n            \"be equal to the number of frequencies, i.e. `msc` + 1\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return f\"TRANS1D {' '.join(str(v) for v in self.trcoef)}\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['trans1d', 'TRANS1D'] = Field(default='trans1d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: list[Annotated[float, Field(ge=0.0, le=1.0)]] = Field(description='Transmission coefficient (ratio of transmitted over incoming significant wave height) per frequency. The number of these transmission values must be equal to the number of frequencies, i.e. `msc` + 1')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS1D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return f\"TRANS1D {' '.join(str(v) for v in self.trcoef)}\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D","title":"TRANS2D","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Frequency-direction dependent transmission.</p> <p>.. code-block:: text</p> <pre><code>TRANS2D &lt; [trcoef] &gt;\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import TRANS2D\ntrcoef = np.array([[0.0, 0.0], [0.1, 0.1], [0.2, 0.2]])\ntransm = TRANS2D(trcoef=trcoef)\nprint(transm.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class TRANS2D(BaseSubComponent):\n    \"\"\"Frequency-direction dependent transmission.\n\n    .. code-block:: text\n\n        TRANS2D &lt; [trcoef] &gt;\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import TRANS2D\n        trcoef = np.array([[0.0, 0.0], [0.1, 0.1], [0.2, 0.2]])\n        transm = TRANS2D(trcoef=trcoef)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"trans2d\", \"TRANS2D\"] = Field(\n        default=\"trans2d\", description=\"Model type discriminator\"\n    )\n    trcoef: Np2DArray = Field(\n        description=(\n            \"Transmission coefficient (ratio of transmitted over incoming significant \"\n            \"wave height) per frequency and direction, rows represent directions and \"\n            \"columns represent frequencies\"\n        ),\n    )\n\n    @field_validator(\"trcoef\")\n    @classmethod\n    def constrained_0_1(cls, value: float) -&gt; float:\n        \"\"\"Ensure all directions have the same number of frequencies.\"\"\"\n        if value.min() &lt; 0 or value.max() &gt; 1:\n            raise ValueError(\"Transmission coefficients must be between 0.0 and 1.0\")\n        return value\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"TRANS2D\"\n        for coef in self.trcoef:\n            repr += f\" &amp;\\n\\t{' '.join(str(v) for v in coef)}\"\n        return f\"{repr} &amp;\\n\\t\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['trans2d', 'TRANS2D'] = Field(default='trans2d', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.trcoef","title":"trcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trcoef: Np2DArray = Field(description='Transmission coefficient (ratio of transmitted over incoming significant wave height) per frequency and direction, rows represent directions and columns represent frequencies')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.constrained_0_1","title":"constrained_0_1  <code>classmethod</code>","text":"<pre><code>constrained_0_1(value: float) -&gt; float\n</code></pre> <p>Ensure all directions have the same number of frequencies.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>@field_validator(\"trcoef\")\n@classmethod\ndef constrained_0_1(cls, value: float) -&gt; float:\n    \"\"\"Ensure all directions have the same number of frequencies.\"\"\"\n    if value.min() &lt; 0 or value.max() &gt; 1:\n        raise ValueError(\"Transmission coefficients must be between 0.0 and 1.0\")\n    return value\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.TRANS2D.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"TRANS2D\"\n    for coef in self.trcoef:\n        repr += f\" &amp;\\n\\t{' '.join(str(v) for v in coef)}\"\n    return f\"{repr} &amp;\\n\\t\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA","title":"GODA","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>DAM transmission of Goda/Seelig (1979).</p> <p>.. code-block:: text</p> <pre><code>DAM GODA [hgt] [alpha] [beta]\n</code></pre> <p>This option specified transmission coefficients dependent on the incident wave conditions at the obstacle and on the obstacle height (which may be submerged).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA--references","title":"References","text":"<p>Goda, Y. and Suzuki, Y., 1976. Estimation of incident and reflected waves in random wave experiments. In Coastal Engineering 1976 (pp. 828-845).</p> <p>Seelig, W.N., 1979. Effects of breakwaters on waves: Laboratory test of wave transmission by overtopping. In Proc. Conf. Coastal Structures, 1979 (Vol. 79, No. 2, pp. 941-961).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import GODA\ntransm = GODA(hgt=3.0)\nprint(transm.render())\ntransm = GODA(hgt=3.0, alpha=2.6, beta=0.15)\nprint(transm.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class GODA(BaseSubComponent):\n    \"\"\"DAM transmission of Goda/Seelig (1979).\n\n    .. code-block:: text\n\n        DAM GODA [hgt] [alpha] [beta]\n\n    This option specified transmission coefficients dependent on the incident wave\n    conditions at the obstacle and on the obstacle height (which may be submerged).\n\n    References\n    ----------\n    Goda, Y. and Suzuki, Y., 1976. Estimation of incident and reflected waves in random\n    wave experiments. In Coastal Engineering 1976 (pp. 828-845).\n\n    Seelig, W.N., 1979. Effects of breakwaters on waves: Laboratory test of wave\n    transmission by overtopping. In Proc. Conf. Coastal Structures, 1979\n    (Vol. 79, No. 2, pp. 941-961).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import GODA\n        transm = GODA(hgt=3.0)\n        print(transm.render())\n        transm = GODA(hgt=3.0, alpha=2.6, beta=0.15)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"goda\", \"GODA\"] = Field(\n        default=\"goda\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle above reference level (same \"\n            \"reference level as for bottom etc.); use a negative value if the top is \"\n            \"below that reference level\"\n        ),\n    )\n    alpha: Optional[float] = Field(\n        default=None,\n        description=(\n            \"coefficient determining the transmission coefficient for Goda's \"\n            \"transmission formula (SWAN default: 2.6)\"\n        ),\n    )\n    beta: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Another coefficient determining the transmission coefficient for Goda's \"\n            \"transmission formula (SWAN default: 0.15)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"DAM {self.model_type.upper()} hgt={self.hgt}\"\n        if self.alpha is not None:\n            repr += f\" alpha={self.alpha}\"\n        if self.beta is not None:\n            repr += f\" beta={self.beta}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['goda', 'GODA'] = Field(default='goda', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle above reference level (same reference level as for bottom etc.); use a negative value if the top is below that reference level')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Optional[float] = Field(default=None, description=\"coefficient determining the transmission coefficient for Goda's transmission formula (SWAN default: 2.6)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.beta","title":"beta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>beta: Optional[float] = Field(default=None, description=\"Another coefficient determining the transmission coefficient for Goda's transmission formula (SWAN default: 0.15)\")\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.GODA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"DAM {self.model_type.upper()} hgt={self.hgt}\"\n    if self.alpha is not None:\n        repr += f\" alpha={self.alpha}\"\n    if self.beta is not None:\n        repr += f\" beta={self.beta}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND","title":"DANGREMOND","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>DAM transmission of d'Angremond et al. (1996).</p> <p>.. code-block:: text</p> <pre><code>DAM DANGREMOND [hgt] [slope] [Bk]\n</code></pre> <p>This option specifies transmission coefficients dependent on the incident wave conditions at the obstacle and on the obstacle height (which may be submerged).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND--references","title":"References","text":"<p>d'Angremond, K., Van Der Meer, J.W. and De Jong, R.J., 1996. Wave transmission at low-crested structures. In Coastal Engineering 1996 (pp. 2418-2427).</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import DANGREMOND\ntransm = DANGREMOND(hgt=3.0, slope=60, Bk=10.0)\nprint(transm.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class DANGREMOND(BaseSubComponent):\n    \"\"\"DAM transmission of d'Angremond et al. (1996).\n\n    .. code-block:: text\n\n        DAM DANGREMOND [hgt] [slope] [Bk]\n\n    This option specifies transmission coefficients dependent on the incident wave\n    conditions at the obstacle and on the obstacle height (which may be submerged).\n\n    References\n    ----------\n    d'Angremond, K., Van Der Meer, J.W. and De Jong, R.J., 1996. Wave transmission at\n    low-crested structures. In Coastal Engineering 1996 (pp. 2418-2427).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import DANGREMOND\n        transm = DANGREMOND(hgt=3.0, slope=60, Bk=10.0)\n        print(transm.render())\n\n    \"\"\"\n\n    model_type: Literal[\"dangremond\", \"DANGREMOND\"] = Field(\n        default=\"dangremond\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle above reference level (same \"\n            \"reference level as for bottom etc.); use a negative value if the top is \"\n            \"below that reference level\"\n        ),\n    )\n    slope: float = Field(\n        description=\"The slope of the obstacle (in degrees)\", ge=0.0, le=90.0\n    )\n    Bk: float = Field(description=\"The crest width of the obstacle\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"DAM {self.model_type.upper()}\"\n        repr += f\" hgt={self.hgt} slope={self.slope} Bk={self.Bk}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['dangremond', 'DANGREMOND'] = Field(default='dangremond', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle above reference level (same reference level as for bottom etc.); use a negative value if the top is below that reference level')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: float = Field(description='The slope of the obstacle (in degrees)', ge=0.0, le=90.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.Bk","title":"Bk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bk: float = Field(description='The crest width of the obstacle')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.DANGREMOND.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"DAM {self.model_type.upper()}\"\n    repr += f\" hgt={self.hgt} slope={self.slope} Bk={self.Bk}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL","title":"REFL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Obstacle reflections.</p> <p>.. code-block:: text</p> <pre><code>REFL [reflc]\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import REFL\nrefl = REFL()\nprint(refl.render())\nrefl = REFL(reflc=0.5)\nprint(refl.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class REFL(BaseSubComponent):\n    \"\"\"Obstacle reflections.\n\n    .. code-block:: text\n\n        REFL [reflc]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import REFL\n        refl = REFL()\n        print(refl.render())\n        refl = REFL(reflc=0.5)\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"refl\", \"REFL\"] = Field(\n        default=\"refl\", description=\"Model type discriminator\"\n    )\n    reflc: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Constant reflection coefficient (ratio of reflected over incoming \"\n            \"significant wave height) (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"REFL\"\n        if self.reflc is not None:\n            repr += f\" reflc={self.reflc}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['refl', 'REFL'] = Field(default='refl', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.reflc","title":"reflc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflc: Optional[float] = Field(default=None, description='Constant reflection coefficient (ratio of reflected over incoming significant wave height) (SWAN default: 1.0)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.REFL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"REFL\"\n    if self.reflc is not None:\n        repr += f\" reflc={self.reflc}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC","title":"RSPEC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Specular reflection.</p> <p>.. code-block:: text</p> <pre><code>RSPEC\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import RSPEC\nrefl = RSPEC()\nprint(refl.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class RSPEC(BaseSubComponent):\n    \"\"\"Specular reflection.\n\n    .. code-block:: text\n\n        RSPEC\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import RSPEC\n        refl = RSPEC()\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rspec\", \"RSPEC\"] = Field(\n        default=\"rspec\", description=\"Model type discriminator\"\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        return \"RSPEC\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rspec', 'RSPEC'] = Field(default='rspec', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RSPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    return \"RSPEC\"\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF","title":"RDIFF","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Diffuse reflection.</p> <p>.. code-block:: text</p> <pre><code>RDIFF [pown]\n</code></pre> <p>Specular reflection where incident waves are scattered over reflected direction.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import RDIFF\nrefl = RDIFF()\nprint(refl.render())\nrefl = RDIFF(pown=1.0)\nprint(refl.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class RDIFF(BaseSubComponent):\n    \"\"\"Diffuse reflection.\n\n    .. code-block:: text\n\n        RDIFF [pown]\n\n    Specular reflection where incident waves are scattered over reflected direction.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import RDIFF\n        refl = RDIFF()\n        print(refl.render())\n        refl = RDIFF(pown=1.0)\n        print(refl.render())\n\n    \"\"\"\n\n    model_type: Literal[\"rdiff\", \"RDIFF\"] = Field(\n        default=\"rdiff\", description=\"Model type discriminator\"\n    )\n    pown: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Each incoming direction \u03b8 is scattered over reflected direction \u03b8_refl \"\n            \"according to cos^pown(\u03b8-\u03b8_refl). The parameter `pown` indicates the width\"\n            \"of the redistribution function (SWAN default: 1.0)\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"RDIFF\"\n        if self.pown is not None:\n            repr += f\" pown={self.pown}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['rdiff', 'RDIFF'] = Field(default='rdiff', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.pown","title":"pown  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pown: Optional[float] = Field(default=None, description='Each incoming direction \u03b8 is scattered over reflected direction \u03b8_refl according to cos^pown(\u03b8-\u03b8_refl). The parameter `pown` indicates the widthof the redistribution function (SWAN default: 1.0)')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.RDIFF.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"RDIFF\"\n    if self.pown is not None:\n        repr += f\" pown={self.pown}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD","title":"FREEBOARD","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Freeboard dependent transmission and reflection.</p> <p>.. code-block:: text</p> <pre><code>FREEBOARD [hgt] [gammat] [gammar] [QUAY]\n</code></pre> <p>With this option the user indicates that the fixed transmission <code>trcoef</code> and reflection <code>reflc</code> coefficients are freeboard dependent. The freeboard dependency has no effect on the transmission coefficient as computed using the DAM option.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD--notes","title":"Notes","text":"<p>See the Scientific/Technical documentation for background information on the <code>gammat</code> and <code>gammar</code> shape parameters.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import FREEBOARD\nfreeboard = FREEBOARD(hgt=2.0)\nprint(freeboard.render())\nfreeboard = FREEBOARD(hgt=2.0, gammat=1.0, gammar=1.0, quay=True)\nprint(freeboard.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class FREEBOARD(BaseSubComponent):\n    \"\"\"Freeboard dependent transmission and reflection.\n\n    .. code-block:: text\n\n        FREEBOARD [hgt] [gammat] [gammar] [QUAY]\n\n    With this option the user indicates that the fixed transmission `trcoef` and\n    reflection `reflc` coefficients are freeboard dependent. The freeboard dependency\n    has no effect on the transmission coefficient as computed using the DAM option.\n\n    Notes\n    -----\n    See the Scientific/Technical documentation for background information on the\n    `gammat` and `gammar` shape parameters.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import FREEBOARD\n        freeboard = FREEBOARD(hgt=2.0)\n        print(freeboard.render())\n        freeboard = FREEBOARD(hgt=2.0, gammat=1.0, gammar=1.0, quay=True)\n        print(freeboard.render())\n\n    \"\"\"\n\n    model_type: Literal[\"freeboard\", \"FREEBOARD\"] = Field(\n        default=\"freeboard\", description=\"Model type discriminator\"\n    )\n    hgt: float = Field(\n        description=(\n            \"The elevation of the top of the obstacle or height of the quay above the \"\n            \"reference level (same reference level as for the bottom). Use a negative \"\n            \"value if the top is below that reference level. In case `hgt` is also \"\n            \"specified in the DAM option, both values of `hgt` should be equal for \"\n            \"consistency\"\n        ),\n    )\n    gammat: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape parameter of relative freeboard dependency of transmission \"\n            \"coefficient. This parameter should be higher than zero (SWAN default 1.0)\"\n        ),\n        gt=0.0,\n    )\n    gammar: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Shape parameter of relative freeboard dependency of reflection \"\n            \"coefficient. This parameter should be higher than zero (SWAN default 1.0)\"\n        ),\n        gt=0.0,\n    )\n    quay: bool = Field(\n        default=False,\n        description=(\n            \"With this option the user indicates that the freeboard dependency of the \"\n            \"transmission and reflection coefficients also depends on the relative \"\n            \"position of an obstacle-linked grid point with respect to the position \"\n            \"of the obstacle line representing the edge of a quay. In case the active \"\n            \"grid point is on the deeper side of the obstacle, then the correction \"\n            \"factors are applied using the parameters `hgt`, `gammat` and `gammar`.\"\n            \"In case the active grid point is on the shallower side of the obstacle, \"\n            \"the reflection coefficient is set to 0 and the transmission coefficient \"\n            \"to 1.\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"FREEBOARD\"\n        if self.hgt is not None:\n            repr += f\" hgt={self.hgt}\"\n        if self.gammat is not None:\n            repr += f\" gammat={self.gammat}\"\n        if self.gammar is not None:\n            repr += f\" gammar={self.gammar}\"\n        if self.quay:\n            repr += \" QUAY\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['freeboard', 'FREEBOARD'] = Field(default='freeboard', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.hgt","title":"hgt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hgt: float = Field(description='The elevation of the top of the obstacle or height of the quay above the reference level (same reference level as for the bottom). Use a negative value if the top is below that reference level. In case `hgt` is also specified in the DAM option, both values of `hgt` should be equal for consistency')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.gammat","title":"gammat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gammat: Optional[float] = Field(default=None, description='Shape parameter of relative freeboard dependency of transmission coefficient. This parameter should be higher than zero (SWAN default 1.0)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.gammar","title":"gammar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gammar: Optional[float] = Field(default=None, description='Shape parameter of relative freeboard dependency of reflection coefficient. This parameter should be higher than zero (SWAN default 1.0)', gt=0.0)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.quay","title":"quay  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quay: bool = Field(default=False, description='With this option the user indicates that the freeboard dependency of the transmission and reflection coefficients also depends on the relative position of an obstacle-linked grid point with respect to the position of the obstacle line representing the edge of a quay. In case the active grid point is on the deeper side of the obstacle, then the correction factors are applied using the parameters `hgt`, `gammat` and `gammar`.In case the active grid point is on the shallower side of the obstacle, the reflection coefficient is set to 0 and the transmission coefficient to 1.')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.FREEBOARD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"FREEBOARD\"\n    if self.hgt is not None:\n        repr += f\" hgt={self.hgt}\"\n    if self.gammat is not None:\n        repr += f\" gammat={self.gammat}\"\n    if self.gammar is not None:\n        repr += f\" gammar={self.gammar}\"\n    if self.quay:\n        repr += \" QUAY\"\n    return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE","title":"LINE","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Line of points to define obstacle location.</p> <p>.. code-block:: text</p> <pre><code>LINE &lt; [xp] [yp] &gt;\n</code></pre> <p>With this option the user indicates that the fixed transmission <code>trcoef</code> and reflection <code>reflc</code> coefficients are freeboard dependent. The freeboard dependency has no effect on the transmission coefficient as computed using the DAM option.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE--notes","title":"Notes","text":"<p>Points coordinates should be provided in m If Cartesian coordinates are used or in degrees if spherical coordinates are used (see command <code>COORD</code>). At least two corner points must be provided.</p>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.physics import LINE\nline = LINE(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1])\nprint(line.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>class LINE(BaseSubComponent):\n    \"\"\"Line of points to define obstacle location.\n\n    .. code-block:: text\n\n        LINE &lt; [xp] [yp] &gt;\n\n    With this option the user indicates that the fixed transmission `trcoef` and\n    reflection `reflc` coefficients are freeboard dependent. The freeboard dependency\n    has no effect on the transmission coefficient as computed using the DAM option.\n\n    Notes\n    -----\n    Points coordinates should be provided in m If Cartesian coordinates are used or in\n    degrees if spherical coordinates are used (see command `COORD`). At least two\n    corner points must be provided.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.physics import LINE\n        line = LINE(xp=[174.1, 174.2, 174.3], yp=[-39.1, -39.1, -39.1])\n        print(line.render())\n\n    \"\"\"\n\n    model_type: Literal[\"line\", \"LINE\"] = Field(\n        default=\"line\", description=\"Model type discriminator\"\n    )\n    xp: list[float] = Field(\n        description=\"The x-coordinates of the points defining the line\", min_length=2\n    )\n    yp: list[float] = Field(\n        description=\"The y-coordinates of the points defining the line\", min_length=2\n    )\n\n    @model_validator(mode=\"after\")\n    def check_length(self) -&gt; \"LINE\":\n        \"\"\"Check that the length of xp and yp are the same.\"\"\"\n        if len(self.xp) != len(self.yp):\n            raise ValueError(\"xp and yp must be the same length\")\n        return self\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = \"LINE\"\n        for xp, yp in zip(self.xp, self.yp):\n            repr += f\" {xp} {yp}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE-attributes","title":"Attributes","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['line', 'LINE'] = Field(default='line', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: list[float] = Field(description='The x-coordinates of the points defining the line', min_length=2)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: list[float] = Field(description='The y-coordinates of the points defining the line', min_length=2)\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE-functions","title":"Functions","text":""},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.check_length","title":"check_length","text":"<pre><code>check_length() -&gt; LINE\n</code></pre> <p>Check that the length of xp and yp are the same.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_length(self) -&gt; \"LINE\":\n    \"\"\"Check that the length of xp and yp are the same.\"\"\"\n    if len(self.xp) != len(self.yp):\n        raise ValueError(\"xp and yp must be the same length\")\n    return self\n</code></pre>"},{"location":"subcomponents/physics/#rompy_swan.subcomponents.physics.LINE.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/physics.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = \"LINE\"\n    for xp, yp in zip(self.xp, self.yp):\n        repr += f\" {xp} {yp}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/","title":"Grid reader","text":"<p>Sub-commands to support file reading. These are in technically components in that they render a full command line however they are not intended to be used directly but rather as sub-components of CGRID and INPGRID commands.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR","title":"GRIDREGULAR","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>SWAN Regular Grid subcomponent.</p> <p>.. code-block:: text</p> <pre><code>xp yp alp xlen ylen mx my\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--note","title":"Note","text":"<p>The direction of the x-axis <code>alp</code> must be 0 in case of spherical coordinates</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--note_1","title":"Note","text":"<p>All coordinates and distances should be given in m when Cartesian coordinates are used or degrees when Spherical coordinates are used (see command COORD).</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import GRIDREGULAR\nkwargs = dict(xp=173, yp=-40, alp=0, xlen=2, ylen=2, mx=199, my=199)\ngrid = GRIDREGULAR(suffix=\"c\", **kwargs)\nprint(grid.render())\ngrid = GRIDREGULAR(suffix=\"inp\", **kwargs)\nprint(grid.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>class GRIDREGULAR(BaseSubComponent):\n    \"\"\"SWAN Regular Grid subcomponent.\n\n    .. code-block:: text\n\n        xp yp alp xlen ylen mx my\n\n    Note\n    ----\n    The direction of the x-axis `alp` must be 0 in case of spherical coordinates\n\n    Note\n    ----\n    All coordinates and distances should be given in m when Cartesian coordinates are\n    used or degrees when Spherical coordinates are used (see command COORD).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import GRIDREGULAR\n        kwargs = dict(xp=173, yp=-40, alp=0, xlen=2, ylen=2, mx=199, my=199)\n        grid = GRIDREGULAR(suffix=\"c\", **kwargs)\n        print(grid.render())\n        grid = GRIDREGULAR(suffix=\"inp\", **kwargs)\n        print(grid.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gridregular\", \"GRIDREGULAR\"] = Field(\n        default=\"gridregular\", description=\"Model type discriminator\"\n    )\n    xp: float = Field(\n        description=\"The x-coordinate of the origin in problem coordinates\",\n    )\n    yp: float = Field(\n        description=\"The y-coordinate of the origin in problem coordinates\",\n    )\n    alp: Optional[float] = Field(\n        default=0.0,\n        description=\"Direction of the xaxis in degrees\",\n    )\n    xlen: float = Field(\n        description=\"Length of the computational grid in the x-direction\"\n    )\n    ylen: float = Field(\n        description=\"Length of the computational grid in the y-direction\"\n    )\n    mx: int = Field(\n        description=(\n            \"Number of meshes in computational grid in x-direction (this number is \"\n            \"one less than the number of grid points in this domain)\"\n        ),\n    )\n    my: int = Field(\n        description=(\n            \"Number of meshes in computational grid in y-direction (this number is \"\n            \"one less than the number of grid points in this domain)\"\n        ),\n    )\n    suffix: Optional[str] = Field(\n        default=\"\", description=\"Suffix for rendering with each output grid parameter.\"\n    )\n\n    @property\n    def dx(self):\n        \"\"\"Grid spacing in x-direction.\"\"\"\n        return self.xlen / self.mx\n\n    @property\n    def dy(self):\n        \"\"\"Grid spacing in y-direction.\"\"\"\n        return self.ylen / self.my\n\n    def cmd(self) -&gt; str:\n        \"\"\"Command file string for this subcomponent.\"\"\"\n        repr = f\"xp{self.suffix}={self.xp}\"\n        repr += f\" yp{self.suffix}={self.yp}\"\n        repr += f\" alp{self.suffix}={self.alp}\"\n        repr += f\" xlen{self.suffix}={self.xlen}\"\n        repr += f\" ylen{self.suffix}={self.ylen}\"\n        repr += f\" mx{self.suffix}={self.mx}\"\n        repr += f\" my{self.suffix}={self.my}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gridregular', 'GRIDREGULAR'] = Field(default='gridregular', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.xp","title":"xp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xp: float = Field(description='The x-coordinate of the origin in problem coordinates')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.yp","title":"yp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>yp: float = Field(description='The y-coordinate of the origin in problem coordinates')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.alp","title":"alp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alp: Optional[float] = Field(default=0.0, description='Direction of the xaxis in degrees')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.xlen","title":"xlen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xlen: float = Field(description='Length of the computational grid in the x-direction')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.ylen","title":"ylen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ylen: float = Field(description='Length of the computational grid in the y-direction')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.mx","title":"mx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mx: int = Field(description='Number of meshes in computational grid in x-direction (this number is one less than the number of grid points in this domain)')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.my","title":"my  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>my: int = Field(description='Number of meshes in computational grid in y-direction (this number is one less than the number of grid points in this domain)')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: Optional[str] = Field(default='', description='Suffix for rendering with each output grid parameter.')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.dx","title":"dx  <code>property</code>","text":"<pre><code>dx\n</code></pre> <p>Grid spacing in x-direction.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.dy","title":"dy  <code>property</code>","text":"<pre><code>dy\n</code></pre> <p>Grid spacing in y-direction.</p>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.GRIDREGULAR.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Command file string for this subcomponent.</p> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Command file string for this subcomponent.\"\"\"\n    repr = f\"xp{self.suffix}={self.xp}\"\n    repr += f\" yp{self.suffix}={self.yp}\"\n    repr += f\" alp{self.suffix}={self.alp}\"\n    repr += f\" xlen{self.suffix}={self.xlen}\"\n    repr += f\" ylen{self.suffix}={self.ylen}\"\n    repr += f\" mx{self.suffix}={self.mx}\"\n    repr += f\" my{self.suffix}={self.my}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD","title":"READCOORD","text":"<p>               Bases: <code>READGRID</code></p> <p>SWAN coordinates reader.</p> <p>.. code-block:: text</p> <pre><code>READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n    FREE|FORMAT ('form'|idfm)\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import READCOORD\nreadcoord = READCOORD(\n    fac=1.0,\n    fname=\"coords.txt\",\n    idla=3,\n    format=\"free\",\n)\nprint(readcoord.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>class READCOORD(READGRID):\n    \"\"\"SWAN coordinates reader.\n\n    .. code-block:: text\n\n        READGRID COORDINATES [fac] 'fname' [idla] [nhedf] [nhedvec] &amp;\n            FREE|FORMAT ('form'|idfm)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import READCOORD\n        readcoord = READCOORD(\n            fac=1.0,\n            fname=\"coords.txt\",\n            idla=3,\n            format=\"free\",\n        )\n        print(readcoord.render())\n\n    \"\"\"\n\n    model_type: Literal[\"readcoord\", \"READCOORD\"] = Field(\n        default=\"readcoord\", description=\"Model type discriminator\"\n    )\n    grid_type: Literal[\"coordinates\"] = Field(\n        default=\"coordinates\", description=\"Type of the SWAN grid file\"\n    )\n    fname: str = Field(description=\"Name of the SWAN coordinates file\")\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"READGRID COORDINATES fac={self.fac} fname='{self.fname}' \"\n            f\"idla={self.idla} nhedf={self.nhedf} nhedvec={self.nhedvec} \"\n            f\"{self.format_repr}\"\n        )\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['readcoord', 'READCOORD'] = Field(default='readcoord', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Literal['coordinates'] = Field(default='coordinates', description='Type of the SWAN grid file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.fname","title":"fname  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname: str = Field(description='Name of the SWAN coordinates file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READCOORD.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"READGRID COORDINATES fac={self.fac} fname='{self.fname}' \"\n        f\"idla={self.idla} nhedf={self.nhedf} nhedvec={self.nhedvec} \"\n        f\"{self.format_repr}\"\n    )\n    return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP","title":"READINP","text":"<p>               Bases: <code>READGRID</code></p> <p>SWAN input grid reader.</p> <p>.. code-block:: text</p> <pre><code>READINP GRID_TYPE [fac] ('fname1' | SERIES 'fname2') [idla] [nhedf] &amp;\n    ([nhedt]) [nhedvec] FREE|FORMAT ('form'|idfm)|UNFORMATTED`\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.readgrid import READINP\nreadinp = READINP(\n    grid_type=\"wind\",\n    fname1=\"wind.txt\",\n    fac=1.0,\n    idla=3,\n    format=\"free\",\n)\nprint(readinp.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>class READINP(READGRID):\n    \"\"\"SWAN input grid reader.\n\n    .. code-block:: text\n\n        READINP GRID_TYPE [fac] ('fname1' | SERIES 'fname2') [idla] [nhedf] &amp;\n            ([nhedt]) [nhedvec] FREE|FORMAT ('form'|idfm)|UNFORMATTED`\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.readgrid import READINP\n        readinp = READINP(\n            grid_type=\"wind\",\n            fname1=\"wind.txt\",\n            fac=1.0,\n            idla=3,\n            format=\"free\",\n        )\n        print(readinp.render())\n\n    \"\"\"\n\n    model_type: Literal[\"readinp\", \"READINP\"] = Field(\n        default=\"readinp\", description=\"Model type discriminator\"\n    )\n    grid_type: Optional[GridOptions] = Field(\n        default=None, description=\"Type of the SWAN grid file\"\n    )\n    fname1: str = Field(\n        description=\"Name of the file with the values of the variable.\",\n    )\n    fname2: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Name of file that contains the names of the files where the variables \"\n            \"are given when the SERIES option is used. These names are to be given in \"\n            \"proper time sequence. SWAN reads the next file when the previous file \"\n            \"end has been encountered. In these files the input should be given in \"\n            \"the same format as in the above file 'fname1' (that implies that a file \"\n            \"should start with the start of an input time step)\"\n        ),\n    )\n    nhedt: int = Field(\n        default=0,\n        description=(\n            \"Only if variable is time dependent: number of header lines in the file \"\n            \"at the start of each time level. A time step may start with more header \"\n            \"lines than `nhedt` because the variable may be a vector variable which \"\n            \"has its own header lines (see `nhedvec`)\"\n        ),\n        ge=0,\n    )\n\n    @field_validator(\"grid_type\")\n    @classmethod\n    def set_undefined(cls, v: str | None) -&gt; str:\n        \"\"\"Allow for undefined value so it can be redefined in INPGRID components.\"\"\"\n        if v is None:\n            return \"undefined\"\n        return v\n\n    def cmd(self) -&gt; str:\n        repr = f\"READINP {self.grid_type.upper()} fac={self.fac} fname1='{self.fname1}'\"\n        if self.fname2:\n            repr += f\" SERIES fname2='{self.fname2}'\"\n        repr += f\" idla={self.idla} nhedf={self.nhedf} nhedt={self.nhedt} nhedvec={self.nhedvec} {self.format_repr}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP-attributes","title":"Attributes","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['readinp', 'READINP'] = Field(default='readinp', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.grid_type","title":"grid_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid_type: Optional[GridOptions] = Field(default=None, description='Type of the SWAN grid file')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.fname1","title":"fname1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname1: str = Field(description='Name of the file with the values of the variable.')\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.fname2","title":"fname2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fname2: Optional[str] = Field(default=None, description=\"Name of file that contains the names of the files where the variables are given when the SERIES option is used. These names are to be given in proper time sequence. SWAN reads the next file when the previous file end has been encountered. In these files the input should be given in the same format as in the above file 'fname1' (that implies that a file should start with the start of an input time step)\")\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.nhedt","title":"nhedt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nhedt: int = Field(default=0, description='Only if variable is time dependent: number of header lines in the file at the start of each time level. A time step may start with more header lines than `nhedt` because the variable may be a vector variable which has its own header lines (see `nhedvec`)', ge=0)\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP-functions","title":"Functions","text":""},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.set_undefined","title":"set_undefined  <code>classmethod</code>","text":"<pre><code>set_undefined(v: str | None) -&gt; str\n</code></pre> <p>Allow for undefined value so it can be redefined in INPGRID components.</p> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>@field_validator(\"grid_type\")\n@classmethod\ndef set_undefined(cls, v: str | None) -&gt; str:\n    \"\"\"Allow for undefined value so it can be redefined in INPGRID components.\"\"\"\n    if v is None:\n        return \"undefined\"\n    return v\n</code></pre>"},{"location":"subcomponents/readgrid/#rompy_swan.subcomponents.readgrid.READINP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/readgrid.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"READINP {self.grid_type.upper()} fac={self.fac} fname1='{self.fname1}'\"\n    if self.fname2:\n        repr += f\" SERIES fname2='{self.fname2}'\"\n    repr += f\" idla={self.idla} nhedf={self.nhedf} nhedt={self.nhedt} nhedvec={self.nhedvec} {self.format_repr}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/","title":"Spectrum","text":"<p>Sub-commands to support spectrum definition</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM","title":"SPECTRUM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>SWAN spectrum specification.</p> <p>.. code-block:: text</p> <pre><code>-&gt;CIRCLE|SECTOR ([dir1] [dir2]) [mdc] [flow] [fhigh] [msc]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM--notes","title":"Notes","text":"<p>Directions in the spectra are defined either as a CIRCLE or as a SECTOR. In the case of a SECTOR, both <code>dir1</code> and <code>dir2</code> must be specified. In the case of a CIRCLE, neither <code>dir1</code> nor <code>dir2</code> should be specified.</p> <p>At least two of <code>flow</code>, <code>fhigh</code> and <code>msc</code> must be specified in which case the third parameter will be calculated by SWAN such that the frequency resolution <code>df/f = 0.1</code> (10% increments).</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import SPECTRUM\nspec = SPECTRUM(mdc=36, flow=0.04, fhigh=1.0)\nprint(spec.render())\nspec = SPECTRUM(mdc=36, dir1=0, dir2=180, flow=0.04, msc=31)\nprint(spec.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class SPECTRUM(BaseSubComponent):\n    \"\"\"SWAN spectrum specification.\n\n    .. code-block:: text\n\n        -&gt;CIRCLE|SECTOR ([dir1] [dir2]) [mdc] [flow] [fhigh] [msc]\n\n    Notes\n    -----\n\n    Directions in the spectra are defined either as a CIRCLE or as a SECTOR. In the\n    case of a SECTOR, both `dir1` and `dir2` must be specified. In the case of a\n    CIRCLE, neither `dir1` nor `dir2` should be specified.\n\n    At least two of `flow`, `fhigh` and `msc` must be specified in which case the\n    third parameter will be calculated by SWAN such that the frequency resolution\n    `df/f = 0.1` (10% increments).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import SPECTRUM\n        spec = SPECTRUM(mdc=36, flow=0.04, fhigh=1.0)\n        print(spec.render())\n        spec = SPECTRUM(mdc=36, dir1=0, dir2=180, flow=0.04, msc=31)\n        print(spec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spectrum\", \"SPECTRUM\"] = Field(\n        default=\"spectrum\", description=\"Model type discriminator\"\n    )\n    mdc: int = Field(\n        description=(\n            \"Number of meshes in theta-space. In the case of CIRCLE, this is the \"\n            \"number of subdivisions of the 360 degrees of a circle so \"\n            \"`dtheta = [360]/[mdc]` is the spectral directional resolution. In the \"\n            \"case of SECTOR, `dtheta = ([dir2] - [dir1])/[mdc]`. The minimum number \"\n            \"of directional bins is 3 per directional quadrant.\"\n        )\n    )\n    flow: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Lowest discrete frequency that is used in the calculation (in Hz).\"\n        ),\n    )\n    fhigh: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Highest discrete frequency that is used in the calculation (in Hz).\"\n        ),\n    )\n    msc: Optional[int] = Field(\n        default=None,\n        description=(\n            \"One less than the number of frequencies. This defines the grid \"\n            \"resolution in frequency-space between the lowest discrete frequency \"\n            \"`flow` and the highest discrete frequency `fhigh`. This resolution is \"\n            \"not constant, since the frequencies are distributed logarithmical: \"\n            \"`fi+1 = yfi` where `y` is a constant. The minimum number of frequencies \"\n            \"is 4\"\n        ),\n        ge=3,\n    )\n    dir1: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The direction of the right-hand boundary of the sector when looking \"\n            \"outward from the sector (required for option SECTOR) in degrees.\"\n        ),\n    )\n    dir2: Optional[float] = Field(\n        default=None,\n        description=(\n            \"The direction of the left-hand boundary of the sector when looking \"\n            \"outward from the sector (required for option SECTOR) in degrees.\"\n        ),\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_direction_definition(cls, data: Any) -&gt; Any:\n        \"\"\"Check that dir1 and dir2 are specified together.\"\"\"\n        dir1 = data.get(\"dir1\")\n        dir2 = data.get(\"dir2\")\n        if None in [dir1, dir2] and dir1 != dir2:\n            raise ValueError(\"dir1 and dir2 must be specified together\")\n        return data\n\n    @model_validator(mode=\"after\")\n    def check_frequency_definition(self) -&gt; \"SPECTRUM\":\n        \"\"\"Check spectral frequencies are prescribed correctly.\"\"\"\n        args = [self.flow, self.fhigh, self.msc]\n        if None in args:\n            args = [arg for arg in args if arg is not None]\n            if len(args) != 2:\n                raise ValueError(\"You must specify at least 2 of [flow, fhigh, msc]\")\n        if self.flow is not None and self.fhigh is not None and self.flow &gt;= self.fhigh:\n            raise ValueError(\"flow must be less than fhigh\")\n        return self\n\n    @property\n    def dir_sector(self):\n        if self.dir1 is None and self.dir2 is None:\n            return \"CIRCLE\"\n        else:\n            return f\"SECTOR {self.dir1} {self.dir2}\"\n\n    def cmd(self) -&gt; str:\n        repr = f\"{self.dir_sector} mdc={self.mdc}\"\n        if self.flow is not None:\n            repr += f\" flow={self.flow}\"\n        if self.fhigh is not None:\n            repr += f\" fhigh={self.fhigh}\"\n        if self.msc is not None:\n            repr += f\" msc={self.msc}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spectrum', 'SPECTRUM'] = Field(default='spectrum', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.mdc","title":"mdc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mdc: int = Field(description='Number of meshes in theta-space. In the case of CIRCLE, this is the number of subdivisions of the 360 degrees of a circle so `dtheta = [360]/[mdc]` is the spectral directional resolution. In the case of SECTOR, `dtheta = ([dir2] - [dir1])/[mdc]`. The minimum number of directional bins is 3 per directional quadrant.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.flow","title":"flow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flow: Optional[float] = Field(default=None, description='Lowest discrete frequency that is used in the calculation (in Hz).')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.fhigh","title":"fhigh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fhigh: Optional[float] = Field(default=None, description='Highest discrete frequency that is used in the calculation (in Hz).')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.msc","title":"msc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>msc: Optional[int] = Field(default=None, description='One less than the number of frequencies. This defines the grid resolution in frequency-space between the lowest discrete frequency `flow` and the highest discrete frequency `fhigh`. This resolution is not constant, since the frequencies are distributed logarithmical: `fi+1 = yfi` where `y` is a constant. The minimum number of frequencies is 4', ge=3)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir1","title":"dir1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir1: Optional[float] = Field(default=None, description='The direction of the right-hand boundary of the sector when looking outward from the sector (required for option SECTOR) in degrees.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir2","title":"dir2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dir2: Optional[float] = Field(default=None, description='The direction of the left-hand boundary of the sector when looking outward from the sector (required for option SECTOR) in degrees.')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.dir_sector","title":"dir_sector  <code>property</code>","text":"<pre><code>dir_sector\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.check_direction_definition","title":"check_direction_definition  <code>classmethod</code>","text":"<pre><code>check_direction_definition(data: Any) -&gt; Any\n</code></pre> <p>Check that dir1 and dir2 are specified together.</p> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef check_direction_definition(cls, data: Any) -&gt; Any:\n    \"\"\"Check that dir1 and dir2 are specified together.\"\"\"\n    dir1 = data.get(\"dir1\")\n    dir2 = data.get(\"dir2\")\n    if None in [dir1, dir2] and dir1 != dir2:\n        raise ValueError(\"dir1 and dir2 must be specified together\")\n    return data\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.check_frequency_definition","title":"check_frequency_definition","text":"<pre><code>check_frequency_definition() -&gt; SPECTRUM\n</code></pre> <p>Check spectral frequencies are prescribed correctly.</p> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_frequency_definition(self) -&gt; \"SPECTRUM\":\n    \"\"\"Check spectral frequencies are prescribed correctly.\"\"\"\n    args = [self.flow, self.fhigh, self.msc]\n    if None in args:\n        args = [arg for arg in args if arg is not None]\n        if len(args) != 2:\n            raise ValueError(\"You must specify at least 2 of [flow, fhigh, msc]\")\n    if self.flow is not None and self.fhigh is not None and self.flow &gt;= self.fhigh:\n        raise ValueError(\"flow must be less than fhigh\")\n    return self\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SPECTRUM.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = f\"{self.dir_sector} mdc={self.mdc}\"\n    if self.flow is not None:\n        repr += f\" flow={self.flow}\"\n    if self.fhigh is not None:\n        repr += f\" fhigh={self.fhigh}\"\n    if self.msc is not None:\n        repr += f\" msc={self.msc}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC","title":"SHAPESPEC","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spectral shape specification.</p> <p>.. code-block:: text</p> <pre><code>BOUND SHAPESPEC JONSWAP|PM|GAUSS|BIN|TMA PEAK|MEAN DSPR [POWER|DEGREES]\n</code></pre> <p>This command BOUND SHAPESPEC defines the shape of the spectra (both in frequency and direction) at the boundary of the computational grid in case of parametric spectral input.</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC--notes","title":"Notes","text":"<p>While technically a component <code>BOUND SHAPESPEC</code>, this is only intended to be used as a subcomponent of the <code>BOUNDSPEC</code> component.</p>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import SHAPESPEC\nshapespec = SHAPESPEC()\nprint(shapespec.render())\nshapespec = SHAPESPEC(\n    shape=dict(model_type=\"tma\", gamma=3.1, d=12),\n    per_type=\"mean\",\n    dspr_type=\"degrees\",\n)\nprint(shapespec.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class SHAPESPEC(BaseSubComponent):\n    \"\"\"Spectral shape specification.\n\n    .. code-block:: text\n\n        BOUND SHAPESPEC JONSWAP|PM|GAUSS|BIN|TMA PEAK|MEAN DSPR [POWER|DEGREES]\n\n    This command BOUND SHAPESPEC defines the shape of the spectra (both in frequency\n    and direction) at the boundary of the computational grid in case of parametric\n    spectral input.\n\n    Notes\n    -----\n    While technically a component `BOUND SHAPESPEC`, this is only intended to be used\n    as a subcomponent of the `BOUNDSPEC` component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import SHAPESPEC\n        shapespec = SHAPESPEC()\n        print(shapespec.render())\n        shapespec = SHAPESPEC(\n            shape=dict(model_type=\"tma\", gamma=3.1, d=12),\n            per_type=\"mean\",\n            dspr_type=\"degrees\",\n        )\n        print(shapespec.render())\n\n    \"\"\"\n\n    model_type: Literal[\"shapespec\", \"SHAPESPEC\"] = Field(\n        default=\"shapespec\", description=\"Model type discriminator\"\n    )\n    shape: JONSWAP | PM | GAUSS | BIN | TMA = Field(\n        default_factory=JONSWAP,\n        description=\"The spectral shape\",\n    )\n    per_type: Literal[\"peak\", \"mean\"] = Field(\n        default=\"peak\",\n        description=\"The type of characteristic wave period\",\n    )\n    dspr_type: Literal[\"power\", \"degrees\"] = Field(\n        default=\"power\",\n        description=\"The type of directional spreading\",\n    )\n\n    def cmd(self) -&gt; str:\n        repr = (\n            f\"BOUND SHAPESPEC {self.shape.render()} {self.per_type.upper()} \"\n            f\"DSPR {self.dspr_type.upper()}\"\n        )\n        return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['shapespec', 'SHAPESPEC'] = Field(default='shapespec', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.shape","title":"shape  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shape: JONSWAP | PM | GAUSS | BIN | TMA = Field(default_factory=JONSWAP, description='The spectral shape')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.per_type","title":"per_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per_type: Literal['peak', 'mean'] = Field(default='peak', description='The type of characteristic wave period')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.dspr_type","title":"dspr_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dspr_type: Literal['power', 'degrees'] = Field(default='power', description='The type of directional spreading')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.SHAPESPEC.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    repr = (\n        f\"BOUND SHAPESPEC {self.shape.render()} {self.per_type.upper()} \"\n        f\"DSPR {self.dspr_type.upper()}\"\n    )\n    return repr\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP","title":"JONSWAP","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Jonswap spectral shape.</p> <p>.. code-block:: text</p> <pre><code>JONSWAP [gamma]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import JONSWAP\nshape = JONSWAP(gamma=3.3)\nprint(shape.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class JONSWAP(BaseSubComponent):\n    \"\"\"Jonswap spectral shape.\n\n    .. code-block:: text\n\n        JONSWAP [gamma]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import JONSWAP\n        shape = JONSWAP(gamma=3.3)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"jonswap\", \"JONSWAP\"] = Field(\n        default=\"jonswap\", description=\"Model type discriminator\"\n    )\n    gamma: float = Field(\n        default=3.3,\n        description=\"Peak enhancement parameter of the JONSWAP spectrum.\",\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} gamma={self.gamma}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['jonswap', 'JONSWAP'] = Field(default='jonswap', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.gamma","title":"gamma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gamma: float = Field(default=3.3, description='Peak enhancement parameter of the JONSWAP spectrum.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.JONSWAP.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} gamma={self.gamma}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA","title":"TMA","text":"<p>               Bases: <code>JONSWAP</code></p> <p>TMA spectral shape.</p> <p>.. code-block:: text</p> <pre><code>TMA [gamma] [d]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import TMA\nshape = TMA(gamma=2.0, d=18)\nprint(shape.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class TMA(JONSWAP):\n    \"\"\"TMA spectral shape.\n\n    .. code-block:: text\n\n        TMA [gamma] [d]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import TMA\n        shape = TMA(gamma=2.0, d=18)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"tma\", \"TMA\"] = Field(\n        default=\"tma\", description=\"Model type discriminator\"\n    )\n    d: float = Field(\n        description=\"The reference depth at the wave maker in meters.\",\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} d={self.d}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['tma', 'TMA'] = Field(default='tma', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.d","title":"d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>d: float = Field(description='The reference depth at the wave maker in meters.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.TMA.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} d={self.d}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS","title":"GAUSS","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Gaussian spectral shape.</p> <p>.. code-block:: text</p> <pre><code>GAUSS [sigfr]\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import GAUSS\nshape = GAUSS(sigfr=0.02)\nprint(shape.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class GAUSS(BaseSubComponent):\n    \"\"\"Gaussian spectral shape.\n\n    .. code-block:: text\n\n        GAUSS [sigfr]\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import GAUSS\n        shape = GAUSS(sigfr=0.02)\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"gauss\", \"GAUSS\"] = Field(\n        default=\"gauss\", description=\"Model type discriminator\"\n    )\n    sigfr: float = Field(\n        description=(\n            \"Width of the Gaussian frequency spectrum expressed \"\n            \"as a standard deviation in Hz.\"\n        ),\n        gt=0.0,\n    )\n\n    def cmd(self) -&gt; str:\n        return f\"{super().cmd()} sigfr={self.sigfr}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['gauss', 'GAUSS'] = Field(default='gauss', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.sigfr","title":"sigfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigfr: float = Field(description='Width of the Gaussian frequency spectrum expressed as a standard deviation in Hz.', gt=0.0)\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS-functions","title":"Functions","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.GAUSS.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>def cmd(self) -&gt; str:\n    return f\"{super().cmd()} sigfr={self.sigfr}\"\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM","title":"PM","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Pearson-Moskowitz spectral shape.</p> <p>.. code-block:: text</p> <pre><code>PM\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import PM\nshape = PM()\nprint(shape.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class PM(BaseSubComponent):\n    \"\"\"Pearson-Moskowitz spectral shape.\n\n    .. code-block:: text\n\n        PM\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import PM\n        shape = PM()\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"pm\", \"PM\"] = Field(\n        default=\"pm\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.PM.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['pm', 'PM'] = Field(default='pm', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN","title":"BIN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Single frequency bin spectral shape.</p> <p>.. code-block:: text</p> <pre><code>BIN\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.spectrum import BIN\nshape = BIN()\nprint(shape.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/spectrum.py</code> <pre><code>class BIN(BaseSubComponent):\n    \"\"\"Single frequency bin spectral shape.\n\n    .. code-block:: text\n\n        BIN\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.spectrum import BIN\n        shape = BIN()\n        print(shape.render())\n\n    \"\"\"\n\n    model_type: Literal[\"bin\", \"BIN\"] = Field(\n        default=\"bin\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN-attributes","title":"Attributes","text":""},{"location":"subcomponents/spectrum/#rompy_swan.subcomponents.spectrum.BIN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['bin', 'BIN'] = Field(default='bin', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/","title":"Startup","text":"<p>Sub-commands to support the startup components</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN","title":"CARTESIAN","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Cartesian coordinates.</p> <p>.. code-block:: text</p> <pre><code>CARTESIAN\n</code></pre> <p>All locations and distances are in m. Coordinates are given with respect to x- and y-axes chosen by the user in the various commands.</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import CARTESIAN\ncoords = CARTESIAN()\nprint(coords.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>class CARTESIAN(BaseSubComponent):\n    \"\"\"Cartesian coordinates.\n\n    .. code-block:: text\n\n        CARTESIAN\n\n    All locations and distances are in m. Coordinates are given with respect\n    to x- and y-axes chosen by the user in the various commands.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import CARTESIAN\n        coords = CARTESIAN()\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"cartesian\", \"CARTESIAN\"] = Field(\n        default=\"cartesian\", description=\"Model type discriminator\"\n    )\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN-attributes","title":"Attributes","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.CARTESIAN.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['cartesian', 'CARTESIAN'] = Field(default='cartesian', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL","title":"SPHERICAL","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Spherical coordinates.</p> <p>.. code-block:: text</p> <pre><code>SPHERICAL [-&gt;CCM|QC]\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL--notes","title":"Notes","text":"<p>projection options:</p> <ul> <li>CCM: central conformal Mercator. The horizontal and vertical scales are   uniform in terms of cm/degree over the area shown. In the centre of the scale   is identical to that of the conventional Mercator projection (but only at   that centre). The area in the projection centre is therefore exactly conformal.</li> <li>QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical   scales are equal to one another in terms of cm/degree.</li> </ul> <p>All coordinates of locations and geographical grid sizes are given in degrees;<code>x</code> is longitude with <code>x = 0</code> being the Greenwich meridian and <code>x &gt; 0</code> is East of this meridian; <code>y</code> is latitude with <code>y &gt; 0</code> being the Northern hemisphere. Input and output grids have to be oriented with their x-axis to the East; mesh sizes are in degrees. All other distances are in meters.</p> <p>Note that spherical coordinates can also be used for relatively small areas, say 10 or 20 km horizontal dimension. This may be useful if one obtains the boundary conditions by nesting in an oceanic model which is naturally formulated in spherical coordinates. Note that in case of spherical coordinates regular grids must always be oriented E-W, N-S, i.e. <code>alpc=0</code>, <code>alpinp=0</code>, <code>alpfr=0</code> (see commands CGRID, INPUT GRID and FRAME, respectively).</p>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.components.startup import SPHERICAL\ncoords = SPHERICAL()\nprint(coords.render())\ncoords = SPHERICAL(projection=\"qc\")\nprint(coords.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>class SPHERICAL(BaseSubComponent):\n    \"\"\"Spherical coordinates.\n\n    .. code-block:: text\n\n        SPHERICAL [-&gt;CCM|QC]\n\n    Notes\n    -----\n\n    projection options:\n\n    * CCM: central conformal Mercator. The horizontal and vertical scales are\n      uniform in terms of cm/degree over the area shown. In the centre of the scale\n      is identical to that of the conventional Mercator projection (but only at\n      that centre). The area in the projection centre is therefore exactly conformal.\n    * QC: the projection method is quasi-cartesian, i.e. the horizontal and vertical\n      scales are equal to one another in terms of cm/degree.\n\n    All coordinates of locations and geographical grid sizes are given in degrees;`x`\n    is longitude with `x = 0` being the Greenwich meridian and `x &gt; 0` is East of this\n    meridian; `y` is latitude with `y &gt; 0` being the Northern hemisphere. Input and\n    output grids have to be oriented with their x-axis to the East; mesh sizes are in\n    degrees. All other distances are in meters.\n\n    Note that spherical coordinates can also be used for relatively small areas, say 10\n    or 20 km horizontal dimension. This may be useful if one obtains the boundary\n    conditions by nesting in an oceanic model which is naturally formulated in\n    spherical coordinates. Note that in case of spherical coordinates regular grids\n    must always be oriented E-W, N-S, i.e. `alpc=0`, `alpinp=0`, `alpfr=0`\n    (see commands CGRID, INPUT GRID and FRAME, respectively).\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.components.startup import SPHERICAL\n        coords = SPHERICAL()\n        print(coords.render())\n        coords = SPHERICAL(projection=\"qc\")\n        print(coords.render())\n\n    \"\"\"\n\n    model_type: Literal[\"spherical\", \"SPHERICAL\"] = Field(\n        default=\"spherical\", description=\"Model type discriminator\"\n    )\n    projection: Literal[\"ccm\", \"qc\"] = Field(\n        default=\"ccm\",\n        description=(\n            \"Defines the projection method in case of spherical coordinates, `ccm` \"\n            \"Central Conformal Mercator, `qc` means Quasi-cartesian\"\n        ),\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        if self.projection is not None:\n            repr += f\" {self.projection.upper()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL-attributes","title":"Attributes","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['spherical', 'SPHERICAL'] = Field(default='spherical', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.projection","title":"projection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projection: Literal['ccm', 'qc'] = Field(default='ccm', description='Defines the projection method in case of spherical coordinates, `ccm` Central Conformal Mercator, `qc` means Quasi-cartesian')\n</code></pre>"},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL-functions","title":"Functions","text":""},{"location":"subcomponents/startup/#rompy_swan.subcomponents.startup.SPHERICAL.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/startup.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    if self.projection is not None:\n        repr += f\" {self.projection.upper()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/","title":"Time","text":"<p>Sub-commands to support time definition</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time","title":"Time","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Time specification in SWAN.</p> <p>.. code-block:: text</p> <pre><code>[time]\n</code></pre> <p>Time is rendered in one of the following formats:</p> <ul> <li>1: ISO-notation 19870530.153000</li> <li>2: (as in HP compiler) '30-May-87 15:30:00'</li> <li>3: (as in Lahey compiler) 05/30/87.15:30:00</li> <li>4: 15:30:00</li> <li>5: 87/05/30 15:30:00'</li> <li>6: as in WAM 8705301530</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time--note","title":"Note","text":"<p>The <code>time</code> field can be specified as:</p> <ul> <li>existing datetime object</li> <li>int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or   milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.</li> <li>ISO 8601 time string.</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import Time\nfrom datetime import datetime\ntime = Time(time=datetime(1990, 1, 1))\nprint(time.render())\ntime = Time(time=\"2012-01-01T00:00:00\", tfmt=2)\nprint(time.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class Time(BaseSubComponent):\n    \"\"\"Time specification in SWAN.\n\n    .. code-block:: text\n\n        [time]\n\n    Time is rendered in one of the following formats:\n\n    * 1: ISO-notation 19870530.153000\n    * 2: (as in HP compiler) '30-May-87 15:30:00'\n    * 3: (as in Lahey compiler) 05/30/87.15:30:00\n    * 4: 15:30:00\n    * 5: 87/05/30 15:30:00'\n    * 6: as in WAM 8705301530\n\n    Note\n    ----\n    The `time` field can be specified as:\n\n    * existing datetime object\n    * int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or\n      milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.\n    * ISO 8601 time string.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import Time\n        from datetime import datetime\n        time = Time(time=datetime(1990, 1, 1))\n        print(time.render())\n        time = Time(time=\"2012-01-01T00:00:00\", tfmt=2)\n        print(time.render())\n\n    \"\"\"\n\n    model_type: Literal[\"time\", \"Time\", \"TIME\"] = Field(\n        default=\"time\", description=\"Model type discriminator\"\n    )\n    time: datetime = Field(description=\"Datetime specification\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n        validate_default=True,\n    )\n\n    @field_validator(\"tfmt\")\n    @classmethod\n    def set_time_format(cls, v: int | str) -&gt; str:\n        \"\"\"Set the time format to render.\"\"\"\n        if isinstance(v, str):\n            return v\n        return TIME_FORMAT[v]\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"{self.time.strftime(self.tfmt)}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['time', 'Time', 'TIME'] = Field(default='time', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: datetime = Field(description='Datetime specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification', validate_default=True)\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.set_time_format","title":"set_time_format  <code>classmethod</code>","text":"<pre><code>set_time_format(v: int | str) -&gt; str\n</code></pre> <p>Set the time format to render.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>@field_validator(\"tfmt\")\n@classmethod\ndef set_time_format(cls, v: int | str) -&gt; str:\n    \"\"\"Set the time format to render.\"\"\"\n    if isinstance(v, str):\n        return v\n    return TIME_FORMAT[v]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Time.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"{self.time.strftime(self.tfmt)}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt","title":"Delt","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Time interval specification in SWAN.</p> <p>.. code-block:: text</p> <pre><code>[delt] SEC|MIN|HR|DAY\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt--note","title":"Note","text":"<p>The <code>tdelta</code> field can be specified as:</p> <ul> <li>existing timedelta object</li> <li>int or float, assumed as seconds</li> <li> <p>ISO 8601 duration string, following formats work:</p> </li> <li> <p><code>[-][DD ][HH:MM]SS[.ffffff]</code></p> </li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 format for timedelta)</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import Delt\nfrom datetime import timedelta\ndelt = Delt(delt=timedelta(minutes=30))\nprint(delt.render())\ndelt = Delt(delt=\"PT1H\", dfmt=\"hr\")\nprint(delt.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class Delt(BaseSubComponent):\n    \"\"\"Time interval specification in SWAN.\n\n    .. code-block:: text\n\n        [delt] SEC|MIN|HR|DAY\n\n    Note\n    ----\n    The `tdelta` field can be specified as:\n\n    * existing timedelta object\n    * int or float, assumed as seconds\n    * ISO 8601 duration string, following formats work:\n\n      * `[-][DD ][HH:MM]SS[.ffffff]`\n      * `[\u00b1]P[DD]DT[HH]H[MM]M[SS]S` (ISO 8601 format for timedelta)\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import Delt\n        from datetime import timedelta\n        delt = Delt(delt=timedelta(minutes=30))\n        print(delt.render())\n        delt = Delt(delt=\"PT1H\", dfmt=\"hr\")\n        print(delt.render())\n\n    \"\"\"\n\n    model_type: Literal[\"delt\"] = Field(\n        default=\"delt\", description=\"Model type discriminator\"\n    )\n    delt: timedelta = Field(description=\"Time interval\")\n    dfmt: Literal[\"sec\", \"min\", \"hr\", \"day\"] = Field(\n        default=\"sec\",\n        description=\"Format to render time interval specification\",\n    )\n\n    @property\n    def delt_float(self):\n        delt_scaling = {\"sec\": 1, \"min\": 60, \"hr\": 3600, \"day\": 86400}\n        return self.delt.total_seconds() / delt_scaling[self.dfmt]\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"{self.delt_float} {self.dfmt.upper()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['delt'] = Field(default='delt', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.dfmt","title":"dfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dfmt: Literal['sec', 'min', 'hr', 'day'] = Field(default='sec', description='Format to render time interval specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.delt_float","title":"delt_float  <code>property</code>","text":"<pre><code>delt_float\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.Delt.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"{self.delt_float} {self.dfmt.upper()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen","title":"TimeRangeOpen","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Regular times with an open boundary.</p> <p>.. code-block:: text</p> <pre><code>[tbeg] [delt] SEC|MIN|HR|DAY\n</code></pre> <p>Time is rendered in one of the following formats:</p> <ul> <li>1: ISO-notation 19870530.153000</li> <li>2: (as in HP compiler) '30-May-87 15:30:00'</li> <li>3: (as in Lahey compiler) 05/30/87.15:30:00</li> <li>4: 15:30:00</li> <li>5: 87/05/30 15:30:00'</li> <li>6: as in WAM 8705301530</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note","title":"Note","text":"<p>The <code>tbeg</code> field can be specified as:</p> <ul> <li>existing datetime object</li> <li>int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or   milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.</li> <li>ISO 8601 time string.</li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note_1","title":"Note","text":"<p>The <code>tdelta</code> field can be specified as:</p> <ul> <li>existing timedelta object</li> <li>int or float, assumed as seconds</li> <li> <p>ISO 8601 duration string, following formats work:</p> <ul> <li><code>[-][DD ][HH:MM]SS[.ffffff]</code></li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 format for timedelta)</li> </ul> </li> </ul>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--note_2","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import TimeRangeOpen\nfrom datetime import datetime, timedelta\ntimes = TimeRangeOpen(\n    tbeg=datetime(1990, 1, 1), delt=timedelta(minutes=30), dfmt=\"min\"\n)\nprint(times.render())\ntimes = TimeRangeOpen(\n    tbeg=\"2012-01-01T00:00:00\", delt=\"PT1H\", tfmt=2, dfmt=\"hr\", suffix=\"blk\"\n)\nprint(times.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class TimeRangeOpen(BaseSubComponent):\n    \"\"\"Regular times with an open boundary.\n\n    .. code-block:: text\n\n        [tbeg] [delt] SEC|MIN|HR|DAY\n\n    Time is rendered in one of the following formats:\n\n    * 1: ISO-notation 19870530.153000\n    * 2: (as in HP compiler) '30-May-87 15:30:00'\n    * 3: (as in Lahey compiler) 05/30/87.15:30:00\n    * 4: 15:30:00\n    * 5: 87/05/30 15:30:00'\n    * 6: as in WAM 8705301530\n\n    Note\n    ----\n    The `tbeg` field can be specified as:\n\n    * existing datetime object\n    * int or float, assumed as Unix time, i.e. seconds (if &gt;= -2e10 or &lt;= 2e10) or\n      milliseconds (if &lt; -2e10 or &gt; 2e10) since 1 January 1970.\n    * ISO 8601 time string.\n\n    Note\n    ----\n    The `tdelta` field can be specified as:\n\n    * existing timedelta object\n    * int or float, assumed as seconds\n    * ISO 8601 duration string, following formats work:\n\n        * `[-][DD ][HH:MM]SS[.ffffff]`\n        * `[\u00b1]P[DD]DT[HH]H[MM]M[SS]S` (ISO 8601 format for timedelta)\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import TimeRangeOpen\n        from datetime import datetime, timedelta\n        times = TimeRangeOpen(\n            tbeg=datetime(1990, 1, 1), delt=timedelta(minutes=30), dfmt=\"min\"\n        )\n        print(times.render())\n        times = TimeRangeOpen(\n            tbeg=\"2012-01-01T00:00:00\", delt=\"PT1H\", tfmt=2, dfmt=\"hr\", suffix=\"blk\"\n        )\n        print(times.render())\n\n    \"\"\"\n\n    model_type: Literal[\"open\", \"OPEN\"] = Field(\n        default=\"open\", description=\"Model type discriminator\"\n    )\n    tbeg: datetime = Field(default=DEFAULT_TIME, description=\"Start time\")\n    delt: timedelta = Field(default=DEFAULT_DELT, description=\"Time interval\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n    )\n    dfmt: Literal[\"sec\", \"min\", \"hr\", \"day\"] = Field(\n        default=\"sec\",\n        description=\"Format to render time interval specification\",\n    )\n    suffix: str = Field(\n        default=\"\",\n        description=\"Suffix to prepend to argument names when rendering\",\n    )\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"tbeg{self.suffix}={Time(time=self.tbeg, tfmt=self.tfmt).render()}\"\n        repr += f\" delt{self.suffix}={Delt(delt=self.delt, dfmt=self.dfmt).render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['open', 'OPEN'] = Field(default='open', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.tbeg","title":"tbeg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbeg: datetime = Field(default=DEFAULT_TIME, description='Start time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(default=DEFAULT_DELT, description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.dfmt","title":"dfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dfmt: Literal['sec', 'min', 'hr', 'day'] = Field(default='sec', description='Format to render time interval specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.suffix","title":"suffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suffix: str = Field(default='', description='Suffix to prepend to argument names when rendering')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeOpen.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"tbeg{self.suffix}={Time(time=self.tbeg, tfmt=self.tfmt).render()}\"\n    repr += f\" delt{self.suffix}={Delt(delt=self.delt, dfmt=self.dfmt).render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed","title":"TimeRangeClosed","text":"<p>               Bases: <code>TimeRangeOpen</code></p> <p>Regular times with a closed boundary.</p> <p>.. code-block:: text</p> <pre><code>[tbeg] [delt] SEC|MIN|HR|DAY [tend]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed--note","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import TimeRangeClosed\nfrom datetime import datetime, timedelta\ntimes = TimeRangeClosed(\n    tbeg=datetime(1990, 1, 1),\n    tend=datetime(1990, 1, 7),\n    delt=timedelta(minutes=30),\n    dfmt=\"min\",\n)\nprint(times.render())\ntimes = TimeRangeClosed(\n    tbeg=\"2012-01-01T00:00:00\",\n    tend=\"2012-02-01T00:00:00\",\n    delt=\"PT1H\",\n    tfmt=2,\n    dfmt=\"hr\",\n    suffix=\"blk\",\n)\nprint(times.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class TimeRangeClosed(TimeRangeOpen):\n    \"\"\"Regular times with a closed boundary.\n\n    .. code-block:: text\n\n        [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import TimeRangeClosed\n        from datetime import datetime, timedelta\n        times = TimeRangeClosed(\n            tbeg=datetime(1990, 1, 1),\n            tend=datetime(1990, 1, 7),\n            delt=timedelta(minutes=30),\n            dfmt=\"min\",\n        )\n        print(times.render())\n        times = TimeRangeClosed(\n            tbeg=\"2012-01-01T00:00:00\",\n            tend=\"2012-02-01T00:00:00\",\n            delt=\"PT1H\",\n            tfmt=2,\n            dfmt=\"hr\",\n            suffix=\"blk\",\n        )\n        print(times.render())\n\n    \"\"\"\n\n    model_type: Literal[\"closed\", \"CLOSED\"] = Field(\n        default=\"closed\", description=\"Model type discriminator\"\n    )\n    tend: datetime = Field(default=DEFAULT_TEND, description=\"End time\")\n\n    def __call__(self) -&gt; list[Time]:\n        \"\"\"Returns the list of Time objects.\"\"\"\n        times = pd.date_range(start=self.tbeg, end=self.tend, freq=self.delt)\n        return [time.to_pydatetime() for time in times]\n\n    def __getitem__(self, index) -&gt; datetime | list[datetime]:\n        \"\"\"Slicing from the times array.\"\"\"\n        return self.__call__()[index]\n\n    def __len__(self):\n        \"\"\"Returns the length of the times array.\"\"\"\n        return len(self())\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = super().cmd()\n        repr += f\" tend{self.suffix}={Time(time=self.tend, tfmt=self.tfmt).render()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['closed', 'CLOSED'] = Field(default='closed', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.tend","title":"tend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tend: datetime = Field(default=DEFAULT_TEND, description='End time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.TimeRangeClosed.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = super().cmd()\n    repr += f\" tend{self.suffix}={Time(time=self.tend, tfmt=self.tfmt).render()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY","title":"NONSTATIONARY","text":"<p>               Bases: <code>TimeRangeClosed</code></p> <p>Nonstationary time specification.</p> <p>.. code-block:: text</p> <pre><code>NONSTATIONARY [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY--note","title":"Note","text":"<p>Default values for the time specification fields are provided for the case where the user wants to set times dynamically after instantiating this subcomponent.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import NONSTATIONARY\nnonstat = NONSTATIONARY(\n    tbeg=\"2012-01-01T00:00:00\",\n    tend=\"2012-02-01T00:00:00\",\n    delt=\"PT1H\",\n    dfmt=\"hr\",\n)\nprint(nonstat.render())\nfrom datetime import datetime, timedelta\nnonstat = NONSTATIONARY(\n    tbeg=datetime(1990, 1, 1),\n    tend=datetime(1990, 1, 7),\n    delt=timedelta(minutes=30),\n    tfmt=1,\n    dfmt=\"min\",\n    suffix=\"tbl\",\n)\nprint(nonstat.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class NONSTATIONARY(TimeRangeClosed):\n    \"\"\"Nonstationary time specification.\n\n    .. code-block:: text\n\n        NONSTATIONARY [tbeg] [delt] SEC|MIN|HR|DAY [tend]\n\n    Note\n    ----\n    Default values for the time specification fields are provided for the case where\n    the user wants to set times dynamically after instantiating this subcomponent.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import NONSTATIONARY\n        nonstat = NONSTATIONARY(\n            tbeg=\"2012-01-01T00:00:00\",\n            tend=\"2012-02-01T00:00:00\",\n            delt=\"PT1H\",\n            dfmt=\"hr\",\n        )\n        print(nonstat.render())\n        from datetime import datetime, timedelta\n        nonstat = NONSTATIONARY(\n            tbeg=datetime(1990, 1, 1),\n            tend=datetime(1990, 1, 7),\n            delt=timedelta(minutes=30),\n            tfmt=1,\n            dfmt=\"min\",\n            suffix=\"tbl\",\n        )\n        print(nonstat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"nonstationary\", \"NONSTATIONARY\"] = Field(\n        default=\"nonstationary\", description=\"Model type discriminator\"\n    )\n    tbeg: datetime = Field(default=DEFAULT_TIME, description=\"Start time\")\n    tend: datetime = Field(default=DEFAULT_TEND, description=\"End time\")\n    delt: timedelta = Field(default=DEFAULT_DELT, description=\"Time interval\")\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        repr = f\"NONSTATIONARY {super().cmd()}\"\n        return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nonstationary', 'NONSTATIONARY'] = Field(default='nonstationary', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.tbeg","title":"tbeg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tbeg: datetime = Field(default=DEFAULT_TIME, description='Start time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.tend","title":"tend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tend: datetime = Field(default=DEFAULT_TEND, description='End time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.delt","title":"delt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delt: timedelta = Field(default=DEFAULT_DELT, description='Time interval')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.NONSTATIONARY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    repr = f\"NONSTATIONARY {super().cmd()}\"\n    return repr\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY","title":"STATIONARY","text":"<p>               Bases: <code>BaseSubComponent</code></p> <p>Stationary time specification.</p> <p>.. code-block:: text</p> <pre><code>STATIONARY [time]\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY--note","title":"Note","text":"<p>The field <code>time</code> is optional to allow for the case where the user wants to set the time dynamically after instantiating this component.</p>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY--examples","title":"Examples","text":"<p>.. ipython:: python     :okwarning:</p> <pre><code>from rompy_swan.subcomponents.time import STATIONARY\nstat = STATIONARY(time=\"2012-01-01T00:00:00\")\nprint(stat.render())\n</code></pre> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>class STATIONARY(BaseSubComponent):\n    \"\"\"Stationary time specification.\n\n    .. code-block:: text\n\n        STATIONARY [time]\n\n    Note\n    ----\n    The field `time` is optional to allow for the case where the user wants to set the\n    time dynamically after instantiating this component.\n\n    Examples\n    --------\n\n    .. ipython:: python\n        :okwarning:\n\n        from rompy_swan.subcomponents.time import STATIONARY\n        stat = STATIONARY(time=\"2012-01-01T00:00:00\")\n        print(stat.render())\n\n    \"\"\"\n\n    model_type: Literal[\"stationary\", \"STATIONARY\"] = Field(\n        default=\"stationary\", description=\"Model type discriminator\"\n    )\n    time: datetime = Field(default=DEFAULT_TIME, description=\"Stationary time\")\n    tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(\n        default=1,\n        description=\"Format to render time specification\",\n    )\n\n    def __call__(self) -&gt; list[Time]:\n        \"\"\"Returns the list of Time object for consistency with NONSTATIONARY.\"\"\"\n        return [self.time]\n\n    def __getitem__(self, index) -&gt; Time | list[Time]:\n        \"\"\"Slicing from the times array.\"\"\"\n        return self.__call__()[index]\n\n    def __len__(self):\n        \"\"\"Returns the length of the times array.\"\"\"\n        return len(self())\n\n    def cmd(self) -&gt; str:\n        \"\"\"Render subcomponent cmd.\"\"\"\n        return f\"STATIONARY time={Time(time=self.time, tfmt=self.tfmt).render()}\"\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY-attributes","title":"Attributes","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['stationary', 'STATIONARY'] = Field(default='stationary', description='Model type discriminator')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: datetime = Field(default=DEFAULT_TIME, description='Stationary time')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.tfmt","title":"tfmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tfmt: Union[Literal[1, 2, 3, 4, 5, 6], str] = Field(default=1, description='Format to render time specification')\n</code></pre>"},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY-functions","title":"Functions","text":""},{"location":"subcomponents/time/#rompy_swan.subcomponents.time.STATIONARY.cmd","title":"cmd","text":"<pre><code>cmd() -&gt; str\n</code></pre> <p>Render subcomponent cmd.</p> Source code in <code>rompy_swan/subcomponents/time.py</code> <pre><code>def cmd(self) -&gt; str:\n    \"\"\"Render subcomponent cmd.\"\"\"\n    return f\"STATIONARY time={Time(time=self.time, tfmt=self.tfmt).render()}\"\n</code></pre>"}]}